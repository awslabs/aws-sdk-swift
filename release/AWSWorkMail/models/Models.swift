// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension WorkMailClientTypes.AccessControlRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case description = "Description"
        case effect = "Effect"
        case ipRanges = "IpRanges"
        case name = "Name"
        case notActions = "NotActions"
        case notIpRanges = "NotIpRanges"
        case notUserIds = "NotUserIds"
        case userIds = "UserIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actionslist0 in actions {
                try actionsContainer.encode(actionslist0)
            }
        }
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated.timeIntervalSince1970, forKey: .dateCreated)
        }
        if let dateModified = dateModified {
            try encodeContainer.encode(dateModified.timeIntervalSince1970, forKey: .dateModified)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let effect = effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let ipRanges = ipRanges {
            var ipRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipRanges)
            for iprangelist0 in ipRanges {
                try ipRangesContainer.encode(iprangelist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notActions = notActions {
            var notActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notActions)
            for actionslist0 in notActions {
                try notActionsContainer.encode(actionslist0)
            }
        }
        if let notIpRanges = notIpRanges {
            var notIpRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notIpRanges)
            for iprangelist0 in notIpRanges {
                try notIpRangesContainer.encode(iprangelist0)
            }
        }
        if let notUserIds = notUserIds {
            var notUserIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notUserIds)
            for useridlist0 in notUserIds {
                try notUserIdsContainer.encode(useridlist0)
            }
        }
        if let userIds = userIds {
            var userIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userIds)
            for useridlist0 in userIds {
                try userIdsContainer.encode(useridlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.AccessControlRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ipRangesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipRanges)
        var ipRangesDecoded0:[Swift.String]? = nil
        if let ipRangesContainer = ipRangesContainer {
            ipRangesDecoded0 = [Swift.String]()
            for string0 in ipRangesContainer {
                if let string0 = string0 {
                    ipRangesDecoded0?.append(string0)
                }
            }
        }
        ipRanges = ipRangesDecoded0
        let notIpRangesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notIpRanges)
        var notIpRangesDecoded0:[Swift.String]? = nil
        if let notIpRangesContainer = notIpRangesContainer {
            notIpRangesDecoded0 = [Swift.String]()
            for string0 in notIpRangesContainer {
                if let string0 = string0 {
                    notIpRangesDecoded0?.append(string0)
                }
            }
        }
        notIpRanges = notIpRangesDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actions)
        var actionsDecoded0:[Swift.String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
        let notActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notActions)
        var notActionsDecoded0:[Swift.String]? = nil
        if let notActionsContainer = notActionsContainer {
            notActionsDecoded0 = [Swift.String]()
            for string0 in notActionsContainer {
                if let string0 = string0 {
                    notActionsDecoded0?.append(string0)
                }
            }
        }
        notActions = notActionsDecoded0
        let userIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userIds)
        var userIdsDecoded0:[Swift.String]? = nil
        if let userIdsContainer = userIdsContainer {
            userIdsDecoded0 = [Swift.String]()
            for string0 in userIdsContainer {
                if let string0 = string0 {
                    userIdsDecoded0?.append(string0)
                }
            }
        }
        userIds = userIdsDecoded0
        let notUserIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notUserIds)
        var notUserIdsDecoded0:[Swift.String]? = nil
        if let notUserIdsContainer = notUserIdsContainer {
            notUserIdsDecoded0 = [Swift.String]()
            for string0 in notUserIdsContainer {
                if let string0 = string0 {
                    notUserIdsDecoded0?.append(string0)
                }
            }
        }
        notUserIds = notUserIdsDecoded0
        let dateCreatedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .dateModified)
        dateModified = dateModifiedDecoded
    }
}

extension WorkMailClientTypes.AccessControlRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessControlRule(actions: \(Swift.String(describing: actions)), dateCreated: \(Swift.String(describing: dateCreated)), dateModified: \(Swift.String(describing: dateModified)), description: \(Swift.String(describing: description)), effect: \(Swift.String(describing: effect)), ipRanges: \(Swift.String(describing: ipRanges)), name: \(Swift.String(describing: name)), notActions: \(Swift.String(describing: notActions)), notIpRanges: \(Swift.String(describing: notIpRanges)), notUserIds: \(Swift.String(describing: notUserIds)), userIds: \(Swift.String(describing: userIds)))"}
}

extension WorkMailClientTypes {
    /// A rule that controls access to an Amazon WorkMail organization.
    public struct AccessControlRule: Swift.Equatable {
        /// Access protocol actions to include in the rule. Valid values include
        ///             ActiveSync, AutoDiscover, EWS, IMAP,
        ///             SMTP, WindowsOutlook, and WebMail.
        public var actions: [Swift.String]?
        /// The date that the rule was created.
        public var dateCreated: ClientRuntime.Date?
        /// The date that the rule was modified.
        public var dateModified: ClientRuntime.Date?
        /// The rule description.
        public var description: Swift.String?
        /// The rule effect.
        public var effect: WorkMailClientTypes.AccessControlRuleEffect?
        /// IPv4 CIDR ranges to include in the rule.
        public var ipRanges: [Swift.String]?
        /// The rule name.
        public var name: Swift.String?
        /// Access protocol actions to exclude from the rule. Valid values include
        ///             ActiveSync, AutoDiscover, EWS, IMAP,
        ///             SMTP, WindowsOutlook, and WebMail.
        public var notActions: [Swift.String]?
        /// IPv4 CIDR ranges to exclude from the rule.
        public var notIpRanges: [Swift.String]?
        /// User IDs to exclude from the rule.
        public var notUserIds: [Swift.String]?
        /// User IDs to include in the rule.
        public var userIds: [Swift.String]?

        public init (
            actions: [Swift.String]? = nil,
            dateCreated: ClientRuntime.Date? = nil,
            dateModified: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            effect: WorkMailClientTypes.AccessControlRuleEffect? = nil,
            ipRanges: [Swift.String]? = nil,
            name: Swift.String? = nil,
            notActions: [Swift.String]? = nil,
            notIpRanges: [Swift.String]? = nil,
            notUserIds: [Swift.String]? = nil,
            userIds: [Swift.String]? = nil
        )
        {
            self.actions = actions
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.description = description
            self.effect = effect
            self.ipRanges = ipRanges
            self.name = name
            self.notActions = notActions
            self.notIpRanges = notIpRanges
            self.notUserIds = notUserIds
            self.userIds = userIds
        }
    }

}

extension WorkMailClientTypes {
    public enum AccessControlRuleEffect: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessControlRuleEffect] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessControlRuleEffect(rawValue: rawValue) ?? AccessControlRuleEffect.sdkUnknown(rawValue)
        }
    }
}

public struct AssociateDelegateToResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateDelegateToResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateDelegateToResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateDelegateToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateDelegateToResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateDelegateToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateDelegateToResourceOutputError>
}

extension AssociateDelegateToResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateDelegateToResourceInput(entityId: \(Swift.String(describing: entityId)), organizationId: \(Swift.String(describing: organizationId)), resourceId: \(Swift.String(describing: resourceId)))"}
}

extension AssociateDelegateToResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct AssociateDelegateToResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateDelegateToResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateDelegateToResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateDelegateToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateDelegateToResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateDelegateToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateDelegateToResourceOutputError>
}

public struct AssociateDelegateToResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateDelegateToResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateDelegateToResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateDelegateToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateDelegateToResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateDelegateToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateDelegateToResourceOutputError>
}

public struct AssociateDelegateToResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateDelegateToResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateDelegateToResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateDelegateToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateDelegateToResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateDelegateToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateDelegateToResourceOutputError>
}

public struct AssociateDelegateToResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateDelegateToResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateDelegateToResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateDelegateToResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateDelegateToResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateDelegateToResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateDelegateToResourceOutputError>
}

public struct AssociateDelegateToResourceInput: Swift.Equatable {
    /// The member (user or group) to associate to the resource.
    /// This member is required.
    public var entityId: Swift.String?
    /// The organization under which the resource exists.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The resource for which members (users or groups) are associated.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct AssociateDelegateToResourceInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let resourceId: Swift.String?
    public let entityId: Swift.String?
}

extension AssociateDelegateToResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
    }
}

extension AssociateDelegateToResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateDelegateToResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateDelegateToResourceOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateDelegateToResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateDelegateToResourceOutputResponse()"}
}

extension AssociateDelegateToResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateDelegateToResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateDelegateToResourceOutputResponseBody: Swift.Equatable {
}

extension AssociateDelegateToResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct AssociateMemberToGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateMemberToGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateMemberToGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateMemberToGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateMemberToGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateMemberToGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateMemberToGroupOutputError>
}

extension AssociateMemberToGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateMemberToGroupInput(groupId: \(Swift.String(describing: groupId)), memberId: \(Swift.String(describing: memberId)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension AssociateMemberToGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case memberId = "MemberId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let memberId = memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct AssociateMemberToGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateMemberToGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateMemberToGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateMemberToGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateMemberToGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateMemberToGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateMemberToGroupOutputError>
}

public struct AssociateMemberToGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateMemberToGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateMemberToGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateMemberToGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateMemberToGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateMemberToGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateMemberToGroupOutputError>
}

public struct AssociateMemberToGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateMemberToGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: AssociateMemberToGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateMemberToGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateMemberToGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateMemberToGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateMemberToGroupOutputError>
}

public struct AssociateMemberToGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateMemberToGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: AssociateMemberToGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateMemberToGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateMemberToGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateMemberToGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateMemberToGroupOutputError>
}

public struct AssociateMemberToGroupInput: Swift.Equatable {
    /// The group to which the member (user or group) is associated.
    /// This member is required.
    public var groupId: Swift.String?
    /// The member (user or group) to associate to the group.
    /// This member is required.
    public var memberId: Swift.String?
    /// The organization under which the group exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.memberId = memberId
        self.organizationId = organizationId
    }
}

struct AssociateMemberToGroupInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let groupId: Swift.String?
    public let memberId: Swift.String?
}

extension AssociateMemberToGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case memberId = "MemberId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberId)
        memberId = memberIdDecoded
    }
}

extension AssociateMemberToGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateMemberToGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateMemberToGroupOutputError: Swift.Error, Swift.Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateMemberToGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateMemberToGroupOutputResponse()"}
}

extension AssociateMemberToGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateMemberToGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateMemberToGroupOutputResponseBody: Swift.Equatable {
}

extension AssociateMemberToGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension WorkMailClientTypes.BookingOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoAcceptRequests = "AutoAcceptRequests"
        case autoDeclineConflictingRequests = "AutoDeclineConflictingRequests"
        case autoDeclineRecurringRequests = "AutoDeclineRecurringRequests"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoAcceptRequests != false {
            try encodeContainer.encode(autoAcceptRequests, forKey: .autoAcceptRequests)
        }
        if autoDeclineConflictingRequests != false {
            try encodeContainer.encode(autoDeclineConflictingRequests, forKey: .autoDeclineConflictingRequests)
        }
        if autoDeclineRecurringRequests != false {
            try encodeContainer.encode(autoDeclineRecurringRequests, forKey: .autoDeclineRecurringRequests)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoAcceptRequestsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoAcceptRequests)
        autoAcceptRequests = autoAcceptRequestsDecoded
        let autoDeclineRecurringRequestsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoDeclineRecurringRequests)
        autoDeclineRecurringRequests = autoDeclineRecurringRequestsDecoded
        let autoDeclineConflictingRequestsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .autoDeclineConflictingRequests)
        autoDeclineConflictingRequests = autoDeclineConflictingRequestsDecoded
    }
}

extension WorkMailClientTypes.BookingOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BookingOptions(autoAcceptRequests: \(Swift.String(describing: autoAcceptRequests)), autoDeclineConflictingRequests: \(Swift.String(describing: autoDeclineConflictingRequests)), autoDeclineRecurringRequests: \(Swift.String(describing: autoDeclineRecurringRequests)))"}
}

extension WorkMailClientTypes {
    /// At least one delegate must be associated to the resource to disable automatic replies
    ///          from the resource.
    public struct BookingOptions: Swift.Equatable {
        /// The resource's ability to automatically reply to requests. If disabled, delegates
        ///          must be associated to the resource.
        public var autoAcceptRequests: Swift.Bool
        /// The resource's ability to automatically decline any conflicting requests.
        public var autoDeclineConflictingRequests: Swift.Bool
        /// The resource's ability to automatically decline any recurring requests.
        public var autoDeclineRecurringRequests: Swift.Bool

        public init (
            autoAcceptRequests: Swift.Bool = false,
            autoDeclineConflictingRequests: Swift.Bool = false,
            autoDeclineRecurringRequests: Swift.Bool = false
        )
        {
            self.autoAcceptRequests = autoAcceptRequests
            self.autoDeclineConflictingRequests = autoDeclineConflictingRequests
            self.autoDeclineRecurringRequests = autoDeclineRecurringRequests
        }
    }

}

public struct CancelMailboxExportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelMailboxExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelMailboxExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelMailboxExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelMailboxExportJobOutputError>
}

extension CancelMailboxExportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelMailboxExportJobInput(clientToken: \(Swift.String(describing: clientToken)), jobId: \(Swift.String(describing: jobId)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension CancelMailboxExportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case jobId = "JobId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct CancelMailboxExportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelMailboxExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelMailboxExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelMailboxExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelMailboxExportJobOutputError>
}

public struct CancelMailboxExportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelMailboxExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CancelMailboxExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CancelMailboxExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CancelMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelMailboxExportJobOutputError>
}

public struct CancelMailboxExportJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelMailboxExportJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CancelMailboxExportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelMailboxExportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelMailboxExportJobOutputError>
}

public struct CancelMailboxExportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CancelMailboxExportJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CancelMailboxExportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CancelMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CancelMailboxExportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<CancelMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CancelMailboxExportJobOutputError>
}

public struct CancelMailboxExportJobInput: Swift.Equatable {
    /// The idempotency token for the client request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The job ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        jobId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.jobId = jobId
        self.organizationId = organizationId
    }
}

struct CancelMailboxExportJobInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let jobId: Swift.String?
    public let organizationId: Swift.String?
}

extension CancelMailboxExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case jobId = "JobId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension CancelMailboxExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelMailboxExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelMailboxExportJobOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelMailboxExportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelMailboxExportJobOutputResponse()"}
}

extension CancelMailboxExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CancelMailboxExportJobOutputResponse: Swift.Equatable {

    public init() {}
}

struct CancelMailboxExportJobOutputResponseBody: Swift.Equatable {
}

extension CancelMailboxExportJobOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CreateAliasInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAliasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAliasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAliasOutputError>
}

extension CreateAliasInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAliasInput(alias: \(Swift.String(describing: alias)), entityId: \(Swift.String(describing: entityId)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension CreateAliasInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct CreateAliasInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAliasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAliasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAliasOutputError>
}

public struct CreateAliasInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAliasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAliasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAliasOutputError>
}

public struct CreateAliasInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAliasInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateAliasInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAliasInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAliasOutputError>
}

public struct CreateAliasInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAliasInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateAliasInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAliasInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAliasOutputError>
}

public struct CreateAliasInput: Swift.Equatable {
    /// The alias to add to the member set.
    /// This member is required.
    public var alias: Swift.String?
    /// The member (user or group) to which this alias is added.
    /// This member is required.
    public var entityId: Swift.String?
    /// The organization under which the member (user or group) exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        alias: Swift.String? = nil,
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

struct CreateAliasInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let entityId: Swift.String?
    public let alias: Swift.String?
}

extension CreateAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
    }
}

extension CreateAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EmailAddressInUseException" : self = .emailAddressInUseException(try EmailAddressInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainNotFoundException" : self = .mailDomainNotFoundException(try MailDomainNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainStateException" : self = .mailDomainStateException(try MailDomainStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAliasOutputError: Swift.Error, Swift.Equatable {
    case emailAddressInUseException(EmailAddressInUseException)
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case mailDomainNotFoundException(MailDomainNotFoundException)
    case mailDomainStateException(MailDomainStateException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAliasOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAliasOutputResponse()"}
}

extension CreateAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateAliasOutputResponse: Swift.Equatable {

    public init() {}
}

struct CreateAliasOutputResponseBody: Swift.Equatable {
}

extension CreateAliasOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct CreateGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGroupOutputError>
}

extension CreateGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGroupInput(name: \(Swift.String(describing: name)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension CreateGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct CreateGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGroupOutputError>
}

public struct CreateGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGroupOutputError>
}

public struct CreateGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGroupOutputError>
}

public struct CreateGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGroupOutputError>
}

public struct CreateGroupInput: Swift.Equatable {
    /// The name of the group.
    /// This member is required.
    public var name: Swift.String?
    /// The organization under which the group is to be created.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.name = name
        self.organizationId = organizationId
    }
}

struct CreateGroupInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let name: Swift.String?
}

extension CreateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameAvailabilityException" : self = .nameAvailabilityException(try NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNameException" : self = .reservedNameException(try ReservedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGroupOutputError: Swift.Error, Swift.Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case invalidParameterException(InvalidParameterException)
    case nameAvailabilityException(NameAvailabilityException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case reservedNameException(ReservedNameException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGroupOutputResponse(groupId: \(Swift.String(describing: groupId)))"}
}

extension CreateGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groupId = output.groupId
        } else {
            self.groupId = nil
        }
    }
}

public struct CreateGroupOutputResponse: Swift.Equatable {
    /// The identifier of the group.
    public var groupId: Swift.String?

    public init (
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct CreateGroupOutputResponseBody: Swift.Equatable {
    public let groupId: Swift.String?
}

extension CreateGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

public struct CreateMobileDeviceAccessRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMobileDeviceAccessRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMobileDeviceAccessRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMobileDeviceAccessRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMobileDeviceAccessRuleOutputError>
}

extension CreateMobileDeviceAccessRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMobileDeviceAccessRuleInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), deviceModels: \(Swift.String(describing: deviceModels)), deviceOperatingSystems: \(Swift.String(describing: deviceOperatingSystems)), deviceTypes: \(Swift.String(describing: deviceTypes)), deviceUserAgents: \(Swift.String(describing: deviceUserAgents)), effect: \(Swift.String(describing: effect)), name: \(Swift.String(describing: name)), notDeviceModels: \(Swift.String(describing: notDeviceModels)), notDeviceOperatingSystems: \(Swift.String(describing: notDeviceOperatingSystems)), notDeviceTypes: \(Swift.String(describing: notDeviceTypes)), notDeviceUserAgents: \(Swift.String(describing: notDeviceUserAgents)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension CreateMobileDeviceAccessRuleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case deviceModels = "DeviceModels"
        case deviceOperatingSystems = "DeviceOperatingSystems"
        case deviceTypes = "DeviceTypes"
        case deviceUserAgents = "DeviceUserAgents"
        case effect = "Effect"
        case name = "Name"
        case notDeviceModels = "NotDeviceModels"
        case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
        case notDeviceTypes = "NotDeviceTypes"
        case notDeviceUserAgents = "NotDeviceUserAgents"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceModels = deviceModels {
            var deviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceModels)
            for devicemodellist0 in deviceModels {
                try deviceModelsContainer.encode(devicemodellist0)
            }
        }
        if let deviceOperatingSystems = deviceOperatingSystems {
            var deviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceOperatingSystems)
            for deviceoperatingsystemlist0 in deviceOperatingSystems {
                try deviceOperatingSystemsContainer.encode(deviceoperatingsystemlist0)
            }
        }
        if let deviceTypes = deviceTypes {
            var deviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceTypes)
            for devicetypelist0 in deviceTypes {
                try deviceTypesContainer.encode(devicetypelist0)
            }
        }
        if let deviceUserAgents = deviceUserAgents {
            var deviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceUserAgents)
            for deviceuseragentlist0 in deviceUserAgents {
                try deviceUserAgentsContainer.encode(deviceuseragentlist0)
            }
        }
        if let effect = effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notDeviceModels = notDeviceModels {
            var notDeviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceModels)
            for devicemodellist0 in notDeviceModels {
                try notDeviceModelsContainer.encode(devicemodellist0)
            }
        }
        if let notDeviceOperatingSystems = notDeviceOperatingSystems {
            var notDeviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceOperatingSystems)
            for deviceoperatingsystemlist0 in notDeviceOperatingSystems {
                try notDeviceOperatingSystemsContainer.encode(deviceoperatingsystemlist0)
            }
        }
        if let notDeviceTypes = notDeviceTypes {
            var notDeviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceTypes)
            for devicetypelist0 in notDeviceTypes {
                try notDeviceTypesContainer.encode(devicetypelist0)
            }
        }
        if let notDeviceUserAgents = notDeviceUserAgents {
            var notDeviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceUserAgents)
            for deviceuseragentlist0 in notDeviceUserAgents {
                try notDeviceUserAgentsContainer.encode(deviceuseragentlist0)
            }
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct CreateMobileDeviceAccessRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMobileDeviceAccessRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMobileDeviceAccessRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMobileDeviceAccessRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMobileDeviceAccessRuleOutputError>
}

public struct CreateMobileDeviceAccessRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMobileDeviceAccessRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateMobileDeviceAccessRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateMobileDeviceAccessRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMobileDeviceAccessRuleOutputError>
}

public struct CreateMobileDeviceAccessRuleInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMobileDeviceAccessRuleInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateMobileDeviceAccessRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateMobileDeviceAccessRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMobileDeviceAccessRuleOutputError>
}

public struct CreateMobileDeviceAccessRuleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateMobileDeviceAccessRuleInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateMobileDeviceAccessRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateMobileDeviceAccessRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateMobileDeviceAccessRuleOutputError>
}

public struct CreateMobileDeviceAccessRuleInput: Swift.Equatable {
    /// The idempotency token for the client request.
    public var clientToken: Swift.String?
    /// The rule description.
    public var description: Swift.String?
    /// Device models that the rule will match.
    public var deviceModels: [Swift.String]?
    /// Device operating systems that the rule will match.
    public var deviceOperatingSystems: [Swift.String]?
    /// Device types that the rule will match.
    public var deviceTypes: [Swift.String]?
    /// Device user agents that the rule will match.
    public var deviceUserAgents: [Swift.String]?
    /// The effect of the rule when it matches. Allowed values are ALLOW or DENY.
    /// This member is required.
    public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    /// The rule name.
    /// This member is required.
    public var name: Swift.String?
    /// Device models that the rule will not match. All other device models will match.
    public var notDeviceModels: [Swift.String]?
    /// Device operating systems that the rule will not match. All other device operating systems will match.
    public var notDeviceOperatingSystems: [Swift.String]?
    /// Device types that the rule will not match. All other device types will match.
    public var notDeviceTypes: [Swift.String]?
    /// Device user agents that the rule will not match. All other device user agents will match.
    public var notDeviceUserAgents: [Swift.String]?
    /// The Amazon WorkMail organization under which the rule will be created.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        deviceModels: [Swift.String]? = nil,
        deviceOperatingSystems: [Swift.String]? = nil,
        deviceTypes: [Swift.String]? = nil,
        deviceUserAgents: [Swift.String]? = nil,
        effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
        name: Swift.String? = nil,
        notDeviceModels: [Swift.String]? = nil,
        notDeviceOperatingSystems: [Swift.String]? = nil,
        notDeviceTypes: [Swift.String]? = nil,
        notDeviceUserAgents: [Swift.String]? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.deviceModels = deviceModels
        self.deviceOperatingSystems = deviceOperatingSystems
        self.deviceTypes = deviceTypes
        self.deviceUserAgents = deviceUserAgents
        self.effect = effect
        self.name = name
        self.notDeviceModels = notDeviceModels
        self.notDeviceOperatingSystems = notDeviceOperatingSystems
        self.notDeviceTypes = notDeviceTypes
        self.notDeviceUserAgents = notDeviceUserAgents
        self.organizationId = organizationId
    }
}

struct CreateMobileDeviceAccessRuleInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let clientToken: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    public let deviceTypes: [Swift.String]?
    public let notDeviceTypes: [Swift.String]?
    public let deviceModels: [Swift.String]?
    public let notDeviceModels: [Swift.String]?
    public let deviceOperatingSystems: [Swift.String]?
    public let notDeviceOperatingSystems: [Swift.String]?
    public let deviceUserAgents: [Swift.String]?
    public let notDeviceUserAgents: [Swift.String]?
}

extension CreateMobileDeviceAccessRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case deviceModels = "DeviceModels"
        case deviceOperatingSystems = "DeviceOperatingSystems"
        case deviceTypes = "DeviceTypes"
        case deviceUserAgents = "DeviceUserAgents"
        case effect = "Effect"
        case name = "Name"
        case notDeviceModels = "NotDeviceModels"
        case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
        case notDeviceTypes = "NotDeviceTypes"
        case notDeviceUserAgents = "NotDeviceUserAgents"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let deviceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceTypes)
        var deviceTypesDecoded0:[Swift.String]? = nil
        if let deviceTypesContainer = deviceTypesContainer {
            deviceTypesDecoded0 = [Swift.String]()
            for string0 in deviceTypesContainer {
                if let string0 = string0 {
                    deviceTypesDecoded0?.append(string0)
                }
            }
        }
        deviceTypes = deviceTypesDecoded0
        let notDeviceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceTypes)
        var notDeviceTypesDecoded0:[Swift.String]? = nil
        if let notDeviceTypesContainer = notDeviceTypesContainer {
            notDeviceTypesDecoded0 = [Swift.String]()
            for string0 in notDeviceTypesContainer {
                if let string0 = string0 {
                    notDeviceTypesDecoded0?.append(string0)
                }
            }
        }
        notDeviceTypes = notDeviceTypesDecoded0
        let deviceModelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceModels)
        var deviceModelsDecoded0:[Swift.String]? = nil
        if let deviceModelsContainer = deviceModelsContainer {
            deviceModelsDecoded0 = [Swift.String]()
            for string0 in deviceModelsContainer {
                if let string0 = string0 {
                    deviceModelsDecoded0?.append(string0)
                }
            }
        }
        deviceModels = deviceModelsDecoded0
        let notDeviceModelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceModels)
        var notDeviceModelsDecoded0:[Swift.String]? = nil
        if let notDeviceModelsContainer = notDeviceModelsContainer {
            notDeviceModelsDecoded0 = [Swift.String]()
            for string0 in notDeviceModelsContainer {
                if let string0 = string0 {
                    notDeviceModelsDecoded0?.append(string0)
                }
            }
        }
        notDeviceModels = notDeviceModelsDecoded0
        let deviceOperatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceOperatingSystems)
        var deviceOperatingSystemsDecoded0:[Swift.String]? = nil
        if let deviceOperatingSystemsContainer = deviceOperatingSystemsContainer {
            deviceOperatingSystemsDecoded0 = [Swift.String]()
            for string0 in deviceOperatingSystemsContainer {
                if let string0 = string0 {
                    deviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        deviceOperatingSystems = deviceOperatingSystemsDecoded0
        let notDeviceOperatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceOperatingSystems)
        var notDeviceOperatingSystemsDecoded0:[Swift.String]? = nil
        if let notDeviceOperatingSystemsContainer = notDeviceOperatingSystemsContainer {
            notDeviceOperatingSystemsDecoded0 = [Swift.String]()
            for string0 in notDeviceOperatingSystemsContainer {
                if let string0 = string0 {
                    notDeviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        notDeviceOperatingSystems = notDeviceOperatingSystemsDecoded0
        let deviceUserAgentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceUserAgents)
        var deviceUserAgentsDecoded0:[Swift.String]? = nil
        if let deviceUserAgentsContainer = deviceUserAgentsContainer {
            deviceUserAgentsDecoded0 = [Swift.String]()
            for string0 in deviceUserAgentsContainer {
                if let string0 = string0 {
                    deviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        deviceUserAgents = deviceUserAgentsDecoded0
        let notDeviceUserAgentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceUserAgents)
        var notDeviceUserAgentsDecoded0:[Swift.String]? = nil
        if let notDeviceUserAgentsContainer = notDeviceUserAgentsContainer {
            notDeviceUserAgentsDecoded0 = [Swift.String]()
            for string0 in notDeviceUserAgentsContainer {
                if let string0 = string0 {
                    notDeviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        notDeviceUserAgents = notDeviceUserAgentsDecoded0
    }
}

extension CreateMobileDeviceAccessRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMobileDeviceAccessRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMobileDeviceAccessRuleOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMobileDeviceAccessRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateMobileDeviceAccessRuleOutputResponse(mobileDeviceAccessRuleId: \(Swift.String(describing: mobileDeviceAccessRuleId)))"}
}

extension CreateMobileDeviceAccessRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateMobileDeviceAccessRuleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mobileDeviceAccessRuleId = output.mobileDeviceAccessRuleId
        } else {
            self.mobileDeviceAccessRuleId = nil
        }
    }
}

public struct CreateMobileDeviceAccessRuleOutputResponse: Swift.Equatable {
    /// The identifier for the newly created mobile device access rule.
    public var mobileDeviceAccessRuleId: Swift.String?

    public init (
        mobileDeviceAccessRuleId: Swift.String? = nil
    )
    {
        self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
    }
}

struct CreateMobileDeviceAccessRuleOutputResponseBody: Swift.Equatable {
    public let mobileDeviceAccessRuleId: Swift.String?
}

extension CreateMobileDeviceAccessRuleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mobileDeviceAccessRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mobileDeviceAccessRuleId)
        mobileDeviceAccessRuleId = mobileDeviceAccessRuleIdDecoded
    }
}

public struct CreateOrganizationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOrganizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOrganizationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOrganizationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOrganizationOutputError>
}

extension CreateOrganizationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOrganizationInput(alias: \(Swift.String(describing: alias)), clientToken: \(Swift.String(describing: clientToken)), directoryId: \(Swift.String(describing: directoryId)), domains: \(Swift.String(describing: domains)), enableInteroperability: \(Swift.String(describing: enableInteroperability)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)))"}
}

extension CreateOrganizationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case clientToken = "ClientToken"
        case directoryId = "DirectoryId"
        case domains = "Domains"
        case enableInteroperability = "EnableInteroperability"
        case kmsKeyArn = "KmsKeyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let directoryId = directoryId {
            try encodeContainer.encode(directoryId, forKey: .directoryId)
        }
        if let domains = domains {
            var domainsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .domains)
            for domains0 in domains {
                try domainsContainer.encode(domains0)
            }
        }
        if enableInteroperability != false {
            try encodeContainer.encode(enableInteroperability, forKey: .enableInteroperability)
        }
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }
}

public struct CreateOrganizationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOrganizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOrganizationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOrganizationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOrganizationOutputError>
}

public struct CreateOrganizationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOrganizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateOrganizationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateOrganizationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOrganizationOutputError>
}

public struct CreateOrganizationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOrganizationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateOrganizationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateOrganizationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOrganizationOutputError>
}

public struct CreateOrganizationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateOrganizationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateOrganizationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateOrganizationInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateOrganizationOutputError>
}

public struct CreateOrganizationInput: Swift.Equatable {
    /// The organization alias.
    /// This member is required.
    public var alias: Swift.String?
    /// The idempotency token associated with the request.
    public var clientToken: Swift.String?
    /// The AWS Directory Service directory ID.
    public var directoryId: Swift.String?
    /// The email domains to associate with the organization.
    public var domains: [WorkMailClientTypes.Domain]?
    /// When true, allows organization interoperability between Amazon WorkMail and Microsoft Exchange. Can only be set to true if an AD Connector directory ID is included in the request.
    public var enableInteroperability: Swift.Bool
    /// The Amazon Resource Name (ARN) of a customer managed master key from AWS
    ///          KMS.
    public var kmsKeyArn: Swift.String?

    public init (
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        directoryId: Swift.String? = nil,
        domains: [WorkMailClientTypes.Domain]? = nil,
        enableInteroperability: Swift.Bool = false,
        kmsKeyArn: Swift.String? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.directoryId = directoryId
        self.domains = domains
        self.enableInteroperability = enableInteroperability
        self.kmsKeyArn = kmsKeyArn
    }
}

struct CreateOrganizationInputBody: Swift.Equatable {
    public let directoryId: Swift.String?
    public let alias: Swift.String?
    public let clientToken: Swift.String?
    public let domains: [WorkMailClientTypes.Domain]?
    public let kmsKeyArn: Swift.String?
    public let enableInteroperability: Swift.Bool
}

extension CreateOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case clientToken = "ClientToken"
        case directoryId = "DirectoryId"
        case domains = "Domains"
        case enableInteroperability = "EnableInteroperability"
        case kmsKeyArn = "KmsKeyArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let domainsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Domain?].self, forKey: .domains)
        var domainsDecoded0:[WorkMailClientTypes.Domain]? = nil
        if let domainsContainer = domainsContainer {
            domainsDecoded0 = [WorkMailClientTypes.Domain]()
            for structure0 in domainsContainer {
                if let structure0 = structure0 {
                    domainsDecoded0?.append(structure0)
                }
            }
        }
        domains = domainsDecoded0
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let enableInteroperabilityDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enableInteroperability)
        enableInteroperability = enableInteroperabilityDecoded
    }
}

extension CreateOrganizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateOrganizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryInUseException" : self = .directoryInUseException(try DirectoryInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameAvailabilityException" : self = .nameAvailabilityException(try NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateOrganizationOutputError: Swift.Error, Swift.Equatable {
    case directoryInUseException(DirectoryInUseException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case nameAvailabilityException(NameAvailabilityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateOrganizationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateOrganizationOutputResponse(organizationId: \(Swift.String(describing: organizationId)))"}
}

extension CreateOrganizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.organizationId = output.organizationId
        } else {
            self.organizationId = nil
        }
    }
}

public struct CreateOrganizationOutputResponse: Swift.Equatable {
    /// The organization ID.
    public var organizationId: Swift.String?

    public init (
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct CreateOrganizationOutputResponseBody: Swift.Equatable {
    public let organizationId: Swift.String?
}

extension CreateOrganizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

public struct CreateResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceOutputError>
}

extension CreateResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateResourceInput(name: \(Swift.String(describing: name)), organizationId: \(Swift.String(describing: organizationId)), type: \(Swift.String(describing: type)))"}
}

extension CreateResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case organizationId = "OrganizationId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceOutputError>
}

public struct CreateResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceOutputError>
}

public struct CreateResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceOutputError>
}

public struct CreateResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateResourceOutputError>
}

public struct CreateResourceInput: Swift.Equatable {
    /// The name of the new resource.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier associated with the organization for which the resource is
    ///          created.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The type of the new resource. The available types are equipment and
    ///             room.
    /// This member is required.
    public var type: WorkMailClientTypes.ResourceType?

    public init (
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        type: WorkMailClientTypes.ResourceType? = nil
    )
    {
        self.name = name
        self.organizationId = organizationId
        self.type = type
    }
}

struct CreateResourceInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let name: Swift.String?
    public let type: WorkMailClientTypes.ResourceType?
}

extension CreateResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case organizationId = "OrganizationId"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ResourceType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CreateResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameAvailabilityException" : self = .nameAvailabilityException(try NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNameException" : self = .reservedNameException(try ReservedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResourceOutputError: Swift.Error, Swift.Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case invalidParameterException(InvalidParameterException)
    case nameAvailabilityException(NameAvailabilityException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case reservedNameException(ReservedNameException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateResourceOutputResponse(resourceId: \(Swift.String(describing: resourceId)))"}
}

extension CreateResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceId = output.resourceId
        } else {
            self.resourceId = nil
        }
    }
}

public struct CreateResourceOutputResponse: Swift.Equatable {
    /// The identifier of the new resource.
    public var resourceId: Swift.String?

    public init (
        resourceId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
    }
}

struct CreateResourceOutputResponseBody: Swift.Equatable {
    public let resourceId: Swift.String?
}

extension CreateResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

public struct CreateUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

extension CreateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserInput(displayName: \(Swift.String(describing: displayName)), name: \(Swift.String(describing: name)), organizationId: \(Swift.String(describing: organizationId)), password: \(Swift.String(describing: password)))"}
}

extension CreateUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case name = "Name"
        case organizationId = "OrganizationId"
        case password = "Password"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
    }
}

public struct CreateUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

public struct CreateUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

public struct CreateUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: CreateUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

public struct CreateUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: CreateUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateUserOutputError>
}

public struct CreateUserInput: Swift.Equatable {
    /// The display name for the new user.
    /// This member is required.
    public var displayName: Swift.String?
    /// The name for the new user. WorkMail directory user names have a maximum length of 64. All others have a maximum length of 20.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the organization for which the user is created.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The password for the new user.
    /// This member is required.
    public var password: Swift.String?

    public init (
        displayName: Swift.String? = nil,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        password: Swift.String? = nil
    )
    {
        self.displayName = displayName
        self.name = name
        self.organizationId = organizationId
        self.password = password
    }
}

struct CreateUserInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let name: Swift.String?
    public let displayName: Swift.String?
    public let password: Swift.String?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case displayName = "DisplayName"
        case name = "Name"
        case organizationId = "OrganizationId"
        case password = "Password"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension CreateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPasswordException" : self = .invalidPasswordException(try InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameAvailabilityException" : self = .nameAvailabilityException(try NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ReservedNameException" : self = .reservedNameException(try ReservedNameException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserOutputError: Swift.Error, Swift.Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case invalidParameterException(InvalidParameterException)
    case invalidPasswordException(InvalidPasswordException)
    case nameAvailabilityException(NameAvailabilityException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case reservedNameException(ReservedNameException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserOutputResponse(userId: \(Swift.String(describing: userId)))"}
}

extension CreateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userId = output.userId
        } else {
            self.userId = nil
        }
    }
}

public struct CreateUserOutputResponse: Swift.Equatable {
    /// The identifier for the new user.
    public var userId: Swift.String?

    public init (
        userId: Swift.String? = nil
    )
    {
        self.userId = userId
    }
}

struct CreateUserOutputResponseBody: Swift.Equatable {
    public let userId: Swift.String?
}

extension CreateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension WorkMailClientTypes.Delegate: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MemberType.self, forKey: .type)
        type = typeDecoded
    }
}

extension WorkMailClientTypes.Delegate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Delegate(id: \(Swift.String(describing: id)), type: \(Swift.String(describing: type)))"}
}

extension WorkMailClientTypes {
    /// The name of the attribute, which is one of the values defined in the UserAttribute
    ///          enumeration.
    public struct Delegate: Swift.Equatable {
        /// The identifier for the user or group associated as the resource's delegate.
        /// This member is required.
        public var id: Swift.String?
        /// The type of the delegate: user or group.
        /// This member is required.
        public var type: WorkMailClientTypes.MemberType?

        public init (
            id: Swift.String? = nil,
            type: WorkMailClientTypes.MemberType? = nil
        )
        {
            self.id = id
            self.type = type
        }
    }

}

public struct DeleteAccessControlRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAccessControlRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAccessControlRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAccessControlRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAccessControlRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAccessControlRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAccessControlRuleOutputError>
}

extension DeleteAccessControlRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAccessControlRuleInput(name: \(Swift.String(describing: name)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension DeleteAccessControlRuleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DeleteAccessControlRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAccessControlRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAccessControlRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAccessControlRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAccessControlRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAccessControlRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAccessControlRuleOutputError>
}

public struct DeleteAccessControlRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAccessControlRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAccessControlRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAccessControlRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAccessControlRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAccessControlRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAccessControlRuleOutputError>
}

public struct DeleteAccessControlRuleInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAccessControlRuleInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteAccessControlRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAccessControlRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAccessControlRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAccessControlRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAccessControlRuleOutputError>
}

public struct DeleteAccessControlRuleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAccessControlRuleInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteAccessControlRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAccessControlRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAccessControlRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAccessControlRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAccessControlRuleOutputError>
}

public struct DeleteAccessControlRuleInput: Swift.Equatable {
    /// The name of the access control rule.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier for the organization.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.name = name
        self.organizationId = organizationId
    }
}

struct DeleteAccessControlRuleInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let name: Swift.String?
}

extension DeleteAccessControlRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteAccessControlRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccessControlRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccessControlRuleOutputError: Swift.Error, Swift.Equatable {
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessControlRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAccessControlRuleOutputResponse()"}
}

extension DeleteAccessControlRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessControlRuleOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAccessControlRuleOutputResponseBody: Swift.Equatable {
}

extension DeleteAccessControlRuleOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteAliasInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAliasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAliasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAliasOutputError>
}

extension DeleteAliasInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAliasInput(alias: \(Swift.String(describing: alias)), entityId: \(Swift.String(describing: entityId)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension DeleteAliasInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DeleteAliasInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAliasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAliasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAliasOutputError>
}

public struct DeleteAliasInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAliasInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAliasInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAliasOutputError>
}

public struct DeleteAliasInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAliasInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteAliasInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAliasInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAliasOutputError>
}

public struct DeleteAliasInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAliasInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteAliasInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAliasInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAliasOutputError>
}

public struct DeleteAliasInput: Swift.Equatable {
    /// The aliases to be removed from the user's set of aliases. Duplicate entries in the
    ///          list are collapsed into single entries (the list is transformed into a set).
    /// This member is required.
    public var alias: Swift.String?
    /// The identifier for the member (user or group) from which to have the aliases
    ///          removed.
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier for the organization under which the user exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        alias: Swift.String? = nil,
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

struct DeleteAliasInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let entityId: Swift.String?
    public let alias: Swift.String?
}

extension DeleteAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
    }
}

extension DeleteAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAliasOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAliasOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAliasOutputResponse()"}
}

extension DeleteAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAliasOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAliasOutputResponseBody: Swift.Equatable {
}

extension DeleteAliasOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGroupOutputError>
}

extension DeleteGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteGroupInput(groupId: \(Swift.String(describing: groupId)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension DeleteGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DeleteGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGroupOutputError>
}

public struct DeleteGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGroupOutputError>
}

public struct DeleteGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGroupOutputError>
}

public struct DeleteGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGroupOutputError>
}

public struct DeleteGroupInput: Swift.Equatable {
    /// The identifier of the group to be deleted.
    /// This member is required.
    public var groupId: Swift.String?
    /// The organization that contains the group.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.organizationId = organizationId
    }
}

struct DeleteGroupInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let groupId: Swift.String?
}

extension DeleteGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension DeleteGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGroupOutputError: Swift.Error, Swift.Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteGroupOutputResponse()"}
}

extension DeleteGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteGroupOutputResponseBody: Swift.Equatable {
}

extension DeleteGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteMailboxPermissionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMailboxPermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMailboxPermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMailboxPermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMailboxPermissionsOutputError>
}

extension DeleteMailboxPermissionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMailboxPermissionsInput(entityId: \(Swift.String(describing: entityId)), granteeId: \(Swift.String(describing: granteeId)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension DeleteMailboxPermissionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case granteeId = "GranteeId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let granteeId = granteeId {
            try encodeContainer.encode(granteeId, forKey: .granteeId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DeleteMailboxPermissionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMailboxPermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMailboxPermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMailboxPermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMailboxPermissionsOutputError>
}

public struct DeleteMailboxPermissionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMailboxPermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMailboxPermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMailboxPermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMailboxPermissionsOutputError>
}

public struct DeleteMailboxPermissionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMailboxPermissionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteMailboxPermissionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteMailboxPermissionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMailboxPermissionsOutputError>
}

public struct DeleteMailboxPermissionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMailboxPermissionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteMailboxPermissionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteMailboxPermissionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMailboxPermissionsOutputError>
}

public struct DeleteMailboxPermissionsInput: Swift.Equatable {
    /// The identifier of the member (user or group) that owns the mailbox.
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier of the member (user or group) for which to delete granted
    ///          permissions.
    /// This member is required.
    public var granteeId: Swift.String?
    /// The identifier of the organization under which the member (user or group)
    ///          exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        entityId: Swift.String? = nil,
        granteeId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.granteeId = granteeId
        self.organizationId = organizationId
    }
}

struct DeleteMailboxPermissionsInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let entityId: Swift.String?
    public let granteeId: Swift.String?
}

extension DeleteMailboxPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case granteeId = "GranteeId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let granteeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .granteeId)
        granteeId = granteeIdDecoded
    }
}

extension DeleteMailboxPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMailboxPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMailboxPermissionsOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMailboxPermissionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMailboxPermissionsOutputResponse()"}
}

extension DeleteMailboxPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMailboxPermissionsOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteMailboxPermissionsOutputResponseBody: Swift.Equatable {
}

extension DeleteMailboxPermissionsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteMobileDeviceAccessOverrideInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMobileDeviceAccessOverrideInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMobileDeviceAccessOverrideInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMobileDeviceAccessOverrideOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMobileDeviceAccessOverrideInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMobileDeviceAccessOverrideOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMobileDeviceAccessOverrideOutputError>
}

extension DeleteMobileDeviceAccessOverrideInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMobileDeviceAccessOverrideInput(deviceId: \(Swift.String(describing: deviceId)), organizationId: \(Swift.String(describing: organizationId)), userId: \(Swift.String(describing: userId)))"}
}

extension DeleteMobileDeviceAccessOverrideInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct DeleteMobileDeviceAccessOverrideInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMobileDeviceAccessOverrideInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMobileDeviceAccessOverrideInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMobileDeviceAccessOverrideOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMobileDeviceAccessOverrideInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMobileDeviceAccessOverrideOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMobileDeviceAccessOverrideOutputError>
}

public struct DeleteMobileDeviceAccessOverrideInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMobileDeviceAccessOverrideInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMobileDeviceAccessOverrideInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMobileDeviceAccessOverrideOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMobileDeviceAccessOverrideInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMobileDeviceAccessOverrideOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMobileDeviceAccessOverrideOutputError>
}

public struct DeleteMobileDeviceAccessOverrideInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMobileDeviceAccessOverrideInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteMobileDeviceAccessOverrideInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMobileDeviceAccessOverrideOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteMobileDeviceAccessOverrideInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMobileDeviceAccessOverrideOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMobileDeviceAccessOverrideOutputError>
}

public struct DeleteMobileDeviceAccessOverrideInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMobileDeviceAccessOverrideInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteMobileDeviceAccessOverrideInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMobileDeviceAccessOverrideOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteMobileDeviceAccessOverrideInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMobileDeviceAccessOverrideOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMobileDeviceAccessOverrideOutputError>
}

public struct DeleteMobileDeviceAccessOverrideInput: Swift.Equatable {
    /// The mobile device for which you delete the override. DeviceId is case insensitive.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The Amazon WorkMail organization for which the access override will be deleted.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The WorkMail user for which you want to delete the override. Accepts the following types of user identities:
    ///
    ///
    ///                User ID:  12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    ///
    ///
    ///                Email address: user@domain.tld
    ///
    ///
    ///
    ///                User name: user
    ///
    ///
    ///
    /// This member is required.
    public var userId: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct DeleteMobileDeviceAccessOverrideInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let userId: Swift.String?
    public let deviceId: Swift.String?
}

extension DeleteMobileDeviceAccessOverrideInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

extension DeleteMobileDeviceAccessOverrideOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMobileDeviceAccessOverrideOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMobileDeviceAccessOverrideOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMobileDeviceAccessOverrideOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMobileDeviceAccessOverrideOutputResponse()"}
}

extension DeleteMobileDeviceAccessOverrideOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMobileDeviceAccessOverrideOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteMobileDeviceAccessOverrideOutputResponseBody: Swift.Equatable {
}

extension DeleteMobileDeviceAccessOverrideOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteMobileDeviceAccessRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMobileDeviceAccessRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMobileDeviceAccessRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMobileDeviceAccessRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMobileDeviceAccessRuleOutputError>
}

extension DeleteMobileDeviceAccessRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMobileDeviceAccessRuleInput(mobileDeviceAccessRuleId: \(Swift.String(describing: mobileDeviceAccessRuleId)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension DeleteMobileDeviceAccessRuleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mobileDeviceAccessRuleId = mobileDeviceAccessRuleId {
            try encodeContainer.encode(mobileDeviceAccessRuleId, forKey: .mobileDeviceAccessRuleId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DeleteMobileDeviceAccessRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMobileDeviceAccessRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMobileDeviceAccessRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMobileDeviceAccessRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMobileDeviceAccessRuleOutputError>
}

public struct DeleteMobileDeviceAccessRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMobileDeviceAccessRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteMobileDeviceAccessRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteMobileDeviceAccessRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMobileDeviceAccessRuleOutputError>
}

public struct DeleteMobileDeviceAccessRuleInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMobileDeviceAccessRuleInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteMobileDeviceAccessRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteMobileDeviceAccessRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMobileDeviceAccessRuleOutputError>
}

public struct DeleteMobileDeviceAccessRuleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteMobileDeviceAccessRuleInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteMobileDeviceAccessRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteMobileDeviceAccessRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteMobileDeviceAccessRuleOutputError>
}

public struct DeleteMobileDeviceAccessRuleInput: Swift.Equatable {
    /// The identifier of the rule to be deleted.
    /// This member is required.
    public var mobileDeviceAccessRuleId: Swift.String?
    /// The Amazon WorkMail organization under which the rule will be deleted.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        mobileDeviceAccessRuleId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
        self.organizationId = organizationId
    }
}

struct DeleteMobileDeviceAccessRuleInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let mobileDeviceAccessRuleId: Swift.String?
}

extension DeleteMobileDeviceAccessRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let mobileDeviceAccessRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mobileDeviceAccessRuleId)
        mobileDeviceAccessRuleId = mobileDeviceAccessRuleIdDecoded
    }
}

extension DeleteMobileDeviceAccessRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMobileDeviceAccessRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMobileDeviceAccessRuleOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMobileDeviceAccessRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteMobileDeviceAccessRuleOutputResponse()"}
}

extension DeleteMobileDeviceAccessRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteMobileDeviceAccessRuleOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteMobileDeviceAccessRuleOutputResponseBody: Swift.Equatable {
}

extension DeleteMobileDeviceAccessRuleOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteOrganizationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOrganizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOrganizationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOrganizationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOrganizationOutputError>
}

extension DeleteOrganizationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteOrganizationInput(clientToken: \(Swift.String(describing: clientToken)), deleteDirectory: \(Swift.String(describing: deleteDirectory)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension DeleteOrganizationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case deleteDirectory = "DeleteDirectory"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if deleteDirectory != false {
            try encodeContainer.encode(deleteDirectory, forKey: .deleteDirectory)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DeleteOrganizationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOrganizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOrganizationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOrganizationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOrganizationOutputError>
}

public struct DeleteOrganizationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOrganizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteOrganizationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteOrganizationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOrganizationOutputError>
}

public struct DeleteOrganizationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOrganizationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteOrganizationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteOrganizationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOrganizationOutputError>
}

public struct DeleteOrganizationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteOrganizationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteOrganizationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteOrganizationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteOrganizationOutputError>
}

public struct DeleteOrganizationInput: Swift.Equatable {
    /// The idempotency token associated with the request.
    public var clientToken: Swift.String?
    /// If true, deletes the AWS Directory Service directory associated with the organization.
    /// This member is required.
    public var deleteDirectory: Swift.Bool
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        deleteDirectory: Swift.Bool = false,
        organizationId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.deleteDirectory = deleteDirectory
        self.organizationId = organizationId
    }
}

struct DeleteOrganizationInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let organizationId: Swift.String?
    public let deleteDirectory: Swift.Bool
}

extension DeleteOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case deleteDirectory = "DeleteDirectory"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let deleteDirectoryDecoded = try containerValues.decode(Swift.Bool.self, forKey: .deleteDirectory)
        deleteDirectory = deleteDirectoryDecoded
    }
}

extension DeleteOrganizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteOrganizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteOrganizationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteOrganizationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteOrganizationOutputResponse(organizationId: \(Swift.String(describing: organizationId)), state: \(Swift.String(describing: state)))"}
}

extension DeleteOrganizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.organizationId = output.organizationId
            self.state = output.state
        } else {
            self.organizationId = nil
            self.state = nil
        }
    }
}

public struct DeleteOrganizationOutputResponse: Swift.Equatable {
    /// The organization ID.
    public var organizationId: Swift.String?
    /// The state of the organization.
    public var state: Swift.String?

    public init (
        organizationId: Swift.String? = nil,
        state: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.state = state
    }
}

struct DeleteOrganizationOutputResponseBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let state: Swift.String?
}

extension DeleteOrganizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
    }
}

public struct DeleteResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceOutputError>
}

extension DeleteResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResourceInput(organizationId: \(Swift.String(describing: organizationId)), resourceId: \(Swift.String(describing: resourceId)))"}
}

extension DeleteResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct DeleteResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceOutputError>
}

public struct DeleteResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceOutputError>
}

public struct DeleteResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceOutputError>
}

public struct DeleteResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteResourceOutputError>
}

public struct DeleteResourceInput: Swift.Equatable {
    /// The identifier associated with the organization from which the resource is
    ///          deleted.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier of the resource to be deleted.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct DeleteResourceInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let resourceId: Swift.String?
}

extension DeleteResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DeleteResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourceOutputError: Swift.Error, Swift.Equatable {
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteResourceOutputResponse()"}
}

extension DeleteResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteResourceOutputResponseBody: Swift.Equatable {
}

extension DeleteResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteRetentionPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRetentionPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRetentionPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRetentionPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRetentionPolicyOutputError>
}

extension DeleteRetentionPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRetentionPolicyInput(id: \(Swift.String(describing: id)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension DeleteRetentionPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DeleteRetentionPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRetentionPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRetentionPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRetentionPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRetentionPolicyOutputError>
}

public struct DeleteRetentionPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRetentionPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteRetentionPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteRetentionPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRetentionPolicyOutputError>
}

public struct DeleteRetentionPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRetentionPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteRetentionPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRetentionPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRetentionPolicyOutputError>
}

public struct DeleteRetentionPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteRetentionPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteRetentionPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteRetentionPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteRetentionPolicyOutputError>
}

public struct DeleteRetentionPolicyInput: Swift.Equatable {
    /// The retention policy ID.
    /// This member is required.
    public var id: Swift.String?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        id: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.id = id
        self.organizationId = organizationId
    }
}

struct DeleteRetentionPolicyInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let id: Swift.String?
}

extension DeleteRetentionPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteRetentionPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRetentionPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRetentionPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRetentionPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteRetentionPolicyOutputResponse()"}
}

extension DeleteRetentionPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRetentionPolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteRetentionPolicyOutputResponseBody: Swift.Equatable {
}

extension DeleteRetentionPolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserOutputError>
}

extension DeleteUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUserInput(organizationId: \(Swift.String(describing: organizationId)), userId: \(Swift.String(describing: userId)))"}
}

extension DeleteUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct DeleteUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserOutputError>
}

public struct DeleteUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserOutputError>
}

public struct DeleteUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeleteUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserOutputError>
}

public struct DeleteUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeleteUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteUserOutputError>
}

public struct DeleteUserInput: Swift.Equatable {
    /// The organization that contains the user to be deleted.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier of the user to be deleted.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct DeleteUserInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let userId: Swift.String?
}

extension DeleteUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension DeleteUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserOutputError: Swift.Error, Swift.Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteUserOutputResponse()"}
}

extension DeleteUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteUserOutputResponseBody: Swift.Equatable {
}

extension DeleteUserOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeregisterFromWorkMailInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterFromWorkMailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterFromWorkMailInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterFromWorkMailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterFromWorkMailInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterFromWorkMailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterFromWorkMailOutputError>
}

extension DeregisterFromWorkMailInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterFromWorkMailInput(entityId: \(Swift.String(describing: entityId)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension DeregisterFromWorkMailInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DeregisterFromWorkMailInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterFromWorkMailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterFromWorkMailInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterFromWorkMailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterFromWorkMailInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterFromWorkMailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterFromWorkMailOutputError>
}

public struct DeregisterFromWorkMailInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterFromWorkMailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterFromWorkMailInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterFromWorkMailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterFromWorkMailInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterFromWorkMailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterFromWorkMailOutputError>
}

public struct DeregisterFromWorkMailInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterFromWorkMailInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DeregisterFromWorkMailInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterFromWorkMailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterFromWorkMailInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterFromWorkMailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterFromWorkMailOutputError>
}

public struct DeregisterFromWorkMailInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterFromWorkMailInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DeregisterFromWorkMailInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterFromWorkMailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeregisterFromWorkMailInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterFromWorkMailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterFromWorkMailOutputError>
}

public struct DeregisterFromWorkMailInput: Swift.Equatable {
    /// The identifier for the member (user or group) to be updated.
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier for the organization under which the Amazon WorkMail entity exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

struct DeregisterFromWorkMailInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let entityId: Swift.String?
}

extension DeregisterFromWorkMailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
    }
}

extension DeregisterFromWorkMailOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterFromWorkMailOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterFromWorkMailOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterFromWorkMailOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterFromWorkMailOutputResponse()"}
}

extension DeregisterFromWorkMailOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterFromWorkMailOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeregisterFromWorkMailOutputResponseBody: Swift.Equatable {
}

extension DeregisterFromWorkMailOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGroupOutputError>
}

extension DescribeGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGroupInput(groupId: \(Swift.String(describing: groupId)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension DescribeGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DescribeGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGroupOutputError>
}

public struct DescribeGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGroupOutputError>
}

public struct DescribeGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGroupOutputError>
}

public struct DescribeGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGroupOutputError>
}

public struct DescribeGroupInput: Swift.Equatable {
    /// The identifier for the group to be described.
    /// This member is required.
    public var groupId: Swift.String?
    /// The identifier for the organization under which the group exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.organizationId = organizationId
    }
}

struct DescribeGroupInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let groupId: Swift.String?
}

extension DescribeGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension DescribeGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGroupOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGroupOutputResponse(disabledDate: \(Swift.String(describing: disabledDate)), email: \(Swift.String(describing: email)), enabledDate: \(Swift.String(describing: enabledDate)), groupId: \(Swift.String(describing: groupId)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)))"}
}

extension DescribeGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.disabledDate = output.disabledDate
            self.email = output.email
            self.enabledDate = output.enabledDate
            self.groupId = output.groupId
            self.name = output.name
            self.state = output.state
        } else {
            self.disabledDate = nil
            self.email = nil
            self.enabledDate = nil
            self.groupId = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct DescribeGroupOutputResponse: Swift.Equatable {
    /// The date and time when a user was deregistered from WorkMail, in UNIX epoch time
    ///          format.
    public var disabledDate: ClientRuntime.Date?
    /// The email of the described group.
    public var email: Swift.String?
    /// The date and time when a user was registered to WorkMail, in UNIX epoch time
    ///          format.
    public var enabledDate: ClientRuntime.Date?
    /// The identifier of the described group.
    public var groupId: Swift.String?
    /// The name of the described group.
    public var name: Swift.String?
    /// The state of the user: enabled (registered to Amazon WorkMail) or disabled (deregistered or
    ///          never registered to WorkMail).
    public var state: WorkMailClientTypes.EntityState?

    public init (
        disabledDate: ClientRuntime.Date? = nil,
        email: Swift.String? = nil,
        enabledDate: ClientRuntime.Date? = nil,
        groupId: Swift.String? = nil,
        name: Swift.String? = nil,
        state: WorkMailClientTypes.EntityState? = nil
    )
    {
        self.disabledDate = disabledDate
        self.email = email
        self.enabledDate = enabledDate
        self.groupId = groupId
        self.name = name
        self.state = state
    }
}

struct DescribeGroupOutputResponseBody: Swift.Equatable {
    public let groupId: Swift.String?
    public let name: Swift.String?
    public let email: Swift.String?
    public let state: WorkMailClientTypes.EntityState?
    public let enabledDate: ClientRuntime.Date?
    public let disabledDate: ClientRuntime.Date?
}

extension DescribeGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabledDate = "DisabledDate"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case groupId = "GroupId"
        case name = "Name"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
        let enabledDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

public struct DescribeMailboxExportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMailboxExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMailboxExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMailboxExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMailboxExportJobOutputError>
}

extension DescribeMailboxExportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMailboxExportJobInput(jobId: \(Swift.String(describing: jobId)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension DescribeMailboxExportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DescribeMailboxExportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMailboxExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMailboxExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMailboxExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMailboxExportJobOutputError>
}

public struct DescribeMailboxExportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMailboxExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeMailboxExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeMailboxExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMailboxExportJobOutputError>
}

public struct DescribeMailboxExportJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMailboxExportJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeMailboxExportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMailboxExportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMailboxExportJobOutputError>
}

public struct DescribeMailboxExportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeMailboxExportJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeMailboxExportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeMailboxExportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeMailboxExportJobOutputError>
}

public struct DescribeMailboxExportJobInput: Swift.Equatable {
    /// The mailbox export job ID.
    /// This member is required.
    public var jobId: Swift.String?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        jobId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.organizationId = organizationId
    }
}

struct DescribeMailboxExportJobInputBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let organizationId: Swift.String?
}

extension DescribeMailboxExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension DescribeMailboxExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMailboxExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMailboxExportJobOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMailboxExportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeMailboxExportJobOutputResponse(description: \(Swift.String(describing: description)), endTime: \(Swift.String(describing: endTime)), entityId: \(Swift.String(describing: entityId)), errorInfo: \(Swift.String(describing: errorInfo)), estimatedProgress: \(Swift.String(describing: estimatedProgress)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), roleArn: \(Swift.String(describing: roleArn)), s3BucketName: \(Swift.String(describing: s3BucketName)), s3Path: \(Swift.String(describing: s3Path)), s3Prefix: \(Swift.String(describing: s3Prefix)), startTime: \(Swift.String(describing: startTime)), state: \(Swift.String(describing: state)))"}
}

extension DescribeMailboxExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeMailboxExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.endTime = output.endTime
            self.entityId = output.entityId
            self.errorInfo = output.errorInfo
            self.estimatedProgress = output.estimatedProgress
            self.kmsKeyArn = output.kmsKeyArn
            self.roleArn = output.roleArn
            self.s3BucketName = output.s3BucketName
            self.s3Path = output.s3Path
            self.s3Prefix = output.s3Prefix
            self.startTime = output.startTime
            self.state = output.state
        } else {
            self.description = nil
            self.endTime = nil
            self.entityId = nil
            self.errorInfo = nil
            self.estimatedProgress = 0
            self.kmsKeyArn = nil
            self.roleArn = nil
            self.s3BucketName = nil
            self.s3Path = nil
            self.s3Prefix = nil
            self.startTime = nil
            self.state = nil
        }
    }
}

public struct DescribeMailboxExportJobOutputResponse: Swift.Equatable {
    /// The mailbox export job description.
    public var description: Swift.String?
    /// The mailbox export job end timestamp.
    public var endTime: ClientRuntime.Date?
    /// The identifier of the user or resource associated with the mailbox.
    public var entityId: Swift.String?
    /// Error information for failed mailbox export jobs.
    public var errorInfo: Swift.String?
    /// The estimated progress of the mailbox export job, in percentage points.
    public var estimatedProgress: Swift.Int
    /// The Amazon Resource Name (ARN) of the symmetric AWS Key Management Service (AWS KMS)
    ///          key that encrypts the exported mailbox content.
    public var kmsKeyArn: Swift.String?
    /// The ARN of the AWS Identity and Access Management (IAM) role that grants write permission to the Amazon Simple
    ///          Storage Service (Amazon S3) bucket.
    public var roleArn: Swift.String?
    /// The name of the S3 bucket.
    public var s3BucketName: Swift.String?
    /// The path to the S3 bucket and file that the mailbox export job is exporting
    ///          to.
    public var s3Path: Swift.String?
    /// The S3 bucket prefix.
    public var s3Prefix: Swift.String?
    /// The mailbox export job start timestamp.
    public var startTime: ClientRuntime.Date?
    /// The state of the mailbox export job.
    public var state: WorkMailClientTypes.MailboxExportJobState?

    public init (
        description: Swift.String? = nil,
        endTime: ClientRuntime.Date? = nil,
        entityId: Swift.String? = nil,
        errorInfo: Swift.String? = nil,
        estimatedProgress: Swift.Int = 0,
        kmsKeyArn: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3Path: Swift.String? = nil,
        s3Prefix: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        state: WorkMailClientTypes.MailboxExportJobState? = nil
    )
    {
        self.description = description
        self.endTime = endTime
        self.entityId = entityId
        self.errorInfo = errorInfo
        self.estimatedProgress = estimatedProgress
        self.kmsKeyArn = kmsKeyArn
        self.roleArn = roleArn
        self.s3BucketName = s3BucketName
        self.s3Path = s3Path
        self.s3Prefix = s3Prefix
        self.startTime = startTime
        self.state = state
    }
}

struct DescribeMailboxExportJobOutputResponseBody: Swift.Equatable {
    public let entityId: Swift.String?
    public let description: Swift.String?
    public let roleArn: Swift.String?
    public let kmsKeyArn: Swift.String?
    public let s3BucketName: Swift.String?
    public let s3Prefix: Swift.String?
    public let s3Path: Swift.String?
    public let estimatedProgress: Swift.Int
    public let state: WorkMailClientTypes.MailboxExportJobState?
    public let errorInfo: Swift.String?
    public let startTime: ClientRuntime.Date?
    public let endTime: ClientRuntime.Date?
}

extension DescribeMailboxExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case endTime = "EndTime"
        case entityId = "EntityId"
        case errorInfo = "ErrorInfo"
        case estimatedProgress = "EstimatedProgress"
        case kmsKeyArn = "KmsKeyArn"
        case roleArn = "RoleArn"
        case s3BucketName = "S3BucketName"
        case s3Path = "S3Path"
        case s3Prefix = "S3Prefix"
        case startTime = "StartTime"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Path)
        s3Path = s3PathDecoded
        let estimatedProgressDecoded = try containerValues.decode(Swift.Int.self, forKey: .estimatedProgress)
        estimatedProgress = estimatedProgressDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MailboxExportJobState.self, forKey: .state)
        state = stateDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

public struct DescribeOrganizationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOrganizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOrganizationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOrganizationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOrganizationOutputError>
}

extension DescribeOrganizationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeOrganizationInput(organizationId: \(Swift.String(describing: organizationId)))"}
}

extension DescribeOrganizationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DescribeOrganizationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOrganizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOrganizationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOrganizationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOrganizationOutputError>
}

public struct DescribeOrganizationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOrganizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeOrganizationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeOrganizationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOrganizationOutputError>
}

public struct DescribeOrganizationInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOrganizationInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeOrganizationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeOrganizationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOrganizationOutputError>
}

public struct DescribeOrganizationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeOrganizationInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeOrganizationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeOrganizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeOrganizationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeOrganizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeOrganizationOutputError>
}

public struct DescribeOrganizationInput: Swift.Equatable {
    /// The identifier for the organization to be described.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct DescribeOrganizationInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
}

extension DescribeOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension DescribeOrganizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeOrganizationOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeOrganizationOutputResponse(aRN: \(Swift.String(describing: aRN)), alias: \(Swift.String(describing: alias)), completedDate: \(Swift.String(describing: completedDate)), defaultMailDomain: \(Swift.String(describing: defaultMailDomain)), directoryId: \(Swift.String(describing: directoryId)), directoryType: \(Swift.String(describing: directoryType)), errorMessage: \(Swift.String(describing: errorMessage)), organizationId: \(Swift.String(describing: organizationId)), state: \(Swift.String(describing: state)))"}
}

extension DescribeOrganizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aRN = output.aRN
            self.alias = output.alias
            self.completedDate = output.completedDate
            self.defaultMailDomain = output.defaultMailDomain
            self.directoryId = output.directoryId
            self.directoryType = output.directoryType
            self.errorMessage = output.errorMessage
            self.organizationId = output.organizationId
            self.state = output.state
        } else {
            self.aRN = nil
            self.alias = nil
            self.completedDate = nil
            self.defaultMailDomain = nil
            self.directoryId = nil
            self.directoryType = nil
            self.errorMessage = nil
            self.organizationId = nil
            self.state = nil
        }
    }
}

public struct DescribeOrganizationOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the organization.
    public var aRN: Swift.String?
    /// The alias for an organization.
    public var alias: Swift.String?
    /// The date at which the organization became usable in the WorkMail context, in UNIX epoch
    ///          time format.
    public var completedDate: ClientRuntime.Date?
    /// The default mail domain associated with the organization.
    public var defaultMailDomain: Swift.String?
    /// The identifier for the directory associated with an Amazon WorkMail organization.
    public var directoryId: Swift.String?
    /// The type of directory associated with the WorkMail organization.
    public var directoryType: Swift.String?
    /// (Optional) The error message indicating if unexpected behavior was encountered with
    ///          regards to the organization.
    public var errorMessage: Swift.String?
    /// The identifier of an organization.
    public var organizationId: Swift.String?
    /// The state of an organization.
    public var state: Swift.String?

    public init (
        aRN: Swift.String? = nil,
        alias: Swift.String? = nil,
        completedDate: ClientRuntime.Date? = nil,
        defaultMailDomain: Swift.String? = nil,
        directoryId: Swift.String? = nil,
        directoryType: Swift.String? = nil,
        errorMessage: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        state: Swift.String? = nil
    )
    {
        self.aRN = aRN
        self.alias = alias
        self.completedDate = completedDate
        self.defaultMailDomain = defaultMailDomain
        self.directoryId = directoryId
        self.directoryType = directoryType
        self.errorMessage = errorMessage
        self.organizationId = organizationId
        self.state = state
    }
}

struct DescribeOrganizationOutputResponseBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let alias: Swift.String?
    public let state: Swift.String?
    public let directoryId: Swift.String?
    public let directoryType: Swift.String?
    public let defaultMailDomain: Swift.String?
    public let completedDate: ClientRuntime.Date?
    public let errorMessage: Swift.String?
    public let aRN: Swift.String?
}

extension DescribeOrganizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case alias = "Alias"
        case completedDate = "CompletedDate"
        case defaultMailDomain = "DefaultMailDomain"
        case directoryId = "DirectoryId"
        case directoryType = "DirectoryType"
        case errorMessage = "ErrorMessage"
        case organizationId = "OrganizationId"
        case state = "State"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
        let directoryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryId)
        directoryId = directoryIdDecoded
        let directoryTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .directoryType)
        directoryType = directoryTypeDecoded
        let defaultMailDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultMailDomain)
        defaultMailDomain = defaultMailDomainDecoded
        let completedDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .completedDate)
        completedDate = completedDateDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
    }
}

public struct DescribeResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeResourceOutputError>
}

extension DescribeResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeResourceInput(organizationId: \(Swift.String(describing: organizationId)), resourceId: \(Swift.String(describing: resourceId)))"}
}

extension DescribeResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct DescribeResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeResourceOutputError>
}

public struct DescribeResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeResourceOutputError>
}

public struct DescribeResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeResourceOutputError>
}

public struct DescribeResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeResourceOutputError>
}

public struct DescribeResourceInput: Swift.Equatable {
    /// The identifier associated with the organization for which the resource is
    ///          described.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier of the resource to be described.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct DescribeResourceInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let resourceId: Swift.String?
}

extension DescribeResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DescribeResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeResourceOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeResourceOutputResponse(bookingOptions: \(Swift.String(describing: bookingOptions)), disabledDate: \(Swift.String(describing: disabledDate)), email: \(Swift.String(describing: email)), enabledDate: \(Swift.String(describing: enabledDate)), name: \(Swift.String(describing: name)), resourceId: \(Swift.String(describing: resourceId)), state: \(Swift.String(describing: state)), type: \(Swift.String(describing: type)))"}
}

extension DescribeResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bookingOptions = output.bookingOptions
            self.disabledDate = output.disabledDate
            self.email = output.email
            self.enabledDate = output.enabledDate
            self.name = output.name
            self.resourceId = output.resourceId
            self.state = output.state
            self.type = output.type
        } else {
            self.bookingOptions = nil
            self.disabledDate = nil
            self.email = nil
            self.enabledDate = nil
            self.name = nil
            self.resourceId = nil
            self.state = nil
            self.type = nil
        }
    }
}

public struct DescribeResourceOutputResponse: Swift.Equatable {
    /// The booking options for the described resource.
    public var bookingOptions: WorkMailClientTypes.BookingOptions?
    /// The date and time when a resource was disabled from WorkMail, in UNIX epoch time
    ///          format.
    public var disabledDate: ClientRuntime.Date?
    /// The email of the described resource.
    public var email: Swift.String?
    /// The date and time when a resource was enabled for WorkMail, in UNIX epoch time
    ///          format.
    public var enabledDate: ClientRuntime.Date?
    /// The name of the described resource.
    public var name: Swift.String?
    /// The identifier of the described resource.
    public var resourceId: Swift.String?
    /// The state of the resource: enabled (registered to Amazon WorkMail), disabled (deregistered
    ///          or never registered to WorkMail), or deleted.
    public var state: WorkMailClientTypes.EntityState?
    /// The type of the described resource.
    public var type: WorkMailClientTypes.ResourceType?

    public init (
        bookingOptions: WorkMailClientTypes.BookingOptions? = nil,
        disabledDate: ClientRuntime.Date? = nil,
        email: Swift.String? = nil,
        enabledDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        state: WorkMailClientTypes.EntityState? = nil,
        type: WorkMailClientTypes.ResourceType? = nil
    )
    {
        self.bookingOptions = bookingOptions
        self.disabledDate = disabledDate
        self.email = email
        self.enabledDate = enabledDate
        self.name = name
        self.resourceId = resourceId
        self.state = state
        self.type = type
    }
}

struct DescribeResourceOutputResponseBody: Swift.Equatable {
    public let resourceId: Swift.String?
    public let email: Swift.String?
    public let name: Swift.String?
    public let type: WorkMailClientTypes.ResourceType?
    public let bookingOptions: WorkMailClientTypes.BookingOptions?
    public let state: WorkMailClientTypes.EntityState?
    public let enabledDate: ClientRuntime.Date?
    public let disabledDate: ClientRuntime.Date?
}

extension DescribeResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bookingOptions = "BookingOptions"
        case disabledDate = "DisabledDate"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case name = "Name"
        case resourceId = "ResourceId"
        case state = "State"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ResourceType.self, forKey: .type)
        type = typeDecoded
        let bookingOptionsDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.BookingOptions.self, forKey: .bookingOptions)
        bookingOptions = bookingOptionsDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
        let enabledDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

public struct DescribeUserInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserOutputError>
}

extension DescribeUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserInput(organizationId: \(Swift.String(describing: organizationId)), userId: \(Swift.String(describing: userId)))"}
}

extension DescribeUserInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct DescribeUserInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserOutputError>
}

public struct DescribeUserInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeUserInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeUserInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserOutputError>
}

public struct DescribeUserInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DescribeUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserOutputError>
}

public struct DescribeUserInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeUserInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DescribeUserInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeUserOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeUserInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeUserOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeUserOutputError>
}

public struct DescribeUserInput: Swift.Equatable {
    /// The identifier for the organization under which the user exists.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier for the user to be described.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct DescribeUserInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let userId: Swift.String?
}

extension DescribeUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension DescribeUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeUserOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeUserOutputResponse(disabledDate: \(Swift.String(describing: disabledDate)), displayName: \(Swift.String(describing: displayName)), email: \(Swift.String(describing: email)), enabledDate: \(Swift.String(describing: enabledDate)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)), userId: \(Swift.String(describing: userId)), userRole: \(Swift.String(describing: userRole)))"}
}

extension DescribeUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.disabledDate = output.disabledDate
            self.displayName = output.displayName
            self.email = output.email
            self.enabledDate = output.enabledDate
            self.name = output.name
            self.state = output.state
            self.userId = output.userId
            self.userRole = output.userRole
        } else {
            self.disabledDate = nil
            self.displayName = nil
            self.email = nil
            self.enabledDate = nil
            self.name = nil
            self.state = nil
            self.userId = nil
            self.userRole = nil
        }
    }
}

public struct DescribeUserOutputResponse: Swift.Equatable {
    /// The date and time at which the user was disabled for Amazon WorkMail usage, in UNIX epoch
    ///          time format.
    public var disabledDate: ClientRuntime.Date?
    /// The display name of the user.
    public var displayName: Swift.String?
    /// The email of the user.
    public var email: Swift.String?
    /// The date and time at which the user was enabled for Amazon WorkMail usage, in UNIX epoch
    ///          time format.
    public var enabledDate: ClientRuntime.Date?
    /// The name for the user.
    public var name: Swift.String?
    /// The state of a user: enabled (registered to Amazon WorkMail) or disabled (deregistered or
    ///          never registered to WorkMail).
    public var state: WorkMailClientTypes.EntityState?
    /// The identifier for the described user.
    public var userId: Swift.String?
    /// In certain cases, other entities are modeled as users. If interoperability is
    ///          enabled, resources are imported into Amazon WorkMail as users. Because different WorkMail
    ///          organizations rely on different directory types, administrators can distinguish between an
    ///          unregistered user (account is disabled and has a user role) and the directory
    ///          administrators. The values are USER, RESOURCE, and SYSTEM_USER.
    public var userRole: WorkMailClientTypes.UserRole?

    public init (
        disabledDate: ClientRuntime.Date? = nil,
        displayName: Swift.String? = nil,
        email: Swift.String? = nil,
        enabledDate: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        state: WorkMailClientTypes.EntityState? = nil,
        userId: Swift.String? = nil,
        userRole: WorkMailClientTypes.UserRole? = nil
    )
    {
        self.disabledDate = disabledDate
        self.displayName = displayName
        self.email = email
        self.enabledDate = enabledDate
        self.name = name
        self.state = state
        self.userId = userId
        self.userRole = userRole
    }
}

struct DescribeUserOutputResponseBody: Swift.Equatable {
    public let userId: Swift.String?
    public let name: Swift.String?
    public let email: Swift.String?
    public let displayName: Swift.String?
    public let state: WorkMailClientTypes.EntityState?
    public let userRole: WorkMailClientTypes.UserRole?
    public let enabledDate: ClientRuntime.Date?
    public let disabledDate: ClientRuntime.Date?
}

extension DescribeUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabledDate = "DisabledDate"
        case displayName = "DisplayName"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case name = "Name"
        case state = "State"
        case userId = "UserId"
        case userRole = "UserRole"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
        let userRoleDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.UserRole.self, forKey: .userRole)
        userRole = userRoleDecoded
        let enabledDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

extension DirectoryInUseException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DirectoryInUseException(message: \(Swift.String(describing: message)))"}
}

extension DirectoryInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DirectoryInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The directory is already in use by another WorkMail organization in the same account and Region.
public struct DirectoryInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DirectoryInUseExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DirectoryInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DirectoryServiceAuthenticationFailedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DirectoryServiceAuthenticationFailedException(message: \(Swift.String(describing: message)))"}
}

extension DirectoryServiceAuthenticationFailedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DirectoryServiceAuthenticationFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The directory service doesn't recognize the credentials supplied by WorkMail.
public struct DirectoryServiceAuthenticationFailedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DirectoryServiceAuthenticationFailedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DirectoryServiceAuthenticationFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DirectoryUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DirectoryUnavailableException(message: \(Swift.String(describing: message)))"}
}

extension DirectoryUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DirectoryUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The directory is unavailable. It might be located in another Region or deleted.
public struct DirectoryUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DirectoryUnavailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DirectoryUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct DisassociateDelegateFromResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateDelegateFromResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateDelegateFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateDelegateFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateDelegateFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateDelegateFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateDelegateFromResourceOutputError>
}

extension DisassociateDelegateFromResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateDelegateFromResourceInput(entityId: \(Swift.String(describing: entityId)), organizationId: \(Swift.String(describing: organizationId)), resourceId: \(Swift.String(describing: resourceId)))"}
}

extension DisassociateDelegateFromResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct DisassociateDelegateFromResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateDelegateFromResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateDelegateFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateDelegateFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateDelegateFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateDelegateFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateDelegateFromResourceOutputError>
}

public struct DisassociateDelegateFromResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateDelegateFromResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateDelegateFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateDelegateFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateDelegateFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateDelegateFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateDelegateFromResourceOutputError>
}

public struct DisassociateDelegateFromResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateDelegateFromResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateDelegateFromResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateDelegateFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateDelegateFromResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateDelegateFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateDelegateFromResourceOutputError>
}

public struct DisassociateDelegateFromResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateDelegateFromResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateDelegateFromResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateDelegateFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateDelegateFromResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateDelegateFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateDelegateFromResourceOutputError>
}

public struct DisassociateDelegateFromResourceInput: Swift.Equatable {
    /// The identifier for the member (user, group) to be removed from the resource's
    ///          delegates.
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier for the organization under which the resource exists.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier of the resource from which delegates' set members are removed.
    ///
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct DisassociateDelegateFromResourceInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let resourceId: Swift.String?
    public let entityId: Swift.String?
}

extension DisassociateDelegateFromResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
    }
}

extension DisassociateDelegateFromResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateDelegateFromResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateDelegateFromResourceOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateDelegateFromResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateDelegateFromResourceOutputResponse()"}
}

extension DisassociateDelegateFromResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateDelegateFromResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateDelegateFromResourceOutputResponseBody: Swift.Equatable {
}

extension DisassociateDelegateFromResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DisassociateMemberFromGroupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateMemberFromGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateMemberFromGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateMemberFromGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateMemberFromGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateMemberFromGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateMemberFromGroupOutputError>
}

extension DisassociateMemberFromGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateMemberFromGroupInput(groupId: \(Swift.String(describing: groupId)), memberId: \(Swift.String(describing: memberId)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension DisassociateMemberFromGroupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case memberId = "MemberId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let memberId = memberId {
            try encodeContainer.encode(memberId, forKey: .memberId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct DisassociateMemberFromGroupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateMemberFromGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateMemberFromGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateMemberFromGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateMemberFromGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateMemberFromGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateMemberFromGroupOutputError>
}

public struct DisassociateMemberFromGroupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateMemberFromGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateMemberFromGroupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateMemberFromGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateMemberFromGroupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateMemberFromGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateMemberFromGroupOutputError>
}

public struct DisassociateMemberFromGroupInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateMemberFromGroupInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: DisassociateMemberFromGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateMemberFromGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateMemberFromGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateMemberFromGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateMemberFromGroupOutputError>
}

public struct DisassociateMemberFromGroupInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateMemberFromGroupInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: DisassociateMemberFromGroupInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateMemberFromGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateMemberFromGroupInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateMemberFromGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateMemberFromGroupOutputError>
}

public struct DisassociateMemberFromGroupInput: Swift.Equatable {
    /// The identifier for the group from which members are removed.
    /// This member is required.
    public var groupId: Swift.String?
    /// The identifier for the member to be removed to the group.
    /// This member is required.
    public var memberId: Swift.String?
    /// The identifier for the organization under which the group exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        memberId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.memberId = memberId
        self.organizationId = organizationId
    }
}

struct DisassociateMemberFromGroupInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let groupId: Swift.String?
    public let memberId: Swift.String?
}

extension DisassociateMemberFromGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case memberId = "MemberId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let memberIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .memberId)
        memberId = memberIdDecoded
    }
}

extension DisassociateMemberFromGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateMemberFromGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateMemberFromGroupOutputError: Swift.Error, Swift.Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateMemberFromGroupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateMemberFromGroupOutputResponse()"}
}

extension DisassociateMemberFromGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateMemberFromGroupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateMemberFromGroupOutputResponseBody: Swift.Equatable {
}

extension DisassociateMemberFromGroupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension WorkMailClientTypes.Domain: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domainName = "DomainName"
        case hostedZoneId = "HostedZoneId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domainName = domainName {
            try encodeContainer.encode(domainName, forKey: .domainName)
        }
        if let hostedZoneId = hostedZoneId {
            try encodeContainer.encode(hostedZoneId, forKey: .hostedZoneId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domainName)
        domainName = domainNameDecoded
        let hostedZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostedZoneId)
        hostedZoneId = hostedZoneIdDecoded
    }
}

extension WorkMailClientTypes.Domain: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Domain(domainName: \(Swift.String(describing: domainName)), hostedZoneId: \(Swift.String(describing: hostedZoneId)))"}
}

extension WorkMailClientTypes {
    /// The domain to associate with an Amazon WorkMail organization.
    ///          When you configure a domain hosted in Amazon Route 53 (Route 53), all recommended DNS records are added to the organization when you create it. For more information, see <a href="https://docs.aws.amazon.com/workmail/latest/adminguide/add_domain.html">Adding a domain in the Amazon WorkMail Administrator Guide.
    public struct Domain: Swift.Equatable {
        /// The fully qualified domain name.
        public var domainName: Swift.String?
        /// The hosted zone ID for a domain hosted in Route 53. Required when configuring a domain hosted in Route 53.
        public var hostedZoneId: Swift.String?

        public init (
            domainName: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil
        )
        {
            self.domainName = domainName
            self.hostedZoneId = hostedZoneId
        }
    }

}

extension EmailAddressInUseException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EmailAddressInUseException(message: \(Swift.String(describing: message)))"}
}

extension EmailAddressInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EmailAddressInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The email address that you're trying to assign is already created for a different
///          user, group, or resource.
public struct EmailAddressInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EmailAddressInUseExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EmailAddressInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityAlreadyRegisteredException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EntityAlreadyRegisteredException(message: \(Swift.String(describing: message)))"}
}

extension EntityAlreadyRegisteredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EntityAlreadyRegisteredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user, group, or resource that you're trying to register is already
///          registered.
public struct EntityAlreadyRegisteredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EntityAlreadyRegisteredExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EntityAlreadyRegisteredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EntityNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EntityNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension EntityNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EntityNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The identifier supplied for the user, group, or resource does not exist in your
///          organization.
public struct EntityNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EntityNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EntityNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkMailClientTypes {
    public enum EntityState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleted
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityState] {
            return [
                .deleted,
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleted: return "DELETED"
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntityState(rawValue: rawValue) ?? EntityState.sdkUnknown(rawValue)
        }
    }
}

extension EntityStateException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EntityStateException(message: \(Swift.String(describing: message)))"}
}

extension EntityStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: EntityStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You are performing an operation on a user, group, or resource that isn't in the
///          expected state, such as trying to delete an active user.
public struct EntityStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct EntityStateExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension EntityStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkMailClientTypes.FolderConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case name = "Name"
        case period = "Period"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let period = period {
            try encodeContainer.encode(period, forKey: .period)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.FolderName.self, forKey: .name)
        name = nameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.RetentionAction.self, forKey: .action)
        action = actionDecoded
        let periodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .period)
        period = periodDecoded
    }
}

extension WorkMailClientTypes.FolderConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FolderConfiguration(action: \(Swift.String(describing: action)), name: \(Swift.String(describing: name)), period: \(Swift.String(describing: period)))"}
}

extension WorkMailClientTypes {
    /// The configuration applied to an organization's folders by its retention
    ///          policy.
    public struct FolderConfiguration: Swift.Equatable {
        /// The action to take on the folder contents at the end of the folder configuration
        ///          period.
        /// This member is required.
        public var action: WorkMailClientTypes.RetentionAction?
        /// The folder name.
        /// This member is required.
        public var name: WorkMailClientTypes.FolderName?
        /// The period of time at which the folder configuration action is applied.
        public var period: Swift.Int?

        public init (
            action: WorkMailClientTypes.RetentionAction? = nil,
            name: WorkMailClientTypes.FolderName? = nil,
            period: Swift.Int? = nil
        )
        {
            self.action = action
            self.name = name
            self.period = period
        }
    }

}

extension WorkMailClientTypes {
    public enum FolderName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deletedItems
        case drafts
        case inbox
        case junkEmail
        case sentItems
        case sdkUnknown(Swift.String)

        public static var allCases: [FolderName] {
            return [
                .deletedItems,
                .drafts,
                .inbox,
                .junkEmail,
                .sentItems,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deletedItems: return "DELETED_ITEMS"
            case .drafts: return "DRAFTS"
            case .inbox: return "INBOX"
            case .junkEmail: return "JUNK_EMAIL"
            case .sentItems: return "SENT_ITEMS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FolderName(rawValue: rawValue) ?? FolderName.sdkUnknown(rawValue)
        }
    }
}

public struct GetAccessControlEffectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccessControlEffectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccessControlEffectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccessControlEffectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccessControlEffectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccessControlEffectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccessControlEffectOutputError>
}

extension GetAccessControlEffectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccessControlEffectInput(action: \(Swift.String(describing: action)), ipAddress: \(Swift.String(describing: ipAddress)), organizationId: \(Swift.String(describing: organizationId)), userId: \(Swift.String(describing: userId)))"}
}

extension GetAccessControlEffectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case ipAddress = "IpAddress"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let ipAddress = ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct GetAccessControlEffectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccessControlEffectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccessControlEffectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccessControlEffectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccessControlEffectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccessControlEffectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccessControlEffectOutputError>
}

public struct GetAccessControlEffectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccessControlEffectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAccessControlEffectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccessControlEffectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAccessControlEffectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccessControlEffectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccessControlEffectOutputError>
}

public struct GetAccessControlEffectInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccessControlEffectInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetAccessControlEffectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccessControlEffectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAccessControlEffectInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccessControlEffectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccessControlEffectOutputError>
}

public struct GetAccessControlEffectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAccessControlEffectInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetAccessControlEffectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAccessControlEffectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAccessControlEffectInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAccessControlEffectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAccessControlEffectOutputError>
}

public struct GetAccessControlEffectInput: Swift.Equatable {
    /// The access protocol action. Valid values include ActiveSync,
    ///             AutoDiscover, EWS, IMAP, SMTP,
    ///             WindowsOutlook, and WebMail.
    /// This member is required.
    public var action: Swift.String?
    /// The IPv4 address.
    /// This member is required.
    public var ipAddress: Swift.String?
    /// The identifier for the organization.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The user ID.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        action: Swift.String? = nil,
        ipAddress: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.action = action
        self.ipAddress = ipAddress
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct GetAccessControlEffectInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let ipAddress: Swift.String?
    public let action: Swift.String?
    public let userId: Swift.String?
}

extension GetAccessControlEffectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case ipAddress = "IpAddress"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .action)
        action = actionDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension GetAccessControlEffectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccessControlEffectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccessControlEffectOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessControlEffectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAccessControlEffectOutputResponse(effect: \(Swift.String(describing: effect)), matchedRules: \(Swift.String(describing: matchedRules)))"}
}

extension GetAccessControlEffectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAccessControlEffectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.effect = output.effect
            self.matchedRules = output.matchedRules
        } else {
            self.effect = nil
            self.matchedRules = nil
        }
    }
}

public struct GetAccessControlEffectOutputResponse: Swift.Equatable {
    /// The rule effect.
    public var effect: WorkMailClientTypes.AccessControlRuleEffect?
    /// The rules that match the given parameters, resulting in an effect.
    public var matchedRules: [Swift.String]?

    public init (
        effect: WorkMailClientTypes.AccessControlRuleEffect? = nil,
        matchedRules: [Swift.String]? = nil
    )
    {
        self.effect = effect
        self.matchedRules = matchedRules
    }
}

struct GetAccessControlEffectOutputResponseBody: Swift.Equatable {
    public let effect: WorkMailClientTypes.AccessControlRuleEffect?
    public let matchedRules: [Swift.String]?
}

extension GetAccessControlEffectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effect = "Effect"
        case matchedRules = "MatchedRules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.AccessControlRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let matchedRulesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .matchedRules)
        var matchedRulesDecoded0:[Swift.String]? = nil
        if let matchedRulesContainer = matchedRulesContainer {
            matchedRulesDecoded0 = [Swift.String]()
            for string0 in matchedRulesContainer {
                if let string0 = string0 {
                    matchedRulesDecoded0?.append(string0)
                }
            }
        }
        matchedRules = matchedRulesDecoded0
    }
}

public struct GetDefaultRetentionPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDefaultRetentionPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDefaultRetentionPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDefaultRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDefaultRetentionPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDefaultRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDefaultRetentionPolicyOutputError>
}

extension GetDefaultRetentionPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDefaultRetentionPolicyInput(organizationId: \(Swift.String(describing: organizationId)))"}
}

extension GetDefaultRetentionPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct GetDefaultRetentionPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDefaultRetentionPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDefaultRetentionPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDefaultRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDefaultRetentionPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDefaultRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDefaultRetentionPolicyOutputError>
}

public struct GetDefaultRetentionPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDefaultRetentionPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetDefaultRetentionPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDefaultRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetDefaultRetentionPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetDefaultRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDefaultRetentionPolicyOutputError>
}

public struct GetDefaultRetentionPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDefaultRetentionPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetDefaultRetentionPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDefaultRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDefaultRetentionPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDefaultRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDefaultRetentionPolicyOutputError>
}

public struct GetDefaultRetentionPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetDefaultRetentionPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetDefaultRetentionPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetDefaultRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetDefaultRetentionPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetDefaultRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetDefaultRetentionPolicyOutputError>
}

public struct GetDefaultRetentionPolicyInput: Swift.Equatable {
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct GetDefaultRetentionPolicyInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
}

extension GetDefaultRetentionPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension GetDefaultRetentionPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDefaultRetentionPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDefaultRetentionPolicyOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDefaultRetentionPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDefaultRetentionPolicyOutputResponse(description: \(Swift.String(describing: description)), folderConfigurations: \(Swift.String(describing: folderConfigurations)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)))"}
}

extension GetDefaultRetentionPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDefaultRetentionPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.description = output.description
            self.folderConfigurations = output.folderConfigurations
            self.id = output.id
            self.name = output.name
        } else {
            self.description = nil
            self.folderConfigurations = nil
            self.id = nil
            self.name = nil
        }
    }
}

public struct GetDefaultRetentionPolicyOutputResponse: Swift.Equatable {
    /// The retention policy description.
    public var description: Swift.String?
    /// The retention policy folder configurations.
    public var folderConfigurations: [WorkMailClientTypes.FolderConfiguration]?
    /// The retention policy ID.
    public var id: Swift.String?
    /// The retention policy name.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        folderConfigurations: [WorkMailClientTypes.FolderConfiguration]? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.folderConfigurations = folderConfigurations
        self.id = id
        self.name = name
    }
}

struct GetDefaultRetentionPolicyOutputResponseBody: Swift.Equatable {
    public let id: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let folderConfigurations: [WorkMailClientTypes.FolderConfiguration]?
}

extension GetDefaultRetentionPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case folderConfigurations = "FolderConfigurations"
        case id = "Id"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let folderConfigurationsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.FolderConfiguration?].self, forKey: .folderConfigurations)
        var folderConfigurationsDecoded0:[WorkMailClientTypes.FolderConfiguration]? = nil
        if let folderConfigurationsContainer = folderConfigurationsContainer {
            folderConfigurationsDecoded0 = [WorkMailClientTypes.FolderConfiguration]()
            for structure0 in folderConfigurationsContainer {
                if let structure0 = structure0 {
                    folderConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        folderConfigurations = folderConfigurationsDecoded0
    }
}

public struct GetMailboxDetailsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMailboxDetailsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMailboxDetailsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMailboxDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMailboxDetailsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMailboxDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMailboxDetailsOutputError>
}

extension GetMailboxDetailsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMailboxDetailsInput(organizationId: \(Swift.String(describing: organizationId)), userId: \(Swift.String(describing: userId)))"}
}

extension GetMailboxDetailsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct GetMailboxDetailsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMailboxDetailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMailboxDetailsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMailboxDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMailboxDetailsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMailboxDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMailboxDetailsOutputError>
}

public struct GetMailboxDetailsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMailboxDetailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMailboxDetailsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMailboxDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMailboxDetailsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMailboxDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMailboxDetailsOutputError>
}

public struct GetMailboxDetailsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMailboxDetailsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetMailboxDetailsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMailboxDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMailboxDetailsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMailboxDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMailboxDetailsOutputError>
}

public struct GetMailboxDetailsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMailboxDetailsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetMailboxDetailsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMailboxDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMailboxDetailsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMailboxDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMailboxDetailsOutputError>
}

public struct GetMailboxDetailsInput: Swift.Equatable {
    /// The identifier for the organization that contains the user whose mailbox details are
    ///          being requested.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier for the user whose mailbox details are being requested.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct GetMailboxDetailsInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let userId: Swift.String?
}

extension GetMailboxDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension GetMailboxDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMailboxDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMailboxDetailsOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMailboxDetailsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMailboxDetailsOutputResponse(mailboxQuota: \(Swift.String(describing: mailboxQuota)), mailboxSize: \(Swift.String(describing: mailboxSize)))"}
}

extension GetMailboxDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMailboxDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mailboxQuota = output.mailboxQuota
            self.mailboxSize = output.mailboxSize
        } else {
            self.mailboxQuota = nil
            self.mailboxSize = 0.0
        }
    }
}

public struct GetMailboxDetailsOutputResponse: Swift.Equatable {
    /// The maximum allowed mailbox size, in MB, for the specified user.
    public var mailboxQuota: Swift.Int?
    /// The current mailbox size, in MB, for the specified user.
    public var mailboxSize: Swift.Double

    public init (
        mailboxQuota: Swift.Int? = nil,
        mailboxSize: Swift.Double = 0.0
    )
    {
        self.mailboxQuota = mailboxQuota
        self.mailboxSize = mailboxSize
    }
}

struct GetMailboxDetailsOutputResponseBody: Swift.Equatable {
    public let mailboxQuota: Swift.Int?
    public let mailboxSize: Swift.Double
}

extension GetMailboxDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mailboxQuota = "MailboxQuota"
        case mailboxSize = "MailboxSize"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mailboxQuotaDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mailboxQuota)
        mailboxQuota = mailboxQuotaDecoded
        let mailboxSizeDecoded = try containerValues.decode(Swift.Double.self, forKey: .mailboxSize)
        mailboxSize = mailboxSizeDecoded
    }
}

public struct GetMobileDeviceAccessEffectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMobileDeviceAccessEffectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMobileDeviceAccessEffectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMobileDeviceAccessEffectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMobileDeviceAccessEffectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMobileDeviceAccessEffectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMobileDeviceAccessEffectOutputError>
}

extension GetMobileDeviceAccessEffectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMobileDeviceAccessEffectInput(deviceModel: \(Swift.String(describing: deviceModel)), deviceOperatingSystem: \(Swift.String(describing: deviceOperatingSystem)), deviceType: \(Swift.String(describing: deviceType)), deviceUserAgent: \(Swift.String(describing: deviceUserAgent)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension GetMobileDeviceAccessEffectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceModel = "DeviceModel"
        case deviceOperatingSystem = "DeviceOperatingSystem"
        case deviceType = "DeviceType"
        case deviceUserAgent = "DeviceUserAgent"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceModel = deviceModel {
            try encodeContainer.encode(deviceModel, forKey: .deviceModel)
        }
        if let deviceOperatingSystem = deviceOperatingSystem {
            try encodeContainer.encode(deviceOperatingSystem, forKey: .deviceOperatingSystem)
        }
        if let deviceType = deviceType {
            try encodeContainer.encode(deviceType, forKey: .deviceType)
        }
        if let deviceUserAgent = deviceUserAgent {
            try encodeContainer.encode(deviceUserAgent, forKey: .deviceUserAgent)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct GetMobileDeviceAccessEffectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMobileDeviceAccessEffectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMobileDeviceAccessEffectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMobileDeviceAccessEffectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMobileDeviceAccessEffectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMobileDeviceAccessEffectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMobileDeviceAccessEffectOutputError>
}

public struct GetMobileDeviceAccessEffectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMobileDeviceAccessEffectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMobileDeviceAccessEffectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMobileDeviceAccessEffectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMobileDeviceAccessEffectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMobileDeviceAccessEffectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMobileDeviceAccessEffectOutputError>
}

public struct GetMobileDeviceAccessEffectInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMobileDeviceAccessEffectInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetMobileDeviceAccessEffectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMobileDeviceAccessEffectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMobileDeviceAccessEffectInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMobileDeviceAccessEffectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMobileDeviceAccessEffectOutputError>
}

public struct GetMobileDeviceAccessEffectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMobileDeviceAccessEffectInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetMobileDeviceAccessEffectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMobileDeviceAccessEffectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMobileDeviceAccessEffectInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMobileDeviceAccessEffectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMobileDeviceAccessEffectOutputError>
}

public struct GetMobileDeviceAccessEffectInput: Swift.Equatable {
    /// Device model the simulated user will report.
    public var deviceModel: Swift.String?
    /// Device operating system the simulated user will report.
    public var deviceOperatingSystem: Swift.String?
    /// Device type the simulated user will report.
    public var deviceType: Swift.String?
    /// Device user agent the simulated user will report.
    public var deviceUserAgent: Swift.String?
    /// The Amazon WorkMail organization to simulate the access effect for.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        deviceModel: Swift.String? = nil,
        deviceOperatingSystem: Swift.String? = nil,
        deviceType: Swift.String? = nil,
        deviceUserAgent: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.deviceModel = deviceModel
        self.deviceOperatingSystem = deviceOperatingSystem
        self.deviceType = deviceType
        self.deviceUserAgent = deviceUserAgent
        self.organizationId = organizationId
    }
}

struct GetMobileDeviceAccessEffectInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let deviceType: Swift.String?
    public let deviceModel: Swift.String?
    public let deviceOperatingSystem: Swift.String?
    public let deviceUserAgent: Swift.String?
}

extension GetMobileDeviceAccessEffectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceModel = "DeviceModel"
        case deviceOperatingSystem = "DeviceOperatingSystem"
        case deviceType = "DeviceType"
        case deviceUserAgent = "DeviceUserAgent"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let deviceModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceModel)
        deviceModel = deviceModelDecoded
        let deviceOperatingSystemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceOperatingSystem)
        deviceOperatingSystem = deviceOperatingSystemDecoded
        let deviceUserAgentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceUserAgent)
        deviceUserAgent = deviceUserAgentDecoded
    }
}

extension GetMobileDeviceAccessEffectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMobileDeviceAccessEffectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMobileDeviceAccessEffectOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMobileDeviceAccessEffectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMobileDeviceAccessEffectOutputResponse(effect: \(Swift.String(describing: effect)), matchedRules: \(Swift.String(describing: matchedRules)))"}
}

extension GetMobileDeviceAccessEffectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMobileDeviceAccessEffectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.effect = output.effect
            self.matchedRules = output.matchedRules
        } else {
            self.effect = nil
            self.matchedRules = nil
        }
    }
}

public struct GetMobileDeviceAccessEffectOutputResponse: Swift.Equatable {
    /// The effect of the simulated access, ALLOW or DENY, after evaluating mobile device access rules in the Amazon WorkMail organization for the simulated
    ///          user parameters.
    public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    /// A list of the rules which matched the simulated user input and produced the effect.
    public var matchedRules: [WorkMailClientTypes.MobileDeviceAccessMatchedRule]?

    public init (
        effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
        matchedRules: [WorkMailClientTypes.MobileDeviceAccessMatchedRule]? = nil
    )
    {
        self.effect = effect
        self.matchedRules = matchedRules
    }
}

struct GetMobileDeviceAccessEffectOutputResponseBody: Swift.Equatable {
    public let effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    public let matchedRules: [WorkMailClientTypes.MobileDeviceAccessMatchedRule]?
}

extension GetMobileDeviceAccessEffectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effect = "Effect"
        case matchedRules = "MatchedRules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let matchedRulesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.MobileDeviceAccessMatchedRule?].self, forKey: .matchedRules)
        var matchedRulesDecoded0:[WorkMailClientTypes.MobileDeviceAccessMatchedRule]? = nil
        if let matchedRulesContainer = matchedRulesContainer {
            matchedRulesDecoded0 = [WorkMailClientTypes.MobileDeviceAccessMatchedRule]()
            for structure0 in matchedRulesContainer {
                if let structure0 = structure0 {
                    matchedRulesDecoded0?.append(structure0)
                }
            }
        }
        matchedRules = matchedRulesDecoded0
    }
}

public struct GetMobileDeviceAccessOverrideInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMobileDeviceAccessOverrideInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMobileDeviceAccessOverrideInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMobileDeviceAccessOverrideOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMobileDeviceAccessOverrideInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMobileDeviceAccessOverrideOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMobileDeviceAccessOverrideOutputError>
}

extension GetMobileDeviceAccessOverrideInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMobileDeviceAccessOverrideInput(deviceId: \(Swift.String(describing: deviceId)), organizationId: \(Swift.String(describing: organizationId)), userId: \(Swift.String(describing: userId)))"}
}

extension GetMobileDeviceAccessOverrideInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct GetMobileDeviceAccessOverrideInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMobileDeviceAccessOverrideInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMobileDeviceAccessOverrideInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMobileDeviceAccessOverrideOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMobileDeviceAccessOverrideInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMobileDeviceAccessOverrideOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMobileDeviceAccessOverrideOutputError>
}

public struct GetMobileDeviceAccessOverrideInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMobileDeviceAccessOverrideInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetMobileDeviceAccessOverrideInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMobileDeviceAccessOverrideOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetMobileDeviceAccessOverrideInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetMobileDeviceAccessOverrideOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMobileDeviceAccessOverrideOutputError>
}

public struct GetMobileDeviceAccessOverrideInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMobileDeviceAccessOverrideInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: GetMobileDeviceAccessOverrideInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMobileDeviceAccessOverrideOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMobileDeviceAccessOverrideInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMobileDeviceAccessOverrideOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMobileDeviceAccessOverrideOutputError>
}

public struct GetMobileDeviceAccessOverrideInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetMobileDeviceAccessOverrideInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: GetMobileDeviceAccessOverrideInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetMobileDeviceAccessOverrideOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetMobileDeviceAccessOverrideInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetMobileDeviceAccessOverrideOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetMobileDeviceAccessOverrideOutputError>
}

public struct GetMobileDeviceAccessOverrideInput: Swift.Equatable {
    /// The mobile device to which the override applies. DeviceId is case insensitive.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The Amazon WorkMail organization to which you want to apply the override.
    /// This member is required.
    public var organizationId: Swift.String?
    /// Identifies the WorkMail user for the override. Accepts the following types of user identities:
    ///
    ///
    ///                User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    ///
    ///
    ///                Email address: user@domain.tld
    ///
    ///
    ///
    ///                User name: user
    ///
    ///
    ///
    /// This member is required.
    public var userId: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct GetMobileDeviceAccessOverrideInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let userId: Swift.String?
    public let deviceId: Swift.String?
}

extension GetMobileDeviceAccessOverrideInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
    }
}

extension GetMobileDeviceAccessOverrideOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMobileDeviceAccessOverrideOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetMobileDeviceAccessOverrideOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMobileDeviceAccessOverrideOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetMobileDeviceAccessOverrideOutputResponse(dateCreated: \(Swift.String(describing: dateCreated)), dateModified: \(Swift.String(describing: dateModified)), description: \(Swift.String(describing: description)), deviceId: \(Swift.String(describing: deviceId)), effect: \(Swift.String(describing: effect)), userId: \(Swift.String(describing: userId)))"}
}

extension GetMobileDeviceAccessOverrideOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetMobileDeviceAccessOverrideOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dateCreated = output.dateCreated
            self.dateModified = output.dateModified
            self.description = output.description
            self.deviceId = output.deviceId
            self.effect = output.effect
            self.userId = output.userId
        } else {
            self.dateCreated = nil
            self.dateModified = nil
            self.description = nil
            self.deviceId = nil
            self.effect = nil
            self.userId = nil
        }
    }
}

public struct GetMobileDeviceAccessOverrideOutputResponse: Swift.Equatable {
    /// The date the override was first created.
    public var dateCreated: ClientRuntime.Date?
    /// The date the description was last modified.
    public var dateModified: ClientRuntime.Date?
    /// A description of the override.
    public var description: Swift.String?
    /// The device to which the access override applies.
    public var deviceId: Swift.String?
    /// The effect of the override, ALLOW or DENY.
    public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    /// The WorkMail user to which the access override applies.
    public var userId: Swift.String?

    public init (
        dateCreated: ClientRuntime.Date? = nil,
        dateModified: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
        userId: Swift.String? = nil
    )
    {
        self.dateCreated = dateCreated
        self.dateModified = dateModified
        self.description = description
        self.deviceId = deviceId
        self.effect = effect
        self.userId = userId
    }
}

struct GetMobileDeviceAccessOverrideOutputResponseBody: Swift.Equatable {
    public let userId: Swift.String?
    public let deviceId: Swift.String?
    public let effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    public let description: Swift.String?
    public let dateCreated: ClientRuntime.Date?
    public let dateModified: ClientRuntime.Date?
}

extension GetMobileDeviceAccessOverrideOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case description = "Description"
        case deviceId = "DeviceId"
        case effect = "Effect"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .dateModified)
        dateModified = dateModifiedDecoded
    }
}

extension WorkMailClientTypes.Group: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabledDate = "DisabledDate"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case id = "Id"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabledDate = disabledDate {
            try encodeContainer.encode(disabledDate.timeIntervalSince1970, forKey: .disabledDate)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let enabledDate = enabledDate {
            try encodeContainer.encode(enabledDate.timeIntervalSince1970, forKey: .enabledDate)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
        let enabledDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

extension WorkMailClientTypes.Group: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Group(disabledDate: \(Swift.String(describing: disabledDate)), email: \(Swift.String(describing: email)), enabledDate: \(Swift.String(describing: enabledDate)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)))"}
}

extension WorkMailClientTypes {
    /// The representation of an Amazon WorkMail group.
    public struct Group: Swift.Equatable {
        /// The date indicating when the group was disabled from Amazon WorkMail use.
        public var disabledDate: ClientRuntime.Date?
        /// The email of the group.
        public var email: Swift.String?
        /// The date indicating when the group was enabled for Amazon WorkMail use.
        public var enabledDate: ClientRuntime.Date?
        /// The identifier of the group.
        public var id: Swift.String?
        /// The name of the group.
        public var name: Swift.String?
        /// The state of the group, which can be ENABLED, DISABLED, or DELETED.
        public var state: WorkMailClientTypes.EntityState?

        public init (
            disabledDate: ClientRuntime.Date? = nil,
            email: Swift.String? = nil,
            enabledDate: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil
        )
        {
            self.disabledDate = disabledDate
            self.email = email
            self.enabledDate = enabledDate
            self.id = id
            self.name = name
            self.state = state
        }
    }

}

extension InvalidConfigurationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidConfigurationException(message: \(Swift.String(describing: message)))"}
}

extension InvalidConfigurationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidConfigurationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The configuration for a resource isn't valid. A resource must either be able to
///          auto-respond to requests or have at least one delegate associated that can do so on its
///          behalf.
public struct InvalidConfigurationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidConfigurationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidConfigurationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParameterException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more of the input parameters don't match the service's restrictions.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidPasswordException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidPasswordException(message: \(Swift.String(describing: message)))"}
}

extension InvalidPasswordException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidPasswordExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The supplied password doesn't match the minimum security constraints, such as length
///          or use of special characters.
public struct InvalidPasswordException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPasswordExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidPasswordExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request exceeds the limit of the resource.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAccessControlRulesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccessControlRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAccessControlRulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccessControlRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAccessControlRulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccessControlRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccessControlRulesOutputError>
}

extension ListAccessControlRulesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAccessControlRulesInput(organizationId: \(Swift.String(describing: organizationId)))"}
}

extension ListAccessControlRulesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct ListAccessControlRulesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccessControlRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAccessControlRulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccessControlRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAccessControlRulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccessControlRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccessControlRulesOutputError>
}

public struct ListAccessControlRulesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccessControlRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAccessControlRulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccessControlRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAccessControlRulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccessControlRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccessControlRulesOutputError>
}

public struct ListAccessControlRulesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccessControlRulesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAccessControlRulesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccessControlRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAccessControlRulesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccessControlRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccessControlRulesOutputError>
}

public struct ListAccessControlRulesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccessControlRulesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAccessControlRulesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccessControlRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAccessControlRulesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccessControlRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccessControlRulesOutputError>
}

public struct ListAccessControlRulesInput: Swift.Equatable {
    /// The identifier for the organization.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct ListAccessControlRulesInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
}

extension ListAccessControlRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension ListAccessControlRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccessControlRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccessControlRulesOutputError: Swift.Error, Swift.Equatable {
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessControlRulesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAccessControlRulesOutputResponse(rules: \(Swift.String(describing: rules)))"}
}

extension ListAccessControlRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAccessControlRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.rules = output.rules
        } else {
            self.rules = nil
        }
    }
}

public struct ListAccessControlRulesOutputResponse: Swift.Equatable {
    /// The access control rules.
    public var rules: [WorkMailClientTypes.AccessControlRule]?

    public init (
        rules: [WorkMailClientTypes.AccessControlRule]? = nil
    )
    {
        self.rules = rules
    }
}

struct ListAccessControlRulesOutputResponseBody: Swift.Equatable {
    public let rules: [WorkMailClientTypes.AccessControlRule]?
}

extension ListAccessControlRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.AccessControlRule?].self, forKey: .rules)
        var rulesDecoded0:[WorkMailClientTypes.AccessControlRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [WorkMailClientTypes.AccessControlRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

public struct ListAliasesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAliasesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAliasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAliasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAliasesOutputError>
}

extension ListAliasesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAliasesInput(entityId: \(Swift.String(describing: entityId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension ListAliasesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct ListAliasesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAliasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAliasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAliasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAliasesOutputError>
}

public struct ListAliasesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAliasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAliasesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAliasesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAliasesOutputError>
}

public struct ListAliasesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAliasesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListAliasesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAliasesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAliasesOutputError>
}

public struct ListAliasesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAliasesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListAliasesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAliasesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAliasesOutputError>
}

public struct ListAliasesInput: Swift.Equatable {
    /// The identifier for the entity for which to list the aliases.
    /// This member is required.
    public var entityId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not
    ///          contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the entity exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        entityId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListAliasesInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let entityId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListAliasesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAliasesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAliasesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAliasesOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAliasesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAliasesOutputResponse(aliases: \(Swift.String(describing: aliases)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAliasesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAliasesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aliases = output.aliases
            self.nextToken = output.nextToken
        } else {
            self.aliases = nil
            self.nextToken = nil
        }
    }
}

public struct ListAliasesOutputResponse: Swift.Equatable {
    /// The entity's paginated aliases.
    public var aliases: [Swift.String]?
    /// The token to use to retrieve the next page of results. The value is "null" when there
    ///          are no more results to return.
    public var nextToken: Swift.String?

    public init (
        aliases: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aliases = aliases
        self.nextToken = nextToken
    }
}

struct ListAliasesOutputResponseBody: Swift.Equatable {
    public let aliases: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListAliasesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliases = "Aliases"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .aliases)
        var aliasesDecoded0:[Swift.String]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [Swift.String]()
            for string0 in aliasesContainer {
                if let string0 = string0 {
                    aliasesDecoded0?.append(string0)
                }
            }
        }
        aliases = aliasesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListGroupMembersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGroupMembersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGroupMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGroupMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGroupMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGroupMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGroupMembersOutputError>
}

extension ListGroupMembersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGroupMembersInput(groupId: \(Swift.String(describing: groupId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension ListGroupMembersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct ListGroupMembersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGroupMembersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGroupMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGroupMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGroupMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGroupMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGroupMembersOutputError>
}

public struct ListGroupMembersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGroupMembersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGroupMembersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGroupMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGroupMembersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGroupMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGroupMembersOutputError>
}

public struct ListGroupMembersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGroupMembersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListGroupMembersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGroupMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListGroupMembersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListGroupMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGroupMembersOutputError>
}

public struct ListGroupMembersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGroupMembersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListGroupMembersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGroupMembersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListGroupMembersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListGroupMembersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGroupMembersOutputError>
}

public struct ListGroupMembersInput: Swift.Equatable {
    /// The identifier for the group to which the members (users or groups) are
    ///          associated.
    /// This member is required.
    public var groupId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    ///  The token to use to retrieve the next page of results. The first call does not
    ///          contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the group exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        groupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListGroupMembersInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let groupId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListGroupMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "GroupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListGroupMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGroupMembersOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupMembersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGroupMembersOutputResponse(members: \(Swift.String(describing: members)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListGroupMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListGroupMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupMembersOutputResponse: Swift.Equatable {
    /// The members associated to the group.
    public var members: [WorkMailClientTypes.Member]?
    /// The token to use to retrieve the next page of results. The first call does not
    ///          contain any tokens.
    public var nextToken: Swift.String?

    public init (
        members: [WorkMailClientTypes.Member]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListGroupMembersOutputResponseBody: Swift.Equatable {
    public let members: [WorkMailClientTypes.Member]?
    public let nextToken: Swift.String?
}

extension ListGroupMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members = "Members"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Member?].self, forKey: .members)
        var membersDecoded0:[WorkMailClientTypes.Member]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [WorkMailClientTypes.Member]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListGroupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGroupsOutputError>
}

extension ListGroupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGroupsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension ListGroupsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct ListGroupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGroupsOutputError>
}

public struct ListGroupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGroupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGroupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGroupsOutputError>
}

public struct ListGroupsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGroupsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGroupsOutputError>
}

public struct ListGroupsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGroupsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListGroupsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListGroupsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGroupsOutputError>
}

public struct ListGroupsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not
    ///          contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the groups exist.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListGroupsInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGroupsOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGroupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGroupsOutputResponse(groups: \(Swift.String(describing: groups)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.groups = output.groups
            self.nextToken = output.nextToken
        } else {
            self.groups = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupsOutputResponse: Swift.Equatable {
    /// The overview of groups for an organization.
    public var groups: [WorkMailClientTypes.Group]?
    /// The token to use to retrieve the next page of results. The value is "null" when there
    ///          are no more results to return.
    public var nextToken: Swift.String?

    public init (
        groups: [WorkMailClientTypes.Group]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groups = groups
        self.nextToken = nextToken
    }
}

struct ListGroupsOutputResponseBody: Swift.Equatable {
    public let groups: [WorkMailClientTypes.Group]?
    public let nextToken: Swift.String?
}

extension ListGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Group?].self, forKey: .groups)
        var groupsDecoded0:[WorkMailClientTypes.Group]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [WorkMailClientTypes.Group]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListMailboxExportJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMailboxExportJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMailboxExportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMailboxExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMailboxExportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMailboxExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMailboxExportJobsOutputError>
}

extension ListMailboxExportJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMailboxExportJobsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension ListMailboxExportJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct ListMailboxExportJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMailboxExportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMailboxExportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMailboxExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMailboxExportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMailboxExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMailboxExportJobsOutputError>
}

public struct ListMailboxExportJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMailboxExportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMailboxExportJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMailboxExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMailboxExportJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMailboxExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMailboxExportJobsOutputError>
}

public struct ListMailboxExportJobsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMailboxExportJobsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListMailboxExportJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMailboxExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMailboxExportJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMailboxExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMailboxExportJobsOutputError>
}

public struct ListMailboxExportJobsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMailboxExportJobsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListMailboxExportJobsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMailboxExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMailboxExportJobsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMailboxExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMailboxExportJobsOutputError>
}

public struct ListMailboxExportJobsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListMailboxExportJobsInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListMailboxExportJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMailboxExportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMailboxExportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMailboxExportJobsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMailboxExportJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMailboxExportJobsOutputResponse(jobs: \(Swift.String(describing: jobs)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListMailboxExportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMailboxExportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
            self.nextToken = output.nextToken
        } else {
            self.jobs = nil
            self.nextToken = nil
        }
    }
}

public struct ListMailboxExportJobsOutputResponse: Swift.Equatable {
    /// The mailbox export job details.
    public var jobs: [WorkMailClientTypes.MailboxExportJob]?
    /// The token to use to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init (
        jobs: [WorkMailClientTypes.MailboxExportJob]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobs = jobs
        self.nextToken = nextToken
    }
}

struct ListMailboxExportJobsOutputResponseBody: Swift.Equatable {
    public let jobs: [WorkMailClientTypes.MailboxExportJob]?
    public let nextToken: Swift.String?
}

extension ListMailboxExportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs = "Jobs"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.MailboxExportJob?].self, forKey: .jobs)
        var jobsDecoded0:[WorkMailClientTypes.MailboxExportJob]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [WorkMailClientTypes.MailboxExportJob]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListMailboxPermissionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMailboxPermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMailboxPermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMailboxPermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMailboxPermissionsOutputError>
}

extension ListMailboxPermissionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMailboxPermissionsInput(entityId: \(Swift.String(describing: entityId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension ListMailboxPermissionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct ListMailboxPermissionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMailboxPermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMailboxPermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMailboxPermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMailboxPermissionsOutputError>
}

public struct ListMailboxPermissionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMailboxPermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMailboxPermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMailboxPermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMailboxPermissionsOutputError>
}

public struct ListMailboxPermissionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMailboxPermissionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListMailboxPermissionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMailboxPermissionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMailboxPermissionsOutputError>
}

public struct ListMailboxPermissionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMailboxPermissionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListMailboxPermissionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMailboxPermissionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMailboxPermissionsOutputError>
}

public struct ListMailboxPermissionsInput: Swift.Equatable {
    /// The identifier of the user, group, or resource for which to list mailbox
    ///          permissions.
    /// This member is required.
    public var entityId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not
    ///          contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier of the organization under which the user, group, or resource
    ///          exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        entityId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.entityId = entityId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListMailboxPermissionsInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let entityId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListMailboxPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMailboxPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMailboxPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMailboxPermissionsOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMailboxPermissionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMailboxPermissionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), permissions: \(Swift.String(describing: permissions)))"}
}

extension ListMailboxPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMailboxPermissionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissions = output.permissions
        } else {
            self.nextToken = nil
            self.permissions = nil
        }
    }
}

public struct ListMailboxPermissionsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. The value is "null" when there
    ///          are no more results to return.
    public var nextToken: Swift.String?
    /// One page of the user, group, or resource mailbox permissions.
    public var permissions: [WorkMailClientTypes.Permission]?

    public init (
        nextToken: Swift.String? = nil,
        permissions: [WorkMailClientTypes.Permission]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissions = permissions
    }
}

struct ListMailboxPermissionsOutputResponseBody: Swift.Equatable {
    public let permissions: [WorkMailClientTypes.Permission]?
    public let nextToken: Swift.String?
}

extension ListMailboxPermissionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case permissions = "Permissions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Permission?].self, forKey: .permissions)
        var permissionsDecoded0:[WorkMailClientTypes.Permission]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [WorkMailClientTypes.Permission]()
            for structure0 in permissionsContainer {
                if let structure0 = structure0 {
                    permissionsDecoded0?.append(structure0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListMobileDeviceAccessOverridesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMobileDeviceAccessOverridesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMobileDeviceAccessOverridesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMobileDeviceAccessOverridesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMobileDeviceAccessOverridesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMobileDeviceAccessOverridesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMobileDeviceAccessOverridesOutputError>
}

extension ListMobileDeviceAccessOverridesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMobileDeviceAccessOverridesInput(deviceId: \(Swift.String(describing: deviceId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), organizationId: \(Swift.String(describing: organizationId)), userId: \(Swift.String(describing: userId)))"}
}

extension ListMobileDeviceAccessOverridesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct ListMobileDeviceAccessOverridesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMobileDeviceAccessOverridesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMobileDeviceAccessOverridesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMobileDeviceAccessOverridesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMobileDeviceAccessOverridesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMobileDeviceAccessOverridesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMobileDeviceAccessOverridesOutputError>
}

public struct ListMobileDeviceAccessOverridesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMobileDeviceAccessOverridesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMobileDeviceAccessOverridesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMobileDeviceAccessOverridesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMobileDeviceAccessOverridesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMobileDeviceAccessOverridesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMobileDeviceAccessOverridesOutputError>
}

public struct ListMobileDeviceAccessOverridesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMobileDeviceAccessOverridesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListMobileDeviceAccessOverridesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMobileDeviceAccessOverridesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMobileDeviceAccessOverridesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMobileDeviceAccessOverridesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMobileDeviceAccessOverridesOutputError>
}

public struct ListMobileDeviceAccessOverridesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMobileDeviceAccessOverridesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListMobileDeviceAccessOverridesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMobileDeviceAccessOverridesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMobileDeviceAccessOverridesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMobileDeviceAccessOverridesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMobileDeviceAccessOverridesOutputError>
}

public struct ListMobileDeviceAccessOverridesInput: Swift.Equatable {
    /// The mobile device to which the access override applies.
    public var deviceId: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not require a token.
    public var nextToken: Swift.String?
    /// The Amazon WorkMail organization under which to list mobile device access overrides.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The WorkMail user under which you list the mobile device access overrides. Accepts the following types of user identities:
    ///
    ///
    ///                User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    ///
    ///
    ///                Email address: user@domain.tld
    ///
    ///
    ///
    ///                User name: user
    ///
    ///
    ///
    public var userId: Swift.String?

    public init (
        deviceId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct ListMobileDeviceAccessOverridesInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let userId: Swift.String?
    public let deviceId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListMobileDeviceAccessOverridesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceId = "DeviceId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListMobileDeviceAccessOverridesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMobileDeviceAccessOverridesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMobileDeviceAccessOverridesOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMobileDeviceAccessOverridesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMobileDeviceAccessOverridesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), overrides: \(Swift.String(describing: overrides)))"}
}

extension ListMobileDeviceAccessOverridesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMobileDeviceAccessOverridesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.overrides = output.overrides
        } else {
            self.nextToken = nil
            self.overrides = nil
        }
    }
}

public struct ListMobileDeviceAccessOverridesOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. The value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The list of mobile device access overrides that exist for the specified Amazon WorkMail organization and user.
    public var overrides: [WorkMailClientTypes.MobileDeviceAccessOverride]?

    public init (
        nextToken: Swift.String? = nil,
        overrides: [WorkMailClientTypes.MobileDeviceAccessOverride]? = nil
    )
    {
        self.nextToken = nextToken
        self.overrides = overrides
    }
}

struct ListMobileDeviceAccessOverridesOutputResponseBody: Swift.Equatable {
    public let overrides: [WorkMailClientTypes.MobileDeviceAccessOverride]?
    public let nextToken: Swift.String?
}

extension ListMobileDeviceAccessOverridesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case overrides = "Overrides"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overridesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.MobileDeviceAccessOverride?].self, forKey: .overrides)
        var overridesDecoded0:[WorkMailClientTypes.MobileDeviceAccessOverride]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [WorkMailClientTypes.MobileDeviceAccessOverride]()
            for structure0 in overridesContainer {
                if let structure0 = structure0 {
                    overridesDecoded0?.append(structure0)
                }
            }
        }
        overrides = overridesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListMobileDeviceAccessRulesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMobileDeviceAccessRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMobileDeviceAccessRulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMobileDeviceAccessRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMobileDeviceAccessRulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMobileDeviceAccessRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMobileDeviceAccessRulesOutputError>
}

extension ListMobileDeviceAccessRulesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMobileDeviceAccessRulesInput(organizationId: \(Swift.String(describing: organizationId)))"}
}

extension ListMobileDeviceAccessRulesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct ListMobileDeviceAccessRulesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMobileDeviceAccessRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMobileDeviceAccessRulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMobileDeviceAccessRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMobileDeviceAccessRulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMobileDeviceAccessRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMobileDeviceAccessRulesOutputError>
}

public struct ListMobileDeviceAccessRulesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMobileDeviceAccessRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListMobileDeviceAccessRulesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMobileDeviceAccessRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListMobileDeviceAccessRulesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListMobileDeviceAccessRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMobileDeviceAccessRulesOutputError>
}

public struct ListMobileDeviceAccessRulesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMobileDeviceAccessRulesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListMobileDeviceAccessRulesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMobileDeviceAccessRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMobileDeviceAccessRulesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMobileDeviceAccessRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMobileDeviceAccessRulesOutputError>
}

public struct ListMobileDeviceAccessRulesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListMobileDeviceAccessRulesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListMobileDeviceAccessRulesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListMobileDeviceAccessRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListMobileDeviceAccessRulesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListMobileDeviceAccessRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListMobileDeviceAccessRulesOutputError>
}

public struct ListMobileDeviceAccessRulesInput: Swift.Equatable {
    /// The Amazon WorkMail organization for which to list the rules.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        organizationId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
    }
}

struct ListMobileDeviceAccessRulesInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
}

extension ListMobileDeviceAccessRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension ListMobileDeviceAccessRulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMobileDeviceAccessRulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMobileDeviceAccessRulesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMobileDeviceAccessRulesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListMobileDeviceAccessRulesOutputResponse(rules: \(Swift.String(describing: rules)))"}
}

extension ListMobileDeviceAccessRulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListMobileDeviceAccessRulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.rules = output.rules
        } else {
            self.rules = nil
        }
    }
}

public struct ListMobileDeviceAccessRulesOutputResponse: Swift.Equatable {
    /// The list of mobile device access rules that exist under the specified Amazon WorkMail organization.
    public var rules: [WorkMailClientTypes.MobileDeviceAccessRule]?

    public init (
        rules: [WorkMailClientTypes.MobileDeviceAccessRule]? = nil
    )
    {
        self.rules = rules
    }
}

struct ListMobileDeviceAccessRulesOutputResponseBody: Swift.Equatable {
    public let rules: [WorkMailClientTypes.MobileDeviceAccessRule]?
}

extension ListMobileDeviceAccessRulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules = "Rules"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.MobileDeviceAccessRule?].self, forKey: .rules)
        var rulesDecoded0:[WorkMailClientTypes.MobileDeviceAccessRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [WorkMailClientTypes.MobileDeviceAccessRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

public struct ListOrganizationsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOrganizationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOrganizationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOrganizationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOrganizationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOrganizationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOrganizationsOutputError>
}

extension ListOrganizationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOrganizationsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListOrganizationsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListOrganizationsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOrganizationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOrganizationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOrganizationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOrganizationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOrganizationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOrganizationsOutputError>
}

public struct ListOrganizationsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOrganizationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOrganizationsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOrganizationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOrganizationsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOrganizationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOrganizationsOutputError>
}

public struct ListOrganizationsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOrganizationsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListOrganizationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOrganizationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOrganizationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOrganizationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOrganizationsOutputError>
}

public struct ListOrganizationsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOrganizationsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListOrganizationsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOrganizationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOrganizationsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOrganizationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOrganizationsOutputError>
}

public struct ListOrganizationsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not
    ///          contain any tokens.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOrganizationsInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListOrganizationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListOrganizationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOrganizationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOrganizationsOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOrganizationsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOrganizationsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), organizationSummaries: \(Swift.String(describing: organizationSummaries)))"}
}

extension ListOrganizationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOrganizationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.organizationSummaries = output.organizationSummaries
        } else {
            self.nextToken = nil
            self.organizationSummaries = nil
        }
    }
}

public struct ListOrganizationsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. The value is "null" when there
    ///          are no more results to return.
    public var nextToken: Swift.String?
    /// The overview of owned organizations presented as a list of organization
    ///          summaries.
    public var organizationSummaries: [WorkMailClientTypes.OrganizationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        organizationSummaries: [WorkMailClientTypes.OrganizationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationSummaries = organizationSummaries
    }
}

struct ListOrganizationsOutputResponseBody: Swift.Equatable {
    public let organizationSummaries: [WorkMailClientTypes.OrganizationSummary]?
    public let nextToken: Swift.String?
}

extension ListOrganizationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case organizationSummaries = "OrganizationSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationSummariesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.OrganizationSummary?].self, forKey: .organizationSummaries)
        var organizationSummariesDecoded0:[WorkMailClientTypes.OrganizationSummary]? = nil
        if let organizationSummariesContainer = organizationSummariesContainer {
            organizationSummariesDecoded0 = [WorkMailClientTypes.OrganizationSummary]()
            for structure0 in organizationSummariesContainer {
                if let structure0 = structure0 {
                    organizationSummariesDecoded0?.append(structure0)
                }
            }
        }
        organizationSummaries = organizationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourceDelegatesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceDelegatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceDelegatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceDelegatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceDelegatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceDelegatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceDelegatesOutputError>
}

extension ListResourceDelegatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourceDelegatesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), organizationId: \(Swift.String(describing: organizationId)), resourceId: \(Swift.String(describing: resourceId)))"}
}

extension ListResourceDelegatesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct ListResourceDelegatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceDelegatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceDelegatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceDelegatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceDelegatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceDelegatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceDelegatesOutputError>
}

public struct ListResourceDelegatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceDelegatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourceDelegatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceDelegatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourceDelegatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceDelegatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceDelegatesOutputError>
}

public struct ListResourceDelegatesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceDelegatesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListResourceDelegatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceDelegatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResourceDelegatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceDelegatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceDelegatesOutputError>
}

public struct ListResourceDelegatesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourceDelegatesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListResourceDelegatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourceDelegatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResourceDelegatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourceDelegatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourceDelegatesOutputError>
}

public struct ListResourceDelegatesInput: Swift.Equatable {
    /// The number of maximum results in a page.
    public var maxResults: Swift.Int?
    /// The token used to paginate through the delegates associated with a
    ///          resource.
    public var nextToken: Swift.String?
    /// The identifier for the organization that contains the resource for which delegates
    ///          are listed.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier for the resource whose delegates are listed.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct ListResourceDelegatesInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let resourceId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListResourceDelegatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourceDelegatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourceDelegatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourceDelegatesOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourceDelegatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourceDelegatesOutputResponse(delegates: \(Swift.String(describing: delegates)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListResourceDelegatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResourceDelegatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.delegates = output.delegates
            self.nextToken = output.nextToken
        } else {
            self.delegates = nil
            self.nextToken = nil
        }
    }
}

public struct ListResourceDelegatesOutputResponse: Swift.Equatable {
    /// One page of the resource's delegates.
    public var delegates: [WorkMailClientTypes.Delegate]?
    /// The token used to paginate through the delegates associated with a resource. While
    ///          results are still available, it has an associated value. When the last page is reached, the
    ///          token is empty.
    public var nextToken: Swift.String?

    public init (
        delegates: [WorkMailClientTypes.Delegate]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.delegates = delegates
        self.nextToken = nextToken
    }
}

struct ListResourceDelegatesOutputResponseBody: Swift.Equatable {
    public let delegates: [WorkMailClientTypes.Delegate]?
    public let nextToken: Swift.String?
}

extension ListResourceDelegatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delegates = "Delegates"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegatesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Delegate?].self, forKey: .delegates)
        var delegatesDecoded0:[WorkMailClientTypes.Delegate]? = nil
        if let delegatesContainer = delegatesContainer {
            delegatesDecoded0 = [WorkMailClientTypes.Delegate]()
            for structure0 in delegatesContainer {
                if let structure0 = structure0 {
                    delegatesDecoded0?.append(structure0)
                }
            }
        }
        delegates = delegatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResourcesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourcesOutputError>
}

extension ListResourcesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourcesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension ListResourcesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct ListResourcesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourcesOutputError>
}

public struct ListResourcesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourcesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourcesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourcesOutputError>
}

public struct ListResourcesInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourcesInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourcesOutputError>
}

public struct ListResourcesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourcesInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListResourcesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResourcesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourcesOutputError>
}

public struct ListResourcesInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not
    ///          contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the resources exist.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListResourcesInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListResourcesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListResourcesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourcesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourcesOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourcesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourcesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), resources: \(Swift.String(describing: resources)))"}
}

extension ListResourcesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResourcesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListResourcesOutputResponse: Swift.Equatable {
    ///  The token used to paginate through all the organization's resources. While results
    ///          are still available, it has an associated value. When the last page is reached, the token
    ///          is empty.
    public var nextToken: Swift.String?
    /// One page of the organization's resource representation.
    public var resources: [WorkMailClientTypes.Resource]?

    public init (
        nextToken: Swift.String? = nil,
        resources: [WorkMailClientTypes.Resource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListResourcesOutputResponseBody: Swift.Equatable {
    public let resources: [WorkMailClientTypes.Resource]?
    public let nextToken: Swift.String?
}

extension ListResourcesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resources = "Resources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[WorkMailClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [WorkMailClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceARN: \(Swift.String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// A list of tag key-value pairs.
    public var tags: [WorkMailClientTypes.Tag]?

    public init (
        tags: [WorkMailClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [WorkMailClientTypes.Tag]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkMailClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkMailClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListUsersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsersOutputError>
}

extension ListUsersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUsersInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension ListUsersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct ListUsersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsersOutputError>
}

public struct ListUsersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListUsersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListUsersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsersOutputError>
}

public struct ListUsersInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsersInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ListUsersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListUsersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsersOutputError>
}

public struct ListUsersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListUsersInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ListUsersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListUsersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListUsersInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListUsersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListUsersOutputError>
}

public struct ListUsersInput: Swift.Equatable {
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token to use to retrieve the next page of results. The first call does not
    ///          contain any tokens.
    public var nextToken: Swift.String?
    /// The identifier for the organization under which the users exist.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationId = organizationId
    }
}

struct ListUsersInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListUsersOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListUsersOutputResponse(nextToken: \(Swift.String(describing: nextToken)), users: \(Swift.String(describing: users)))"}
}

extension ListUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct ListUsersOutputResponse: Swift.Equatable {
    ///  The token to use to retrieve the next page of results. This value is `null` when
    ///          there are no more results to return.
    public var nextToken: Swift.String?
    /// The overview of users for an organization.
    public var users: [WorkMailClientTypes.User]?

    public init (
        nextToken: Swift.String? = nil,
        users: [WorkMailClientTypes.User]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

struct ListUsersOutputResponseBody: Swift.Equatable {
    public let users: [WorkMailClientTypes.User]?
    public let nextToken: Swift.String?
}

extension ListUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case users = "Users"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.User?].self, forKey: .users)
        var usersDecoded0:[WorkMailClientTypes.User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [WorkMailClientTypes.User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MailDomainNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MailDomainNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension MailDomainNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MailDomainNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// For an email or alias to be created in Amazon WorkMail, the included domain must be defined
///          in the organization.
public struct MailDomainNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MailDomainNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension MailDomainNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MailDomainStateException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MailDomainStateException(message: \(Swift.String(describing: message)))"}
}

extension MailDomainStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MailDomainStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// After a domain has been added to the organization, it must be verified. The domain is
///          not yet verified.
public struct MailDomainStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct MailDomainStateExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension MailDomainStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkMailClientTypes.MailboxExportJob: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case endTime = "EndTime"
        case entityId = "EntityId"
        case estimatedProgress = "EstimatedProgress"
        case jobId = "JobId"
        case s3BucketName = "S3BucketName"
        case s3Path = "S3Path"
        case startTime = "StartTime"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if estimatedProgress != 0 {
            try encodeContainer.encode(estimatedProgress, forKey: .estimatedProgress)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3Path = s3Path {
            try encodeContainer.encode(s3Path, forKey: .s3Path)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Path)
        s3Path = s3PathDecoded
        let estimatedProgressDecoded = try containerValues.decode(Swift.Int.self, forKey: .estimatedProgress)
        estimatedProgress = estimatedProgressDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MailboxExportJobState.self, forKey: .state)
        state = stateDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension WorkMailClientTypes.MailboxExportJob: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MailboxExportJob(description: \(Swift.String(describing: description)), endTime: \(Swift.String(describing: endTime)), entityId: \(Swift.String(describing: entityId)), estimatedProgress: \(Swift.String(describing: estimatedProgress)), jobId: \(Swift.String(describing: jobId)), s3BucketName: \(Swift.String(describing: s3BucketName)), s3Path: \(Swift.String(describing: s3Path)), startTime: \(Swift.String(describing: startTime)), state: \(Swift.String(describing: state)))"}
}

extension WorkMailClientTypes {
    /// The details of a mailbox export job, including the user or resource ID associated
    ///          with the mailbox and the S3 bucket that the mailbox contents are exported to.
    public struct MailboxExportJob: Swift.Equatable {
        /// The mailbox export job description.
        public var description: Swift.String?
        /// The mailbox export job end timestamp.
        public var endTime: ClientRuntime.Date?
        /// The identifier of the user or resource associated with the mailbox.
        public var entityId: Swift.String?
        /// The estimated progress of the mailbox export job, in percentage points.
        public var estimatedProgress: Swift.Int
        /// The identifier of the mailbox export job.
        public var jobId: Swift.String?
        /// The name of the S3 bucket.
        public var s3BucketName: Swift.String?
        /// The path to the S3 bucket and file that the mailbox export job exports to.
        public var s3Path: Swift.String?
        /// The mailbox export job start timestamp.
        public var startTime: ClientRuntime.Date?
        /// The state of the mailbox export job.
        public var state: WorkMailClientTypes.MailboxExportJobState?

        public init (
            description: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            entityId: Swift.String? = nil,
            estimatedProgress: Swift.Int = 0,
            jobId: Swift.String? = nil,
            s3BucketName: Swift.String? = nil,
            s3Path: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: WorkMailClientTypes.MailboxExportJobState? = nil
        )
        {
            self.description = description
            self.endTime = endTime
            self.entityId = entityId
            self.estimatedProgress = estimatedProgress
            self.jobId = jobId
            self.s3BucketName = s3BucketName
            self.s3Path = s3Path
            self.startTime = startTime
            self.state = state
        }
    }

}

extension WorkMailClientTypes {
    public enum MailboxExportJobState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [MailboxExportJobState] {
            return [
                .cancelled,
                .completed,
                .failed,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MailboxExportJobState(rawValue: rawValue) ?? MailboxExportJobState.sdkUnknown(rawValue)
        }
    }
}

extension WorkMailClientTypes.Member: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabledDate = "DisabledDate"
        case enabledDate = "EnabledDate"
        case id = "Id"
        case name = "Name"
        case state = "State"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabledDate = disabledDate {
            try encodeContainer.encode(disabledDate.timeIntervalSince1970, forKey: .disabledDate)
        }
        if let enabledDate = enabledDate {
            try encodeContainer.encode(enabledDate.timeIntervalSince1970, forKey: .enabledDate)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MemberType.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
        let enabledDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

extension WorkMailClientTypes.Member: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Member(disabledDate: \(Swift.String(describing: disabledDate)), enabledDate: \(Swift.String(describing: enabledDate)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)), type: \(Swift.String(describing: type)))"}
}

extension WorkMailClientTypes {
    /// The representation of a user or group.
    public struct Member: Swift.Equatable {
        /// The date indicating when the member was disabled from Amazon WorkMail use.
        public var disabledDate: ClientRuntime.Date?
        /// The date indicating when the member was enabled for Amazon WorkMail use.
        public var enabledDate: ClientRuntime.Date?
        /// The identifier of the member.
        public var id: Swift.String?
        /// The name of the member.
        public var name: Swift.String?
        /// The state of the member, which can be ENABLED, DISABLED, or DELETED.
        public var state: WorkMailClientTypes.EntityState?
        /// A member can be a user or group.
        public var type: WorkMailClientTypes.MemberType?

        public init (
            disabledDate: ClientRuntime.Date? = nil,
            enabledDate: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil,
            type: WorkMailClientTypes.MemberType? = nil
        )
        {
            self.disabledDate = disabledDate
            self.enabledDate = enabledDate
            self.id = id
            self.name = name
            self.state = state
            self.type = type
        }
    }

}

extension WorkMailClientTypes {
    public enum MemberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case group
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberType] {
            return [
                .group,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MemberType(rawValue: rawValue) ?? MemberType.sdkUnknown(rawValue)
        }
    }
}

extension WorkMailClientTypes.MobileDeviceAccessMatchedRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mobileDeviceAccessRuleId = mobileDeviceAccessRuleId {
            try encodeContainer.encode(mobileDeviceAccessRuleId, forKey: .mobileDeviceAccessRuleId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mobileDeviceAccessRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mobileDeviceAccessRuleId)
        mobileDeviceAccessRuleId = mobileDeviceAccessRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension WorkMailClientTypes.MobileDeviceAccessMatchedRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MobileDeviceAccessMatchedRule(mobileDeviceAccessRuleId: \(Swift.String(describing: mobileDeviceAccessRuleId)), name: \(Swift.String(describing: name)))"}
}

extension WorkMailClientTypes {
    /// The rule that a simulated user matches.
    public struct MobileDeviceAccessMatchedRule: Swift.Equatable {
        /// Identifier of the rule that a simulated user matches.
        public var mobileDeviceAccessRuleId: Swift.String?
        /// Name of a rule that a simulated user matches.
        public var name: Swift.String?

        public init (
            mobileDeviceAccessRuleId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
            self.name = name
        }
    }

}

extension WorkMailClientTypes.MobileDeviceAccessOverride: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case description = "Description"
        case deviceId = "DeviceId"
        case effect = "Effect"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated.timeIntervalSince1970, forKey: .dateCreated)
        }
        if let dateModified = dateModified {
            try encodeContainer.encode(dateModified.timeIntervalSince1970, forKey: .dateModified)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let effect = effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let dateCreatedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .dateModified)
        dateModified = dateModifiedDecoded
    }
}

extension WorkMailClientTypes.MobileDeviceAccessOverride: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MobileDeviceAccessOverride(dateCreated: \(Swift.String(describing: dateCreated)), dateModified: \(Swift.String(describing: dateModified)), description: \(Swift.String(describing: description)), deviceId: \(Swift.String(describing: deviceId)), effect: \(Swift.String(describing: effect)), userId: \(Swift.String(describing: userId)))"}
}

extension WorkMailClientTypes {
    /// The override object.
    public struct MobileDeviceAccessOverride: Swift.Equatable {
        /// The date the override was first created.
        public var dateCreated: ClientRuntime.Date?
        /// The date the override was last modified.
        public var dateModified: ClientRuntime.Date?
        /// A description of the override.
        public var description: Swift.String?
        /// The device to which the override applies.
        public var deviceId: Swift.String?
        /// The effect of the override, ALLOW or DENY.
        public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
        /// The WorkMail user to which the access override applies.
        public var userId: Swift.String?

        public init (
            dateCreated: ClientRuntime.Date? = nil,
            dateModified: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            deviceId: Swift.String? = nil,
            effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
            userId: Swift.String? = nil
        )
        {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.description = description
            self.deviceId = deviceId
            self.effect = effect
            self.userId = userId
        }
    }

}

extension WorkMailClientTypes.MobileDeviceAccessRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dateCreated = "DateCreated"
        case dateModified = "DateModified"
        case description = "Description"
        case deviceModels = "DeviceModels"
        case deviceOperatingSystems = "DeviceOperatingSystems"
        case deviceTypes = "DeviceTypes"
        case deviceUserAgents = "DeviceUserAgents"
        case effect = "Effect"
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case name = "Name"
        case notDeviceModels = "NotDeviceModels"
        case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
        case notDeviceTypes = "NotDeviceTypes"
        case notDeviceUserAgents = "NotDeviceUserAgents"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateCreated = dateCreated {
            try encodeContainer.encode(dateCreated.timeIntervalSince1970, forKey: .dateCreated)
        }
        if let dateModified = dateModified {
            try encodeContainer.encode(dateModified.timeIntervalSince1970, forKey: .dateModified)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceModels = deviceModels {
            var deviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceModels)
            for devicemodellist0 in deviceModels {
                try deviceModelsContainer.encode(devicemodellist0)
            }
        }
        if let deviceOperatingSystems = deviceOperatingSystems {
            var deviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceOperatingSystems)
            for deviceoperatingsystemlist0 in deviceOperatingSystems {
                try deviceOperatingSystemsContainer.encode(deviceoperatingsystemlist0)
            }
        }
        if let deviceTypes = deviceTypes {
            var deviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceTypes)
            for devicetypelist0 in deviceTypes {
                try deviceTypesContainer.encode(devicetypelist0)
            }
        }
        if let deviceUserAgents = deviceUserAgents {
            var deviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceUserAgents)
            for deviceuseragentlist0 in deviceUserAgents {
                try deviceUserAgentsContainer.encode(deviceuseragentlist0)
            }
        }
        if let effect = effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let mobileDeviceAccessRuleId = mobileDeviceAccessRuleId {
            try encodeContainer.encode(mobileDeviceAccessRuleId, forKey: .mobileDeviceAccessRuleId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notDeviceModels = notDeviceModels {
            var notDeviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceModels)
            for devicemodellist0 in notDeviceModels {
                try notDeviceModelsContainer.encode(devicemodellist0)
            }
        }
        if let notDeviceOperatingSystems = notDeviceOperatingSystems {
            var notDeviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceOperatingSystems)
            for deviceoperatingsystemlist0 in notDeviceOperatingSystems {
                try notDeviceOperatingSystemsContainer.encode(deviceoperatingsystemlist0)
            }
        }
        if let notDeviceTypes = notDeviceTypes {
            var notDeviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceTypes)
            for devicetypelist0 in notDeviceTypes {
                try notDeviceTypesContainer.encode(devicetypelist0)
            }
        }
        if let notDeviceUserAgents = notDeviceUserAgents {
            var notDeviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceUserAgents)
            for deviceuseragentlist0 in notDeviceUserAgents {
                try notDeviceUserAgentsContainer.encode(deviceuseragentlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mobileDeviceAccessRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mobileDeviceAccessRuleId)
        mobileDeviceAccessRuleId = mobileDeviceAccessRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let deviceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceTypes)
        var deviceTypesDecoded0:[Swift.String]? = nil
        if let deviceTypesContainer = deviceTypesContainer {
            deviceTypesDecoded0 = [Swift.String]()
            for string0 in deviceTypesContainer {
                if let string0 = string0 {
                    deviceTypesDecoded0?.append(string0)
                }
            }
        }
        deviceTypes = deviceTypesDecoded0
        let notDeviceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceTypes)
        var notDeviceTypesDecoded0:[Swift.String]? = nil
        if let notDeviceTypesContainer = notDeviceTypesContainer {
            notDeviceTypesDecoded0 = [Swift.String]()
            for string0 in notDeviceTypesContainer {
                if let string0 = string0 {
                    notDeviceTypesDecoded0?.append(string0)
                }
            }
        }
        notDeviceTypes = notDeviceTypesDecoded0
        let deviceModelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceModels)
        var deviceModelsDecoded0:[Swift.String]? = nil
        if let deviceModelsContainer = deviceModelsContainer {
            deviceModelsDecoded0 = [Swift.String]()
            for string0 in deviceModelsContainer {
                if let string0 = string0 {
                    deviceModelsDecoded0?.append(string0)
                }
            }
        }
        deviceModels = deviceModelsDecoded0
        let notDeviceModelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceModels)
        var notDeviceModelsDecoded0:[Swift.String]? = nil
        if let notDeviceModelsContainer = notDeviceModelsContainer {
            notDeviceModelsDecoded0 = [Swift.String]()
            for string0 in notDeviceModelsContainer {
                if let string0 = string0 {
                    notDeviceModelsDecoded0?.append(string0)
                }
            }
        }
        notDeviceModels = notDeviceModelsDecoded0
        let deviceOperatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceOperatingSystems)
        var deviceOperatingSystemsDecoded0:[Swift.String]? = nil
        if let deviceOperatingSystemsContainer = deviceOperatingSystemsContainer {
            deviceOperatingSystemsDecoded0 = [Swift.String]()
            for string0 in deviceOperatingSystemsContainer {
                if let string0 = string0 {
                    deviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        deviceOperatingSystems = deviceOperatingSystemsDecoded0
        let notDeviceOperatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceOperatingSystems)
        var notDeviceOperatingSystemsDecoded0:[Swift.String]? = nil
        if let notDeviceOperatingSystemsContainer = notDeviceOperatingSystemsContainer {
            notDeviceOperatingSystemsDecoded0 = [Swift.String]()
            for string0 in notDeviceOperatingSystemsContainer {
                if let string0 = string0 {
                    notDeviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        notDeviceOperatingSystems = notDeviceOperatingSystemsDecoded0
        let deviceUserAgentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceUserAgents)
        var deviceUserAgentsDecoded0:[Swift.String]? = nil
        if let deviceUserAgentsContainer = deviceUserAgentsContainer {
            deviceUserAgentsDecoded0 = [Swift.String]()
            for string0 in deviceUserAgentsContainer {
                if let string0 = string0 {
                    deviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        deviceUserAgents = deviceUserAgentsDecoded0
        let notDeviceUserAgentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceUserAgents)
        var notDeviceUserAgentsDecoded0:[Swift.String]? = nil
        if let notDeviceUserAgentsContainer = notDeviceUserAgentsContainer {
            notDeviceUserAgentsDecoded0 = [Swift.String]()
            for string0 in notDeviceUserAgentsContainer {
                if let string0 = string0 {
                    notDeviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        notDeviceUserAgents = notDeviceUserAgentsDecoded0
        let dateCreatedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .dateCreated)
        dateCreated = dateCreatedDecoded
        let dateModifiedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .dateModified)
        dateModified = dateModifiedDecoded
    }
}

extension WorkMailClientTypes.MobileDeviceAccessRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MobileDeviceAccessRule(dateCreated: \(Swift.String(describing: dateCreated)), dateModified: \(Swift.String(describing: dateModified)), description: \(Swift.String(describing: description)), deviceModels: \(Swift.String(describing: deviceModels)), deviceOperatingSystems: \(Swift.String(describing: deviceOperatingSystems)), deviceTypes: \(Swift.String(describing: deviceTypes)), deviceUserAgents: \(Swift.String(describing: deviceUserAgents)), effect: \(Swift.String(describing: effect)), mobileDeviceAccessRuleId: \(Swift.String(describing: mobileDeviceAccessRuleId)), name: \(Swift.String(describing: name)), notDeviceModels: \(Swift.String(describing: notDeviceModels)), notDeviceOperatingSystems: \(Swift.String(describing: notDeviceOperatingSystems)), notDeviceTypes: \(Swift.String(describing: notDeviceTypes)), notDeviceUserAgents: \(Swift.String(describing: notDeviceUserAgents)))"}
}

extension WorkMailClientTypes {
    /// A rule that controls access to mobile devices for an Amazon WorkMail group.
    public struct MobileDeviceAccessRule: Swift.Equatable {
        /// The date and time at which an access rule was created.
        public var dateCreated: ClientRuntime.Date?
        /// The date and time at which an access rule was modified.
        public var dateModified: ClientRuntime.Date?
        /// The description of a mobile access rule.
        public var description: Swift.String?
        /// Device models that a rule will match.
        public var deviceModels: [Swift.String]?
        /// Device operating systems that a rule will match.
        public var deviceOperatingSystems: [Swift.String]?
        /// Device types that a rule will match.
        public var deviceTypes: [Swift.String]?
        /// Device user agents that a rule will match.
        public var deviceUserAgents: [Swift.String]?
        /// The effect of the rule when it matches. Allowed values are ALLOW or DENY.
        public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
        /// The ID assigned to a mobile access rule.
        public var mobileDeviceAccessRuleId: Swift.String?
        /// The name of a mobile access rule.
        public var name: Swift.String?
        /// Device models that a rule will not match. All other device models will match.
        public var notDeviceModels: [Swift.String]?
        /// Device operating systems that a rule will not match. All other device types will match.
        public var notDeviceOperatingSystems: [Swift.String]?
        /// Device types that a rule will not match. All other device types will match.
        public var notDeviceTypes: [Swift.String]?
        /// Device user agents that a rule will not match. All other device user agents will match.
        public var notDeviceUserAgents: [Swift.String]?

        public init (
            dateCreated: ClientRuntime.Date? = nil,
            dateModified: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            deviceModels: [Swift.String]? = nil,
            deviceOperatingSystems: [Swift.String]? = nil,
            deviceTypes: [Swift.String]? = nil,
            deviceUserAgents: [Swift.String]? = nil,
            effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
            mobileDeviceAccessRuleId: Swift.String? = nil,
            name: Swift.String? = nil,
            notDeviceModels: [Swift.String]? = nil,
            notDeviceOperatingSystems: [Swift.String]? = nil,
            notDeviceTypes: [Swift.String]? = nil,
            notDeviceUserAgents: [Swift.String]? = nil
        )
        {
            self.dateCreated = dateCreated
            self.dateModified = dateModified
            self.description = description
            self.deviceModels = deviceModels
            self.deviceOperatingSystems = deviceOperatingSystems
            self.deviceTypes = deviceTypes
            self.deviceUserAgents = deviceUserAgents
            self.effect = effect
            self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
            self.name = name
            self.notDeviceModels = notDeviceModels
            self.notDeviceOperatingSystems = notDeviceOperatingSystems
            self.notDeviceTypes = notDeviceTypes
            self.notDeviceUserAgents = notDeviceUserAgents
        }
    }

}

extension WorkMailClientTypes {
    public enum MobileDeviceAccessRuleEffect: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allow
        case deny
        case sdkUnknown(Swift.String)

        public static var allCases: [MobileDeviceAccessRuleEffect] {
            return [
                .allow,
                .deny,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allow: return "ALLOW"
            case .deny: return "DENY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MobileDeviceAccessRuleEffect(rawValue: rawValue) ?? MobileDeviceAccessRuleEffect.sdkUnknown(rawValue)
        }
    }
}

extension NameAvailabilityException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NameAvailabilityException(message: \(Swift.String(describing: message)))"}
}

extension NameAvailabilityException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NameAvailabilityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The user, group, or resource name isn't unique in Amazon WorkMail.
public struct NameAvailabilityException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NameAvailabilityExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NameAvailabilityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OrganizationNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension OrganizationNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OrganizationNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An operation received a valid organization identifier that either doesn't belong or
///          exist in the system.
public struct OrganizationNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OrganizationNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OrganizationNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OrganizationStateException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OrganizationStateException(message: \(Swift.String(describing: message)))"}
}

extension OrganizationStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OrganizationStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The organization must have a valid state to perform certain
///          operations on the organization or its members.
public struct OrganizationStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OrganizationStateExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OrganizationStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkMailClientTypes.OrganizationSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case defaultMailDomain = "DefaultMailDomain"
        case errorMessage = "ErrorMessage"
        case organizationId = "OrganizationId"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let defaultMailDomain = defaultMailDomain {
            try encodeContainer.encode(defaultMailDomain, forKey: .defaultMailDomain)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let defaultMailDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultMailDomain)
        defaultMailDomain = defaultMailDomainDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let stateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .state)
        state = stateDecoded
    }
}

extension WorkMailClientTypes.OrganizationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OrganizationSummary(alias: \(Swift.String(describing: alias)), defaultMailDomain: \(Swift.String(describing: defaultMailDomain)), errorMessage: \(Swift.String(describing: errorMessage)), organizationId: \(Swift.String(describing: organizationId)), state: \(Swift.String(describing: state)))"}
}

extension WorkMailClientTypes {
    /// The representation of an organization.
    public struct OrganizationSummary: Swift.Equatable {
        /// The alias associated with the organization.
        public var alias: Swift.String?
        /// The default email domain associated with the organization.
        public var defaultMailDomain: Swift.String?
        /// The error message associated with the organization. It is only present if unexpected
        ///          behavior has occurred with regards to the organization. It provides insight or solutions
        ///          regarding unexpected behavior.
        public var errorMessage: Swift.String?
        /// The identifier associated with the organization.
        public var organizationId: Swift.String?
        /// The state associated with the organization.
        public var state: Swift.String?

        public init (
            alias: Swift.String? = nil,
            defaultMailDomain: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            organizationId: Swift.String? = nil,
            state: Swift.String? = nil
        )
        {
            self.alias = alias
            self.defaultMailDomain = defaultMailDomain
            self.errorMessage = errorMessage
            self.organizationId = organizationId
            self.state = state
        }
    }

}

extension WorkMailClientTypes.Permission: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case granteeId = "GranteeId"
        case granteeType = "GranteeType"
        case permissionValues = "PermissionValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let granteeId = granteeId {
            try encodeContainer.encode(granteeId, forKey: .granteeId)
        }
        if let granteeType = granteeType {
            try encodeContainer.encode(granteeType.rawValue, forKey: .granteeType)
        }
        if let permissionValues = permissionValues {
            var permissionValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissionValues)
            for permissionvalues0 in permissionValues {
                try permissionValuesContainer.encode(permissionvalues0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let granteeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .granteeId)
        granteeId = granteeIdDecoded
        let granteeTypeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MemberType.self, forKey: .granteeType)
        granteeType = granteeTypeDecoded
        let permissionValuesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.PermissionType?].self, forKey: .permissionValues)
        var permissionValuesDecoded0:[WorkMailClientTypes.PermissionType]? = nil
        if let permissionValuesContainer = permissionValuesContainer {
            permissionValuesDecoded0 = [WorkMailClientTypes.PermissionType]()
            for string0 in permissionValuesContainer {
                if let string0 = string0 {
                    permissionValuesDecoded0?.append(string0)
                }
            }
        }
        permissionValues = permissionValuesDecoded0
    }
}

extension WorkMailClientTypes.Permission: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Permission(granteeId: \(Swift.String(describing: granteeId)), granteeType: \(Swift.String(describing: granteeType)), permissionValues: \(Swift.String(describing: permissionValues)))"}
}

extension WorkMailClientTypes {
    /// Permission granted to a user, group, or resource to access a certain aspect of
    ///          another user, group, or resource mailbox.
    public struct Permission: Swift.Equatable {
        /// The identifier of the user, group, or resource to which the permissions are
        ///          granted.
        /// This member is required.
        public var granteeId: Swift.String?
        /// The type of user, group, or resource referred to in GranteeId.
        /// This member is required.
        public var granteeType: WorkMailClientTypes.MemberType?
        /// The permissions granted to the grantee. SEND_AS allows the grantee to send email as
        ///          the owner of the mailbox (the grantee is not mentioned on these emails). SEND_ON_BEHALF
        ///          allows the grantee to send email on behalf of the owner of the mailbox (the grantee is not
        ///          mentioned as the physical sender of these emails). FULL_ACCESS allows the grantee full
        ///          access to the mailbox, irrespective of other folder-level permissions set on the
        ///          mailbox.
        /// This member is required.
        public var permissionValues: [WorkMailClientTypes.PermissionType]?

        public init (
            granteeId: Swift.String? = nil,
            granteeType: WorkMailClientTypes.MemberType? = nil,
            permissionValues: [WorkMailClientTypes.PermissionType]? = nil
        )
        {
            self.granteeId = granteeId
            self.granteeType = granteeType
            self.permissionValues = permissionValues
        }
    }

}

extension WorkMailClientTypes {
    public enum PermissionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullAccess
        case sendAs
        case sendOnBehalf
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionType] {
            return [
                .fullAccess,
                .sendAs,
                .sendOnBehalf,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullAccess: return "FULL_ACCESS"
            case .sendAs: return "SEND_AS"
            case .sendOnBehalf: return "SEND_ON_BEHALF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionType(rawValue: rawValue) ?? PermissionType.sdkUnknown(rawValue)
        }
    }
}

public struct PutAccessControlRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAccessControlRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAccessControlRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAccessControlRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAccessControlRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAccessControlRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAccessControlRuleOutputError>
}

extension PutAccessControlRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutAccessControlRuleInput(actions: \(Swift.String(describing: actions)), description: \(Swift.String(describing: description)), effect: \(Swift.String(describing: effect)), ipRanges: \(Swift.String(describing: ipRanges)), name: \(Swift.String(describing: name)), notActions: \(Swift.String(describing: notActions)), notIpRanges: \(Swift.String(describing: notIpRanges)), notUserIds: \(Swift.String(describing: notUserIds)), organizationId: \(Swift.String(describing: organizationId)), userIds: \(Swift.String(describing: userIds)))"}
}

extension PutAccessControlRuleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case description = "Description"
        case effect = "Effect"
        case ipRanges = "IpRanges"
        case name = "Name"
        case notActions = "NotActions"
        case notIpRanges = "NotIpRanges"
        case notUserIds = "NotUserIds"
        case organizationId = "OrganizationId"
        case userIds = "UserIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actionslist0 in actions {
                try actionsContainer.encode(actionslist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let effect = effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let ipRanges = ipRanges {
            var ipRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipRanges)
            for iprangelist0 in ipRanges {
                try ipRangesContainer.encode(iprangelist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notActions = notActions {
            var notActionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notActions)
            for actionslist0 in notActions {
                try notActionsContainer.encode(actionslist0)
            }
        }
        if let notIpRanges = notIpRanges {
            var notIpRangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notIpRanges)
            for iprangelist0 in notIpRanges {
                try notIpRangesContainer.encode(iprangelist0)
            }
        }
        if let notUserIds = notUserIds {
            var notUserIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notUserIds)
            for useridlist0 in notUserIds {
                try notUserIdsContainer.encode(useridlist0)
            }
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userIds = userIds {
            var userIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userIds)
            for useridlist0 in userIds {
                try userIdsContainer.encode(useridlist0)
            }
        }
    }
}

public struct PutAccessControlRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAccessControlRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAccessControlRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAccessControlRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAccessControlRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAccessControlRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAccessControlRuleOutputError>
}

public struct PutAccessControlRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAccessControlRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutAccessControlRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAccessControlRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutAccessControlRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutAccessControlRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAccessControlRuleOutputError>
}

public struct PutAccessControlRuleInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAccessControlRuleInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutAccessControlRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAccessControlRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutAccessControlRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutAccessControlRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAccessControlRuleOutputError>
}

public struct PutAccessControlRuleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutAccessControlRuleInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutAccessControlRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutAccessControlRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutAccessControlRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutAccessControlRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutAccessControlRuleOutputError>
}

public struct PutAccessControlRuleInput: Swift.Equatable {
    /// Access protocol actions to include in the rule. Valid values include
    ///             ActiveSync, AutoDiscover, EWS, IMAP,
    ///             SMTP, WindowsOutlook, and WebMail.
    public var actions: [Swift.String]?
    /// The rule description.
    /// This member is required.
    public var description: Swift.String?
    /// The rule effect.
    /// This member is required.
    public var effect: WorkMailClientTypes.AccessControlRuleEffect?
    /// IPv4 CIDR ranges to include in the rule.
    public var ipRanges: [Swift.String]?
    /// The rule name.
    /// This member is required.
    public var name: Swift.String?
    /// Access protocol actions to exclude from the rule. Valid values include
    ///             ActiveSync, AutoDiscover, EWS, IMAP,
    ///             SMTP, WindowsOutlook, and WebMail.
    public var notActions: [Swift.String]?
    /// IPv4 CIDR ranges to exclude from the rule.
    public var notIpRanges: [Swift.String]?
    /// User IDs to exclude from the rule.
    public var notUserIds: [Swift.String]?
    /// The identifier of the organization.
    /// This member is required.
    public var organizationId: Swift.String?
    /// User IDs to include in the rule.
    public var userIds: [Swift.String]?

    public init (
        actions: [Swift.String]? = nil,
        description: Swift.String? = nil,
        effect: WorkMailClientTypes.AccessControlRuleEffect? = nil,
        ipRanges: [Swift.String]? = nil,
        name: Swift.String? = nil,
        notActions: [Swift.String]? = nil,
        notIpRanges: [Swift.String]? = nil,
        notUserIds: [Swift.String]? = nil,
        organizationId: Swift.String? = nil,
        userIds: [Swift.String]? = nil
    )
    {
        self.actions = actions
        self.description = description
        self.effect = effect
        self.ipRanges = ipRanges
        self.name = name
        self.notActions = notActions
        self.notIpRanges = notIpRanges
        self.notUserIds = notUserIds
        self.organizationId = organizationId
        self.userIds = userIds
    }
}

struct PutAccessControlRuleInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let effect: WorkMailClientTypes.AccessControlRuleEffect?
    public let description: Swift.String?
    public let ipRanges: [Swift.String]?
    public let notIpRanges: [Swift.String]?
    public let actions: [Swift.String]?
    public let notActions: [Swift.String]?
    public let userIds: [Swift.String]?
    public let notUserIds: [Swift.String]?
    public let organizationId: Swift.String?
}

extension PutAccessControlRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case description = "Description"
        case effect = "Effect"
        case ipRanges = "IpRanges"
        case name = "Name"
        case notActions = "NotActions"
        case notIpRanges = "NotIpRanges"
        case notUserIds = "NotUserIds"
        case organizationId = "OrganizationId"
        case userIds = "UserIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.AccessControlRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ipRangesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipRanges)
        var ipRangesDecoded0:[Swift.String]? = nil
        if let ipRangesContainer = ipRangesContainer {
            ipRangesDecoded0 = [Swift.String]()
            for string0 in ipRangesContainer {
                if let string0 = string0 {
                    ipRangesDecoded0?.append(string0)
                }
            }
        }
        ipRanges = ipRangesDecoded0
        let notIpRangesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notIpRanges)
        var notIpRangesDecoded0:[Swift.String]? = nil
        if let notIpRangesContainer = notIpRangesContainer {
            notIpRangesDecoded0 = [Swift.String]()
            for string0 in notIpRangesContainer {
                if let string0 = string0 {
                    notIpRangesDecoded0?.append(string0)
                }
            }
        }
        notIpRanges = notIpRangesDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actions)
        var actionsDecoded0:[Swift.String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
        let notActionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notActions)
        var notActionsDecoded0:[Swift.String]? = nil
        if let notActionsContainer = notActionsContainer {
            notActionsDecoded0 = [Swift.String]()
            for string0 in notActionsContainer {
                if let string0 = string0 {
                    notActionsDecoded0?.append(string0)
                }
            }
        }
        notActions = notActionsDecoded0
        let userIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .userIds)
        var userIdsDecoded0:[Swift.String]? = nil
        if let userIdsContainer = userIdsContainer {
            userIdsDecoded0 = [Swift.String]()
            for string0 in userIdsContainer {
                if let string0 = string0 {
                    userIdsDecoded0?.append(string0)
                }
            }
        }
        userIds = userIdsDecoded0
        let notUserIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notUserIds)
        var notUserIdsDecoded0:[Swift.String]? = nil
        if let notUserIdsContainer = notUserIdsContainer {
            notUserIdsDecoded0 = [Swift.String]()
            for string0 in notUserIdsContainer {
                if let string0 = string0 {
                    notUserIdsDecoded0?.append(string0)
                }
            }
        }
        notUserIds = notUserIdsDecoded0
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension PutAccessControlRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAccessControlRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutAccessControlRuleOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAccessControlRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutAccessControlRuleOutputResponse()"}
}

extension PutAccessControlRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutAccessControlRuleOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutAccessControlRuleOutputResponseBody: Swift.Equatable {
}

extension PutAccessControlRuleOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutMailboxPermissionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutMailboxPermissionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutMailboxPermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutMailboxPermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutMailboxPermissionsOutputError>
}

extension PutMailboxPermissionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutMailboxPermissionsInput(entityId: \(Swift.String(describing: entityId)), granteeId: \(Swift.String(describing: granteeId)), organizationId: \(Swift.String(describing: organizationId)), permissionValues: \(Swift.String(describing: permissionValues)))"}
}

extension PutMailboxPermissionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case granteeId = "GranteeId"
        case organizationId = "OrganizationId"
        case permissionValues = "PermissionValues"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let granteeId = granteeId {
            try encodeContainer.encode(granteeId, forKey: .granteeId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let permissionValues = permissionValues {
            var permissionValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissionValues)
            for permissionvalues0 in permissionValues {
                try permissionValuesContainer.encode(permissionvalues0.rawValue)
            }
        }
    }
}

public struct PutMailboxPermissionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutMailboxPermissionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutMailboxPermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutMailboxPermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutMailboxPermissionsOutputError>
}

public struct PutMailboxPermissionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutMailboxPermissionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutMailboxPermissionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutMailboxPermissionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutMailboxPermissionsOutputError>
}

public struct PutMailboxPermissionsInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutMailboxPermissionsInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutMailboxPermissionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutMailboxPermissionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutMailboxPermissionsOutputError>
}

public struct PutMailboxPermissionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutMailboxPermissionsInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutMailboxPermissionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutMailboxPermissionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutMailboxPermissionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutMailboxPermissionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutMailboxPermissionsOutputError>
}

public struct PutMailboxPermissionsInput: Swift.Equatable {
    /// The identifier of the user, group, or resource for which to update mailbox
    ///          permissions.
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier of the user, group, or resource to which to grant the
    ///          permissions.
    /// This member is required.
    public var granteeId: Swift.String?
    /// The identifier of the organization under which the user, group, or resource
    ///          exists.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The permissions granted to the grantee. SEND_AS allows the grantee to send email as
    ///          the owner of the mailbox (the grantee is not mentioned on these emails). SEND_ON_BEHALF
    ///          allows the grantee to send email on behalf of the owner of the mailbox (the grantee is not
    ///          mentioned as the physical sender of these emails). FULL_ACCESS allows the grantee full
    ///          access to the mailbox, irrespective of other folder-level permissions set on the
    ///          mailbox.
    /// This member is required.
    public var permissionValues: [WorkMailClientTypes.PermissionType]?

    public init (
        entityId: Swift.String? = nil,
        granteeId: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        permissionValues: [WorkMailClientTypes.PermissionType]? = nil
    )
    {
        self.entityId = entityId
        self.granteeId = granteeId
        self.organizationId = organizationId
        self.permissionValues = permissionValues
    }
}

struct PutMailboxPermissionsInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let entityId: Swift.String?
    public let granteeId: Swift.String?
    public let permissionValues: [WorkMailClientTypes.PermissionType]?
}

extension PutMailboxPermissionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityId = "EntityId"
        case granteeId = "GranteeId"
        case organizationId = "OrganizationId"
        case permissionValues = "PermissionValues"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let granteeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .granteeId)
        granteeId = granteeIdDecoded
        let permissionValuesContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.PermissionType?].self, forKey: .permissionValues)
        var permissionValuesDecoded0:[WorkMailClientTypes.PermissionType]? = nil
        if let permissionValuesContainer = permissionValuesContainer {
            permissionValuesDecoded0 = [WorkMailClientTypes.PermissionType]()
            for string0 in permissionValuesContainer {
                if let string0 = string0 {
                    permissionValuesDecoded0?.append(string0)
                }
            }
        }
        permissionValues = permissionValuesDecoded0
    }
}

extension PutMailboxPermissionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutMailboxPermissionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutMailboxPermissionsOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutMailboxPermissionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutMailboxPermissionsOutputResponse()"}
}

extension PutMailboxPermissionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutMailboxPermissionsOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutMailboxPermissionsOutputResponseBody: Swift.Equatable {
}

extension PutMailboxPermissionsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutMobileDeviceAccessOverrideInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutMobileDeviceAccessOverrideInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutMobileDeviceAccessOverrideInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutMobileDeviceAccessOverrideOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutMobileDeviceAccessOverrideInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutMobileDeviceAccessOverrideOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutMobileDeviceAccessOverrideOutputError>
}

extension PutMobileDeviceAccessOverrideInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutMobileDeviceAccessOverrideInput(description: \(Swift.String(describing: description)), deviceId: \(Swift.String(describing: deviceId)), effect: \(Swift.String(describing: effect)), organizationId: \(Swift.String(describing: organizationId)), userId: \(Swift.String(describing: userId)))"}
}

extension PutMobileDeviceAccessOverrideInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case deviceId = "DeviceId"
        case effect = "Effect"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let effect = effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct PutMobileDeviceAccessOverrideInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutMobileDeviceAccessOverrideInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutMobileDeviceAccessOverrideInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutMobileDeviceAccessOverrideOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutMobileDeviceAccessOverrideInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutMobileDeviceAccessOverrideOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutMobileDeviceAccessOverrideOutputError>
}

public struct PutMobileDeviceAccessOverrideInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutMobileDeviceAccessOverrideInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutMobileDeviceAccessOverrideInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutMobileDeviceAccessOverrideOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutMobileDeviceAccessOverrideInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutMobileDeviceAccessOverrideOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutMobileDeviceAccessOverrideOutputError>
}

public struct PutMobileDeviceAccessOverrideInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutMobileDeviceAccessOverrideInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutMobileDeviceAccessOverrideInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutMobileDeviceAccessOverrideOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutMobileDeviceAccessOverrideInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutMobileDeviceAccessOverrideOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutMobileDeviceAccessOverrideOutputError>
}

public struct PutMobileDeviceAccessOverrideInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutMobileDeviceAccessOverrideInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutMobileDeviceAccessOverrideInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutMobileDeviceAccessOverrideOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutMobileDeviceAccessOverrideInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutMobileDeviceAccessOverrideOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutMobileDeviceAccessOverrideOutputError>
}

public struct PutMobileDeviceAccessOverrideInput: Swift.Equatable {
    /// A description of the override.
    public var description: Swift.String?
    /// The mobile device for which you create the override. DeviceId is case insensitive.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The effect of the override, ALLOW or DENY.
    /// This member is required.
    public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    /// Identifies the Amazon WorkMail organization for which you create the override.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The WorkMail user for which you create the override. Accepts the following types of user identities:
    ///
    ///
    ///                User ID: 12345678-1234-1234-1234-123456789012 or S-1-1-12-1234567890-123456789-123456789-1234
    ///
    ///
    ///
    ///                Email address: user@domain.tld
    ///
    ///
    ///
    ///                User name: user
    ///
    ///
    ///
    /// This member is required.
    public var userId: Swift.String?

    public init (
        description: Swift.String? = nil,
        deviceId: Swift.String? = nil,
        effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.description = description
        self.deviceId = deviceId
        self.effect = effect
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct PutMobileDeviceAccessOverrideInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let userId: Swift.String?
    public let deviceId: Swift.String?
    public let effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    public let description: Swift.String?
}

extension PutMobileDeviceAccessOverrideInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case deviceId = "DeviceId"
        case effect = "Effect"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension PutMobileDeviceAccessOverrideOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutMobileDeviceAccessOverrideOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutMobileDeviceAccessOverrideOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutMobileDeviceAccessOverrideOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutMobileDeviceAccessOverrideOutputResponse()"}
}

extension PutMobileDeviceAccessOverrideOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutMobileDeviceAccessOverrideOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutMobileDeviceAccessOverrideOutputResponseBody: Swift.Equatable {
}

extension PutMobileDeviceAccessOverrideOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutRetentionPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRetentionPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRetentionPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRetentionPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRetentionPolicyOutputError>
}

extension PutRetentionPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRetentionPolicyInput(description: \(Swift.String(describing: description)), folderConfigurations: \(Swift.String(describing: folderConfigurations)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension PutRetentionPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case folderConfigurations = "FolderConfigurations"
        case id = "Id"
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let folderConfigurations = folderConfigurations {
            var folderConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .folderConfigurations)
            for folderconfigurations0 in folderConfigurations {
                try folderConfigurationsContainer.encode(folderconfigurations0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct PutRetentionPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRetentionPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRetentionPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRetentionPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRetentionPolicyOutputError>
}

public struct PutRetentionPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRetentionPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutRetentionPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutRetentionPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRetentionPolicyOutputError>
}

public struct PutRetentionPolicyInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRetentionPolicyInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: PutRetentionPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutRetentionPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRetentionPolicyOutputError>
}

public struct PutRetentionPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutRetentionPolicyInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: PutRetentionPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutRetentionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutRetentionPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutRetentionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutRetentionPolicyOutputError>
}

public struct PutRetentionPolicyInput: Swift.Equatable {
    /// The retention policy description.
    public var description: Swift.String?
    /// The retention policy folder configurations.
    /// This member is required.
    public var folderConfigurations: [WorkMailClientTypes.FolderConfiguration]?
    /// The retention policy ID.
    public var id: Swift.String?
    /// The retention policy name.
    /// This member is required.
    public var name: Swift.String?
    /// The organization ID.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        description: Swift.String? = nil,
        folderConfigurations: [WorkMailClientTypes.FolderConfiguration]? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.description = description
        self.folderConfigurations = folderConfigurations
        self.id = id
        self.name = name
        self.organizationId = organizationId
    }
}

struct PutRetentionPolicyInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let id: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let folderConfigurations: [WorkMailClientTypes.FolderConfiguration]?
}

extension PutRetentionPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case folderConfigurations = "FolderConfigurations"
        case id = "Id"
        case name = "Name"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let folderConfigurationsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.FolderConfiguration?].self, forKey: .folderConfigurations)
        var folderConfigurationsDecoded0:[WorkMailClientTypes.FolderConfiguration]? = nil
        if let folderConfigurationsContainer = folderConfigurationsContainer {
            folderConfigurationsDecoded0 = [WorkMailClientTypes.FolderConfiguration]()
            for structure0 in folderConfigurationsContainer {
                if let structure0 = structure0 {
                    folderConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        folderConfigurations = folderConfigurationsDecoded0
    }
}

extension PutRetentionPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRetentionPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRetentionPolicyOutputError: Swift.Error, Swift.Equatable {
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRetentionPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutRetentionPolicyOutputResponse()"}
}

extension PutRetentionPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutRetentionPolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutRetentionPolicyOutputResponseBody: Swift.Equatable {
}

extension PutRetentionPolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct RegisterToWorkMailInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterToWorkMailInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterToWorkMailInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterToWorkMailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterToWorkMailInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterToWorkMailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterToWorkMailOutputError>
}

extension RegisterToWorkMailInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterToWorkMailInput(email: \(Swift.String(describing: email)), entityId: \(Swift.String(describing: entityId)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension RegisterToWorkMailInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct RegisterToWorkMailInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterToWorkMailInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterToWorkMailInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterToWorkMailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterToWorkMailInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterToWorkMailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterToWorkMailOutputError>
}

public struct RegisterToWorkMailInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterToWorkMailInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterToWorkMailInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterToWorkMailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterToWorkMailInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterToWorkMailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterToWorkMailOutputError>
}

public struct RegisterToWorkMailInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterToWorkMailInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: RegisterToWorkMailInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterToWorkMailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterToWorkMailInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterToWorkMailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterToWorkMailOutputError>
}

public struct RegisterToWorkMailInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterToWorkMailInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: RegisterToWorkMailInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterToWorkMailOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RegisterToWorkMailInput
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterToWorkMailOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterToWorkMailOutputError>
}

public struct RegisterToWorkMailInput: Swift.Equatable {
    /// The email for the user, group, or resource to be updated.
    /// This member is required.
    public var email: Swift.String?
    /// The identifier for the user, group, or resource to be updated.
    /// This member is required.
    public var entityId: Swift.String?
    /// The identifier for the organization under which the user, group, or resource
    ///          exists.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        email: Swift.String? = nil,
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.email = email
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

struct RegisterToWorkMailInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let entityId: Swift.String?
    public let email: Swift.String?
}

extension RegisterToWorkMailInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
    }
}

extension RegisterToWorkMailOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterToWorkMailOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EmailAddressInUseException" : self = .emailAddressInUseException(try EmailAddressInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityAlreadyRegisteredException" : self = .entityAlreadyRegisteredException(try EntityAlreadyRegisteredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainNotFoundException" : self = .mailDomainNotFoundException(try MailDomainNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainStateException" : self = .mailDomainStateException(try MailDomainStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterToWorkMailOutputError: Swift.Error, Swift.Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case emailAddressInUseException(EmailAddressInUseException)
    case entityAlreadyRegisteredException(EntityAlreadyRegisteredException)
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case mailDomainNotFoundException(MailDomainNotFoundException)
    case mailDomainStateException(MailDomainStateException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterToWorkMailOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterToWorkMailOutputResponse()"}
}

extension RegisterToWorkMailOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RegisterToWorkMailOutputResponse: Swift.Equatable {

    public init() {}
}

struct RegisterToWorkMailOutputResponseBody: Swift.Equatable {
}

extension RegisterToWorkMailOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ReservedNameException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReservedNameException(message: \(Swift.String(describing: message)))"}
}

extension ReservedNameException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ReservedNameExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This user, group, or resource name is not allowed in Amazon WorkMail.
public struct ReservedNameException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ReservedNameExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ReservedNameExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ResetPasswordInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetPasswordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetPasswordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetPasswordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetPasswordOutputError>
}

extension ResetPasswordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetPasswordInput(organizationId: \(Swift.String(describing: organizationId)), password: \(Swift.String(describing: password)), userId: \(Swift.String(describing: userId)))"}
}

extension ResetPasswordInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case password = "Password"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct ResetPasswordInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetPasswordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetPasswordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetPasswordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetPasswordOutputError>
}

public struct ResetPasswordInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetPasswordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ResetPasswordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ResetPasswordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ResetPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetPasswordOutputError>
}

public struct ResetPasswordInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetPasswordInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: ResetPasswordInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ResetPasswordInput
    public typealias MOutput = ClientRuntime.OperationOutput<ResetPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetPasswordOutputError>
}

public struct ResetPasswordInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ResetPasswordInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: ResetPasswordInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ResetPasswordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ResetPasswordInput
    public typealias MOutput = ClientRuntime.OperationOutput<ResetPasswordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ResetPasswordOutputError>
}

public struct ResetPasswordInput: Swift.Equatable {
    /// The identifier of the organization that contains the user for which the password is
    ///          reset.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The new password for the user.
    /// This member is required.
    public var password: Swift.String?
    /// The identifier of the user for whom the password is reset.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        organizationId: Swift.String? = nil,
        password: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.organizationId = organizationId
        self.password = password
        self.userId = userId
    }
}

struct ResetPasswordInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let userId: Swift.String?
    public let password: Swift.String?
}

extension ResetPasswordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationId = "OrganizationId"
        case password = "Password"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension ResetPasswordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetPasswordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidPasswordException" : self = .invalidPasswordException(try InvalidPasswordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetPasswordOutputError: Swift.Error, Swift.Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case invalidPasswordException(InvalidPasswordException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetPasswordOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetPasswordOutputResponse()"}
}

extension ResetPasswordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ResetPasswordOutputResponse: Swift.Equatable {

    public init() {}
}

struct ResetPasswordOutputResponseBody: Swift.Equatable {
}

extension ResetPasswordOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension WorkMailClientTypes.Resource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabledDate = "DisabledDate"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case id = "Id"
        case name = "Name"
        case state = "State"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabledDate = disabledDate {
            try encodeContainer.encode(disabledDate.timeIntervalSince1970, forKey: .disabledDate)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let enabledDate = enabledDate {
            try encodeContainer.encode(enabledDate.timeIntervalSince1970, forKey: .enabledDate)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.ResourceType.self, forKey: .type)
        type = typeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
        let enabledDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

extension WorkMailClientTypes.Resource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Resource(disabledDate: \(Swift.String(describing: disabledDate)), email: \(Swift.String(describing: email)), enabledDate: \(Swift.String(describing: enabledDate)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)), type: \(Swift.String(describing: type)))"}
}

extension WorkMailClientTypes {
    /// The representation of a resource.
    public struct Resource: Swift.Equatable {
        /// The date indicating when the resource was disabled from Amazon WorkMail use.
        public var disabledDate: ClientRuntime.Date?
        /// The email of the resource.
        public var email: Swift.String?
        /// The date indicating when the resource was enabled for Amazon WorkMail use.
        public var enabledDate: ClientRuntime.Date?
        /// The identifier of the resource.
        public var id: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?
        /// The state of the resource, which can be ENABLED, DISABLED, or DELETED.
        public var state: WorkMailClientTypes.EntityState?
        /// The type of the resource: equipment or room.
        public var type: WorkMailClientTypes.ResourceType?

        public init (
            disabledDate: ClientRuntime.Date? = nil,
            email: Swift.String? = nil,
            enabledDate: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil,
            type: WorkMailClientTypes.ResourceType? = nil
        )
        {
            self.disabledDate = disabledDate
            self.email = email
            self.enabledDate = enabledDate
            self.id = id
            self.name = name
            self.state = state
            self.type = type
        }
    }

}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource cannot be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkMailClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equipment
        case room
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .equipment,
                .room,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equipment: return "EQUIPMENT"
            case .room: return "ROOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension WorkMailClientTypes {
    public enum RetentionAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delete
        case `none`
        case permanentlyDelete
        case sdkUnknown(Swift.String)

        public static var allCases: [RetentionAction] {
            return [
                .delete,
                .none,
                .permanentlyDelete,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delete: return "DELETE"
            case .none: return "NONE"
            case .permanentlyDelete: return "PERMANENTLY_DELETE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RetentionAction(rawValue: rawValue) ?? RetentionAction.sdkUnknown(rawValue)
        }
    }
}

public struct StartMailboxExportJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartMailboxExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartMailboxExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartMailboxExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartMailboxExportJobOutputError>
}

extension StartMailboxExportJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartMailboxExportJobInput(clientToken: \(Swift.String(describing: clientToken)), description: \(Swift.String(describing: description)), entityId: \(Swift.String(describing: entityId)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), organizationId: \(Swift.String(describing: organizationId)), roleArn: \(Swift.String(describing: roleArn)), s3BucketName: \(Swift.String(describing: s3BucketName)), s3Prefix: \(Swift.String(describing: s3Prefix)))"}
}

extension StartMailboxExportJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case entityId = "EntityId"
        case kmsKeyArn = "KmsKeyArn"
        case organizationId = "OrganizationId"
        case roleArn = "RoleArn"
        case s3BucketName = "S3BucketName"
        case s3Prefix = "S3Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let kmsKeyArn = kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3Prefix = s3Prefix {
            try encodeContainer.encode(s3Prefix, forKey: .s3Prefix)
        }
    }
}

public struct StartMailboxExportJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartMailboxExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartMailboxExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartMailboxExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartMailboxExportJobOutputError>
}

public struct StartMailboxExportJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartMailboxExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartMailboxExportJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartMailboxExportJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartMailboxExportJobOutputError>
}

public struct StartMailboxExportJobInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartMailboxExportJobInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: StartMailboxExportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartMailboxExportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartMailboxExportJobOutputError>
}

public struct StartMailboxExportJobInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartMailboxExportJobInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: StartMailboxExportJobInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartMailboxExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = StartMailboxExportJobInput
    public typealias MOutput = ClientRuntime.OperationOutput<StartMailboxExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartMailboxExportJobOutputError>
}

public struct StartMailboxExportJobInput: Swift.Equatable {
    /// The idempotency token for the client request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The mailbox export job description.
    public var description: Swift.String?
    /// The identifier of the user or resource associated with the mailbox.
    /// This member is required.
    public var entityId: Swift.String?
    /// The Amazon Resource Name (ARN) of the symmetric AWS Key Management Service (AWS KMS)
    ///          key that encrypts the exported mailbox content.
    /// This member is required.
    public var kmsKeyArn: Swift.String?
    /// The identifier associated with the organization.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The ARN of the AWS Identity and Access Management (IAM) role that grants write permission to the S3
    ///          bucket.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The name of the S3 bucket.
    /// This member is required.
    public var s3BucketName: Swift.String?
    /// The S3 bucket prefix.
    /// This member is required.
    public var s3Prefix: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        entityId: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        s3BucketName: Swift.String? = nil,
        s3Prefix: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.entityId = entityId
        self.kmsKeyArn = kmsKeyArn
        self.organizationId = organizationId
        self.roleArn = roleArn
        self.s3BucketName = s3BucketName
        self.s3Prefix = s3Prefix
    }
}

struct StartMailboxExportJobInputBody: Swift.Equatable {
    public let clientToken: Swift.String?
    public let organizationId: Swift.String?
    public let entityId: Swift.String?
    public let description: Swift.String?
    public let roleArn: Swift.String?
    public let kmsKeyArn: Swift.String?
    public let s3BucketName: Swift.String?
    public let s3Prefix: Swift.String?
}

extension StartMailboxExportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case description = "Description"
        case entityId = "EntityId"
        case kmsKeyArn = "KmsKeyArn"
        case organizationId = "OrganizationId"
        case roleArn = "RoleArn"
        case s3BucketName = "S3BucketName"
        case s3Prefix = "S3Prefix"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3PrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Prefix)
        s3Prefix = s3PrefixDecoded
    }
}

extension StartMailboxExportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartMailboxExportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartMailboxExportJobOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartMailboxExportJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartMailboxExportJobOutputResponse(jobId: \(Swift.String(describing: jobId)))"}
}

extension StartMailboxExportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartMailboxExportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartMailboxExportJobOutputResponse: Swift.Equatable {
    /// The job ID.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartMailboxExportJobOutputResponseBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension StartMailboxExportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId = "JobId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension WorkMailClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension WorkMailClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension WorkMailClientTypes {
    /// Describes a tag applied to a resource.
    public struct Tag: Swift.Equatable {
        /// The key of the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag key-value pairs.
    /// This member is required.
    public var tags: [WorkMailClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [WorkMailClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tags: [WorkMailClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([WorkMailClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[WorkMailClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [WorkMailClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case organizationStateException(OrganizationStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension TooManyTagsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyTagsException(message: \(Swift.String(describing: message)))"}
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource can have up to 50 user-applied tags.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedOperationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnsupportedOperationException(message: \(Swift.String(describing: message)))"}
}

extension UnsupportedOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnsupportedOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You can't perform a write operation against a read-only directory.
public struct UnsupportedOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedOperationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnsupportedOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceARN: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateMailboxQuotaInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMailboxQuotaInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMailboxQuotaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMailboxQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMailboxQuotaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMailboxQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMailboxQuotaOutputError>
}

extension UpdateMailboxQuotaInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMailboxQuotaInput(mailboxQuota: \(Swift.String(describing: mailboxQuota)), organizationId: \(Swift.String(describing: organizationId)), userId: \(Swift.String(describing: userId)))"}
}

extension UpdateMailboxQuotaInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mailboxQuota = "MailboxQuota"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mailboxQuota = mailboxQuota {
            try encodeContainer.encode(mailboxQuota, forKey: .mailboxQuota)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

public struct UpdateMailboxQuotaInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMailboxQuotaInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMailboxQuotaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMailboxQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMailboxQuotaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMailboxQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMailboxQuotaOutputError>
}

public struct UpdateMailboxQuotaInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMailboxQuotaInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMailboxQuotaInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMailboxQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMailboxQuotaInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMailboxQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMailboxQuotaOutputError>
}

public struct UpdateMailboxQuotaInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMailboxQuotaInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateMailboxQuotaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMailboxQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateMailboxQuotaInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMailboxQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMailboxQuotaOutputError>
}

public struct UpdateMailboxQuotaInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMailboxQuotaInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateMailboxQuotaInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMailboxQuotaOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateMailboxQuotaInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMailboxQuotaOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMailboxQuotaOutputError>
}

public struct UpdateMailboxQuotaInput: Swift.Equatable {
    /// The updated mailbox quota, in MB, for the specified user.
    /// This member is required.
    public var mailboxQuota: Swift.Int?
    /// The identifier for the organization that contains the user for whom to update the
    ///          mailbox quota.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifer for the user for whom to update the mailbox quota.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        mailboxQuota: Swift.Int? = nil,
        organizationId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.mailboxQuota = mailboxQuota
        self.organizationId = organizationId
        self.userId = userId
    }
}

struct UpdateMailboxQuotaInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let userId: Swift.String?
    public let mailboxQuota: Swift.Int?
}

extension UpdateMailboxQuotaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mailboxQuota = "MailboxQuota"
        case organizationId = "OrganizationId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let mailboxQuotaDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mailboxQuota)
        mailboxQuota = mailboxQuotaDecoded
    }
}

extension UpdateMailboxQuotaOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMailboxQuotaOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMailboxQuotaOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMailboxQuotaOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMailboxQuotaOutputResponse()"}
}

extension UpdateMailboxQuotaOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateMailboxQuotaOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateMailboxQuotaOutputResponseBody: Swift.Equatable {
}

extension UpdateMailboxQuotaOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateMobileDeviceAccessRuleInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMobileDeviceAccessRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMobileDeviceAccessRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMobileDeviceAccessRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMobileDeviceAccessRuleOutputError>
}

extension UpdateMobileDeviceAccessRuleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMobileDeviceAccessRuleInput(description: \(Swift.String(describing: description)), deviceModels: \(Swift.String(describing: deviceModels)), deviceOperatingSystems: \(Swift.String(describing: deviceOperatingSystems)), deviceTypes: \(Swift.String(describing: deviceTypes)), deviceUserAgents: \(Swift.String(describing: deviceUserAgents)), effect: \(Swift.String(describing: effect)), mobileDeviceAccessRuleId: \(Swift.String(describing: mobileDeviceAccessRuleId)), name: \(Swift.String(describing: name)), notDeviceModels: \(Swift.String(describing: notDeviceModels)), notDeviceOperatingSystems: \(Swift.String(describing: notDeviceOperatingSystems)), notDeviceTypes: \(Swift.String(describing: notDeviceTypes)), notDeviceUserAgents: \(Swift.String(describing: notDeviceUserAgents)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension UpdateMobileDeviceAccessRuleInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case deviceModels = "DeviceModels"
        case deviceOperatingSystems = "DeviceOperatingSystems"
        case deviceTypes = "DeviceTypes"
        case deviceUserAgents = "DeviceUserAgents"
        case effect = "Effect"
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case name = "Name"
        case notDeviceModels = "NotDeviceModels"
        case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
        case notDeviceTypes = "NotDeviceTypes"
        case notDeviceUserAgents = "NotDeviceUserAgents"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceModels = deviceModels {
            var deviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceModels)
            for devicemodellist0 in deviceModels {
                try deviceModelsContainer.encode(devicemodellist0)
            }
        }
        if let deviceOperatingSystems = deviceOperatingSystems {
            var deviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceOperatingSystems)
            for deviceoperatingsystemlist0 in deviceOperatingSystems {
                try deviceOperatingSystemsContainer.encode(deviceoperatingsystemlist0)
            }
        }
        if let deviceTypes = deviceTypes {
            var deviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceTypes)
            for devicetypelist0 in deviceTypes {
                try deviceTypesContainer.encode(devicetypelist0)
            }
        }
        if let deviceUserAgents = deviceUserAgents {
            var deviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceUserAgents)
            for deviceuseragentlist0 in deviceUserAgents {
                try deviceUserAgentsContainer.encode(deviceuseragentlist0)
            }
        }
        if let effect = effect {
            try encodeContainer.encode(effect.rawValue, forKey: .effect)
        }
        if let mobileDeviceAccessRuleId = mobileDeviceAccessRuleId {
            try encodeContainer.encode(mobileDeviceAccessRuleId, forKey: .mobileDeviceAccessRuleId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notDeviceModels = notDeviceModels {
            var notDeviceModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceModels)
            for devicemodellist0 in notDeviceModels {
                try notDeviceModelsContainer.encode(devicemodellist0)
            }
        }
        if let notDeviceOperatingSystems = notDeviceOperatingSystems {
            var notDeviceOperatingSystemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceOperatingSystems)
            for deviceoperatingsystemlist0 in notDeviceOperatingSystems {
                try notDeviceOperatingSystemsContainer.encode(deviceoperatingsystemlist0)
            }
        }
        if let notDeviceTypes = notDeviceTypes {
            var notDeviceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceTypes)
            for devicetypelist0 in notDeviceTypes {
                try notDeviceTypesContainer.encode(devicetypelist0)
            }
        }
        if let notDeviceUserAgents = notDeviceUserAgents {
            var notDeviceUserAgentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notDeviceUserAgents)
            for deviceuseragentlist0 in notDeviceUserAgents {
                try notDeviceUserAgentsContainer.encode(deviceuseragentlist0)
            }
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct UpdateMobileDeviceAccessRuleInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMobileDeviceAccessRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMobileDeviceAccessRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMobileDeviceAccessRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMobileDeviceAccessRuleOutputError>
}

public struct UpdateMobileDeviceAccessRuleInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMobileDeviceAccessRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateMobileDeviceAccessRuleInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateMobileDeviceAccessRuleInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMobileDeviceAccessRuleOutputError>
}

public struct UpdateMobileDeviceAccessRuleInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMobileDeviceAccessRuleInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateMobileDeviceAccessRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateMobileDeviceAccessRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMobileDeviceAccessRuleOutputError>
}

public struct UpdateMobileDeviceAccessRuleInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateMobileDeviceAccessRuleInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateMobileDeviceAccessRuleInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateMobileDeviceAccessRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateMobileDeviceAccessRuleInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateMobileDeviceAccessRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateMobileDeviceAccessRuleOutputError>
}

public struct UpdateMobileDeviceAccessRuleInput: Swift.Equatable {
    /// The updated rule description.
    public var description: Swift.String?
    /// Device models that the updated rule will match.
    public var deviceModels: [Swift.String]?
    /// Device operating systems that the updated rule will match.
    public var deviceOperatingSystems: [Swift.String]?
    /// Device types that the updated rule will match.
    public var deviceTypes: [Swift.String]?
    /// User agents that the updated rule will match.
    public var deviceUserAgents: [Swift.String]?
    /// The effect of the rule when it matches. Allowed values are ALLOW or DENY.
    /// This member is required.
    public var effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    /// The identifier of the rule to be updated.
    /// This member is required.
    public var mobileDeviceAccessRuleId: Swift.String?
    /// The updated rule name.
    /// This member is required.
    public var name: Swift.String?
    /// Device models that the updated rule will not match. All other device models will match.
    public var notDeviceModels: [Swift.String]?
    /// Device operating systems that the updated rule will not match. All other device operating systems will match.
    public var notDeviceOperatingSystems: [Swift.String]?
    /// Device types that the updated rule will not match. All other device types will match.
    public var notDeviceTypes: [Swift.String]?
    /// User agents that the updated rule will not match. All other user agents will match.
    public var notDeviceUserAgents: [Swift.String]?
    /// The Amazon WorkMail organization under which the rule will be updated.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        description: Swift.String? = nil,
        deviceModels: [Swift.String]? = nil,
        deviceOperatingSystems: [Swift.String]? = nil,
        deviceTypes: [Swift.String]? = nil,
        deviceUserAgents: [Swift.String]? = nil,
        effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect? = nil,
        mobileDeviceAccessRuleId: Swift.String? = nil,
        name: Swift.String? = nil,
        notDeviceModels: [Swift.String]? = nil,
        notDeviceOperatingSystems: [Swift.String]? = nil,
        notDeviceTypes: [Swift.String]? = nil,
        notDeviceUserAgents: [Swift.String]? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.description = description
        self.deviceModels = deviceModels
        self.deviceOperatingSystems = deviceOperatingSystems
        self.deviceTypes = deviceTypes
        self.deviceUserAgents = deviceUserAgents
        self.effect = effect
        self.mobileDeviceAccessRuleId = mobileDeviceAccessRuleId
        self.name = name
        self.notDeviceModels = notDeviceModels
        self.notDeviceOperatingSystems = notDeviceOperatingSystems
        self.notDeviceTypes = notDeviceTypes
        self.notDeviceUserAgents = notDeviceUserAgents
        self.organizationId = organizationId
    }
}

struct UpdateMobileDeviceAccessRuleInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let mobileDeviceAccessRuleId: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let effect: WorkMailClientTypes.MobileDeviceAccessRuleEffect?
    public let deviceTypes: [Swift.String]?
    public let notDeviceTypes: [Swift.String]?
    public let deviceModels: [Swift.String]?
    public let notDeviceModels: [Swift.String]?
    public let deviceOperatingSystems: [Swift.String]?
    public let notDeviceOperatingSystems: [Swift.String]?
    public let deviceUserAgents: [Swift.String]?
    public let notDeviceUserAgents: [Swift.String]?
}

extension UpdateMobileDeviceAccessRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case deviceModels = "DeviceModels"
        case deviceOperatingSystems = "DeviceOperatingSystems"
        case deviceTypes = "DeviceTypes"
        case deviceUserAgents = "DeviceUserAgents"
        case effect = "Effect"
        case mobileDeviceAccessRuleId = "MobileDeviceAccessRuleId"
        case name = "Name"
        case notDeviceModels = "NotDeviceModels"
        case notDeviceOperatingSystems = "NotDeviceOperatingSystems"
        case notDeviceTypes = "NotDeviceTypes"
        case notDeviceUserAgents = "NotDeviceUserAgents"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let mobileDeviceAccessRuleIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mobileDeviceAccessRuleId)
        mobileDeviceAccessRuleId = mobileDeviceAccessRuleIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let effectDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.MobileDeviceAccessRuleEffect.self, forKey: .effect)
        effect = effectDecoded
        let deviceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceTypes)
        var deviceTypesDecoded0:[Swift.String]? = nil
        if let deviceTypesContainer = deviceTypesContainer {
            deviceTypesDecoded0 = [Swift.String]()
            for string0 in deviceTypesContainer {
                if let string0 = string0 {
                    deviceTypesDecoded0?.append(string0)
                }
            }
        }
        deviceTypes = deviceTypesDecoded0
        let notDeviceTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceTypes)
        var notDeviceTypesDecoded0:[Swift.String]? = nil
        if let notDeviceTypesContainer = notDeviceTypesContainer {
            notDeviceTypesDecoded0 = [Swift.String]()
            for string0 in notDeviceTypesContainer {
                if let string0 = string0 {
                    notDeviceTypesDecoded0?.append(string0)
                }
            }
        }
        notDeviceTypes = notDeviceTypesDecoded0
        let deviceModelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceModels)
        var deviceModelsDecoded0:[Swift.String]? = nil
        if let deviceModelsContainer = deviceModelsContainer {
            deviceModelsDecoded0 = [Swift.String]()
            for string0 in deviceModelsContainer {
                if let string0 = string0 {
                    deviceModelsDecoded0?.append(string0)
                }
            }
        }
        deviceModels = deviceModelsDecoded0
        let notDeviceModelsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceModels)
        var notDeviceModelsDecoded0:[Swift.String]? = nil
        if let notDeviceModelsContainer = notDeviceModelsContainer {
            notDeviceModelsDecoded0 = [Swift.String]()
            for string0 in notDeviceModelsContainer {
                if let string0 = string0 {
                    notDeviceModelsDecoded0?.append(string0)
                }
            }
        }
        notDeviceModels = notDeviceModelsDecoded0
        let deviceOperatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceOperatingSystems)
        var deviceOperatingSystemsDecoded0:[Swift.String]? = nil
        if let deviceOperatingSystemsContainer = deviceOperatingSystemsContainer {
            deviceOperatingSystemsDecoded0 = [Swift.String]()
            for string0 in deviceOperatingSystemsContainer {
                if let string0 = string0 {
                    deviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        deviceOperatingSystems = deviceOperatingSystemsDecoded0
        let notDeviceOperatingSystemsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceOperatingSystems)
        var notDeviceOperatingSystemsDecoded0:[Swift.String]? = nil
        if let notDeviceOperatingSystemsContainer = notDeviceOperatingSystemsContainer {
            notDeviceOperatingSystemsDecoded0 = [Swift.String]()
            for string0 in notDeviceOperatingSystemsContainer {
                if let string0 = string0 {
                    notDeviceOperatingSystemsDecoded0?.append(string0)
                }
            }
        }
        notDeviceOperatingSystems = notDeviceOperatingSystemsDecoded0
        let deviceUserAgentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .deviceUserAgents)
        var deviceUserAgentsDecoded0:[Swift.String]? = nil
        if let deviceUserAgentsContainer = deviceUserAgentsContainer {
            deviceUserAgentsDecoded0 = [Swift.String]()
            for string0 in deviceUserAgentsContainer {
                if let string0 = string0 {
                    deviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        deviceUserAgents = deviceUserAgentsDecoded0
        let notDeviceUserAgentsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notDeviceUserAgents)
        var notDeviceUserAgentsDecoded0:[Swift.String]? = nil
        if let notDeviceUserAgentsContainer = notDeviceUserAgentsContainer {
            notDeviceUserAgentsDecoded0 = [Swift.String]()
            for string0 in notDeviceUserAgentsContainer {
                if let string0 = string0 {
                    notDeviceUserAgentsDecoded0?.append(string0)
                }
            }
        }
        notDeviceUserAgents = notDeviceUserAgentsDecoded0
    }
}

extension UpdateMobileDeviceAccessRuleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMobileDeviceAccessRuleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMobileDeviceAccessRuleOutputError: Swift.Error, Swift.Equatable {
    case entityNotFoundException(EntityNotFoundException)
    case invalidParameterException(InvalidParameterException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMobileDeviceAccessRuleOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateMobileDeviceAccessRuleOutputResponse()"}
}

extension UpdateMobileDeviceAccessRuleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateMobileDeviceAccessRuleOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateMobileDeviceAccessRuleOutputResponseBody: Swift.Equatable {
}

extension UpdateMobileDeviceAccessRuleOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdatePrimaryEmailAddressInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePrimaryEmailAddressInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePrimaryEmailAddressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePrimaryEmailAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePrimaryEmailAddressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePrimaryEmailAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePrimaryEmailAddressOutputError>
}

extension UpdatePrimaryEmailAddressInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePrimaryEmailAddressInput(email: \(Swift.String(describing: email)), entityId: \(Swift.String(describing: entityId)), organizationId: \(Swift.String(describing: organizationId)))"}
}

extension UpdatePrimaryEmailAddressInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
    }
}

public struct UpdatePrimaryEmailAddressInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePrimaryEmailAddressInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePrimaryEmailAddressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePrimaryEmailAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePrimaryEmailAddressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePrimaryEmailAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePrimaryEmailAddressOutputError>
}

public struct UpdatePrimaryEmailAddressInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePrimaryEmailAddressInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePrimaryEmailAddressInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePrimaryEmailAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePrimaryEmailAddressInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePrimaryEmailAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePrimaryEmailAddressOutputError>
}

public struct UpdatePrimaryEmailAddressInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePrimaryEmailAddressInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdatePrimaryEmailAddressInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePrimaryEmailAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdatePrimaryEmailAddressInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePrimaryEmailAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePrimaryEmailAddressOutputError>
}

public struct UpdatePrimaryEmailAddressInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePrimaryEmailAddressInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdatePrimaryEmailAddressInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePrimaryEmailAddressOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdatePrimaryEmailAddressInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePrimaryEmailAddressOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePrimaryEmailAddressOutputError>
}

public struct UpdatePrimaryEmailAddressInput: Swift.Equatable {
    /// The value of the email to be updated as primary.
    /// This member is required.
    public var email: Swift.String?
    /// The user, group, or resource to update.
    /// This member is required.
    public var entityId: Swift.String?
    /// The organization that contains the user, group, or resource to update.
    /// This member is required.
    public var organizationId: Swift.String?

    public init (
        email: Swift.String? = nil,
        entityId: Swift.String? = nil,
        organizationId: Swift.String? = nil
    )
    {
        self.email = email
        self.entityId = entityId
        self.organizationId = organizationId
    }
}

struct UpdatePrimaryEmailAddressInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let entityId: Swift.String?
    public let email: Swift.String?
}

extension UpdatePrimaryEmailAddressInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case entityId = "EntityId"
        case organizationId = "OrganizationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
    }
}

extension UpdatePrimaryEmailAddressOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePrimaryEmailAddressOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryServiceAuthenticationFailedException" : self = .directoryServiceAuthenticationFailedException(try DirectoryServiceAuthenticationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EmailAddressInUseException" : self = .emailAddressInUseException(try EmailAddressInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainNotFoundException" : self = .mailDomainNotFoundException(try MailDomainNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainStateException" : self = .mailDomainStateException(try MailDomainStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedOperationException" : self = .unsupportedOperationException(try UnsupportedOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePrimaryEmailAddressOutputError: Swift.Error, Swift.Equatable {
    case directoryServiceAuthenticationFailedException(DirectoryServiceAuthenticationFailedException)
    case directoryUnavailableException(DirectoryUnavailableException)
    case emailAddressInUseException(EmailAddressInUseException)
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidParameterException(InvalidParameterException)
    case mailDomainNotFoundException(MailDomainNotFoundException)
    case mailDomainStateException(MailDomainStateException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unsupportedOperationException(UnsupportedOperationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePrimaryEmailAddressOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePrimaryEmailAddressOutputResponse()"}
}

extension UpdatePrimaryEmailAddressOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePrimaryEmailAddressOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdatePrimaryEmailAddressOutputResponseBody: Swift.Equatable {
}

extension UpdatePrimaryEmailAddressOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResourceOutputError>
}

extension UpdateResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateResourceInput(bookingOptions: \(Swift.String(describing: bookingOptions)), name: \(Swift.String(describing: name)), organizationId: \(Swift.String(describing: organizationId)), resourceId: \(Swift.String(describing: resourceId)))"}
}

extension UpdateResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bookingOptions = "BookingOptions"
        case name = "Name"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bookingOptions = bookingOptions {
            try encodeContainer.encode(bookingOptions, forKey: .bookingOptions)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct UpdateResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResourceOutputError>
}

public struct UpdateResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResourceOutputError>
}

public struct UpdateResourceInputURLHostMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourceInputURLHostMiddleware"

    let host: Swift.String?

    public init(host: Swift.String? = nil) {
        self.host = host
    }

    public func handle<H>(context: Context,
                  input: UpdateResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var copiedContext = context
        if let host = host {
            copiedContext.attributes.set(key: AttributeKey<String>(name: "Host"), value: host)
        }
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResourceOutputError>
}

public struct UpdateResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateResourceInputURLPathMiddleware"

    let urlPrefix: Swift.String?

    public init(urlPrefix: Swift.String? = nil) {
        self.urlPrefix = urlPrefix
    }

    public func handle<H>(context: Context,
                  input: UpdateResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let urlPrefix = urlPrefix, !urlPrefix.isEmpty {
            urlPath = "\(urlPrefix)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateResourceOutputError>
}

public struct UpdateResourceInput: Swift.Equatable {
    /// The resource's booking options to be updated.
    public var bookingOptions: WorkMailClientTypes.BookingOptions?
    /// The name of the resource to be updated.
    public var name: Swift.String?
    /// The identifier associated with the organization for which the resource is
    ///          updated.
    /// This member is required.
    public var organizationId: Swift.String?
    /// The identifier of the resource to be updated.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        bookingOptions: WorkMailClientTypes.BookingOptions? = nil,
        name: Swift.String? = nil,
        organizationId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.bookingOptions = bookingOptions
        self.name = name
        self.organizationId = organizationId
        self.resourceId = resourceId
    }
}

struct UpdateResourceInputBody: Swift.Equatable {
    public let organizationId: Swift.String?
    public let resourceId: Swift.String?
    public let name: Swift.String?
    public let bookingOptions: WorkMailClientTypes.BookingOptions?
}

extension UpdateResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bookingOptions = "BookingOptions"
        case name = "Name"
        case organizationId = "OrganizationId"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let bookingOptionsDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.BookingOptions.self, forKey: .bookingOptions)
        bookingOptions = bookingOptionsDecoded
    }
}

extension UpdateResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DirectoryUnavailableException" : self = .directoryUnavailableException(try DirectoryUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EmailAddressInUseException" : self = .emailAddressInUseException(try EmailAddressInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityNotFoundException" : self = .entityNotFoundException(try EntityNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EntityStateException" : self = .entityStateException(try EntityStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidConfigurationException" : self = .invalidConfigurationException(try InvalidConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainNotFoundException" : self = .mailDomainNotFoundException(try MailDomainNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MailDomainStateException" : self = .mailDomainStateException(try MailDomainStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameAvailabilityException" : self = .nameAvailabilityException(try NameAvailabilityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationNotFoundException" : self = .organizationNotFoundException(try OrganizationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OrganizationStateException" : self = .organizationStateException(try OrganizationStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResourceOutputError: Swift.Error, Swift.Equatable {
    case directoryUnavailableException(DirectoryUnavailableException)
    case emailAddressInUseException(EmailAddressInUseException)
    case entityNotFoundException(EntityNotFoundException)
    case entityStateException(EntityStateException)
    case invalidConfigurationException(InvalidConfigurationException)
    case mailDomainNotFoundException(MailDomainNotFoundException)
    case mailDomainStateException(MailDomainStateException)
    case nameAvailabilityException(NameAvailabilityException)
    case organizationNotFoundException(OrganizationNotFoundException)
    case organizationStateException(OrganizationStateException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateResourceOutputResponse()"}
}

extension UpdateResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateResourceOutputResponseBody: Swift.Equatable {
}

extension UpdateResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension WorkMailClientTypes.User: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabledDate = "DisabledDate"
        case displayName = "DisplayName"
        case email = "Email"
        case enabledDate = "EnabledDate"
        case id = "Id"
        case name = "Name"
        case state = "State"
        case userRole = "UserRole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabledDate = disabledDate {
            try encodeContainer.encode(disabledDate.timeIntervalSince1970, forKey: .disabledDate)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let enabledDate = enabledDate {
            try encodeContainer.encode(enabledDate.timeIntervalSince1970, forKey: .enabledDate)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let userRole = userRole {
            try encodeContainer.encode(userRole.rawValue, forKey: .userRole)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.EntityState.self, forKey: .state)
        state = stateDecoded
        let userRoleDecoded = try containerValues.decodeIfPresent(WorkMailClientTypes.UserRole.self, forKey: .userRole)
        userRole = userRoleDecoded
        let enabledDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .enabledDate)
        enabledDate = enabledDateDecoded
        let disabledDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .disabledDate)
        disabledDate = disabledDateDecoded
    }
}

extension WorkMailClientTypes.User: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "User(disabledDate: \(Swift.String(describing: disabledDate)), displayName: \(Swift.String(describing: displayName)), email: \(Swift.String(describing: email)), enabledDate: \(Swift.String(describing: enabledDate)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), state: \(Swift.String(describing: state)), userRole: \(Swift.String(describing: userRole)))"}
}

extension WorkMailClientTypes {
    /// The representation of an Amazon WorkMail user.
    public struct User: Swift.Equatable {
        /// The date indicating when the user was disabled from Amazon WorkMail use.
        public var disabledDate: ClientRuntime.Date?
        /// The display name of the user.
        public var displayName: Swift.String?
        /// The email of the user.
        public var email: Swift.String?
        /// The date indicating when the user was enabled for Amazon WorkMail use.
        public var enabledDate: ClientRuntime.Date?
        /// The identifier of the user.
        public var id: Swift.String?
        /// The name of the user.
        public var name: Swift.String?
        /// The state of the user, which can be ENABLED, DISABLED, or DELETED.
        public var state: WorkMailClientTypes.EntityState?
        /// The role of the user.
        public var userRole: WorkMailClientTypes.UserRole?

        public init (
            disabledDate: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            email: Swift.String? = nil,
            enabledDate: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            state: WorkMailClientTypes.EntityState? = nil,
            userRole: WorkMailClientTypes.UserRole? = nil
        )
        {
            self.disabledDate = disabledDate
            self.displayName = displayName
            self.email = email
            self.enabledDate = enabledDate
            self.id = id
            self.name = name
            self.state = state
            self.userRole = userRole
        }
    }

}

extension WorkMailClientTypes {
    public enum UserRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case resource
        case systemUser
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [UserRole] {
            return [
                .resource,
                .systemUser,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .resource: return "RESOURCE"
            case .systemUser: return "SYSTEM_USER"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserRole(rawValue: rawValue) ?? UserRole.sdkUnknown(rawValue)
        }
    }
}
