// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Sends Conflict Exception.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Sends Conflict Exception message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateSuiteDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "CreateSuiteDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSuiteDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSuiteDefinitionInput>
    public typealias MOutput = OperationOutput<CreateSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSuiteDefinitionOutputError>
}

extension CreateSuiteDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSuiteDefinitionInput(suiteDefinitionConfiguration: \(String(describing: suiteDefinitionConfiguration)), tags: \(String(describing: tags)))"}
}

extension CreateSuiteDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case suiteDefinitionConfiguration
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let suiteDefinitionConfiguration = suiteDefinitionConfiguration {
            try encodeContainer.encode(suiteDefinitionConfiguration, forKey: .suiteDefinitionConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateSuiteDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSuiteDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSuiteDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSuiteDefinitionInput>
    public typealias MOutput = OperationOutput<CreateSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSuiteDefinitionOutputError>
}

public struct CreateSuiteDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSuiteDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSuiteDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSuiteDefinitionInput>
    public typealias MOutput = OperationOutput<CreateSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSuiteDefinitionOutputError>
}

public struct CreateSuiteDefinitionInput: Equatable {
    /// <p>Creates a Device Advisor test suite with suite definition configuration.</p>
    public let suiteDefinitionConfiguration: SuiteDefinitionConfiguration?
    /// <p>The tags to be attached to the suite definition.</p>
    public let tags: [String:String]?

    public init (
        suiteDefinitionConfiguration: SuiteDefinitionConfiguration? = nil,
        tags: [String:String]? = nil
    )
    {
        self.suiteDefinitionConfiguration = suiteDefinitionConfiguration
        self.tags = tags
    }
}

struct CreateSuiteDefinitionInputBody: Equatable {
    public let suiteDefinitionConfiguration: SuiteDefinitionConfiguration?
    public let tags: [String:String]?
}

extension CreateSuiteDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case suiteDefinitionConfiguration
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionConfigurationDecoded = try containerValues.decodeIfPresent(SuiteDefinitionConfiguration.self, forKey: .suiteDefinitionConfiguration)
        suiteDefinitionConfiguration = suiteDefinitionConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSuiteDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSuiteDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSuiteDefinitionOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSuiteDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSuiteDefinitionOutputResponse(createdAt: \(String(describing: createdAt)), suiteDefinitionArn: \(String(describing: suiteDefinitionArn)), suiteDefinitionId: \(String(describing: suiteDefinitionId)), suiteDefinitionName: \(String(describing: suiteDefinitionName)))"}
}

extension CreateSuiteDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSuiteDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdAt = output.createdAt
            self.suiteDefinitionArn = output.suiteDefinitionArn
            self.suiteDefinitionId = output.suiteDefinitionId
            self.suiteDefinitionName = output.suiteDefinitionName
        } else {
            self.createdAt = nil
            self.suiteDefinitionArn = nil
            self.suiteDefinitionId = nil
            self.suiteDefinitionName = nil
        }
    }
}

public struct CreateSuiteDefinitionOutputResponse: Equatable {
    /// <p>Creates a Device Advisor test suite with TimeStamp of when it was created.</p>
    public let createdAt: Date?
    /// <p>Creates a Device Advisor test suite with Amazon Resource name.</p>
    public let suiteDefinitionArn: String?
    /// <p>Creates a Device Advisor test suite with suite UUID.</p>
    public let suiteDefinitionId: String?
    /// <p>Creates a Device Advisor test suite with suite definition name.</p>
    public let suiteDefinitionName: String?

    public init (
        createdAt: Date? = nil,
        suiteDefinitionArn: String? = nil,
        suiteDefinitionId: String? = nil,
        suiteDefinitionName: String? = nil
    )
    {
        self.createdAt = createdAt
        self.suiteDefinitionArn = suiteDefinitionArn
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionName = suiteDefinitionName
    }
}

struct CreateSuiteDefinitionOutputResponseBody: Equatable {
    public let suiteDefinitionId: String?
    public let suiteDefinitionArn: String?
    public let suiteDefinitionName: String?
    public let createdAt: Date?
}

extension CreateSuiteDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case suiteDefinitionArn
        case suiteDefinitionId
        case suiteDefinitionName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteDefinitionArn)
        suiteDefinitionArn = suiteDefinitionArnDecoded
        let suiteDefinitionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteDefinitionName)
        suiteDefinitionName = suiteDefinitionNameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension DeleteSuiteDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSuiteDefinitionInput(suiteDefinitionId: \(String(describing: suiteDefinitionId)))"}
}

extension DeleteSuiteDefinitionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteSuiteDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSuiteDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSuiteDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSuiteDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSuiteDefinitionOutputError>
}

public struct DeleteSuiteDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSuiteDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSuiteDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSuiteDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSuiteDefinitionOutputError>
}

public struct DeleteSuiteDefinitionInput: Equatable {
    /// <p>Suite definition Id of the test suite to be deleted.</p>
    public let suiteDefinitionId: String?

    public init (
        suiteDefinitionId: String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
    }
}

struct DeleteSuiteDefinitionInputBody: Equatable {
}

extension DeleteSuiteDefinitionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSuiteDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSuiteDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSuiteDefinitionOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSuiteDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSuiteDefinitionOutputResponse()"}
}

extension DeleteSuiteDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSuiteDefinitionOutputResponse: Equatable {

    public init() {}
}

struct DeleteSuiteDefinitionOutputResponseBody: Equatable {
}

extension DeleteSuiteDefinitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeviceUnderTest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn
        case thingArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let thingArn = thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension DeviceUnderTest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceUnderTest(certificateArn: \(String(describing: certificateArn)), thingArn: \(String(describing: thingArn)))"}
}

/// <p>Lists all the devices under test</p>
public struct DeviceUnderTest: Equatable {
    /// <p>Lists devices certificate arn</p>
    public let certificateArn: String?
    /// <p>Lists devices thing arn</p>
    public let thingArn: String?

    public init (
        certificateArn: String? = nil,
        thingArn: String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.thingArn = thingArn
    }
}

extension GetSuiteDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSuiteDefinitionInput(suiteDefinitionId: \(String(describing: suiteDefinitionId)), suiteDefinitionVersion: \(String(describing: suiteDefinitionVersion)))"}
}

extension GetSuiteDefinitionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSuiteDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "GetSuiteDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSuiteDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSuiteDefinitionInput>
    public typealias MOutput = OperationOutput<GetSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSuiteDefinitionOutputError>
}

public struct GetSuiteDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSuiteDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSuiteDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let suiteDefinitionVersion = input.operationInput.suiteDefinitionVersion {
            let suiteDefinitionVersionQueryItem = URLQueryItem(name: "suiteDefinitionVersion".urlPercentEncoding(), value: String(suiteDefinitionVersion).urlPercentEncoding())
            input.builder.withQueryItem(suiteDefinitionVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSuiteDefinitionInput>
    public typealias MOutput = OperationOutput<GetSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSuiteDefinitionOutputError>
}

public struct GetSuiteDefinitionInput: Equatable {
    /// <p>Suite definition Id of the test suite to get.</p>
    public let suiteDefinitionId: String?
    /// <p>Suite definition version of the test suite to get.</p>
    public let suiteDefinitionVersion: String?

    public init (
        suiteDefinitionId: String? = nil,
        suiteDefinitionVersion: String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
    }
}

struct GetSuiteDefinitionInputBody: Equatable {
}

extension GetSuiteDefinitionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSuiteDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSuiteDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSuiteDefinitionOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSuiteDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSuiteDefinitionOutputResponse(createdAt: \(String(describing: createdAt)), lastModifiedAt: \(String(describing: lastModifiedAt)), latestVersion: \(String(describing: latestVersion)), suiteDefinitionArn: \(String(describing: suiteDefinitionArn)), suiteDefinitionConfiguration: \(String(describing: suiteDefinitionConfiguration)), suiteDefinitionId: \(String(describing: suiteDefinitionId)), suiteDefinitionVersion: \(String(describing: suiteDefinitionVersion)), tags: \(String(describing: tags)))"}
}

extension GetSuiteDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSuiteDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdAt = output.createdAt
            self.lastModifiedAt = output.lastModifiedAt
            self.latestVersion = output.latestVersion
            self.suiteDefinitionArn = output.suiteDefinitionArn
            self.suiteDefinitionConfiguration = output.suiteDefinitionConfiguration
            self.suiteDefinitionId = output.suiteDefinitionId
            self.suiteDefinitionVersion = output.suiteDefinitionVersion
            self.tags = output.tags
        } else {
            self.createdAt = nil
            self.lastModifiedAt = nil
            self.latestVersion = nil
            self.suiteDefinitionArn = nil
            self.suiteDefinitionConfiguration = nil
            self.suiteDefinitionId = nil
            self.suiteDefinitionVersion = nil
            self.tags = nil
        }
    }
}

public struct GetSuiteDefinitionOutputResponse: Equatable {
    /// <p>Date (in Unix epoch time) when the suite definition was created.</p>
    public let createdAt: Date?
    /// <p>Date (in Unix epoch time) when the suite definition was last modified.</p>
    public let lastModifiedAt: Date?
    /// <p>Latest suite definition version of the suite definition.</p>
    public let latestVersion: String?
    /// <p>The ARN of the suite definition.</p>
    public let suiteDefinitionArn: String?
    /// <p>Suite configuration of the suite definition.</p>
    public let suiteDefinitionConfiguration: SuiteDefinitionConfiguration?
    /// <p>Suite definition Id of the suite definition.</p>
    public let suiteDefinitionId: String?
    /// <p>Suite definition version of the suite definition.</p>
    public let suiteDefinitionVersion: String?
    /// <p>Tags attached to the suite definition.</p>
    public let tags: [String:String]?

    public init (
        createdAt: Date? = nil,
        lastModifiedAt: Date? = nil,
        latestVersion: String? = nil,
        suiteDefinitionArn: String? = nil,
        suiteDefinitionConfiguration: SuiteDefinitionConfiguration? = nil,
        suiteDefinitionId: String? = nil,
        suiteDefinitionVersion: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.createdAt = createdAt
        self.lastModifiedAt = lastModifiedAt
        self.latestVersion = latestVersion
        self.suiteDefinitionArn = suiteDefinitionArn
        self.suiteDefinitionConfiguration = suiteDefinitionConfiguration
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
        self.tags = tags
    }
}

struct GetSuiteDefinitionOutputResponseBody: Equatable {
    public let suiteDefinitionId: String?
    public let suiteDefinitionArn: String?
    public let suiteDefinitionVersion: String?
    public let latestVersion: String?
    public let suiteDefinitionConfiguration: SuiteDefinitionConfiguration?
    public let createdAt: Date?
    public let lastModifiedAt: Date?
    public let tags: [String:String]?
}

extension GetSuiteDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case lastModifiedAt
        case latestVersion
        case suiteDefinitionArn
        case suiteDefinitionConfiguration
        case suiteDefinitionId
        case suiteDefinitionVersion
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteDefinitionArn)
        suiteDefinitionArn = suiteDefinitionArnDecoded
        let suiteDefinitionVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteDefinitionVersion)
        suiteDefinitionVersion = suiteDefinitionVersionDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let suiteDefinitionConfigurationDecoded = try containerValues.decodeIfPresent(SuiteDefinitionConfiguration.self, forKey: .suiteDefinitionConfiguration)
        suiteDefinitionConfiguration = suiteDefinitionConfigurationDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetSuiteRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSuiteRunInput(suiteDefinitionId: \(String(describing: suiteDefinitionId)), suiteRunId: \(String(describing: suiteRunId)))"}
}

extension GetSuiteRunInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSuiteRunInputHeadersMiddleware: Middleware {
    public let id: String = "GetSuiteRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSuiteRunInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSuiteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSuiteRunInput>
    public typealias MOutput = OperationOutput<GetSuiteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSuiteRunOutputError>
}

public struct GetSuiteRunInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSuiteRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSuiteRunInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSuiteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSuiteRunInput>
    public typealias MOutput = OperationOutput<GetSuiteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSuiteRunOutputError>
}

public struct GetSuiteRunInput: Equatable {
    /// <p>Suite definition Id for the test suite run.</p>
    public let suiteDefinitionId: String?
    /// <p>Suite run Id for the test suite run.</p>
    public let suiteRunId: String?

    public init (
        suiteDefinitionId: String? = nil,
        suiteRunId: String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteRunId = suiteRunId
    }
}

struct GetSuiteRunInputBody: Equatable {
}

extension GetSuiteRunInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSuiteRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSuiteRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSuiteRunOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSuiteRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSuiteRunOutputResponse(endTime: \(String(describing: endTime)), errorReason: \(String(describing: errorReason)), startTime: \(String(describing: startTime)), status: \(String(describing: status)), suiteDefinitionId: \(String(describing: suiteDefinitionId)), suiteDefinitionVersion: \(String(describing: suiteDefinitionVersion)), suiteRunArn: \(String(describing: suiteRunArn)), suiteRunConfiguration: \(String(describing: suiteRunConfiguration)), suiteRunId: \(String(describing: suiteRunId)), tags: \(String(describing: tags)), testResult: \(String(describing: testResult)))"}
}

extension GetSuiteRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSuiteRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.endTime = output.endTime
            self.errorReason = output.errorReason
            self.startTime = output.startTime
            self.status = output.status
            self.suiteDefinitionId = output.suiteDefinitionId
            self.suiteDefinitionVersion = output.suiteDefinitionVersion
            self.suiteRunArn = output.suiteRunArn
            self.suiteRunConfiguration = output.suiteRunConfiguration
            self.suiteRunId = output.suiteRunId
            self.tags = output.tags
            self.testResult = output.testResult
        } else {
            self.endTime = nil
            self.errorReason = nil
            self.startTime = nil
            self.status = nil
            self.suiteDefinitionId = nil
            self.suiteDefinitionVersion = nil
            self.suiteRunArn = nil
            self.suiteRunConfiguration = nil
            self.suiteRunId = nil
            self.tags = nil
            self.testResult = nil
        }
    }
}

public struct GetSuiteRunOutputResponse: Equatable {
    /// <p>Date (in Unix epoch time) when the test suite run ended.</p>
    public let endTime: Date?
    /// <p>Error reason for any test suite run failure.</p>
    public let errorReason: String?
    /// <p>Date (in Unix epoch time) when the test suite run was started.</p>
    public let startTime: Date?
    /// <p>Status for the test suite run.</p>
    public let status: SuiteRunStatus?
    /// <p>Suite definition Id for the test suite run.</p>
    public let suiteDefinitionId: String?
    /// <p>Suite definition version for the test suite run.</p>
    public let suiteDefinitionVersion: String?
    /// <p>The ARN of the suite run.</p>
    public let suiteRunArn: String?
    /// <p>Suite run configuration for the test suite run.</p>
    public let suiteRunConfiguration: SuiteRunConfiguration?
    /// <p>Suite run Id for the test suite run.</p>
    public let suiteRunId: String?
    /// <p>The tags attached to the suite run.</p>
    public let tags: [String:String]?
    /// <p>Test results for the test suite run.</p>
    public let testResult: TestResult?

    public init (
        endTime: Date? = nil,
        errorReason: String? = nil,
        startTime: Date? = nil,
        status: SuiteRunStatus? = nil,
        suiteDefinitionId: String? = nil,
        suiteDefinitionVersion: String? = nil,
        suiteRunArn: String? = nil,
        suiteRunConfiguration: SuiteRunConfiguration? = nil,
        suiteRunId: String? = nil,
        tags: [String:String]? = nil,
        testResult: TestResult? = nil
    )
    {
        self.endTime = endTime
        self.errorReason = errorReason
        self.startTime = startTime
        self.status = status
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
        self.suiteRunArn = suiteRunArn
        self.suiteRunConfiguration = suiteRunConfiguration
        self.suiteRunId = suiteRunId
        self.tags = tags
        self.testResult = testResult
    }
}

struct GetSuiteRunOutputResponseBody: Equatable {
    public let suiteDefinitionId: String?
    public let suiteDefinitionVersion: String?
    public let suiteRunId: String?
    public let suiteRunArn: String?
    public let suiteRunConfiguration: SuiteRunConfiguration?
    public let testResult: TestResult?
    public let startTime: Date?
    public let endTime: Date?
    public let status: SuiteRunStatus?
    public let errorReason: String?
    public let tags: [String:String]?
}

extension GetSuiteRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime
        case errorReason
        case startTime
        case status
        case suiteDefinitionId
        case suiteDefinitionVersion
        case suiteRunArn
        case suiteRunConfiguration
        case suiteRunId
        case tags
        case testResult
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteDefinitionVersion)
        suiteDefinitionVersion = suiteDefinitionVersionDecoded
        let suiteRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteRunId)
        suiteRunId = suiteRunIdDecoded
        let suiteRunArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteRunArn)
        suiteRunArn = suiteRunArnDecoded
        let suiteRunConfigurationDecoded = try containerValues.decodeIfPresent(SuiteRunConfiguration.self, forKey: .suiteRunConfiguration)
        suiteRunConfiguration = suiteRunConfigurationDecoded
        let testResultDecoded = try containerValues.decodeIfPresent(TestResult.self, forKey: .testResult)
        testResult = testResultDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SuiteRunStatus.self, forKey: .status)
        status = statusDecoded
        let errorReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorReason)
        errorReason = errorReasonDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetSuiteRunReportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSuiteRunReportInput(suiteDefinitionId: \(String(describing: suiteDefinitionId)), suiteRunId: \(String(describing: suiteRunId)))"}
}

extension GetSuiteRunReportInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSuiteRunReportInputHeadersMiddleware: Middleware {
    public let id: String = "GetSuiteRunReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSuiteRunReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSuiteRunReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSuiteRunReportInput>
    public typealias MOutput = OperationOutput<GetSuiteRunReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSuiteRunReportOutputError>
}

public struct GetSuiteRunReportInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSuiteRunReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSuiteRunReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSuiteRunReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSuiteRunReportInput>
    public typealias MOutput = OperationOutput<GetSuiteRunReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSuiteRunReportOutputError>
}

public struct GetSuiteRunReportInput: Equatable {
    /// <p>Suite definition Id of the test suite.</p>
    public let suiteDefinitionId: String?
    /// <p>Suite run Id of the test suite run.</p>
    public let suiteRunId: String?

    public init (
        suiteDefinitionId: String? = nil,
        suiteRunId: String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteRunId = suiteRunId
    }
}

struct GetSuiteRunReportInputBody: Equatable {
}

extension GetSuiteRunReportInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSuiteRunReportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSuiteRunReportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSuiteRunReportOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSuiteRunReportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSuiteRunReportOutputResponse(qualificationReportDownloadUrl: \(String(describing: qualificationReportDownloadUrl)))"}
}

extension GetSuiteRunReportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSuiteRunReportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.qualificationReportDownloadUrl = output.qualificationReportDownloadUrl
        } else {
            self.qualificationReportDownloadUrl = nil
        }
    }
}

public struct GetSuiteRunReportOutputResponse: Equatable {
    /// <p>Download URL of the qualification report.</p>
    public let qualificationReportDownloadUrl: String?

    public init (
        qualificationReportDownloadUrl: String? = nil
    )
    {
        self.qualificationReportDownloadUrl = qualificationReportDownloadUrl
    }
}

struct GetSuiteRunReportOutputResponseBody: Equatable {
    public let qualificationReportDownloadUrl: String?
}

extension GetSuiteRunReportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case qualificationReportDownloadUrl
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationReportDownloadUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .qualificationReportDownloadUrl)
        qualificationReportDownloadUrl = qualificationReportDownloadUrlDecoded
    }
}

extension GroupResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupId
        case groupName
        case tests
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let tests = tests {
            var testsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tests)
            for testcaseruns0 in tests {
                try testsContainer.encode(testcaseruns0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let testsContainer = try containerValues.decodeIfPresent([TestCaseRun?].self, forKey: .tests)
        var testsDecoded0:[TestCaseRun]? = nil
        if let testsContainer = testsContainer {
            testsDecoded0 = [TestCaseRun]()
            for structure0 in testsContainer {
                if let structure0 = structure0 {
                    testsDecoded0?.append(structure0)
                }
            }
        }
        tests = testsDecoded0
    }
}

extension GroupResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupResult(groupId: \(String(describing: groupId)), groupName: \(String(describing: groupName)), tests: \(String(describing: tests)))"}
}

/// <p>Show Group Result.</p>
public struct GroupResult: Equatable {
    /// <p>Group result Id.</p>
    public let groupId: String?
    /// <p>Group Result Name.</p>
    public let groupName: String?
    /// <p>Tests under Group Result.</p>
    public let tests: [TestCaseRun]?

    public init (
        groupId: String? = nil,
        groupName: String? = nil,
        tests: [TestCaseRun]? = nil
    )
    {
        self.groupId = groupId
        self.groupName = groupName
        self.tests = tests
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Sends Internal Failure Exception.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>Sends Internal Failure Exception message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListSuiteDefinitionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSuiteDefinitionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListSuiteDefinitionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListSuiteDefinitionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSuiteDefinitionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSuiteDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSuiteDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSuiteDefinitionsInput>
    public typealias MOutput = OperationOutput<ListSuiteDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSuiteDefinitionsOutputError>
}

public struct ListSuiteDefinitionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSuiteDefinitionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSuiteDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSuiteDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSuiteDefinitionsInput>
    public typealias MOutput = OperationOutput<ListSuiteDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSuiteDefinitionsOutputError>
}

public struct ListSuiteDefinitionsInput: Equatable {
    /// <p>The maximum number of results to return at once.</p>
    public let maxResults: Int
    /// <p>A token used to get the next set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSuiteDefinitionsInputBody: Equatable {
}

extension ListSuiteDefinitionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListSuiteDefinitionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSuiteDefinitionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSuiteDefinitionsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSuiteDefinitionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSuiteDefinitionsOutputResponse(nextToken: \(String(describing: nextToken)), suiteDefinitionInformationList: \(String(describing: suiteDefinitionInformationList)))"}
}

extension ListSuiteDefinitionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSuiteDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.suiteDefinitionInformationList = output.suiteDefinitionInformationList
        } else {
            self.nextToken = nil
            self.suiteDefinitionInformationList = nil
        }
    }
}

public struct ListSuiteDefinitionsOutputResponse: Equatable {
    /// <p>A token used to get the next set of results.</p>
    public let nextToken: String?
    /// <p>An array of objects that provide summaries of information about the suite definitions in the list.</p>
    public let suiteDefinitionInformationList: [SuiteDefinitionInformation]?

    public init (
        nextToken: String? = nil,
        suiteDefinitionInformationList: [SuiteDefinitionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.suiteDefinitionInformationList = suiteDefinitionInformationList
    }
}

struct ListSuiteDefinitionsOutputResponseBody: Equatable {
    public let suiteDefinitionInformationList: [SuiteDefinitionInformation]?
    public let nextToken: String?
}

extension ListSuiteDefinitionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case suiteDefinitionInformationList
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionInformationListContainer = try containerValues.decodeIfPresent([SuiteDefinitionInformation?].self, forKey: .suiteDefinitionInformationList)
        var suiteDefinitionInformationListDecoded0:[SuiteDefinitionInformation]? = nil
        if let suiteDefinitionInformationListContainer = suiteDefinitionInformationListContainer {
            suiteDefinitionInformationListDecoded0 = [SuiteDefinitionInformation]()
            for structure0 in suiteDefinitionInformationListContainer {
                if let structure0 = structure0 {
                    suiteDefinitionInformationListDecoded0?.append(structure0)
                }
            }
        }
        suiteDefinitionInformationList = suiteDefinitionInformationListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSuiteRunsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSuiteRunsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), suiteDefinitionId: \(String(describing: suiteDefinitionId)), suiteDefinitionVersion: \(String(describing: suiteDefinitionVersion)))"}
}

extension ListSuiteRunsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListSuiteRunsInputHeadersMiddleware: Middleware {
    public let id: String = "ListSuiteRunsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSuiteRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSuiteRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSuiteRunsInput>
    public typealias MOutput = OperationOutput<ListSuiteRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSuiteRunsOutputError>
}

public struct ListSuiteRunsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListSuiteRunsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListSuiteRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListSuiteRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let suiteDefinitionId = input.operationInput.suiteDefinitionId {
            let suiteDefinitionIdQueryItem = URLQueryItem(name: "suiteDefinitionId".urlPercentEncoding(), value: String(suiteDefinitionId).urlPercentEncoding())
            input.builder.withQueryItem(suiteDefinitionIdQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let suiteDefinitionVersion = input.operationInput.suiteDefinitionVersion {
            let suiteDefinitionVersionQueryItem = URLQueryItem(name: "suiteDefinitionVersion".urlPercentEncoding(), value: String(suiteDefinitionVersion).urlPercentEncoding())
            input.builder.withQueryItem(suiteDefinitionVersionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListSuiteRunsInput>
    public typealias MOutput = OperationOutput<ListSuiteRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListSuiteRunsOutputError>
}

public struct ListSuiteRunsInput: Equatable {
    /// <p>The maximum number of results to return at once.</p>
    public let maxResults: Int
    /// <p>A token to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>Lists the test suite runs of the specified test suite based on suite definition Id.</p>
    public let suiteDefinitionId: String?
    /// <p>Must be passed along with suiteDefinitionId. Lists the test suite runs of the specified test suite based on suite definition version.</p>
    public let suiteDefinitionVersion: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        suiteDefinitionId: String? = nil,
        suiteDefinitionVersion: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
    }
}

struct ListSuiteRunsInputBody: Equatable {
}

extension ListSuiteRunsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListSuiteRunsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSuiteRunsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSuiteRunsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSuiteRunsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListSuiteRunsOutputResponse(nextToken: \(String(describing: nextToken)), suiteRunsList: \(String(describing: suiteRunsList)))"}
}

extension ListSuiteRunsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListSuiteRunsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.suiteRunsList = output.suiteRunsList
        } else {
            self.nextToken = nil
            self.suiteRunsList = nil
        }
    }
}

public struct ListSuiteRunsOutputResponse: Equatable {
    /// <p>A token to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>An array of objects that provide summaries of information about the suite runs in the list.</p>
    public let suiteRunsList: [SuiteRunInformation]?

    public init (
        nextToken: String? = nil,
        suiteRunsList: [SuiteRunInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.suiteRunsList = suiteRunsList
    }
}

struct ListSuiteRunsOutputResponseBody: Equatable {
    public let suiteRunsList: [SuiteRunInformation]?
    public let nextToken: String?
}

extension ListSuiteRunsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case suiteRunsList
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteRunsListContainer = try containerValues.decodeIfPresent([SuiteRunInformation?].self, forKey: .suiteRunsList)
        var suiteRunsListDecoded0:[SuiteRunInformation]? = nil
        if let suiteRunsListContainer = suiteRunsListContainer {
            suiteRunsListDecoded0 = [SuiteRunInformation]()
            for structure0 in suiteRunsListContainer {
                if let structure0 = structure0 {
                    suiteRunsListDecoded0?.append(structure0)
                }
            }
        }
        suiteRunsList = suiteRunsListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The ARN of the IoT Device Advisor resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags attached to the IoT Device Advisor resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Sends Resource Not Found Exception.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Sends Resource Not Found Exception message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct StartSuiteRunInputBodyMiddleware: Middleware {
    public let id: String = "StartSuiteRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSuiteRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSuiteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSuiteRunInput>
    public typealias MOutput = OperationOutput<StartSuiteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSuiteRunOutputError>
}

extension StartSuiteRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSuiteRunInput(suiteDefinitionId: \(String(describing: suiteDefinitionId)), suiteDefinitionVersion: \(String(describing: suiteDefinitionVersion)), suiteRunConfiguration: \(String(describing: suiteRunConfiguration)), tags: \(String(describing: tags)))"}
}

extension StartSuiteRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case suiteDefinitionVersion
        case suiteRunConfiguration
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let suiteDefinitionVersion = suiteDefinitionVersion {
            try encodeContainer.encode(suiteDefinitionVersion, forKey: .suiteDefinitionVersion)
        }
        if let suiteRunConfiguration = suiteRunConfiguration {
            try encodeContainer.encode(suiteRunConfiguration, forKey: .suiteRunConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct StartSuiteRunInputHeadersMiddleware: Middleware {
    public let id: String = "StartSuiteRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSuiteRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSuiteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSuiteRunInput>
    public typealias MOutput = OperationOutput<StartSuiteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSuiteRunOutputError>
}

public struct StartSuiteRunInputQueryItemMiddleware: Middleware {
    public let id: String = "StartSuiteRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartSuiteRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartSuiteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartSuiteRunInput>
    public typealias MOutput = OperationOutput<StartSuiteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartSuiteRunOutputError>
}

public struct StartSuiteRunInput: Equatable {
    /// <p>Suite definition Id of the test suite.</p>
    public let suiteDefinitionId: String?
    /// <p>Suite definition version of the test suite.</p>
    public let suiteDefinitionVersion: String?
    /// <p>Suite run configuration.</p>
    public let suiteRunConfiguration: SuiteRunConfiguration?
    /// <p>The tags to be attached to the suite run.</p>
    public let tags: [String:String]?

    public init (
        suiteDefinitionId: String? = nil,
        suiteDefinitionVersion: String? = nil,
        suiteRunConfiguration: SuiteRunConfiguration? = nil,
        tags: [String:String]? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
        self.suiteRunConfiguration = suiteRunConfiguration
        self.tags = tags
    }
}

struct StartSuiteRunInputBody: Equatable {
    public let suiteDefinitionVersion: String?
    public let suiteRunConfiguration: SuiteRunConfiguration?
    public let tags: [String:String]?
}

extension StartSuiteRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case suiteDefinitionVersion
        case suiteRunConfiguration
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteDefinitionVersion)
        suiteDefinitionVersion = suiteDefinitionVersionDecoded
        let suiteRunConfigurationDecoded = try containerValues.decodeIfPresent(SuiteRunConfiguration.self, forKey: .suiteRunConfiguration)
        suiteRunConfiguration = suiteRunConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartSuiteRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSuiteRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSuiteRunOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSuiteRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartSuiteRunOutputResponse(createdAt: \(String(describing: createdAt)), suiteRunArn: \(String(describing: suiteRunArn)), suiteRunId: \(String(describing: suiteRunId)))"}
}

extension StartSuiteRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartSuiteRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdAt = output.createdAt
            self.suiteRunArn = output.suiteRunArn
            self.suiteRunId = output.suiteRunId
        } else {
            self.createdAt = nil
            self.suiteRunArn = nil
            self.suiteRunId = nil
        }
    }
}

public struct StartSuiteRunOutputResponse: Equatable {
    /// <p>Date (in Unix epoch time) when the suite run was created.</p>
    public let createdAt: Date?
    /// <p>Amazon resource name of the started suite run.</p>
    public let suiteRunArn: String?
    /// <p>Suite Run Id of the started suite run.</p>
    public let suiteRunId: String?

    public init (
        createdAt: Date? = nil,
        suiteRunArn: String? = nil,
        suiteRunId: String? = nil
    )
    {
        self.createdAt = createdAt
        self.suiteRunArn = suiteRunArn
        self.suiteRunId = suiteRunId
    }
}

struct StartSuiteRunOutputResponseBody: Equatable {
    public let suiteRunId: String?
    public let suiteRunArn: String?
    public let createdAt: Date?
}

extension StartSuiteRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case suiteRunArn
        case suiteRunId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteRunId)
        suiteRunId = suiteRunIdDecoded
        let suiteRunArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteRunArn)
        suiteRunArn = suiteRunArnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

public enum Status {
    case canceled
    case error
    case fail
    case pass
    case passWithWarnings
    case pending
    case running
    case stopped
    case stopping
    case sdkUnknown(String)
}

extension Status : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Status] {
        return [
            .canceled,
            .error,
            .fail,
            .pass,
            .passWithWarnings,
            .pending,
            .running,
            .stopped,
            .stopping,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canceled: return "CANCELED"
        case .error: return "ERROR"
        case .fail: return "FAIL"
        case .pass: return "PASS"
        case .passWithWarnings: return "PASS_WITH_WARNINGS"
        case .pending: return "PENDING"
        case .running: return "RUNNING"
        case .stopped: return "STOPPED"
        case .stopping: return "STOPPING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
    }
}

extension StopSuiteRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopSuiteRunInput(suiteDefinitionId: \(String(describing: suiteDefinitionId)), suiteRunId: \(String(describing: suiteRunId)))"}
}

extension StopSuiteRunInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct StopSuiteRunInputHeadersMiddleware: Middleware {
    public let id: String = "StopSuiteRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopSuiteRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StopSuiteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopSuiteRunInput>
    public typealias MOutput = OperationOutput<StopSuiteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopSuiteRunOutputError>
}

public struct StopSuiteRunInputQueryItemMiddleware: Middleware {
    public let id: String = "StopSuiteRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopSuiteRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StopSuiteRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopSuiteRunInput>
    public typealias MOutput = OperationOutput<StopSuiteRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopSuiteRunOutputError>
}

public struct StopSuiteRunInput: Equatable {
    /// <p>Suite definition Id of the test suite run to be stopped.</p>
    public let suiteDefinitionId: String?
    /// <p>Suite run Id of the test suite run to be stopped.</p>
    public let suiteRunId: String?

    public init (
        suiteDefinitionId: String? = nil,
        suiteRunId: String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteRunId = suiteRunId
    }
}

struct StopSuiteRunInputBody: Equatable {
}

extension StopSuiteRunInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StopSuiteRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopSuiteRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopSuiteRunOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopSuiteRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopSuiteRunOutputResponse()"}
}

extension StopSuiteRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopSuiteRunOutputResponse: Equatable {

    public init() {}
}

struct StopSuiteRunOutputResponseBody: Equatable {
}

extension StopSuiteRunOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension SuiteDefinitionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case devicePermissionRoleArn
        case devices
        case intendedForQualification
        case rootGroup
        case suiteDefinitionName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devicePermissionRoleArn = devicePermissionRoleArn {
            try encodeContainer.encode(devicePermissionRoleArn, forKey: .devicePermissionRoleArn)
        }
        if let devices = devices {
            var devicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .devices)
            for deviceundertestlist0 in devices {
                try devicesContainer.encode(deviceundertestlist0)
            }
        }
        if intendedForQualification != false {
            try encodeContainer.encode(intendedForQualification, forKey: .intendedForQualification)
        }
        if let rootGroup = rootGroup {
            try encodeContainer.encode(rootGroup, forKey: .rootGroup)
        }
        if let suiteDefinitionName = suiteDefinitionName {
            try encodeContainer.encode(suiteDefinitionName, forKey: .suiteDefinitionName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteDefinitionName)
        suiteDefinitionName = suiteDefinitionNameDecoded
        let devicesContainer = try containerValues.decodeIfPresent([DeviceUnderTest?].self, forKey: .devices)
        var devicesDecoded0:[DeviceUnderTest]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [DeviceUnderTest]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let intendedForQualificationDecoded = try containerValues.decode(Bool.self, forKey: .intendedForQualification)
        intendedForQualification = intendedForQualificationDecoded
        let rootGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rootGroup)
        rootGroup = rootGroupDecoded
        let devicePermissionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .devicePermissionRoleArn)
        devicePermissionRoleArn = devicePermissionRoleArnDecoded
    }
}

extension SuiteDefinitionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SuiteDefinitionConfiguration(devicePermissionRoleArn: \(String(describing: devicePermissionRoleArn)), devices: \(String(describing: devices)), intendedForQualification: \(String(describing: intendedForQualification)), rootGroup: \(String(describing: rootGroup)), suiteDefinitionName: \(String(describing: suiteDefinitionName)))"}
}

/// <p>Gets Suite Definition Configuration.</p>
public struct SuiteDefinitionConfiguration: Equatable {
    /// <p>Gets device permission arn.</p>
    public let devicePermissionRoleArn: String?
    /// <p>Gets the devices configured.</p>
    public let devices: [DeviceUnderTest]?
    /// <p>Gets the tests intended for qualification in a suite.</p>
    public let intendedForQualification: Bool
    /// <p>Gets test suite root group.</p>
    public let rootGroup: String?
    /// <p>Gets Suite Definition Configuration name.</p>
    public let suiteDefinitionName: String?

    public init (
        devicePermissionRoleArn: String? = nil,
        devices: [DeviceUnderTest]? = nil,
        intendedForQualification: Bool = false,
        rootGroup: String? = nil,
        suiteDefinitionName: String? = nil
    )
    {
        self.devicePermissionRoleArn = devicePermissionRoleArn
        self.devices = devices
        self.intendedForQualification = intendedForQualification
        self.rootGroup = rootGroup
        self.suiteDefinitionName = suiteDefinitionName
    }
}

extension SuiteDefinitionInformation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case defaultDevices
        case intendedForQualification
        case suiteDefinitionId
        case suiteDefinitionName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let defaultDevices = defaultDevices {
            var defaultDevicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultDevices)
            for deviceundertestlist0 in defaultDevices {
                try defaultDevicesContainer.encode(deviceundertestlist0)
            }
        }
        if intendedForQualification != false {
            try encodeContainer.encode(intendedForQualification, forKey: .intendedForQualification)
        }
        if let suiteDefinitionId = suiteDefinitionId {
            try encodeContainer.encode(suiteDefinitionId, forKey: .suiteDefinitionId)
        }
        if let suiteDefinitionName = suiteDefinitionName {
            try encodeContainer.encode(suiteDefinitionName, forKey: .suiteDefinitionName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteDefinitionName)
        suiteDefinitionName = suiteDefinitionNameDecoded
        let defaultDevicesContainer = try containerValues.decodeIfPresent([DeviceUnderTest?].self, forKey: .defaultDevices)
        var defaultDevicesDecoded0:[DeviceUnderTest]? = nil
        if let defaultDevicesContainer = defaultDevicesContainer {
            defaultDevicesDecoded0 = [DeviceUnderTest]()
            for structure0 in defaultDevicesContainer {
                if let structure0 = structure0 {
                    defaultDevicesDecoded0?.append(structure0)
                }
            }
        }
        defaultDevices = defaultDevicesDecoded0
        let intendedForQualificationDecoded = try containerValues.decode(Bool.self, forKey: .intendedForQualification)
        intendedForQualification = intendedForQualificationDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension SuiteDefinitionInformation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SuiteDefinitionInformation(createdAt: \(String(describing: createdAt)), defaultDevices: \(String(describing: defaultDevices)), intendedForQualification: \(String(describing: intendedForQualification)), suiteDefinitionId: \(String(describing: suiteDefinitionId)), suiteDefinitionName: \(String(describing: suiteDefinitionName)))"}
}

/// <p>Information about the suite definition.</p>
public struct SuiteDefinitionInformation: Equatable {
    /// <p>Date (in Unix epoch time) when the test suite was created.</p>
    public let createdAt: Date?
    /// <p>Specifies the devices under test for the test suite.</p>
    public let defaultDevices: [DeviceUnderTest]?
    /// <p>Specifies if the test suite is intended for qualification.</p>
    public let intendedForQualification: Bool
    /// <p>Suite definition Id of the test suite.</p>
    public let suiteDefinitionId: String?
    /// <p>Suite name of the test suite.</p>
    public let suiteDefinitionName: String?

    public init (
        createdAt: Date? = nil,
        defaultDevices: [DeviceUnderTest]? = nil,
        intendedForQualification: Bool = false,
        suiteDefinitionId: String? = nil,
        suiteDefinitionName: String? = nil
    )
    {
        self.createdAt = createdAt
        self.defaultDevices = defaultDevices
        self.intendedForQualification = intendedForQualification
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionName = suiteDefinitionName
    }
}

extension SuiteRunConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case primaryDevice
        case selectedTestList
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let primaryDevice = primaryDevice {
            try encodeContainer.encode(primaryDevice, forKey: .primaryDevice)
        }
        if let selectedTestList = selectedTestList {
            var selectedTestListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedTestList)
            for selectedtestlist0 in selectedTestList {
                try selectedTestListContainer.encode(selectedtestlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryDeviceDecoded = try containerValues.decodeIfPresent(DeviceUnderTest.self, forKey: .primaryDevice)
        primaryDevice = primaryDeviceDecoded
        let selectedTestListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .selectedTestList)
        var selectedTestListDecoded0:[String]? = nil
        if let selectedTestListContainer = selectedTestListContainer {
            selectedTestListDecoded0 = [String]()
            for string0 in selectedTestListContainer {
                if let string0 = string0 {
                    selectedTestListDecoded0?.append(string0)
                }
            }
        }
        selectedTestList = selectedTestListDecoded0
    }
}

extension SuiteRunConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SuiteRunConfiguration(primaryDevice: \(String(describing: primaryDevice)), selectedTestList: \(String(describing: selectedTestList)))"}
}

/// <p>Gets suite run configuration.</p>
public struct SuiteRunConfiguration: Equatable {
    /// <p>Gets the primary device for suite run.</p>
    public let primaryDevice: DeviceUnderTest?
    /// <p>Gets test case list.</p>
    public let selectedTestList: [String]?

    public init (
        primaryDevice: DeviceUnderTest? = nil,
        selectedTestList: [String]? = nil
    )
    {
        self.primaryDevice = primaryDevice
        self.selectedTestList = selectedTestList
    }
}

extension SuiteRunInformation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case endAt
        case failed
        case passed
        case startedAt
        case status
        case suiteDefinitionId
        case suiteDefinitionName
        case suiteDefinitionVersion
        case suiteRunId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let endAt = endAt {
            try encodeContainer.encode(endAt.timeIntervalSince1970, forKey: .endAt)
        }
        if failed != 0 {
            try encodeContainer.encode(failed, forKey: .failed)
        }
        if passed != 0 {
            try encodeContainer.encode(passed, forKey: .passed)
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt.timeIntervalSince1970, forKey: .startedAt)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let suiteDefinitionId = suiteDefinitionId {
            try encodeContainer.encode(suiteDefinitionId, forKey: .suiteDefinitionId)
        }
        if let suiteDefinitionName = suiteDefinitionName {
            try encodeContainer.encode(suiteDefinitionName, forKey: .suiteDefinitionName)
        }
        if let suiteDefinitionVersion = suiteDefinitionVersion {
            try encodeContainer.encode(suiteDefinitionVersion, forKey: .suiteDefinitionVersion)
        }
        if let suiteRunId = suiteRunId {
            try encodeContainer.encode(suiteRunId, forKey: .suiteRunId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteDefinitionVersion)
        suiteDefinitionVersion = suiteDefinitionVersionDecoded
        let suiteDefinitionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteDefinitionName)
        suiteDefinitionName = suiteDefinitionNameDecoded
        let suiteRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteRunId)
        suiteRunId = suiteRunIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endAt)
        endAt = endAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SuiteRunStatus.self, forKey: .status)
        status = statusDecoded
        let passedDecoded = try containerValues.decode(Int.self, forKey: .passed)
        passed = passedDecoded
        let failedDecoded = try containerValues.decode(Int.self, forKey: .failed)
        failed = failedDecoded
    }
}

extension SuiteRunInformation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SuiteRunInformation(createdAt: \(String(describing: createdAt)), endAt: \(String(describing: endAt)), failed: \(String(describing: failed)), passed: \(String(describing: passed)), startedAt: \(String(describing: startedAt)), status: \(String(describing: status)), suiteDefinitionId: \(String(describing: suiteDefinitionId)), suiteDefinitionName: \(String(describing: suiteDefinitionName)), suiteDefinitionVersion: \(String(describing: suiteDefinitionVersion)), suiteRunId: \(String(describing: suiteRunId)))"}
}

/// <p>Information about the suite run.</p>
public struct SuiteRunInformation: Equatable {
    /// <p>Date (in Unix epoch time) when the suite run was created.</p>
    public let createdAt: Date?
    /// <p>Date (in Unix epoch time) when the suite run ended.</p>
    public let endAt: Date?
    /// <p>Number of test cases that failed in the suite run.</p>
    public let failed: Int
    /// <p>Number of test cases that passed in the suite run.</p>
    public let passed: Int
    /// <p>Date (in Unix epoch time) when the suite run was started.</p>
    public let startedAt: Date?
    /// <p>Status of the suite run.</p>
    public let status: SuiteRunStatus?
    /// <p>Suite definition Id of the suite run.</p>
    public let suiteDefinitionId: String?
    /// <p>Suite definition name of the suite run.</p>
    public let suiteDefinitionName: String?
    /// <p>Suite definition version of the suite run.</p>
    public let suiteDefinitionVersion: String?
    /// <p>Suite run Id of the suite run.</p>
    public let suiteRunId: String?

    public init (
        createdAt: Date? = nil,
        endAt: Date? = nil,
        failed: Int = 0,
        passed: Int = 0,
        startedAt: Date? = nil,
        status: SuiteRunStatus? = nil,
        suiteDefinitionId: String? = nil,
        suiteDefinitionName: String? = nil,
        suiteDefinitionVersion: String? = nil,
        suiteRunId: String? = nil
    )
    {
        self.createdAt = createdAt
        self.endAt = endAt
        self.failed = failed
        self.passed = passed
        self.startedAt = startedAt
        self.status = status
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionName = suiteDefinitionName
        self.suiteDefinitionVersion = suiteDefinitionVersion
        self.suiteRunId = suiteRunId
    }
}

public enum SuiteRunStatus {
    case canceled
    case error
    case fail
    case pass
    case passWithWarnings
    case pending
    case running
    case stopped
    case stopping
    case sdkUnknown(String)
}

extension SuiteRunStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SuiteRunStatus] {
        return [
            .canceled,
            .error,
            .fail,
            .pass,
            .passWithWarnings,
            .pending,
            .running,
            .stopped,
            .stopping,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canceled: return "CANCELED"
        case .error: return "ERROR"
        case .fail: return "FAIL"
        case .pass: return "PASS"
        case .passWithWarnings: return "PASS_WITH_WARNINGS"
        case .pending: return "PENDING"
        case .running: return "RUNNING"
        case .stopped: return "STOPPED"
        case .stopping: return "STOPPING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SuiteRunStatus(rawValue: rawValue) ?? SuiteRunStatus.sdkUnknown(rawValue)
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The resource ARN of an IoT Device Advisor resource.</p>
    public let resourceArn: String?
    /// <p>The tags to be attached to the IoT Device Advisor resource.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TestCaseRun: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime
        case failure
        case logUrl
        case startTime
        case status
        case testCaseDefinitionId
        case testCaseDefinitionName
        case testCaseRunId
        case warnings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let failure = failure {
            try encodeContainer.encode(failure, forKey: .failure)
        }
        if let logUrl = logUrl {
            try encodeContainer.encode(logUrl, forKey: .logUrl)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let testCaseDefinitionId = testCaseDefinitionId {
            try encodeContainer.encode(testCaseDefinitionId, forKey: .testCaseDefinitionId)
        }
        if let testCaseDefinitionName = testCaseDefinitionName {
            try encodeContainer.encode(testCaseDefinitionName, forKey: .testCaseDefinitionName)
        }
        if let testCaseRunId = testCaseRunId {
            try encodeContainer.encode(testCaseRunId, forKey: .testCaseRunId)
        }
        if let warnings = warnings {
            try encodeContainer.encode(warnings, forKey: .warnings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testCaseRunIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .testCaseRunId)
        testCaseRunId = testCaseRunIdDecoded
        let testCaseDefinitionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .testCaseDefinitionId)
        testCaseDefinitionId = testCaseDefinitionIdDecoded
        let testCaseDefinitionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .testCaseDefinitionName)
        testCaseDefinitionName = testCaseDefinitionNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let logUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logUrl)
        logUrl = logUrlDecoded
        let warningsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .warnings)
        warnings = warningsDecoded
        let failureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .failure)
        failure = failureDecoded
    }
}

extension TestCaseRun: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestCaseRun(endTime: \(String(describing: endTime)), failure: \(String(describing: failure)), logUrl: \(String(describing: logUrl)), startTime: \(String(describing: startTime)), status: \(String(describing: status)), testCaseDefinitionId: \(String(describing: testCaseDefinitionId)), testCaseDefinitionName: \(String(describing: testCaseDefinitionName)), testCaseRunId: \(String(describing: testCaseRunId)), warnings: \(String(describing: warnings)))"}
}

/// <p>Provides test case run.</p>
public struct TestCaseRun: Equatable {
    /// <p>Provides test case run end time.</p>
    public let endTime: Date?
    /// <p>Provides test case run failure result.</p>
    public let failure: String?
    /// <p>Provides test case run log Url.</p>
    public let logUrl: String?
    /// <p>Provides test case run start time.</p>
    public let startTime: Date?
    /// <p>Provides test case run status.</p>
    public let status: Status?
    /// <p>Provides test case run definition Id.</p>
    public let testCaseDefinitionId: String?
    /// <p>Provides test case run definition Name.</p>
    public let testCaseDefinitionName: String?
    /// <p>Provides test case run Id.</p>
    public let testCaseRunId: String?
    /// <p>Provides test case run warnings.</p>
    public let warnings: String?

    public init (
        endTime: Date? = nil,
        failure: String? = nil,
        logUrl: String? = nil,
        startTime: Date? = nil,
        status: Status? = nil,
        testCaseDefinitionId: String? = nil,
        testCaseDefinitionName: String? = nil,
        testCaseRunId: String? = nil,
        warnings: String? = nil
    )
    {
        self.endTime = endTime
        self.failure = failure
        self.logUrl = logUrl
        self.startTime = startTime
        self.status = status
        self.testCaseDefinitionId = testCaseDefinitionId
        self.testCaseDefinitionName = testCaseDefinitionName
        self.testCaseRunId = testCaseRunId
        self.warnings = warnings
    }
}

extension TestResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groups
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for groupresultlist0 in groups {
                try groupsContainer.encode(groupresultlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([GroupResult?].self, forKey: .groups)
        var groupsDecoded0:[GroupResult]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [GroupResult]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
    }
}

extension TestResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestResult(groups: \(String(describing: groups)))"}
}

/// <p>Show each group result.</p>
public struct TestResult: Equatable {
    /// <p>Show each group of test results.</p>
    public let groups: [GroupResult]?

    public init (
        groups: [GroupResult]? = nil
    )
    {
        self.groups = groups
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The resource ARN of an IoT Device Advisor resource.</p>
    public let resourceArn: String?
    /// <p>List of tag keys to remove from the IoT Device Advisor resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateSuiteDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSuiteDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSuiteDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSuiteDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSuiteDefinitionOutputError>
}

extension UpdateSuiteDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSuiteDefinitionInput(suiteDefinitionConfiguration: \(String(describing: suiteDefinitionConfiguration)), suiteDefinitionId: \(String(describing: suiteDefinitionId)))"}
}

extension UpdateSuiteDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case suiteDefinitionConfiguration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let suiteDefinitionConfiguration = suiteDefinitionConfiguration {
            try encodeContainer.encode(suiteDefinitionConfiguration, forKey: .suiteDefinitionConfiguration)
        }
    }
}

public struct UpdateSuiteDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSuiteDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSuiteDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSuiteDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSuiteDefinitionOutputError>
}

public struct UpdateSuiteDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSuiteDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSuiteDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSuiteDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSuiteDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateSuiteDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSuiteDefinitionOutputError>
}

public struct UpdateSuiteDefinitionInput: Equatable {
    /// <p>Updates a Device Advisor test suite with suite definition configuration.</p>
    public let suiteDefinitionConfiguration: SuiteDefinitionConfiguration?
    /// <p>Suite definition Id of the test suite to be updated.</p>
    public let suiteDefinitionId: String?

    public init (
        suiteDefinitionConfiguration: SuiteDefinitionConfiguration? = nil,
        suiteDefinitionId: String? = nil
    )
    {
        self.suiteDefinitionConfiguration = suiteDefinitionConfiguration
        self.suiteDefinitionId = suiteDefinitionId
    }
}

struct UpdateSuiteDefinitionInputBody: Equatable {
    public let suiteDefinitionConfiguration: SuiteDefinitionConfiguration?
}

extension UpdateSuiteDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case suiteDefinitionConfiguration
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionConfigurationDecoded = try containerValues.decodeIfPresent(SuiteDefinitionConfiguration.self, forKey: .suiteDefinitionConfiguration)
        suiteDefinitionConfiguration = suiteDefinitionConfigurationDecoded
    }
}

extension UpdateSuiteDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSuiteDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSuiteDefinitionOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSuiteDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSuiteDefinitionOutputResponse(createdAt: \(String(describing: createdAt)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), suiteDefinitionArn: \(String(describing: suiteDefinitionArn)), suiteDefinitionId: \(String(describing: suiteDefinitionId)), suiteDefinitionName: \(String(describing: suiteDefinitionName)), suiteDefinitionVersion: \(String(describing: suiteDefinitionVersion)))"}
}

extension UpdateSuiteDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSuiteDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdAt = output.createdAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.suiteDefinitionArn = output.suiteDefinitionArn
            self.suiteDefinitionId = output.suiteDefinitionId
            self.suiteDefinitionName = output.suiteDefinitionName
            self.suiteDefinitionVersion = output.suiteDefinitionVersion
        } else {
            self.createdAt = nil
            self.lastUpdatedAt = nil
            self.suiteDefinitionArn = nil
            self.suiteDefinitionId = nil
            self.suiteDefinitionName = nil
            self.suiteDefinitionVersion = nil
        }
    }
}

public struct UpdateSuiteDefinitionOutputResponse: Equatable {
    /// <p>Timestamp of when the test suite was created.</p>
    public let createdAt: Date?
    /// <p>Timestamp of when the test suite was updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>Amazon Resource name of the updated test suite.</p>
    public let suiteDefinitionArn: String?
    /// <p>Suite definition Id of the updated test suite.</p>
    public let suiteDefinitionId: String?
    /// <p>Suite definition name of the updated test suite.</p>
    public let suiteDefinitionName: String?
    /// <p>Suite definition version of the updated test suite.</p>
    public let suiteDefinitionVersion: String?

    public init (
        createdAt: Date? = nil,
        lastUpdatedAt: Date? = nil,
        suiteDefinitionArn: String? = nil,
        suiteDefinitionId: String? = nil,
        suiteDefinitionName: String? = nil,
        suiteDefinitionVersion: String? = nil
    )
    {
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.suiteDefinitionArn = suiteDefinitionArn
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionName = suiteDefinitionName
        self.suiteDefinitionVersion = suiteDefinitionVersion
    }
}

struct UpdateSuiteDefinitionOutputResponseBody: Equatable {
    public let suiteDefinitionId: String?
    public let suiteDefinitionArn: String?
    public let suiteDefinitionName: String?
    public let suiteDefinitionVersion: String?
    public let createdAt: Date?
    public let lastUpdatedAt: Date?
}

extension UpdateSuiteDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case lastUpdatedAt
        case suiteDefinitionArn
        case suiteDefinitionId
        case suiteDefinitionName
        case suiteDefinitionVersion
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteDefinitionArn)
        suiteDefinitionArn = suiteDefinitionArnDecoded
        let suiteDefinitionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteDefinitionName)
        suiteDefinitionName = suiteDefinitionNameDecoded
        let suiteDefinitionVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .suiteDefinitionVersion)
        suiteDefinitionVersion = suiteDefinitionVersionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Sends invalid request exception.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Sends invalid request exception message.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
