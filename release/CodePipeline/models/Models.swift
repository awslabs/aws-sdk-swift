// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AWSSessionCredentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessKeyId
        case secretAccessKey
        case sessionToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let secretAccessKey = secretAccessKey {
            try encodeContainer.encode(secretAccessKey, forKey: .secretAccessKey)
        }
        if let sessionToken = sessionToken {
            try encodeContainer.encode(sessionToken, forKey: .sessionToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
    }
}

extension AWSSessionCredentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

/// <p>Represents an AWS session credentials object. These credentials are temporary
///             credentials that are issued by AWS Secure Token Service (STS). They can be used to
///             access input and output artifacts in the S3 bucket used to store artifact for the
///             pipeline in AWS CodePipeline.</p>
public struct AWSSessionCredentials: Equatable {
    /// <p>The access key for the session.</p>
    public let accessKeyId: String?
    /// <p>The secret access key for the session.</p>
    public let secretAccessKey: String?
    /// <p>The token for the session.</p>
    public let sessionToken: String?

    public init (
        accessKeyId: String? = nil,
        secretAccessKey: String? = nil,
        sessionToken: String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.secretAccessKey = secretAccessKey
        self.sessionToken = sessionToken
    }
}

public struct AcknowledgeJobInputBodyMiddleware: Middleware {
    public let id: String = "AcknowledgeJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcknowledgeJobInput>,
                  next: H) -> Swift.Result<OperationOutput<AcknowledgeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcknowledgeJobInput>
    public typealias MOutput = OperationOutput<AcknowledgeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcknowledgeJobOutputError>
}

extension AcknowledgeJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcknowledgeJobInput(jobId: \(String(describing: jobId)), nonce: \(String(describing: nonce)))"}
}

extension AcknowledgeJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId
        case nonce
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let nonce = nonce {
            try encodeContainer.encode(nonce, forKey: .nonce)
        }
    }
}

public struct AcknowledgeJobInputHeadersMiddleware: Middleware {
    public let id: String = "AcknowledgeJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcknowledgeJobInput>,
                  next: H) -> Swift.Result<OperationOutput<AcknowledgeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcknowledgeJobInput>
    public typealias MOutput = OperationOutput<AcknowledgeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcknowledgeJobOutputError>
}

public struct AcknowledgeJobInputQueryItemMiddleware: Middleware {
    public let id: String = "AcknowledgeJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcknowledgeJobInput>,
                  next: H) -> Swift.Result<OperationOutput<AcknowledgeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcknowledgeJobInput>
    public typealias MOutput = OperationOutput<AcknowledgeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcknowledgeJobOutputError>
}

/// <p>Represents the input of an AcknowledgeJob action.</p>
public struct AcknowledgeJobInput: Equatable {
    /// <p>The unique system-generated ID of the job for which you want to confirm
    ///             receipt.</p>
    public let jobId: String?
    /// <p>A system-generated random number that AWS CodePipeline uses to ensure that the job
    ///             is being worked on by only one job worker. Get this number from the response of the
    ///                 <a>PollForJobs</a> request that returned this job.</p>
    public let nonce: String?

    public init (
        jobId: String? = nil,
        nonce: String? = nil
    )
    {
        self.jobId = jobId
        self.nonce = nonce
    }
}

struct AcknowledgeJobInputBody: Equatable {
    public let jobId: String?
    public let nonce: String?
}

extension AcknowledgeJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId
        case nonce
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let nonceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nonce)
        nonce = nonceDecoded
    }
}

extension AcknowledgeJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcknowledgeJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNonceException" : self = .invalidNonceException(try InvalidNonceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcknowledgeJobOutputError: Swift.Error, Equatable {
    case invalidNonceException(InvalidNonceException)
    case jobNotFoundException(JobNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcknowledgeJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcknowledgeJobOutputResponse(status: \(String(describing: status)))"}
}

extension AcknowledgeJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AcknowledgeJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

/// <p>Represents the output of an AcknowledgeJob action.</p>
public struct AcknowledgeJobOutputResponse: Equatable {
    /// <p>Whether the job worker has received the specified job.</p>
    public let status: JobStatus?

    public init (
        status: JobStatus? = nil
    )
    {
        self.status = status
    }
}

struct AcknowledgeJobOutputResponseBody: Equatable {
    public let status: JobStatus?
}

extension AcknowledgeJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct AcknowledgeThirdPartyJobInputBodyMiddleware: Middleware {
    public let id: String = "AcknowledgeThirdPartyJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcknowledgeThirdPartyJobInput>,
                  next: H) -> Swift.Result<OperationOutput<AcknowledgeThirdPartyJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcknowledgeThirdPartyJobInput>
    public typealias MOutput = OperationOutput<AcknowledgeThirdPartyJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcknowledgeThirdPartyJobOutputError>
}

extension AcknowledgeThirdPartyJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcknowledgeThirdPartyJobInput(clientToken: \(String(describing: clientToken)), jobId: \(String(describing: jobId)), nonce: \(String(describing: nonce)))"}
}

extension AcknowledgeThirdPartyJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case jobId
        case nonce
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let nonce = nonce {
            try encodeContainer.encode(nonce, forKey: .nonce)
        }
    }
}

public struct AcknowledgeThirdPartyJobInputHeadersMiddleware: Middleware {
    public let id: String = "AcknowledgeThirdPartyJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcknowledgeThirdPartyJobInput>,
                  next: H) -> Swift.Result<OperationOutput<AcknowledgeThirdPartyJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcknowledgeThirdPartyJobInput>
    public typealias MOutput = OperationOutput<AcknowledgeThirdPartyJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcknowledgeThirdPartyJobOutputError>
}

public struct AcknowledgeThirdPartyJobInputQueryItemMiddleware: Middleware {
    public let id: String = "AcknowledgeThirdPartyJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AcknowledgeThirdPartyJobInput>,
                  next: H) -> Swift.Result<OperationOutput<AcknowledgeThirdPartyJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AcknowledgeThirdPartyJobInput>
    public typealias MOutput = OperationOutput<AcknowledgeThirdPartyJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AcknowledgeThirdPartyJobOutputError>
}

/// <p>Represents the input of an AcknowledgeThirdPartyJob action.</p>
public struct AcknowledgeThirdPartyJobInput: Equatable {
    /// <p>The clientToken portion of the clientId and clientToken pair used to verify that
    ///             the calling entity is allowed access to the job and its details.</p>
    public let clientToken: String?
    /// <p>The unique system-generated ID of the job.</p>
    public let jobId: String?
    /// <p>A system-generated random number that AWS CodePipeline uses to ensure that the job
    ///             is being worked on by only one job worker. Get this number from the response to a <a>GetThirdPartyJobDetails</a> request.</p>
    public let nonce: String?

    public init (
        clientToken: String? = nil,
        jobId: String? = nil,
        nonce: String? = nil
    )
    {
        self.clientToken = clientToken
        self.jobId = jobId
        self.nonce = nonce
    }
}

struct AcknowledgeThirdPartyJobInputBody: Equatable {
    public let jobId: String?
    public let nonce: String?
    public let clientToken: String?
}

extension AcknowledgeThirdPartyJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case jobId
        case nonce
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let nonceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nonce)
        nonce = nonceDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AcknowledgeThirdPartyJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcknowledgeThirdPartyJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNonceException" : self = .invalidNonceException(try InvalidNonceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcknowledgeThirdPartyJobOutputError: Swift.Error, Equatable {
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidNonceException(InvalidNonceException)
    case jobNotFoundException(JobNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcknowledgeThirdPartyJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AcknowledgeThirdPartyJobOutputResponse(status: \(String(describing: status)))"}
}

extension AcknowledgeThirdPartyJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AcknowledgeThirdPartyJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

/// <p>Represents the output of an AcknowledgeThirdPartyJob action.</p>
public struct AcknowledgeThirdPartyJobOutputResponse: Equatable {
    /// <p>The status information for the third party job, if any.</p>
    public let status: JobStatus?

    public init (
        status: JobStatus? = nil
    )
    {
        self.status = status
    }
}

struct AcknowledgeThirdPartyJobOutputResponseBody: Equatable {
    public let status: JobStatus?
}

extension AcknowledgeThirdPartyJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public enum ActionCategory {
    case approval
    case build
    case deploy
    case invoke
    case source
    case test
    case sdkUnknown(String)
}

extension ActionCategory : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActionCategory] {
        return [
            .approval,
            .build,
            .deploy,
            .invoke,
            .source,
            .test,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .approval: return "Approval"
        case .build: return "Build"
        case .deploy: return "Deploy"
        case .invoke: return "Invoke"
        case .source: return "Source"
        case .test: return "Test"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActionCategory(rawValue: rawValue) ?? ActionCategory.sdkUnknown(rawValue)
    }
}

extension ActionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configuration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            var configurationContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .configuration)
            for (dictKey0, actionconfigurationmap0) in configuration {
                try configurationContainer.encode(actionconfigurationmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .configuration)
        var configurationDecoded0: [String:String]? = nil
        if let configurationContainer = configurationContainer {
            configurationDecoded0 = [String:String]()
            for (key0, actionconfigurationvalue0) in configurationContainer {
                if let actionconfigurationvalue0 = actionconfigurationvalue0 {
                    configurationDecoded0?[key0] = actionconfigurationvalue0
                }
            }
        }
        configuration = configurationDecoded0
    }
}

extension ActionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionConfiguration(configuration: \(String(describing: configuration)))"}
}

/// <p>Represents information about an action configuration.</p>
public struct ActionConfiguration: Equatable {
    /// <p>The configuration data for the action.</p>
    public let configuration: [String:String]?

    public init (
        configuration: [String:String]? = nil
    )
    {
        self.configuration = configuration
    }
}

extension ActionConfigurationProperty: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case key
        case name
        case queryable
        case `required` = "required"
        case secret
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if key != false {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if queryable != false {
            try encodeContainer.encode(queryable, forKey: .queryable)
        }
        if `required` != false {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
        if secret != false {
            try encodeContainer.encode(secret, forKey: .secret)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let requiredDecoded = try containerValues.decode(Bool.self, forKey: .required)
        `required` = requiredDecoded
        let keyDecoded = try containerValues.decode(Bool.self, forKey: .key)
        key = keyDecoded
        let secretDecoded = try containerValues.decode(Bool.self, forKey: .secret)
        secret = secretDecoded
        let queryableDecoded = try containerValues.decode(Bool.self, forKey: .queryable)
        queryable = queryableDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ActionConfigurationPropertyType.self, forKey: .type)
        type = typeDecoded
    }
}

extension ActionConfigurationProperty: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionConfigurationProperty(description: \(String(describing: description)), key: \(String(describing: key)), name: \(String(describing: name)), queryable: \(String(describing: queryable)), required: \(String(describing: `required`)), secret: \(String(describing: secret)), type: \(String(describing: type)))"}
}

/// <p>Represents information about an action configuration property.</p>
public struct ActionConfigurationProperty: Equatable {
    /// <p>Whether the configuration property is a required value.</p>
    public let `required`: Bool
    /// <p>The description of the action configuration property that is displayed to
    ///             users.</p>
    public let description: String?
    /// <p>Whether the configuration property is a key.</p>
    public let key: Bool
    /// <p>The name of the action configuration property.</p>
    public let name: String?
    /// <p>Indicates that the property is used with <code>PollForJobs</code>. When creating a
    ///             custom action, an action can have up to one queryable property. If it has one, that
    ///             property must be both required and not secret.</p>
    ///         <p>If you create a pipeline with a custom action type, and that custom action contains
    ///             a queryable property, the value for that configuration property is subject to other
    ///             restrictions. The value must be less than or equal to twenty (20) characters. The value
    ///             can contain only alphanumeric characters, underscores, and hyphens.</p>
    public let queryable: Bool
    /// <p>Whether the configuration property is secret. Secrets are hidden from all calls
    ///             except for <code>GetJobDetails</code>, <code>GetThirdPartyJobDetails</code>,
    ///                 <code>PollForJobs</code>, and <code>PollForThirdPartyJobs</code>.</p>
    ///         <p>When updating a pipeline, passing * * * * * without changing any other values of
    ///             the action preserves the previous value of the secret.</p>
    public let secret: Bool
    /// <p>The type of the configuration property.</p>
    public let type: ActionConfigurationPropertyType?

    public init (
        `required`: Bool = false,
        description: String? = nil,
        key: Bool = false,
        name: String? = nil,
        queryable: Bool = false,
        secret: Bool = false,
        type: ActionConfigurationPropertyType? = nil
    )
    {
        self.`required` = `required`
        self.description = description
        self.key = key
        self.name = name
        self.queryable = queryable
        self.secret = secret
        self.type = type
    }
}

public enum ActionConfigurationPropertyType {
    case boolean
    case number
    case string
    case sdkUnknown(String)
}

extension ActionConfigurationPropertyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActionConfigurationPropertyType] {
        return [
            .boolean,
            .number,
            .string,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .boolean: return "Boolean"
        case .number: return "Number"
        case .string: return "String"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActionConfigurationPropertyType(rawValue: rawValue) ?? ActionConfigurationPropertyType.sdkUnknown(rawValue)
    }
}

extension ActionContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionExecutionId
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionExecutionId = actionExecutionId {
            try encodeContainer.encode(actionExecutionId, forKey: .actionExecutionId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let actionExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionExecutionId)
        actionExecutionId = actionExecutionIdDecoded
    }
}

extension ActionContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionContext(actionExecutionId: \(String(describing: actionExecutionId)), name: \(String(describing: name)))"}
}

/// <p>Represents the context of an action in the stage of a pipeline to a job
///             worker.</p>
public struct ActionContext: Equatable {
    /// <p>The system-generated unique ID that corresponds to an action's execution.</p>
    public let actionExecutionId: String?
    /// <p>The name of the action in the context of a job.</p>
    public let name: String?

    public init (
        actionExecutionId: String? = nil,
        name: String? = nil
    )
    {
        self.actionExecutionId = actionExecutionId
        self.name = name
    }
}

extension ActionDeclaration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionTypeId
        case configuration
        case inputArtifacts
        case name
        case namespace
        case outputArtifacts
        case region
        case roleArn
        case runOrder
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionTypeId = actionTypeId {
            try encodeContainer.encode(actionTypeId, forKey: .actionTypeId)
        }
        if let configuration = configuration {
            var configurationContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .configuration)
            for (dictKey0, actionconfigurationmap0) in configuration {
                try configurationContainer.encode(actionconfigurationmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let inputArtifacts = inputArtifacts {
            var inputArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputArtifacts)
            for inputartifactlist0 in inputArtifacts {
                try inputArtifactsContainer.encode(inputartifactlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let outputArtifacts = outputArtifacts {
            var outputArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputArtifacts)
            for outputartifactlist0 in outputArtifacts {
                try outputArtifactsContainer.encode(outputartifactlist0)
            }
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let runOrder = runOrder {
            try encodeContainer.encode(runOrder, forKey: .runOrder)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let actionTypeIdDecoded = try containerValues.decodeIfPresent(ActionTypeId.self, forKey: .actionTypeId)
        actionTypeId = actionTypeIdDecoded
        let runOrderDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .runOrder)
        runOrder = runOrderDecoded
        let configurationContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .configuration)
        var configurationDecoded0: [String:String]? = nil
        if let configurationContainer = configurationContainer {
            configurationDecoded0 = [String:String]()
            for (key0, actionconfigurationvalue0) in configurationContainer {
                if let actionconfigurationvalue0 = actionconfigurationvalue0 {
                    configurationDecoded0?[key0] = actionconfigurationvalue0
                }
            }
        }
        configuration = configurationDecoded0
        let outputArtifactsContainer = try containerValues.decodeIfPresent([OutputArtifact?].self, forKey: .outputArtifacts)
        var outputArtifactsDecoded0:[OutputArtifact]? = nil
        if let outputArtifactsContainer = outputArtifactsContainer {
            outputArtifactsDecoded0 = [OutputArtifact]()
            for structure0 in outputArtifactsContainer {
                if let structure0 = structure0 {
                    outputArtifactsDecoded0?.append(structure0)
                }
            }
        }
        outputArtifacts = outputArtifactsDecoded0
        let inputArtifactsContainer = try containerValues.decodeIfPresent([InputArtifact?].self, forKey: .inputArtifacts)
        var inputArtifactsDecoded0:[InputArtifact]? = nil
        if let inputArtifactsContainer = inputArtifactsContainer {
            inputArtifactsDecoded0 = [InputArtifact]()
            for structure0 in inputArtifactsContainer {
                if let structure0 = structure0 {
                    inputArtifactsDecoded0?.append(structure0)
                }
            }
        }
        inputArtifacts = inputArtifactsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension ActionDeclaration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionDeclaration(actionTypeId: \(String(describing: actionTypeId)), configuration: \(String(describing: configuration)), inputArtifacts: \(String(describing: inputArtifacts)), name: \(String(describing: name)), namespace: \(String(describing: namespace)), outputArtifacts: \(String(describing: outputArtifacts)), region: \(String(describing: region)), roleArn: \(String(describing: roleArn)), runOrder: \(String(describing: runOrder)))"}
}

/// <p>Represents information about an action declaration.</p>
public struct ActionDeclaration: Equatable {
    /// <p>Specifies the action type and the provider of the action.</p>
    public let actionTypeId: ActionTypeId?
    /// <p>The action's configuration. These are key-value pairs that specify input values for
    ///             an action. For more information, see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html#action-requirements">Action Structure Requirements in CodePipeline</a>. For the list of
    ///             configuration properties for the AWS CloudFormation action type in CodePipeline, see
    ///                 <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-action-reference.html">Configuration Properties Reference</a> in the <i>AWS CloudFormation User
    ///                 Guide</i>. For template snippets with examples, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-parameter-override-functions.html">Using Parameter Override Functions with CodePipeline Pipelines</a> in the
    ///                 <i>AWS CloudFormation User Guide</i>.</p>
    ///         <p>The values can be represented in either JSON or YAML format. For example, the JSON
    ///             configuration item format is as follows: </p>
    ///         <p>
    ///             <i>JSON:</i>
    ///          </p>
    ///         <p>
    ///             <code>"Configuration" : { Key : Value },</code>
    ///         </p>
    public let configuration: [String:String]?
    /// <p>The name or ID of the artifact consumed by the action, such as a test or build
    ///             artifact.</p>
    public let inputArtifacts: [InputArtifact]?
    /// <p>The action declaration's name.</p>
    public let name: String?
    /// <p>The variable namespace associated with the action. All variables produced as output by
    ///             this action fall under this namespace.</p>
    public let namespace: String?
    /// <p>The name or ID of the result of the action declaration, such as a test or build
    ///             artifact.</p>
    public let outputArtifacts: [OutputArtifact]?
    /// <p>The action declaration's AWS Region, such as us-east-1.</p>
    public let region: String?
    /// <p>The ARN of the IAM service role that performs the declared action. This is assumed
    ///             through the roleArn for the pipeline.</p>
    public let roleArn: String?
    /// <p>The order in which actions are run.</p>
    public let runOrder: Int?

    public init (
        actionTypeId: ActionTypeId? = nil,
        configuration: [String:String]? = nil,
        inputArtifacts: [InputArtifact]? = nil,
        name: String? = nil,
        namespace: String? = nil,
        outputArtifacts: [OutputArtifact]? = nil,
        region: String? = nil,
        roleArn: String? = nil,
        runOrder: Int? = nil
    )
    {
        self.actionTypeId = actionTypeId
        self.configuration = configuration
        self.inputArtifacts = inputArtifacts
        self.name = name
        self.namespace = namespace
        self.outputArtifacts = outputArtifacts
        self.region = region
        self.roleArn = roleArn
        self.runOrder = runOrder
    }
}

extension ActionExecution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionExecutionId
        case errorDetails
        case externalExecutionId
        case externalExecutionUrl
        case lastStatusChange
        case lastUpdatedBy
        case percentComplete
        case status
        case summary
        case token
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionExecutionId = actionExecutionId {
            try encodeContainer.encode(actionExecutionId, forKey: .actionExecutionId)
        }
        if let errorDetails = errorDetails {
            try encodeContainer.encode(errorDetails, forKey: .errorDetails)
        }
        if let externalExecutionId = externalExecutionId {
            try encodeContainer.encode(externalExecutionId, forKey: .externalExecutionId)
        }
        if let externalExecutionUrl = externalExecutionUrl {
            try encodeContainer.encode(externalExecutionUrl, forKey: .externalExecutionUrl)
        }
        if let lastStatusChange = lastStatusChange {
            try encodeContainer.encode(lastStatusChange.timeIntervalSince1970, forKey: .lastStatusChange)
        }
        if let lastUpdatedBy = lastUpdatedBy {
            try encodeContainer.encode(lastUpdatedBy, forKey: .lastUpdatedBy)
        }
        if let percentComplete = percentComplete {
            try encodeContainer.encode(percentComplete, forKey: .percentComplete)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let summary = summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let token = token {
            try encodeContainer.encode(token, forKey: .token)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionExecutionId)
        actionExecutionId = actionExecutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ActionExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .summary)
        summary = summaryDecoded
        let lastStatusChangeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastStatusChange)
        lastStatusChange = lastStatusChangeDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .token)
        token = tokenDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
        let externalExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalExecutionId)
        externalExecutionId = externalExecutionIdDecoded
        let externalExecutionUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalExecutionUrl)
        externalExecutionUrl = externalExecutionUrlDecoded
        let percentCompleteDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .percentComplete)
        percentComplete = percentCompleteDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(ErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
    }
}

extension ActionExecution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionExecution(actionExecutionId: \(String(describing: actionExecutionId)), errorDetails: \(String(describing: errorDetails)), externalExecutionId: \(String(describing: externalExecutionId)), externalExecutionUrl: \(String(describing: externalExecutionUrl)), lastStatusChange: \(String(describing: lastStatusChange)), lastUpdatedBy: \(String(describing: lastUpdatedBy)), percentComplete: \(String(describing: percentComplete)), status: \(String(describing: status)), summary: \(String(describing: summary)), token: \(String(describing: token)))"}
}

/// <p>Represents information about the run of an action.</p>
public struct ActionExecution: Equatable {
    /// <p>ID of the workflow action execution in the current stage. Use the <a>GetPipelineState</a> action to retrieve the current action execution details
    ///             of the current stage.</p>
    ///         <note>
    ///             <p>For older executions, this field might be empty. The action execution ID is
    ///                 available for executions run on or after March 2020.</p>
    ///         </note>
    public let actionExecutionId: String?
    /// <p>The details of an error returned by a URL external to AWS.</p>
    public let errorDetails: ErrorDetails?
    /// <p>The external ID of the run of the action.</p>
    public let externalExecutionId: String?
    /// <p>The URL of a resource external to AWS that is used when running the action (for
    ///             example, an external repository URL).</p>
    public let externalExecutionUrl: String?
    /// <p>The last status change of the action.</p>
    public let lastStatusChange: Date?
    /// <p>The ARN of the user who last changed the pipeline.</p>
    public let lastUpdatedBy: String?
    /// <p>A percentage of completeness of the action as it runs.</p>
    public let percentComplete: Int?
    /// <p>The status of the action, or for a completed action, the last status of the
    ///             action.</p>
    public let status: ActionExecutionStatus?
    /// <p>A summary of the run of the action.</p>
    public let summary: String?
    /// <p>The system-generated token used to identify a unique approval request. The token
    ///             for each open approval request can be obtained using the <code>GetPipelineState</code>
    ///             command. It is used to validate that the approval request corresponding to this token is
    ///             still valid.</p>
    public let token: String?

    public init (
        actionExecutionId: String? = nil,
        errorDetails: ErrorDetails? = nil,
        externalExecutionId: String? = nil,
        externalExecutionUrl: String? = nil,
        lastStatusChange: Date? = nil,
        lastUpdatedBy: String? = nil,
        percentComplete: Int? = nil,
        status: ActionExecutionStatus? = nil,
        summary: String? = nil,
        token: String? = nil
    )
    {
        self.actionExecutionId = actionExecutionId
        self.errorDetails = errorDetails
        self.externalExecutionId = externalExecutionId
        self.externalExecutionUrl = externalExecutionUrl
        self.lastStatusChange = lastStatusChange
        self.lastUpdatedBy = lastUpdatedBy
        self.percentComplete = percentComplete
        self.status = status
        self.summary = summary
        self.token = token
    }
}

extension ActionExecutionDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionExecutionId
        case actionName
        case input
        case lastUpdateTime
        case output
        case pipelineExecutionId
        case pipelineVersion
        case stageName
        case startTime
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionExecutionId = actionExecutionId {
            try encodeContainer.encode(actionExecutionId, forKey: .actionExecutionId)
        }
        if let actionName = actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let pipelineExecutionId = pipelineExecutionId {
            try encodeContainer.encode(pipelineExecutionId, forKey: .pipelineExecutionId)
        }
        if let pipelineVersion = pipelineVersion {
            try encodeContainer.encode(pipelineVersion, forKey: .pipelineVersion)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
        let actionExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionExecutionId)
        actionExecutionId = actionExecutionIdDecoded
        let pipelineVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .pipelineVersion)
        pipelineVersion = pipelineVersionDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ActionExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let inputDecoded = try containerValues.decodeIfPresent(ActionExecutionInput.self, forKey: .input)
        input = inputDecoded
        let outputDecoded = try containerValues.decodeIfPresent(ActionExecutionOutput.self, forKey: .output)
        output = outputDecoded
    }
}

extension ActionExecutionDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionExecutionDetail(actionExecutionId: \(String(describing: actionExecutionId)), actionName: \(String(describing: actionName)), input: \(String(describing: input)), lastUpdateTime: \(String(describing: lastUpdateTime)), output: \(String(describing: output)), pipelineExecutionId: \(String(describing: pipelineExecutionId)), pipelineVersion: \(String(describing: pipelineVersion)), stageName: \(String(describing: stageName)), startTime: \(String(describing: startTime)), status: \(String(describing: status)))"}
}

/// <p>Returns information about an execution of an action, including the action execution
///             ID, and the name, version, and timing of the action. </p>
public struct ActionExecutionDetail: Equatable {
    /// <p>The action execution ID.</p>
    public let actionExecutionId: String?
    /// <p>The name of the action.</p>
    public let actionName: String?
    /// <p>Input details for the action execution, such as role ARN, Region, and input
    ///             artifacts.</p>
    public let input: ActionExecutionInput?
    /// <p>The last update time of the action execution.</p>
    public let lastUpdateTime: Date?
    /// <p>Output details for the action execution, such as the action execution result.</p>
    public let output: ActionExecutionOutput?
    /// <p>The pipeline execution ID for the action execution.</p>
    public let pipelineExecutionId: String?
    /// <p>The version of the pipeline where the action was run.</p>
    public let pipelineVersion: Int?
    /// <p>The name of the stage that contains the action.</p>
    public let stageName: String?
    /// <p>The start time of the action execution.</p>
    public let startTime: Date?
    /// <p> The status of the action execution. Status categories are <code>InProgress</code>,
    ///                 <code>Succeeded</code>, and <code>Failed</code>.</p>
    public let status: ActionExecutionStatus?

    public init (
        actionExecutionId: String? = nil,
        actionName: String? = nil,
        input: ActionExecutionInput? = nil,
        lastUpdateTime: Date? = nil,
        output: ActionExecutionOutput? = nil,
        pipelineExecutionId: String? = nil,
        pipelineVersion: Int? = nil,
        stageName: String? = nil,
        startTime: Date? = nil,
        status: ActionExecutionStatus? = nil
    )
    {
        self.actionExecutionId = actionExecutionId
        self.actionName = actionName
        self.input = input
        self.lastUpdateTime = lastUpdateTime
        self.output = output
        self.pipelineExecutionId = pipelineExecutionId
        self.pipelineVersion = pipelineVersion
        self.stageName = stageName
        self.startTime = startTime
        self.status = status
    }
}

extension ActionExecutionFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pipelineExecutionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineExecutionId = pipelineExecutionId {
            try encodeContainer.encode(pipelineExecutionId, forKey: .pipelineExecutionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
    }
}

extension ActionExecutionFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionExecutionFilter(pipelineExecutionId: \(String(describing: pipelineExecutionId)))"}
}

/// <p>Filter values for the action execution.</p>
public struct ActionExecutionFilter: Equatable {
    /// <p>The pipeline execution ID used to filter action execution history.</p>
    public let pipelineExecutionId: String?

    public init (
        pipelineExecutionId: String? = nil
    )
    {
        self.pipelineExecutionId = pipelineExecutionId
    }
}

extension ActionExecutionInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionTypeId
        case configuration
        case inputArtifacts
        case namespace
        case region
        case resolvedConfiguration
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionTypeId = actionTypeId {
            try encodeContainer.encode(actionTypeId, forKey: .actionTypeId)
        }
        if let configuration = configuration {
            var configurationContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .configuration)
            for (dictKey0, actionconfigurationmap0) in configuration {
                try configurationContainer.encode(actionconfigurationmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let inputArtifacts = inputArtifacts {
            var inputArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputArtifacts)
            for artifactdetaillist0 in inputArtifacts {
                try inputArtifactsContainer.encode(artifactdetaillist0)
            }
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resolvedConfiguration = resolvedConfiguration {
            var resolvedConfigurationContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .resolvedConfiguration)
            for (dictKey0, resolvedactionconfigurationmap0) in resolvedConfiguration {
                try resolvedConfigurationContainer.encode(resolvedactionconfigurationmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeIdDecoded = try containerValues.decodeIfPresent(ActionTypeId.self, forKey: .actionTypeId)
        actionTypeId = actionTypeIdDecoded
        let configurationContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .configuration)
        var configurationDecoded0: [String:String]? = nil
        if let configurationContainer = configurationContainer {
            configurationDecoded0 = [String:String]()
            for (key0, actionconfigurationvalue0) in configurationContainer {
                if let actionconfigurationvalue0 = actionconfigurationvalue0 {
                    configurationDecoded0?[key0] = actionconfigurationvalue0
                }
            }
        }
        configuration = configurationDecoded0
        let resolvedConfigurationContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .resolvedConfiguration)
        var resolvedConfigurationDecoded0: [String:String]? = nil
        if let resolvedConfigurationContainer = resolvedConfigurationContainer {
            resolvedConfigurationDecoded0 = [String:String]()
            for (key0, string0) in resolvedConfigurationContainer {
                if let string0 = string0 {
                    resolvedConfigurationDecoded0?[key0] = string0
                }
            }
        }
        resolvedConfiguration = resolvedConfigurationDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let inputArtifactsContainer = try containerValues.decodeIfPresent([ArtifactDetail?].self, forKey: .inputArtifacts)
        var inputArtifactsDecoded0:[ArtifactDetail]? = nil
        if let inputArtifactsContainer = inputArtifactsContainer {
            inputArtifactsDecoded0 = [ArtifactDetail]()
            for structure0 in inputArtifactsContainer {
                if let structure0 = structure0 {
                    inputArtifactsDecoded0?.append(structure0)
                }
            }
        }
        inputArtifacts = inputArtifactsDecoded0
        let namespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension ActionExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionExecutionInput(actionTypeId: \(String(describing: actionTypeId)), configuration: \(String(describing: configuration)), inputArtifacts: \(String(describing: inputArtifacts)), namespace: \(String(describing: namespace)), region: \(String(describing: region)), resolvedConfiguration: \(String(describing: resolvedConfiguration)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Input information used for an action execution.</p>
public struct ActionExecutionInput: Equatable {
    /// <p>Represents information about an action type.</p>
    public let actionTypeId: ActionTypeId?
    /// <p>Configuration data for an action execution.</p>
    public let configuration: [String:String]?
    /// <p>Details of input artifacts of the action that correspond to the action
    ///             execution.</p>
    public let inputArtifacts: [ArtifactDetail]?
    /// <p>The variable namespace associated with the action. All variables produced as output by
    ///             this action fall under this namespace.</p>
    public let namespace: String?
    /// <p>The AWS Region for the action, such as us-east-1.</p>
    public let region: String?
    /// <p>Configuration data for an action execution with all variable references replaced with
    ///             their real values for the execution.</p>
    public let resolvedConfiguration: [String:String]?
    /// <p>The ARN of the IAM service role that performs the declared action. This is assumed
    ///             through the roleArn for the pipeline. </p>
    public let roleArn: String?

    public init (
        actionTypeId: ActionTypeId? = nil,
        configuration: [String:String]? = nil,
        inputArtifacts: [ArtifactDetail]? = nil,
        namespace: String? = nil,
        region: String? = nil,
        resolvedConfiguration: [String:String]? = nil,
        roleArn: String? = nil
    )
    {
        self.actionTypeId = actionTypeId
        self.configuration = configuration
        self.inputArtifacts = inputArtifacts
        self.namespace = namespace
        self.region = region
        self.resolvedConfiguration = resolvedConfiguration
        self.roleArn = roleArn
    }
}

extension ActionExecutionOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case executionResult
        case outputArtifacts
        case outputVariables
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionResult = executionResult {
            try encodeContainer.encode(executionResult, forKey: .executionResult)
        }
        if let outputArtifacts = outputArtifacts {
            var outputArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputArtifacts)
            for artifactdetaillist0 in outputArtifacts {
                try outputArtifactsContainer.encode(artifactdetaillist0)
            }
        }
        if let outputVariables = outputVariables {
            var outputVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .outputVariables)
            for (dictKey0, outputvariablesmap0) in outputVariables {
                try outputVariablesContainer.encode(outputvariablesmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputArtifactsContainer = try containerValues.decodeIfPresent([ArtifactDetail?].self, forKey: .outputArtifacts)
        var outputArtifactsDecoded0:[ArtifactDetail]? = nil
        if let outputArtifactsContainer = outputArtifactsContainer {
            outputArtifactsDecoded0 = [ArtifactDetail]()
            for structure0 in outputArtifactsContainer {
                if let structure0 = structure0 {
                    outputArtifactsDecoded0?.append(structure0)
                }
            }
        }
        outputArtifacts = outputArtifactsDecoded0
        let executionResultDecoded = try containerValues.decodeIfPresent(ActionExecutionResult.self, forKey: .executionResult)
        executionResult = executionResultDecoded
        let outputVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .outputVariables)
        var outputVariablesDecoded0: [String:String]? = nil
        if let outputVariablesContainer = outputVariablesContainer {
            outputVariablesDecoded0 = [String:String]()
            for (key0, outputvariablesvalue0) in outputVariablesContainer {
                if let outputvariablesvalue0 = outputvariablesvalue0 {
                    outputVariablesDecoded0?[key0] = outputvariablesvalue0
                }
            }
        }
        outputVariables = outputVariablesDecoded0
    }
}

extension ActionExecutionOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionExecutionOutput(executionResult: \(String(describing: executionResult)), outputArtifacts: \(String(describing: outputArtifacts)), outputVariables: \(String(describing: outputVariables)))"}
}

/// <p>Output details listed for an action execution, such as the action execution
///             result.</p>
public struct ActionExecutionOutput: Equatable {
    /// <p>Execution result information listed in the output details for an action
    ///             execution.</p>
    public let executionResult: ActionExecutionResult?
    /// <p>Details of output artifacts of the action that correspond to the action
    ///             execution.</p>
    public let outputArtifacts: [ArtifactDetail]?
    /// <p>The outputVariables field shows the key-value pairs that were output as part of that
    ///             execution.</p>
    public let outputVariables: [String:String]?

    public init (
        executionResult: ActionExecutionResult? = nil,
        outputArtifacts: [ArtifactDetail]? = nil,
        outputVariables: [String:String]? = nil
    )
    {
        self.executionResult = executionResult
        self.outputArtifacts = outputArtifacts
        self.outputVariables = outputVariables
    }
}

extension ActionExecutionResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case externalExecutionId
        case externalExecutionSummary
        case externalExecutionUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalExecutionId = externalExecutionId {
            try encodeContainer.encode(externalExecutionId, forKey: .externalExecutionId)
        }
        if let externalExecutionSummary = externalExecutionSummary {
            try encodeContainer.encode(externalExecutionSummary, forKey: .externalExecutionSummary)
        }
        if let externalExecutionUrl = externalExecutionUrl {
            try encodeContainer.encode(externalExecutionUrl, forKey: .externalExecutionUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalExecutionId)
        externalExecutionId = externalExecutionIdDecoded
        let externalExecutionSummaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalExecutionSummary)
        externalExecutionSummary = externalExecutionSummaryDecoded
        let externalExecutionUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalExecutionUrl)
        externalExecutionUrl = externalExecutionUrlDecoded
    }
}

extension ActionExecutionResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionExecutionResult(externalExecutionId: \(String(describing: externalExecutionId)), externalExecutionSummary: \(String(describing: externalExecutionSummary)), externalExecutionUrl: \(String(describing: externalExecutionUrl)))"}
}

/// <p>Execution result information, such as the external execution ID.</p>
public struct ActionExecutionResult: Equatable {
    /// <p>The action provider's external ID for the action execution.</p>
    public let externalExecutionId: String?
    /// <p>The action provider's summary for the action execution.</p>
    public let externalExecutionSummary: String?
    /// <p>The deepest external link to the external resource (for example, a repository URL or
    ///             deployment endpoint) that is used when running the action.</p>
    public let externalExecutionUrl: String?

    public init (
        externalExecutionId: String? = nil,
        externalExecutionSummary: String? = nil,
        externalExecutionUrl: String? = nil
    )
    {
        self.externalExecutionId = externalExecutionId
        self.externalExecutionSummary = externalExecutionSummary
        self.externalExecutionUrl = externalExecutionUrl
    }
}

public enum ActionExecutionStatus {
    case abandoned
    case failed
    case inprogress
    case succeeded
    case sdkUnknown(String)
}

extension ActionExecutionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActionExecutionStatus] {
        return [
            .abandoned,
            .failed,
            .inprogress,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .abandoned: return "Abandoned"
        case .failed: return "Failed"
        case .inprogress: return "InProgress"
        case .succeeded: return "Succeeded"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActionExecutionStatus(rawValue: rawValue) ?? ActionExecutionStatus.sdkUnknown(rawValue)
    }
}

extension ActionNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionNotFoundException(message: \(String(describing: message)))"}
}

extension ActionNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ActionNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified action cannot be found.</p>
public struct ActionNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ActionNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ActionNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ActionOwner {
    case aws
    case custom
    case thirdparty
    case sdkUnknown(String)
}

extension ActionOwner : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActionOwner] {
        return [
            .aws,
            .custom,
            .thirdparty,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .aws: return "AWS"
        case .custom: return "Custom"
        case .thirdparty: return "ThirdParty"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActionOwner(rawValue: rawValue) ?? ActionOwner.sdkUnknown(rawValue)
    }
}

extension ActionRevision: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case created
        case revisionChangeId
        case revisionId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let revisionChangeId = revisionChangeId {
            try encodeContainer.encode(revisionChangeId, forKey: .revisionChangeId)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let revisionChangeIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionChangeId)
        revisionChangeId = revisionChangeIdDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
    }
}

extension ActionRevision: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionRevision(created: \(String(describing: created)), revisionChangeId: \(String(describing: revisionChangeId)), revisionId: \(String(describing: revisionId)))"}
}

/// <p>Represents information about the version (or revision) of an action.</p>
public struct ActionRevision: Equatable {
    /// <p>The date and time when the most recent version of the action was created, in
    ///             timestamp format.</p>
    public let created: Date?
    /// <p>The unique identifier of the change that set the state to this revision (for
    ///             example, a deployment ID or timestamp).</p>
    public let revisionChangeId: String?
    /// <p>The system-generated unique ID that identifies the revision number of the
    ///             action.</p>
    public let revisionId: String?

    public init (
        created: Date? = nil,
        revisionChangeId: String? = nil,
        revisionId: String? = nil
    )
    {
        self.created = created
        self.revisionChangeId = revisionChangeId
        self.revisionId = revisionId
    }
}

extension ActionState: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionName
        case currentRevision
        case entityUrl
        case latestExecution
        case revisionUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionName = actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let currentRevision = currentRevision {
            try encodeContainer.encode(currentRevision, forKey: .currentRevision)
        }
        if let entityUrl = entityUrl {
            try encodeContainer.encode(entityUrl, forKey: .entityUrl)
        }
        if let latestExecution = latestExecution {
            try encodeContainer.encode(latestExecution, forKey: .latestExecution)
        }
        if let revisionUrl = revisionUrl {
            try encodeContainer.encode(revisionUrl, forKey: .revisionUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let currentRevisionDecoded = try containerValues.decodeIfPresent(ActionRevision.self, forKey: .currentRevision)
        currentRevision = currentRevisionDecoded
        let latestExecutionDecoded = try containerValues.decodeIfPresent(ActionExecution.self, forKey: .latestExecution)
        latestExecution = latestExecutionDecoded
        let entityUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityUrl)
        entityUrl = entityUrlDecoded
        let revisionUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionUrl)
        revisionUrl = revisionUrlDecoded
    }
}

extension ActionState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionState(actionName: \(String(describing: actionName)), currentRevision: \(String(describing: currentRevision)), entityUrl: \(String(describing: entityUrl)), latestExecution: \(String(describing: latestExecution)), revisionUrl: \(String(describing: revisionUrl)))"}
}

/// <p>Represents information about the state of an action.</p>
public struct ActionState: Equatable {
    /// <p>The name of the action.</p>
    public let actionName: String?
    /// <p>Represents information about the version (or revision) of an action.</p>
    public let currentRevision: ActionRevision?
    /// <p>A URL link for more information about the state of the action, such as a deployment
    ///             group details page.</p>
    public let entityUrl: String?
    /// <p>Represents information about the run of an action.</p>
    public let latestExecution: ActionExecution?
    /// <p>A URL link for more information about the revision, such as a commit details
    ///             page.</p>
    public let revisionUrl: String?

    public init (
        actionName: String? = nil,
        currentRevision: ActionRevision? = nil,
        entityUrl: String? = nil,
        latestExecution: ActionExecution? = nil,
        revisionUrl: String? = nil
    )
    {
        self.actionName = actionName
        self.currentRevision = currentRevision
        self.entityUrl = entityUrl
        self.latestExecution = latestExecution
        self.revisionUrl = revisionUrl
    }
}

extension ActionType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionConfigurationProperties
        case id
        case inputArtifactDetails
        case outputArtifactDetails
        case settings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionConfigurationProperties = actionConfigurationProperties {
            var actionConfigurationPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actionConfigurationProperties)
            for actionconfigurationpropertylist0 in actionConfigurationProperties {
                try actionConfigurationPropertiesContainer.encode(actionconfigurationpropertylist0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let inputArtifactDetails = inputArtifactDetails {
            try encodeContainer.encode(inputArtifactDetails, forKey: .inputArtifactDetails)
        }
        if let outputArtifactDetails = outputArtifactDetails {
            try encodeContainer.encode(outputArtifactDetails, forKey: .outputArtifactDetails)
        }
        if let settings = settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(ActionTypeId.self, forKey: .id)
        id = idDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(ActionTypeSettings.self, forKey: .settings)
        settings = settingsDecoded
        let actionConfigurationPropertiesContainer = try containerValues.decodeIfPresent([ActionConfigurationProperty?].self, forKey: .actionConfigurationProperties)
        var actionConfigurationPropertiesDecoded0:[ActionConfigurationProperty]? = nil
        if let actionConfigurationPropertiesContainer = actionConfigurationPropertiesContainer {
            actionConfigurationPropertiesDecoded0 = [ActionConfigurationProperty]()
            for structure0 in actionConfigurationPropertiesContainer {
                if let structure0 = structure0 {
                    actionConfigurationPropertiesDecoded0?.append(structure0)
                }
            }
        }
        actionConfigurationProperties = actionConfigurationPropertiesDecoded0
        let inputArtifactDetailsDecoded = try containerValues.decodeIfPresent(ArtifactDetails.self, forKey: .inputArtifactDetails)
        inputArtifactDetails = inputArtifactDetailsDecoded
        let outputArtifactDetailsDecoded = try containerValues.decodeIfPresent(ArtifactDetails.self, forKey: .outputArtifactDetails)
        outputArtifactDetails = outputArtifactDetailsDecoded
    }
}

extension ActionType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionType(actionConfigurationProperties: \(String(describing: actionConfigurationProperties)), id: \(String(describing: id)), inputArtifactDetails: \(String(describing: inputArtifactDetails)), outputArtifactDetails: \(String(describing: outputArtifactDetails)), settings: \(String(describing: settings)))"}
}

/// <p>Returns information about the details of an action type.</p>
public struct ActionType: Equatable {
    /// <p>The configuration properties for the action type.</p>
    public let actionConfigurationProperties: [ActionConfigurationProperty]?
    /// <p>Represents information about an action type.</p>
    public let id: ActionTypeId?
    /// <p>The details of the input artifact for the action, such as its commit ID.</p>
    public let inputArtifactDetails: ArtifactDetails?
    /// <p>The details of the output artifact of the action, such as its commit ID.</p>
    public let outputArtifactDetails: ArtifactDetails?
    /// <p>The settings for the action type.</p>
    public let settings: ActionTypeSettings?

    public init (
        actionConfigurationProperties: [ActionConfigurationProperty]? = nil,
        id: ActionTypeId? = nil,
        inputArtifactDetails: ArtifactDetails? = nil,
        outputArtifactDetails: ArtifactDetails? = nil,
        settings: ActionTypeSettings? = nil
    )
    {
        self.actionConfigurationProperties = actionConfigurationProperties
        self.id = id
        self.inputArtifactDetails = inputArtifactDetails
        self.outputArtifactDetails = outputArtifactDetails
        self.settings = settings
    }
}

extension ActionTypeArtifactDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maximumCount
        case minimumCount
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maximumCount != 0 {
            try encodeContainer.encode(maximumCount, forKey: .maximumCount)
        }
        if minimumCount != 0 {
            try encodeContainer.encode(minimumCount, forKey: .minimumCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minimumCountDecoded = try containerValues.decode(Int.self, forKey: .minimumCount)
        minimumCount = minimumCountDecoded
        let maximumCountDecoded = try containerValues.decode(Int.self, forKey: .maximumCount)
        maximumCount = maximumCountDecoded
    }
}

extension ActionTypeArtifactDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionTypeArtifactDetails(maximumCount: \(String(describing: maximumCount)), minimumCount: \(String(describing: minimumCount)))"}
}

/// <p>Information about parameters for artifacts associated with the action type, such as
///             the minimum and maximum artifacts allowed.</p>
public struct ActionTypeArtifactDetails: Equatable {
    /// <p>The maximum number of artifacts that can be used with the actiontype. For example, you
    ///             should specify a minimum and maximum of zero input artifacts for an action type with a
    ///             category of <code>source</code>.</p>
    public let maximumCount: Int
    /// <p>The minimum number of artifacts that can be used with the action type. For example,
    ///             you should specify a minimum and maximum of zero input artifacts for an action type with
    ///             a category of <code>source</code>.</p>
    public let minimumCount: Int

    public init (
        maximumCount: Int = 0,
        minimumCount: Int = 0
    )
    {
        self.maximumCount = maximumCount
        self.minimumCount = minimumCount
    }
}

extension ActionTypeDeclaration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case executor
        case id
        case inputArtifactDetails
        case outputArtifactDetails
        case permissions
        case properties
        case urls
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let executor = executor {
            try encodeContainer.encode(executor, forKey: .executor)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let inputArtifactDetails = inputArtifactDetails {
            try encodeContainer.encode(inputArtifactDetails, forKey: .inputArtifactDetails)
        }
        if let outputArtifactDetails = outputArtifactDetails {
            try encodeContainer.encode(outputArtifactDetails, forKey: .outputArtifactDetails)
        }
        if let permissions = permissions {
            try encodeContainer.encode(permissions, forKey: .permissions)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for actiontypeproperties0 in properties {
                try propertiesContainer.encode(actiontypeproperties0)
            }
        }
        if let urls = urls {
            try encodeContainer.encode(urls, forKey: .urls)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let executorDecoded = try containerValues.decodeIfPresent(ActionTypeExecutor.self, forKey: .executor)
        executor = executorDecoded
        let idDecoded = try containerValues.decodeIfPresent(ActionTypeIdentifier.self, forKey: .id)
        id = idDecoded
        let inputArtifactDetailsDecoded = try containerValues.decodeIfPresent(ActionTypeArtifactDetails.self, forKey: .inputArtifactDetails)
        inputArtifactDetails = inputArtifactDetailsDecoded
        let outputArtifactDetailsDecoded = try containerValues.decodeIfPresent(ActionTypeArtifactDetails.self, forKey: .outputArtifactDetails)
        outputArtifactDetails = outputArtifactDetailsDecoded
        let permissionsDecoded = try containerValues.decodeIfPresent(ActionTypePermissions.self, forKey: .permissions)
        permissions = permissionsDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([ActionTypeProperty?].self, forKey: .properties)
        var propertiesDecoded0:[ActionTypeProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [ActionTypeProperty]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
        let urlsDecoded = try containerValues.decodeIfPresent(ActionTypeUrls.self, forKey: .urls)
        urls = urlsDecoded
    }
}

extension ActionTypeDeclaration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionTypeDeclaration(description: \(String(describing: description)), executor: \(String(describing: executor)), id: \(String(describing: id)), inputArtifactDetails: \(String(describing: inputArtifactDetails)), outputArtifactDetails: \(String(describing: outputArtifactDetails)), permissions: \(String(describing: permissions)), properties: \(String(describing: properties)), urls: \(String(describing: urls)))"}
}

/// <p>The parameters for the action type definition that are provided when the action type
///             is created or updated.</p>
public struct ActionTypeDeclaration: Equatable {
    /// <p>The description for the action type to be updated.</p>
    public let description: String?
    /// <p>Information about the executor for an action type that was created with any supported
    ///             integration model.</p>
    public let executor: ActionTypeExecutor?
    /// <p>The action category, owner, provider, and version of the action type to be
    ///             updated.</p>
    public let id: ActionTypeIdentifier?
    /// <p>Details for the artifacts, such as application files, to be worked on by the action.
    ///             For example, the minimum and maximum number of input artifacts allowed.</p>
    public let inputArtifactDetails: ActionTypeArtifactDetails?
    /// <p>Details for the output artifacts, such as a built application, that are the result of
    ///             the action. For example, the minimum and maximum number of output artifacts
    ///             allowed.</p>
    public let outputArtifactDetails: ActionTypeArtifactDetails?
    /// <p>Details identifying the accounts with permissions to use the action type.</p>
    public let permissions: ActionTypePermissions?
    /// <p>The properties of the action type to be updated.</p>
    public let properties: [ActionTypeProperty]?
    /// <p>The links associated with the action type to be updated.</p>
    public let urls: ActionTypeUrls?

    public init (
        description: String? = nil,
        executor: ActionTypeExecutor? = nil,
        id: ActionTypeIdentifier? = nil,
        inputArtifactDetails: ActionTypeArtifactDetails? = nil,
        outputArtifactDetails: ActionTypeArtifactDetails? = nil,
        permissions: ActionTypePermissions? = nil,
        properties: [ActionTypeProperty]? = nil,
        urls: ActionTypeUrls? = nil
    )
    {
        self.description = description
        self.executor = executor
        self.id = id
        self.inputArtifactDetails = inputArtifactDetails
        self.outputArtifactDetails = outputArtifactDetails
        self.permissions = permissions
        self.properties = properties
        self.urls = urls
    }
}

extension ActionTypeExecutor: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configuration
        case jobTimeout
        case policyStatementsTemplate
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let jobTimeout = jobTimeout {
            try encodeContainer.encode(jobTimeout, forKey: .jobTimeout)
        }
        if let policyStatementsTemplate = policyStatementsTemplate {
            try encodeContainer.encode(policyStatementsTemplate, forKey: .policyStatementsTemplate)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(ExecutorConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ExecutorType.self, forKey: .type)
        type = typeDecoded
        let policyStatementsTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyStatementsTemplate)
        policyStatementsTemplate = policyStatementsTemplateDecoded
        let jobTimeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .jobTimeout)
        jobTimeout = jobTimeoutDecoded
    }
}

extension ActionTypeExecutor: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionTypeExecutor(configuration: \(String(describing: configuration)), jobTimeout: \(String(describing: jobTimeout)), policyStatementsTemplate: \(String(describing: policyStatementsTemplate)), type: \(String(describing: type)))"}
}

/// <p>The action engine, or executor, for an action type created for a provider, where the
///             action is to be used by customers of the provider. The action engine is associated with
///             the model used to create and update the action, such as the Lambda integration
///             model.</p>
public struct ActionTypeExecutor: Equatable {
    /// <p>The action configuration properties for the action type. These properties are
    ///             specified in the action definition when the action type is created.</p>
    public let configuration: ExecutorConfiguration?
    /// <p>The timeout in seconds for the job. An action execution can have multiple jobs. This
    ///             is the timeout for a single job, not the entire action execution.</p>
    public let jobTimeout: Int?
    /// <p>The policy statement that specifies the permissions in the CodePipeline customers
    ///             account that are needed to successfully run an action.</p>
    ///         <p>To grant permission to another account, specify the account ID as the Principal, a
    ///             domain-style identifier defined by the service, for example
    ///                 <code>codepipeline.amazonaws.com</code>.</p>
    ///         <note>
    ///             <p>The size of the passed JSON policy document cannot exceed 2048 characters.</p>
    ///         </note>
    public let policyStatementsTemplate: String?
    /// <p>The integration model used to create and update the action type, <code>Lambda</code>
    ///             or <code>JobWorker</code>. </p>
    public let type: ExecutorType?

    public init (
        configuration: ExecutorConfiguration? = nil,
        jobTimeout: Int? = nil,
        policyStatementsTemplate: String? = nil,
        type: ExecutorType? = nil
    )
    {
        self.configuration = configuration
        self.jobTimeout = jobTimeout
        self.policyStatementsTemplate = policyStatementsTemplate
        self.type = type
    }
}

extension ActionTypeId: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case category
        case owner
        case provider
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let owner = owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryDecoded = try containerValues.decodeIfPresent(ActionCategory.self, forKey: .category)
        category = categoryDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(ActionOwner.self, forKey: .owner)
        owner = ownerDecoded
        let providerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provider)
        provider = providerDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension ActionTypeId: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionTypeId(category: \(String(describing: category)), owner: \(String(describing: owner)), provider: \(String(describing: provider)), version: \(String(describing: version)))"}
}

/// <p>Represents information about an action type.</p>
public struct ActionTypeId: Equatable {
    /// <p>A category defines what kind of action can be taken in the stage, and constrains
    ///             the provider type for the action. Valid categories are limited to one of the following
    ///             values. </p>
    ///         <ul>
    ///             <li>
    ///                 <p>Source</p>
    ///             </li>
    ///             <li>
    ///                 <p>Build</p>
    ///             </li>
    ///             <li>
    ///                 <p>Test</p>
    ///             </li>
    ///             <li>
    ///                 <p>Deploy</p>
    ///             </li>
    ///             <li>
    ///                 <p>Invoke</p>
    ///             </li>
    ///             <li>
    ///                 <p>Approval</p>
    ///             </li>
    ///          </ul>
    public let category: ActionCategory?
    /// <p>The creator of the action being called. There are three valid values for the
    ///                 <code>Owner</code> field in the action category section within your pipeline
    ///             structure: <code>AWS</code>, <code>ThirdParty</code>, and <code>Custom</code>. For more
    ///             information, see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html#actions-valid-providers">Valid Action Types and Providers in CodePipeline</a>.</p>
    public let owner: ActionOwner?
    /// <p>The provider of the service being called by the action. Valid providers are
    ///             determined by the action category. For example, an action in the Deploy category type
    ///             might have a provider of AWS CodeDeploy, which would be specified as CodeDeploy. For
    ///             more information, see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html#actions-valid-providers">Valid Action Types and Providers in CodePipeline</a>.</p>
    public let provider: String?
    /// <p>A string that describes the action version.</p>
    public let version: String?

    public init (
        category: ActionCategory? = nil,
        owner: ActionOwner? = nil,
        provider: String? = nil,
        version: String? = nil
    )
    {
        self.category = category
        self.owner = owner
        self.provider = provider
        self.version = version
    }
}

extension ActionTypeIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case category
        case owner
        case provider
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryDecoded = try containerValues.decodeIfPresent(ActionCategory.self, forKey: .category)
        category = categoryDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let providerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provider)
        provider = providerDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension ActionTypeIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionTypeIdentifier(category: \(String(describing: category)), owner: \(String(describing: owner)), provider: \(String(describing: provider)), version: \(String(describing: version)))"}
}

/// <p>Specifies the category, owner, provider, and version of the action type.</p>
public struct ActionTypeIdentifier: Equatable {
    /// <p>Defines what kind of action can be taken in the stage, one of the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>Source</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Build</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Test</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Deploy</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Approval</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Invoke</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let category: ActionCategory?
    /// <p>The creator of the action type being called: <code>AWS</code> or
    ///                 <code>ThirdParty</code>.</p>
    public let owner: String?
    /// <p>The provider of the action type being called. The provider name is supplied when the
    ///             action type is created.</p>
    public let provider: String?
    /// <p>A string that describes the action type version.</p>
    public let version: String?

    public init (
        category: ActionCategory? = nil,
        owner: String? = nil,
        provider: String? = nil,
        version: String? = nil
    )
    {
        self.category = category
        self.owner = owner
        self.provider = provider
        self.version = version
    }
}

extension ActionTypeNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionTypeNotFoundException(message: \(String(describing: message)))"}
}

extension ActionTypeNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ActionTypeNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified action type cannot be found.</p>
public struct ActionTypeNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ActionTypeNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ActionTypeNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ActionTypePermissions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedAccounts
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedAccounts = allowedAccounts {
            var allowedAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedAccounts)
            for allowedaccounts0 in allowedAccounts {
                try allowedAccountsContainer.encode(allowedaccounts0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedAccountsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .allowedAccounts)
        var allowedAccountsDecoded0:[String]? = nil
        if let allowedAccountsContainer = allowedAccountsContainer {
            allowedAccountsDecoded0 = [String]()
            for string0 in allowedAccountsContainer {
                if let string0 = string0 {
                    allowedAccountsDecoded0?.append(string0)
                }
            }
        }
        allowedAccounts = allowedAccountsDecoded0
    }
}

extension ActionTypePermissions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionTypePermissions(allowedAccounts: \(String(describing: allowedAccounts)))"}
}

/// <p>Details identifying the users with permissions to use the action type.</p>
public struct ActionTypePermissions: Equatable {
    /// <p>A list of AWS account IDs with access to use the action type in their
    ///             pipelines.</p>
    public let allowedAccounts: [String]?

    public init (
        allowedAccounts: [String]? = nil
    )
    {
        self.allowedAccounts = allowedAccounts
    }
}

extension ActionTypeProperty: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case key
        case name
        case noEcho
        case `optional` = "optional"
        case queryable
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if key != false {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if noEcho != false {
            try encodeContainer.encode(noEcho, forKey: .noEcho)
        }
        if `optional` != false {
            try encodeContainer.encode(`optional`, forKey: .`optional`)
        }
        if queryable != false {
            try encodeContainer.encode(queryable, forKey: .queryable)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let optionalDecoded = try containerValues.decode(Bool.self, forKey: .optional)
        `optional` = optionalDecoded
        let keyDecoded = try containerValues.decode(Bool.self, forKey: .key)
        key = keyDecoded
        let noEchoDecoded = try containerValues.decode(Bool.self, forKey: .noEcho)
        noEcho = noEchoDecoded
        let queryableDecoded = try containerValues.decode(Bool.self, forKey: .queryable)
        queryable = queryableDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ActionTypeProperty: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionTypeProperty(description: \(String(describing: description)), key: \(String(describing: key)), name: \(String(describing: name)), noEcho: \(String(describing: noEcho)), optional: \(String(describing: `optional`)), queryable: \(String(describing: queryable)))"}
}

/// <p>Represents information about each property specified in the action configuration, such
///             as the description and key name that display for the customer using the action
///             type.</p>
public struct ActionTypeProperty: Equatable {
    /// <p>Whether the configuration property is an optional value.</p>
    public let `optional`: Bool
    /// <p>The description of the property that is displayed to users.</p>
    public let description: String?
    /// <p>Whether the configuration property is a key.</p>
    public let key: Bool
    /// <p>The property name that is displayed to users.</p>
    public let name: String?
    /// <p>Whether to omit the field value entered by the customer in the log. If
    ///                 <code>true</code>, the value is not saved in CloudTrail logs for the action
    ///             execution.</p>
    public let noEcho: Bool
    /// <p>Indicates that the property is used with polling. An action type can have up to one
    ///             queryable property. If it has one, that property must be both required and not
    ///             secret.</p>
    public let queryable: Bool

    public init (
        `optional`: Bool = false,
        description: String? = nil,
        key: Bool = false,
        name: String? = nil,
        noEcho: Bool = false,
        queryable: Bool = false
    )
    {
        self.`optional` = `optional`
        self.description = description
        self.key = key
        self.name = name
        self.noEcho = noEcho
        self.queryable = queryable
    }
}

extension ActionTypeSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityUrlTemplate
        case executionUrlTemplate
        case revisionUrlTemplate
        case thirdPartyConfigurationUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityUrlTemplate = entityUrlTemplate {
            try encodeContainer.encode(entityUrlTemplate, forKey: .entityUrlTemplate)
        }
        if let executionUrlTemplate = executionUrlTemplate {
            try encodeContainer.encode(executionUrlTemplate, forKey: .executionUrlTemplate)
        }
        if let revisionUrlTemplate = revisionUrlTemplate {
            try encodeContainer.encode(revisionUrlTemplate, forKey: .revisionUrlTemplate)
        }
        if let thirdPartyConfigurationUrl = thirdPartyConfigurationUrl {
            try encodeContainer.encode(thirdPartyConfigurationUrl, forKey: .thirdPartyConfigurationUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thirdPartyConfigurationUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thirdPartyConfigurationUrl)
        thirdPartyConfigurationUrl = thirdPartyConfigurationUrlDecoded
        let entityUrlTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityUrlTemplate)
        entityUrlTemplate = entityUrlTemplateDecoded
        let executionUrlTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionUrlTemplate)
        executionUrlTemplate = executionUrlTemplateDecoded
        let revisionUrlTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionUrlTemplate)
        revisionUrlTemplate = revisionUrlTemplateDecoded
    }
}

extension ActionTypeSettings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionTypeSettings(entityUrlTemplate: \(String(describing: entityUrlTemplate)), executionUrlTemplate: \(String(describing: executionUrlTemplate)), revisionUrlTemplate: \(String(describing: revisionUrlTemplate)), thirdPartyConfigurationUrl: \(String(describing: thirdPartyConfigurationUrl)))"}
}

/// <p>Returns information about the settings for an action type.</p>
public struct ActionTypeSettings: Equatable {
    /// <p>The URL returned to the AWS CodePipeline console that provides a deep link to the
    ///             resources of the external system, such as the configuration page for an AWS CodeDeploy
    ///             deployment group. This link is provided as part of the action display in the
    ///             pipeline.</p>
    public let entityUrlTemplate: String?
    /// <p>The URL returned to the AWS CodePipeline console that contains a link to the
    ///             top-level landing page for the external system, such as the console page for AWS
    ///             CodeDeploy. This link is shown on the pipeline view page in the AWS CodePipeline console
    ///             and provides a link to the execution entity of the external action.</p>
    public let executionUrlTemplate: String?
    /// <p>The URL returned to the AWS CodePipeline console that contains a link to the page
    ///             where customers can update or change the configuration of the external action.</p>
    public let revisionUrlTemplate: String?
    /// <p>The URL of a sign-up page where users can sign up for an external service and
    ///             perform initial configuration of the action provided by that service.</p>
    public let thirdPartyConfigurationUrl: String?

    public init (
        entityUrlTemplate: String? = nil,
        executionUrlTemplate: String? = nil,
        revisionUrlTemplate: String? = nil,
        thirdPartyConfigurationUrl: String? = nil
    )
    {
        self.entityUrlTemplate = entityUrlTemplate
        self.executionUrlTemplate = executionUrlTemplate
        self.revisionUrlTemplate = revisionUrlTemplate
        self.thirdPartyConfigurationUrl = thirdPartyConfigurationUrl
    }
}

extension ActionTypeUrls: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationUrl
        case entityUrlTemplate
        case executionUrlTemplate
        case revisionUrlTemplate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationUrl = configurationUrl {
            try encodeContainer.encode(configurationUrl, forKey: .configurationUrl)
        }
        if let entityUrlTemplate = entityUrlTemplate {
            try encodeContainer.encode(entityUrlTemplate, forKey: .entityUrlTemplate)
        }
        if let executionUrlTemplate = executionUrlTemplate {
            try encodeContainer.encode(executionUrlTemplate, forKey: .executionUrlTemplate)
        }
        if let revisionUrlTemplate = revisionUrlTemplate {
            try encodeContainer.encode(revisionUrlTemplate, forKey: .revisionUrlTemplate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationUrl)
        configurationUrl = configurationUrlDecoded
        let entityUrlTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityUrlTemplate)
        entityUrlTemplate = entityUrlTemplateDecoded
        let executionUrlTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionUrlTemplate)
        executionUrlTemplate = executionUrlTemplateDecoded
        let revisionUrlTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionUrlTemplate)
        revisionUrlTemplate = revisionUrlTemplateDecoded
    }
}

extension ActionTypeUrls: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActionTypeUrls(configurationUrl: \(String(describing: configurationUrl)), entityUrlTemplate: \(String(describing: entityUrlTemplate)), executionUrlTemplate: \(String(describing: executionUrlTemplate)), revisionUrlTemplate: \(String(describing: revisionUrlTemplate)))"}
}

/// <p>Returns information about URLs for web pages that display to customers as links on the
///             pipeline view, such as an external configuration page for the action type.</p>
public struct ActionTypeUrls: Equatable {
    /// <p>The URL returned to the CodePipeline console that contains a link to the page where
    ///             customers can configure the external action.</p>
    public let configurationUrl: String?
    /// <p>The URL returned to the CodePipeline console that provides a deep link to the
    ///             resources of the external system, such as a status page. This link is provided as part
    ///             of the action display in the pipeline.</p>
    public let entityUrlTemplate: String?
    /// <p>The link to an execution page for the action type in progress. For example, for a
    ///             CodeDeploy action, this link is shown on the pipeline view page in the CodePipeline
    ///             console, and it links to a CodeDeploy status page.</p>
    public let executionUrlTemplate: String?
    /// <p>The URL returned to the CodePipeline console that contains a link to the page where
    ///             customers can update or change the configuration of the external action.</p>
    public let revisionUrlTemplate: String?

    public init (
        configurationUrl: String? = nil,
        entityUrlTemplate: String? = nil,
        executionUrlTemplate: String? = nil,
        revisionUrlTemplate: String? = nil
    )
    {
        self.configurationUrl = configurationUrl
        self.entityUrlTemplate = entityUrlTemplate
        self.executionUrlTemplate = executionUrlTemplate
        self.revisionUrlTemplate = revisionUrlTemplate
    }
}

extension ApprovalAlreadyCompletedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApprovalAlreadyCompletedException(message: \(String(describing: message)))"}
}

extension ApprovalAlreadyCompletedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ApprovalAlreadyCompletedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The approval action has already been approved or rejected.</p>
public struct ApprovalAlreadyCompletedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalAlreadyCompletedExceptionBody: Equatable {
    public let message: String?
}

extension ApprovalAlreadyCompletedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApprovalResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status
        case summary
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let summary = summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .summary)
        summary = summaryDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ApprovalStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ApprovalResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApprovalResult(status: \(String(describing: status)), summary: \(String(describing: summary)))"}
}

/// <p>Represents information about the result of an approval request.</p>
public struct ApprovalResult: Equatable {
    /// <p>The response submitted by a reviewer assigned to an approval action
    ///             request.</p>
    public let status: ApprovalStatus?
    /// <p>The summary of the current status of the approval request.</p>
    public let summary: String?

    public init (
        status: ApprovalStatus? = nil,
        summary: String? = nil
    )
    {
        self.status = status
        self.summary = summary
    }
}

public enum ApprovalStatus {
    case approved
    case rejected
    case sdkUnknown(String)
}

extension ApprovalStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ApprovalStatus] {
        return [
            .approved,
            .rejected,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .approved: return "Approved"
        case .rejected: return "Rejected"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ApprovalStatus(rawValue: rawValue) ?? ApprovalStatus.sdkUnknown(rawValue)
    }
}

extension Artifact: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case location
        case name
        case revision
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revision)
        revision = revisionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(ArtifactLocation.self, forKey: .location)
        location = locationDecoded
    }
}

extension Artifact: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Artifact(location: \(String(describing: location)), name: \(String(describing: name)), revision: \(String(describing: revision)))"}
}

/// <p>Represents information about an artifact that is worked on by actions in the
///             pipeline.</p>
public struct Artifact: Equatable {
    /// <p>The location of an artifact.</p>
    public let location: ArtifactLocation?
    /// <p>The artifact's name.</p>
    public let name: String?
    /// <p>The artifact's revision ID. Depending on the type of object, this could be a commit
    ///             ID (GitHub) or a revision ID (Amazon S3).</p>
    public let revision: String?

    public init (
        location: ArtifactLocation? = nil,
        name: String? = nil,
        revision: String? = nil
    )
    {
        self.location = location
        self.name = name
        self.revision = revision
    }
}

extension ArtifactDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case s3location
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3location = s3location {
            try encodeContainer.encode(s3location, forKey: .s3location)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let s3locationDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .s3location)
        s3location = s3locationDecoded
    }
}

extension ArtifactDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ArtifactDetail(name: \(String(describing: name)), s3location: \(String(describing: s3location)))"}
}

/// <p>Artifact details for the action execution, such as the artifact location.</p>
public struct ArtifactDetail: Equatable {
    /// <p>The artifact object name for the action execution.</p>
    public let name: String?
    /// <p>The Amazon S3 artifact location for the action execution.</p>
    public let s3location: S3Location?

    public init (
        name: String? = nil,
        s3location: S3Location? = nil
    )
    {
        self.name = name
        self.s3location = s3location
    }
}

extension ArtifactDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maximumCount
        case minimumCount
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maximumCount != 0 {
            try encodeContainer.encode(maximumCount, forKey: .maximumCount)
        }
        if minimumCount != 0 {
            try encodeContainer.encode(minimumCount, forKey: .minimumCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minimumCountDecoded = try containerValues.decode(Int.self, forKey: .minimumCount)
        minimumCount = minimumCountDecoded
        let maximumCountDecoded = try containerValues.decode(Int.self, forKey: .maximumCount)
        maximumCount = maximumCountDecoded
    }
}

extension ArtifactDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ArtifactDetails(maximumCount: \(String(describing: maximumCount)), minimumCount: \(String(describing: minimumCount)))"}
}

/// <p>Returns information about the details of an artifact.</p>
public struct ArtifactDetails: Equatable {
    /// <p>The maximum number of artifacts allowed for the action type.</p>
    public let maximumCount: Int
    /// <p>The minimum number of artifacts allowed for the action type.</p>
    public let minimumCount: Int

    public init (
        maximumCount: Int = 0,
        minimumCount: Int = 0
    )
    {
        self.maximumCount = maximumCount
        self.minimumCount = minimumCount
    }
}

extension ArtifactLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Location
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ArtifactLocationType.self, forKey: .type)
        type = typeDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(S3ArtifactLocation.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension ArtifactLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ArtifactLocation(s3Location: \(String(describing: s3Location)), type: \(String(describing: type)))"}
}

/// <p>Represents information about the location of an artifact.</p>
public struct ArtifactLocation: Equatable {
    /// <p>The S3 bucket that contains the artifact.</p>
    public let s3Location: S3ArtifactLocation?
    /// <p>The type of artifact in the location.</p>
    public let type: ArtifactLocationType?

    public init (
        s3Location: S3ArtifactLocation? = nil,
        type: ArtifactLocationType? = nil
    )
    {
        self.s3Location = s3Location
        self.type = type
    }
}

public enum ArtifactLocationType {
    case s3
    case sdkUnknown(String)
}

extension ArtifactLocationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ArtifactLocationType] {
        return [
            .s3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .s3: return "S3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ArtifactLocationType(rawValue: rawValue) ?? ArtifactLocationType.sdkUnknown(rawValue)
    }
}

extension ArtifactRevision: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case created
        case name
        case revisionChangeIdentifier
        case revisionId
        case revisionSummary
        case revisionUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let revisionChangeIdentifier = revisionChangeIdentifier {
            try encodeContainer.encode(revisionChangeIdentifier, forKey: .revisionChangeIdentifier)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let revisionSummary = revisionSummary {
            try encodeContainer.encode(revisionSummary, forKey: .revisionSummary)
        }
        if let revisionUrl = revisionUrl {
            try encodeContainer.encode(revisionUrl, forKey: .revisionUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let revisionChangeIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionChangeIdentifier)
        revisionChangeIdentifier = revisionChangeIdentifierDecoded
        let revisionSummaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionSummary)
        revisionSummary = revisionSummaryDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let revisionUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionUrl)
        revisionUrl = revisionUrlDecoded
    }
}

extension ArtifactRevision: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ArtifactRevision(created: \(String(describing: created)), name: \(String(describing: name)), revisionChangeIdentifier: \(String(describing: revisionChangeIdentifier)), revisionId: \(String(describing: revisionId)), revisionSummary: \(String(describing: revisionSummary)), revisionUrl: \(String(describing: revisionUrl)))"}
}

/// <p>Represents revision details of an artifact. </p>
public struct ArtifactRevision: Equatable {
    /// <p>The date and time when the most recent revision of the artifact was created, in
    ///             timestamp format.</p>
    public let created: Date?
    /// <p>The name of an artifact. This name might be system-generated, such as "MyApp", or
    ///             defined by the user when an action is created.</p>
    public let name: String?
    /// <p>An additional identifier for a revision, such as a commit date or, for artifacts
    ///             stored in Amazon S3 buckets, the ETag value.</p>
    public let revisionChangeIdentifier: String?
    /// <p>The revision ID of the artifact.</p>
    public let revisionId: String?
    /// <p>Summary information about the most recent revision of the artifact. For GitHub and
    ///             AWS CodeCommit repositories, the commit message. For Amazon S3 buckets or actions, the
    ///             user-provided content of a <code>codepipeline-artifact-revision-summary</code> key
    ///             specified in the object metadata.</p>
    public let revisionSummary: String?
    /// <p>The commit ID for the artifact revision. For artifacts stored in GitHub or AWS
    ///             CodeCommit repositories, the commit ID is linked to a commit details page.</p>
    public let revisionUrl: String?

    public init (
        created: Date? = nil,
        name: String? = nil,
        revisionChangeIdentifier: String? = nil,
        revisionId: String? = nil,
        revisionSummary: String? = nil,
        revisionUrl: String? = nil
    )
    {
        self.created = created
        self.name = name
        self.revisionChangeIdentifier = revisionChangeIdentifier
        self.revisionId = revisionId
        self.revisionSummary = revisionSummary
        self.revisionUrl = revisionUrl
    }
}

extension ArtifactStore: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionKey
        case location
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ArtifactStoreType.self, forKey: .type)
        type = typeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(EncryptionKey.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
    }
}

extension ArtifactStore: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ArtifactStore(encryptionKey: \(String(describing: encryptionKey)), location: \(String(describing: location)), type: \(String(describing: type)))"}
}

/// <p>The S3 bucket where artifacts for the pipeline are stored.</p>
///         <note>
///             <p>You must include either <code>artifactStore</code> or
///                     <code>artifactStores</code> in your pipeline, but you cannot use both. If you
///                 create a cross-region action in your pipeline, you must use
///                     <code>artifactStores</code>.</p>
///         </note>
public struct ArtifactStore: Equatable {
    /// <p>The encryption key used to encrypt the data in the artifact store, such as an AWS
    ///             Key Management Service (AWS KMS) key. If this is undefined, the default key for Amazon
    ///             S3 is used.</p>
    public let encryptionKey: EncryptionKey?
    /// <p>The S3 bucket used for storing the artifacts for a pipeline. You can specify the
    ///             name of an S3 bucket but not a folder in the bucket. A folder to contain the pipeline
    ///             artifacts is created for you based on the name of the pipeline. You can use any S3
    ///             bucket in the same AWS Region as the pipeline to store your pipeline
    ///             artifacts.</p>
    public let location: String?
    /// <p>The type of the artifact store, such as S3.</p>
    public let type: ArtifactStoreType?

    public init (
        encryptionKey: EncryptionKey? = nil,
        location: String? = nil,
        type: ArtifactStoreType? = nil
    )
    {
        self.encryptionKey = encryptionKey
        self.location = location
        self.type = type
    }
}

public enum ArtifactStoreType {
    case s3
    case sdkUnknown(String)
}

extension ArtifactStoreType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ArtifactStoreType] {
        return [
            .s3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .s3: return "S3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ArtifactStoreType(rawValue: rawValue) ?? ArtifactStoreType.sdkUnknown(rawValue)
    }
}

extension BlockerDeclaration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(BlockerType.self, forKey: .type)
        type = typeDecoded
    }
}

extension BlockerDeclaration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BlockerDeclaration(name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>Reserved for future use.</p>
public struct BlockerDeclaration: Equatable {
    /// <p>Reserved for future use.</p>
    public let name: String?
    /// <p>Reserved for future use.</p>
    public let type: BlockerType?

    public init (
        name: String? = nil,
        type: BlockerType? = nil
    )
    {
        self.name = name
        self.type = type
    }
}

public enum BlockerType {
    case schedule
    case sdkUnknown(String)
}

extension BlockerType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BlockerType] {
        return [
            .schedule,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .schedule: return "Schedule"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BlockerType(rawValue: rawValue) ?? BlockerType.sdkUnknown(rawValue)
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Unable to modify the tag due to a simultaneous update request.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request cannot be handled because the pipeline is busy handling ongoing
///             activities. Try again later.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateCustomActionTypeInputBodyMiddleware: Middleware {
    public let id: String = "CreateCustomActionTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomActionTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomActionTypeInput>
    public typealias MOutput = OperationOutput<CreateCustomActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomActionTypeOutputError>
}

extension CreateCustomActionTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomActionTypeInput(category: \(String(describing: category)), configurationProperties: \(String(describing: configurationProperties)), inputArtifactDetails: \(String(describing: inputArtifactDetails)), outputArtifactDetails: \(String(describing: outputArtifactDetails)), provider: \(String(describing: provider)), settings: \(String(describing: settings)), tags: \(String(describing: tags)), version: \(String(describing: version)))"}
}

extension CreateCustomActionTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case category
        case configurationProperties
        case inputArtifactDetails
        case outputArtifactDetails
        case provider
        case settings
        case tags
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let configurationProperties = configurationProperties {
            var configurationPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationProperties)
            for actionconfigurationpropertylist0 in configurationProperties {
                try configurationPropertiesContainer.encode(actionconfigurationpropertylist0)
            }
        }
        if let inputArtifactDetails = inputArtifactDetails {
            try encodeContainer.encode(inputArtifactDetails, forKey: .inputArtifactDetails)
        }
        if let outputArtifactDetails = outputArtifactDetails {
            try encodeContainer.encode(outputArtifactDetails, forKey: .outputArtifactDetails)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let settings = settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

public struct CreateCustomActionTypeInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCustomActionTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomActionTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomActionTypeInput>
    public typealias MOutput = OperationOutput<CreateCustomActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomActionTypeOutputError>
}

public struct CreateCustomActionTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCustomActionTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCustomActionTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCustomActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCustomActionTypeInput>
    public typealias MOutput = OperationOutput<CreateCustomActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCustomActionTypeOutputError>
}

/// <p>Represents the input of a CreateCustomActionType operation.</p>
public struct CreateCustomActionTypeInput: Equatable {
    /// <p>The category of the custom action, such as a build action or a test
    ///             action.</p>
    public let category: ActionCategory?
    /// <p>The configuration properties for the custom action.</p>
    ///         <note>
    ///             <p>You can refer to a name in the configuration properties of the custom action
    ///                 within the URL templates by following the format of {Config:name}, as long as the
    ///                 configuration property is both required and not secret. For more information, see
    ///                     <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/how-to-create-custom-action.html">Create a
    ///                     Custom Action for a Pipeline</a>.</p>
    ///         </note>
    public let configurationProperties: [ActionConfigurationProperty]?
    /// <p>The details of the input artifact for the action, such as its commit ID.</p>
    public let inputArtifactDetails: ArtifactDetails?
    /// <p>The details of the output artifact of the action, such as its commit ID.</p>
    public let outputArtifactDetails: ArtifactDetails?
    /// <p>The provider of the service used in the custom action, such as AWS
    ///             CodeDeploy.</p>
    public let provider: String?
    /// <p>URLs that provide users information about this custom action.</p>
    public let settings: ActionTypeSettings?
    /// <p>The tags for the custom action.</p>
    public let tags: [Tag]?
    /// <p>The version identifier of the custom action.</p>
    public let version: String?

    public init (
        category: ActionCategory? = nil,
        configurationProperties: [ActionConfigurationProperty]? = nil,
        inputArtifactDetails: ArtifactDetails? = nil,
        outputArtifactDetails: ArtifactDetails? = nil,
        provider: String? = nil,
        settings: ActionTypeSettings? = nil,
        tags: [Tag]? = nil,
        version: String? = nil
    )
    {
        self.category = category
        self.configurationProperties = configurationProperties
        self.inputArtifactDetails = inputArtifactDetails
        self.outputArtifactDetails = outputArtifactDetails
        self.provider = provider
        self.settings = settings
        self.tags = tags
        self.version = version
    }
}

struct CreateCustomActionTypeInputBody: Equatable {
    public let category: ActionCategory?
    public let provider: String?
    public let version: String?
    public let settings: ActionTypeSettings?
    public let configurationProperties: [ActionConfigurationProperty]?
    public let inputArtifactDetails: ArtifactDetails?
    public let outputArtifactDetails: ArtifactDetails?
    public let tags: [Tag]?
}

extension CreateCustomActionTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case category
        case configurationProperties
        case inputArtifactDetails
        case outputArtifactDetails
        case provider
        case settings
        case tags
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryDecoded = try containerValues.decodeIfPresent(ActionCategory.self, forKey: .category)
        category = categoryDecoded
        let providerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provider)
        provider = providerDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(ActionTypeSettings.self, forKey: .settings)
        settings = settingsDecoded
        let configurationPropertiesContainer = try containerValues.decodeIfPresent([ActionConfigurationProperty?].self, forKey: .configurationProperties)
        var configurationPropertiesDecoded0:[ActionConfigurationProperty]? = nil
        if let configurationPropertiesContainer = configurationPropertiesContainer {
            configurationPropertiesDecoded0 = [ActionConfigurationProperty]()
            for structure0 in configurationPropertiesContainer {
                if let structure0 = structure0 {
                    configurationPropertiesDecoded0?.append(structure0)
                }
            }
        }
        configurationProperties = configurationPropertiesDecoded0
        let inputArtifactDetailsDecoded = try containerValues.decodeIfPresent(ArtifactDetails.self, forKey: .inputArtifactDetails)
        inputArtifactDetails = inputArtifactDetailsDecoded
        let outputArtifactDetailsDecoded = try containerValues.decodeIfPresent(ArtifactDetails.self, forKey: .outputArtifactDetails)
        outputArtifactDetails = outputArtifactDetailsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCustomActionTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCustomActionTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagsException" : self = .invalidTagsException(try InvalidTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCustomActionTypeOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidTagsException(InvalidTagsException)
    case limitExceededException(LimitExceededException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomActionTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCustomActionTypeOutputResponse(actionType: \(String(describing: actionType)), tags: \(String(describing: tags)))"}
}

extension CreateCustomActionTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCustomActionTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actionType = output.actionType
            self.tags = output.tags
        } else {
            self.actionType = nil
            self.tags = nil
        }
    }
}

/// <p>Represents the output of a <code>CreateCustomActionType</code> operation.</p>
public struct CreateCustomActionTypeOutputResponse: Equatable {
    /// <p>Returns information about the details of an action type.</p>
    public let actionType: ActionType?
    /// <p>Specifies the tags applied to the custom action.</p>
    public let tags: [Tag]?

    public init (
        actionType: ActionType? = nil,
        tags: [Tag]? = nil
    )
    {
        self.actionType = actionType
        self.tags = tags
    }
}

struct CreateCustomActionTypeOutputResponseBody: Equatable {
    public let actionType: ActionType?
    public let tags: [Tag]?
}

extension CreateCustomActionTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionType
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(ActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreatePipelineInputBodyMiddleware: Middleware {
    public let id: String = "CreatePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePipelineInput>
    public typealias MOutput = OperationOutput<CreatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePipelineOutputError>
}

extension CreatePipelineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePipelineInput(pipeline: \(String(describing: pipeline)), tags: \(String(describing: tags)))"}
}

extension CreatePipelineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pipeline
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipeline = pipeline {
            try encodeContainer.encode(pipeline, forKey: .pipeline)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreatePipelineInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePipelineInput>
    public typealias MOutput = OperationOutput<CreatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePipelineOutputError>
}

public struct CreatePipelineInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePipelineInput>
    public typealias MOutput = OperationOutput<CreatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePipelineOutputError>
}

/// <p>Represents the input of a <code>CreatePipeline</code> action.</p>
public struct CreatePipelineInput: Equatable {
    /// <p>Represents the structure of actions and stages to be performed in the pipeline.
    ///         </p>
    public let pipeline: PipelineDeclaration?
    /// <p>The tags for the pipeline.</p>
    public let tags: [Tag]?

    public init (
        pipeline: PipelineDeclaration? = nil,
        tags: [Tag]? = nil
    )
    {
        self.pipeline = pipeline
        self.tags = tags
    }
}

struct CreatePipelineInputBody: Equatable {
    public let pipeline: PipelineDeclaration?
    public let tags: [Tag]?
}

extension CreatePipelineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipeline
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(PipelineDeclaration.self, forKey: .pipeline)
        pipeline = pipelineDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePipelineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePipelineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidActionDeclarationException" : self = .invalidActionDeclarationException(try InvalidActionDeclarationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBlockerDeclarationException" : self = .invalidBlockerDeclarationException(try InvalidBlockerDeclarationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStageDeclarationException" : self = .invalidStageDeclarationException(try InvalidStageDeclarationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStructureException" : self = .invalidStructureException(try InvalidStructureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagsException" : self = .invalidTagsException(try InvalidTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNameInUseException" : self = .pipelineNameInUseException(try PipelineNameInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePipelineOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidActionDeclarationException(InvalidActionDeclarationException)
    case invalidBlockerDeclarationException(InvalidBlockerDeclarationException)
    case invalidStageDeclarationException(InvalidStageDeclarationException)
    case invalidStructureException(InvalidStructureException)
    case invalidTagsException(InvalidTagsException)
    case limitExceededException(LimitExceededException)
    case pipelineNameInUseException(PipelineNameInUseException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePipelineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePipelineOutputResponse(pipeline: \(String(describing: pipeline)), tags: \(String(describing: tags)))"}
}

extension CreatePipelineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pipeline = output.pipeline
            self.tags = output.tags
        } else {
            self.pipeline = nil
            self.tags = nil
        }
    }
}

/// <p>Represents the output of a <code>CreatePipeline</code> action.</p>
public struct CreatePipelineOutputResponse: Equatable {
    /// <p>Represents the structure of actions and stages to be performed in the pipeline.
    ///         </p>
    public let pipeline: PipelineDeclaration?
    /// <p>Specifies the tags applied to the pipeline.</p>
    public let tags: [Tag]?

    public init (
        pipeline: PipelineDeclaration? = nil,
        tags: [Tag]? = nil
    )
    {
        self.pipeline = pipeline
        self.tags = tags
    }
}

struct CreatePipelineOutputResponseBody: Equatable {
    public let pipeline: PipelineDeclaration?
    public let tags: [Tag]?
}

extension CreatePipelineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipeline
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(PipelineDeclaration.self, forKey: .pipeline)
        pipeline = pipelineDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CurrentRevision: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changeIdentifier
        case created
        case revision
        case revisionSummary
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeIdentifier = changeIdentifier {
            try encodeContainer.encode(changeIdentifier, forKey: .changeIdentifier)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let revisionSummary = revisionSummary {
            try encodeContainer.encode(revisionSummary, forKey: .revisionSummary)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revision)
        revision = revisionDecoded
        let changeIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .changeIdentifier)
        changeIdentifier = changeIdentifierDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let revisionSummaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionSummary)
        revisionSummary = revisionSummaryDecoded
    }
}

extension CurrentRevision: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CurrentRevision(changeIdentifier: \(String(describing: changeIdentifier)), created: \(String(describing: created)), revision: \(String(describing: revision)), revisionSummary: \(String(describing: revisionSummary)))"}
}

/// <p>Represents information about a current revision.</p>
public struct CurrentRevision: Equatable {
    /// <p>The change identifier for the current revision.</p>
    public let changeIdentifier: String?
    /// <p>The date and time when the most recent revision of the artifact was created, in
    ///             timestamp format.</p>
    public let created: Date?
    /// <p>The revision ID of the current version of an artifact.</p>
    public let revision: String?
    /// <p>The summary of the most recent revision of the artifact.</p>
    public let revisionSummary: String?

    public init (
        changeIdentifier: String? = nil,
        created: Date? = nil,
        revision: String? = nil,
        revisionSummary: String? = nil
    )
    {
        self.changeIdentifier = changeIdentifier
        self.created = created
        self.revision = revision
        self.revisionSummary = revisionSummary
    }
}

public struct DeleteCustomActionTypeInputBodyMiddleware: Middleware {
    public let id: String = "DeleteCustomActionTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomActionTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomActionTypeInput>
    public typealias MOutput = OperationOutput<DeleteCustomActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomActionTypeOutputError>
}

extension DeleteCustomActionTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomActionTypeInput(category: \(String(describing: category)), provider: \(String(describing: provider)), version: \(String(describing: version)))"}
}

extension DeleteCustomActionTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case category
        case provider
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

public struct DeleteCustomActionTypeInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCustomActionTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomActionTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomActionTypeInput>
    public typealias MOutput = OperationOutput<DeleteCustomActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomActionTypeOutputError>
}

public struct DeleteCustomActionTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCustomActionTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCustomActionTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCustomActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCustomActionTypeInput>
    public typealias MOutput = OperationOutput<DeleteCustomActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCustomActionTypeOutputError>
}

/// <p>Represents the input of a <code>DeleteCustomActionType</code> operation. The custom
///             action will be marked as deleted.</p>
public struct DeleteCustomActionTypeInput: Equatable {
    /// <p>The category of the custom action that you want to delete, such as source or
    ///             deploy.</p>
    public let category: ActionCategory?
    /// <p>The provider of the service used in the custom action, such as AWS
    ///             CodeDeploy.</p>
    public let provider: String?
    /// <p>The version of the custom action to delete.</p>
    public let version: String?

    public init (
        category: ActionCategory? = nil,
        provider: String? = nil,
        version: String? = nil
    )
    {
        self.category = category
        self.provider = provider
        self.version = version
    }
}

struct DeleteCustomActionTypeInputBody: Equatable {
    public let category: ActionCategory?
    public let provider: String?
    public let version: String?
}

extension DeleteCustomActionTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case category
        case provider
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryDecoded = try containerValues.decodeIfPresent(ActionCategory.self, forKey: .category)
        category = categoryDecoded
        let providerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provider)
        provider = providerDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension DeleteCustomActionTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCustomActionTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCustomActionTypeOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomActionTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCustomActionTypeOutputResponse()"}
}

extension DeleteCustomActionTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCustomActionTypeOutputResponse: Equatable {

    public init() {}
}

struct DeleteCustomActionTypeOutputResponseBody: Equatable {
}

extension DeleteCustomActionTypeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePipelineInputBodyMiddleware: Middleware {
    public let id: String = "DeletePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePipelineInput>
    public typealias MOutput = OperationOutput<DeletePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePipelineOutputError>
}

extension DeletePipelineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePipelineInput(name: \(String(describing: name)))"}
}

extension DeletePipelineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeletePipelineInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePipelineInput>
    public typealias MOutput = OperationOutput<DeletePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePipelineOutputError>
}

public struct DeletePipelineInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePipelineInput>
    public typealias MOutput = OperationOutput<DeletePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePipelineOutputError>
}

/// <p>Represents the input of a <code>DeletePipeline</code> action.</p>
public struct DeletePipelineInput: Equatable {
    /// <p>The name of the pipeline to be deleted.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeletePipelineInputBody: Equatable {
    public let name: String?
}

extension DeletePipelineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeletePipelineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePipelineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePipelineOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePipelineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePipelineOutputResponse()"}
}

extension DeletePipelineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePipelineOutputResponse: Equatable {

    public init() {}
}

struct DeletePipelineOutputResponseBody: Equatable {
}

extension DeletePipelineOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteWebhookInputBodyMiddleware: Middleware {
    public let id: String = "DeleteWebhookInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWebhookInput>
    public typealias MOutput = OperationOutput<DeleteWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWebhookOutputError>
}

extension DeleteWebhookInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWebhookInput(name: \(String(describing: name)))"}
}

extension DeleteWebhookInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteWebhookInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteWebhookInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWebhookInput>
    public typealias MOutput = OperationOutput<DeleteWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWebhookOutputError>
}

public struct DeleteWebhookInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteWebhookInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWebhookInput>
    public typealias MOutput = OperationOutput<DeleteWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWebhookOutputError>
}

public struct DeleteWebhookInput: Equatable {
    /// <p>The name of the webhook you want to delete.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteWebhookInputBody: Equatable {
    public let name: String?
}

extension DeleteWebhookInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteWebhookOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWebhookOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWebhookOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWebhookOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWebhookOutputResponse()"}
}

extension DeleteWebhookOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWebhookOutputResponse: Equatable {

    public init() {}
}

struct DeleteWebhookOutputResponseBody: Equatable {
}

extension DeleteWebhookOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeregisterWebhookWithThirdPartyInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterWebhookWithThirdPartyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterWebhookWithThirdPartyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterWebhookWithThirdPartyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterWebhookWithThirdPartyInput>
    public typealias MOutput = OperationOutput<DeregisterWebhookWithThirdPartyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterWebhookWithThirdPartyOutputError>
}

extension DeregisterWebhookWithThirdPartyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterWebhookWithThirdPartyInput(webhookName: \(String(describing: webhookName)))"}
}

extension DeregisterWebhookWithThirdPartyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case webhookName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let webhookName = webhookName {
            try encodeContainer.encode(webhookName, forKey: .webhookName)
        }
    }
}

public struct DeregisterWebhookWithThirdPartyInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterWebhookWithThirdPartyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterWebhookWithThirdPartyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterWebhookWithThirdPartyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterWebhookWithThirdPartyInput>
    public typealias MOutput = OperationOutput<DeregisterWebhookWithThirdPartyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterWebhookWithThirdPartyOutputError>
}

public struct DeregisterWebhookWithThirdPartyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterWebhookWithThirdPartyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterWebhookWithThirdPartyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterWebhookWithThirdPartyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterWebhookWithThirdPartyInput>
    public typealias MOutput = OperationOutput<DeregisterWebhookWithThirdPartyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterWebhookWithThirdPartyOutputError>
}

public struct DeregisterWebhookWithThirdPartyInput: Equatable {
    /// <p>The name of the webhook you want to deregister.</p>
    public let webhookName: String?

    public init (
        webhookName: String? = nil
    )
    {
        self.webhookName = webhookName
    }
}

struct DeregisterWebhookWithThirdPartyInputBody: Equatable {
    public let webhookName: String?
}

extension DeregisterWebhookWithThirdPartyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case webhookName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webhookName)
        webhookName = webhookNameDecoded
    }
}

extension DeregisterWebhookWithThirdPartyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterWebhookWithThirdPartyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WebhookNotFoundException" : self = .webhookNotFoundException(try WebhookNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterWebhookWithThirdPartyOutputError: Swift.Error, Equatable {
    case validationException(ValidationException)
    case webhookNotFoundException(WebhookNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterWebhookWithThirdPartyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterWebhookWithThirdPartyOutputResponse()"}
}

extension DeregisterWebhookWithThirdPartyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterWebhookWithThirdPartyOutputResponse: Equatable {

    public init() {}
}

struct DeregisterWebhookWithThirdPartyOutputResponseBody: Equatable {
}

extension DeregisterWebhookWithThirdPartyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisableStageTransitionInputBodyMiddleware: Middleware {
    public let id: String = "DisableStageTransitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableStageTransitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableStageTransitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableStageTransitionInput>
    public typealias MOutput = OperationOutput<DisableStageTransitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableStageTransitionOutputError>
}

extension DisableStageTransitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableStageTransitionInput(pipelineName: \(String(describing: pipelineName)), reason: \(String(describing: reason)), stageName: \(String(describing: stageName)), transitionType: \(String(describing: transitionType)))"}
}

extension DisableStageTransitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pipelineName
        case reason
        case stageName
        case transitionType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let transitionType = transitionType {
            try encodeContainer.encode(transitionType.rawValue, forKey: .transitionType)
        }
    }
}

public struct DisableStageTransitionInputHeadersMiddleware: Middleware {
    public let id: String = "DisableStageTransitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableStageTransitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableStageTransitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableStageTransitionInput>
    public typealias MOutput = OperationOutput<DisableStageTransitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableStageTransitionOutputError>
}

public struct DisableStageTransitionInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableStageTransitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableStageTransitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableStageTransitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableStageTransitionInput>
    public typealias MOutput = OperationOutput<DisableStageTransitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableStageTransitionOutputError>
}

/// <p>Represents the input of a <code>DisableStageTransition</code> action.</p>
public struct DisableStageTransitionInput: Equatable {
    /// <p>The name of the pipeline in which you want to disable the flow of artifacts from
    ///             one stage to another.</p>
    public let pipelineName: String?
    /// <p>The reason given to the user that a stage is disabled, such as waiting for manual
    ///             approval or manual tests. This message is displayed in the pipeline console
    ///             UI.</p>
    public let reason: String?
    /// <p>The name of the stage where you want to disable the inbound or outbound transition
    ///             of artifacts.</p>
    public let stageName: String?
    /// <p>Specifies whether artifacts are prevented from transitioning into the stage and
    ///             being processed by the actions in that stage (inbound), or prevented from transitioning
    ///             from the stage after they have been processed by the actions in that stage
    ///             (outbound).</p>
    public let transitionType: StageTransitionType?

    public init (
        pipelineName: String? = nil,
        reason: String? = nil,
        stageName: String? = nil,
        transitionType: StageTransitionType? = nil
    )
    {
        self.pipelineName = pipelineName
        self.reason = reason
        self.stageName = stageName
        self.transitionType = transitionType
    }
}

struct DisableStageTransitionInputBody: Equatable {
    public let pipelineName: String?
    public let stageName: String?
    public let transitionType: StageTransitionType?
    public let reason: String?
}

extension DisableStageTransitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipelineName
        case reason
        case stageName
        case transitionType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let transitionTypeDecoded = try containerValues.decodeIfPresent(StageTransitionType.self, forKey: .transitionType)
        transitionType = transitionTypeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension DisableStageTransitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableStageTransitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StageNotFoundException" : self = .stageNotFoundException(try StageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableStageTransitionOutputError: Swift.Error, Equatable {
    case pipelineNotFoundException(PipelineNotFoundException)
    case stageNotFoundException(StageNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableStageTransitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableStageTransitionOutputResponse()"}
}

extension DisableStageTransitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisableStageTransitionOutputResponse: Equatable {

    public init() {}
}

struct DisableStageTransitionOutputResponseBody: Equatable {
}

extension DisableStageTransitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DuplicatedStopRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DuplicatedStopRequestException(message: \(String(describing: message)))"}
}

extension DuplicatedStopRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DuplicatedStopRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pipeline execution is already in a <code>Stopping</code> state. If you already
///             chose to stop and wait, you cannot make that request again. You can choose to stop and
///             abandon now, but be aware that this option can lead to failed tasks or out of sequence
///             tasks. If you already chose to stop and abandon, you cannot make that request
///             again.</p>
public struct DuplicatedStopRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicatedStopRequestExceptionBody: Equatable {
    public let message: String?
}

extension DuplicatedStopRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct EnableStageTransitionInputBodyMiddleware: Middleware {
    public let id: String = "EnableStageTransitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableStageTransitionInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableStageTransitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableStageTransitionInput>
    public typealias MOutput = OperationOutput<EnableStageTransitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableStageTransitionOutputError>
}

extension EnableStageTransitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableStageTransitionInput(pipelineName: \(String(describing: pipelineName)), stageName: \(String(describing: stageName)), transitionType: \(String(describing: transitionType)))"}
}

extension EnableStageTransitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pipelineName
        case stageName
        case transitionType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let transitionType = transitionType {
            try encodeContainer.encode(transitionType.rawValue, forKey: .transitionType)
        }
    }
}

public struct EnableStageTransitionInputHeadersMiddleware: Middleware {
    public let id: String = "EnableStageTransitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableStageTransitionInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableStageTransitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableStageTransitionInput>
    public typealias MOutput = OperationOutput<EnableStageTransitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableStageTransitionOutputError>
}

public struct EnableStageTransitionInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableStageTransitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableStageTransitionInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableStageTransitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableStageTransitionInput>
    public typealias MOutput = OperationOutput<EnableStageTransitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableStageTransitionOutputError>
}

/// <p>Represents the input of an <code>EnableStageTransition</code> action.</p>
public struct EnableStageTransitionInput: Equatable {
    /// <p>The name of the pipeline in which you want to enable the flow of artifacts from one
    ///             stage to another.</p>
    public let pipelineName: String?
    /// <p>The name of the stage where you want to enable the transition of artifacts, either
    ///             into the stage (inbound) or from that stage to the next stage (outbound).</p>
    public let stageName: String?
    /// <p>Specifies whether artifacts are allowed to enter the stage and be processed by the
    ///             actions in that stage (inbound) or whether already processed artifacts are allowed to
    ///             transition to the next stage (outbound).</p>
    public let transitionType: StageTransitionType?

    public init (
        pipelineName: String? = nil,
        stageName: String? = nil,
        transitionType: StageTransitionType? = nil
    )
    {
        self.pipelineName = pipelineName
        self.stageName = stageName
        self.transitionType = transitionType
    }
}

struct EnableStageTransitionInputBody: Equatable {
    public let pipelineName: String?
    public let stageName: String?
    public let transitionType: StageTransitionType?
}

extension EnableStageTransitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipelineName
        case stageName
        case transitionType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let transitionTypeDecoded = try containerValues.decodeIfPresent(StageTransitionType.self, forKey: .transitionType)
        transitionType = transitionTypeDecoded
    }
}

extension EnableStageTransitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableStageTransitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StageNotFoundException" : self = .stageNotFoundException(try StageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableStageTransitionOutputError: Swift.Error, Equatable {
    case pipelineNotFoundException(PipelineNotFoundException)
    case stageNotFoundException(StageNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableStageTransitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableStageTransitionOutputResponse()"}
}

extension EnableStageTransitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct EnableStageTransitionOutputResponse: Equatable {

    public init() {}
}

struct EnableStageTransitionOutputResponseBody: Equatable {
}

extension EnableStageTransitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension EncryptionKey: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(EncryptionKeyType.self, forKey: .type)
        type = typeDecoded
    }
}

extension EncryptionKey: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EncryptionKey(id: \(String(describing: id)), type: \(String(describing: type)))"}
}

/// <p>Represents information about the key used to encrypt data in the artifact store,
///             such as an AWS Key Management Service (AWS KMS) key.</p>
public struct EncryptionKey: Equatable {
    /// <p>The ID used to identify the key. For an AWS KMS key, you can use the key ID, the
    ///             key ARN, or the alias ARN.</p>
    ///         <note>
    ///             <p>Aliases are recognized only in the account that created the customer master key
    ///                 (CMK). For cross-account actions, you can only use the key ID or key ARN to identify
    ///                 the key.</p>
    ///         </note>
    public let id: String?
    /// <p>The type of encryption key, such as an AWS Key Management Service (AWS KMS) key.
    ///             When creating or updating a pipeline, the value must be set to 'KMS'.</p>
    public let type: EncryptionKeyType?

    public init (
        id: String? = nil,
        type: EncryptionKeyType? = nil
    )
    {
        self.id = id
        self.type = type
    }
}

public enum EncryptionKeyType {
    case kms
    case sdkUnknown(String)
}

extension EncryptionKeyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EncryptionKeyType] {
        return [
            .kms,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .kms: return "KMS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EncryptionKeyType(rawValue: rawValue) ?? EncryptionKeyType.sdkUnknown(rawValue)
    }
}

extension ErrorDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ErrorDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ErrorDetails(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

/// <p>Represents information about an error in AWS CodePipeline.</p>
public struct ErrorDetails: Equatable {
    /// <p>The system ID or number code of the error.</p>
    public let code: String?
    /// <p>The text of the error message.</p>
    public let message: String?

    public init (
        code: String? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

extension ExecutionDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case externalExecutionId
        case percentComplete
        case summary
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalExecutionId = externalExecutionId {
            try encodeContainer.encode(externalExecutionId, forKey: .externalExecutionId)
        }
        if let percentComplete = percentComplete {
            try encodeContainer.encode(percentComplete, forKey: .percentComplete)
        }
        if let summary = summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .summary)
        summary = summaryDecoded
        let externalExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalExecutionId)
        externalExecutionId = externalExecutionIdDecoded
        let percentCompleteDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .percentComplete)
        percentComplete = percentCompleteDecoded
    }
}

extension ExecutionDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecutionDetails(externalExecutionId: \(String(describing: externalExecutionId)), percentComplete: \(String(describing: percentComplete)), summary: \(String(describing: summary)))"}
}

/// <p>The details of the actions taken and results produced on an artifact as it passes
///             through stages in the pipeline.</p>
public struct ExecutionDetails: Equatable {
    /// <p>The system-generated unique ID of this action used to identify this job worker in
    ///             any external systems, such as AWS CodeDeploy.</p>
    public let externalExecutionId: String?
    /// <p>The percentage of work completed on the action, represented on a scale of 0 to 100
    ///             percent.</p>
    public let percentComplete: Int?
    /// <p>The summary of the current status of the actions.</p>
    public let summary: String?

    public init (
        externalExecutionId: String? = nil,
        percentComplete: Int? = nil,
        summary: String? = nil
    )
    {
        self.externalExecutionId = externalExecutionId
        self.percentComplete = percentComplete
        self.summary = summary
    }
}

extension ExecutionTrigger: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case triggerDetail
        case triggerType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let triggerDetail = triggerDetail {
            try encodeContainer.encode(triggerDetail, forKey: .triggerDetail)
        }
        if let triggerType = triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let triggerTypeDecoded = try containerValues.decodeIfPresent(TriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let triggerDetailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .triggerDetail)
        triggerDetail = triggerDetailDecoded
    }
}

extension ExecutionTrigger: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecutionTrigger(triggerDetail: \(String(describing: triggerDetail)), triggerType: \(String(describing: triggerType)))"}
}

/// <p>The interaction or event that started a pipeline execution.</p>
public struct ExecutionTrigger: Equatable {
    /// <p>Detail related to the event that started a pipeline execution, such as the webhook ARN
    ///             of the webhook that triggered the pipeline execution or the user ARN for a
    ///             user-initiated <code>start-pipeline-execution</code> CLI command.</p>
    public let triggerDetail: String?
    /// <p>The type of change-detection method, command, or user interaction that started a
    ///             pipeline execution.</p>
    public let triggerType: TriggerType?

    public init (
        triggerDetail: String? = nil,
        triggerType: TriggerType? = nil
    )
    {
        self.triggerDetail = triggerDetail
        self.triggerType = triggerType
    }
}

extension ExecutorConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobWorkerExecutorConfiguration
        case lambdaExecutorConfiguration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobWorkerExecutorConfiguration = jobWorkerExecutorConfiguration {
            try encodeContainer.encode(jobWorkerExecutorConfiguration, forKey: .jobWorkerExecutorConfiguration)
        }
        if let lambdaExecutorConfiguration = lambdaExecutorConfiguration {
            try encodeContainer.encode(lambdaExecutorConfiguration, forKey: .lambdaExecutorConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaExecutorConfigurationDecoded = try containerValues.decodeIfPresent(LambdaExecutorConfiguration.self, forKey: .lambdaExecutorConfiguration)
        lambdaExecutorConfiguration = lambdaExecutorConfigurationDecoded
        let jobWorkerExecutorConfigurationDecoded = try containerValues.decodeIfPresent(JobWorkerExecutorConfiguration.self, forKey: .jobWorkerExecutorConfiguration)
        jobWorkerExecutorConfiguration = jobWorkerExecutorConfigurationDecoded
    }
}

extension ExecutorConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExecutorConfiguration(jobWorkerExecutorConfiguration: \(String(describing: jobWorkerExecutorConfiguration)), lambdaExecutorConfiguration: \(String(describing: lambdaExecutorConfiguration)))"}
}

/// <p>The action engine, or executor, related to the supported integration model used to
///             create and update the action type. The available executor types are <code>Lambda</code>
///             and <code>JobWorker</code>.</p>
public struct ExecutorConfiguration: Equatable {
    /// <p>Details about the <code>JobWorker</code> executor of the action type.</p>
    public let jobWorkerExecutorConfiguration: JobWorkerExecutorConfiguration?
    /// <p>Details about the <code>Lambda</code> executor of the action type.</p>
    public let lambdaExecutorConfiguration: LambdaExecutorConfiguration?

    public init (
        jobWorkerExecutorConfiguration: JobWorkerExecutorConfiguration? = nil,
        lambdaExecutorConfiguration: LambdaExecutorConfiguration? = nil
    )
    {
        self.jobWorkerExecutorConfiguration = jobWorkerExecutorConfiguration
        self.lambdaExecutorConfiguration = lambdaExecutorConfiguration
    }
}

public enum ExecutorType {
    case jobworker
    case lambda
    case sdkUnknown(String)
}

extension ExecutorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExecutorType] {
        return [
            .jobworker,
            .lambda,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .jobworker: return "JobWorker"
        case .lambda: return "Lambda"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExecutorType(rawValue: rawValue) ?? ExecutorType.sdkUnknown(rawValue)
    }
}

extension FailureDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case externalExecutionId
        case message
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalExecutionId = externalExecutionId {
            try encodeContainer.encode(externalExecutionId, forKey: .externalExecutionId)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(FailureType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let externalExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalExecutionId)
        externalExecutionId = externalExecutionIdDecoded
    }
}

extension FailureDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailureDetails(externalExecutionId: \(String(describing: externalExecutionId)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

/// <p>Represents information about failure details.</p>
public struct FailureDetails: Equatable {
    /// <p>The external ID of the run of the action that failed.</p>
    public let externalExecutionId: String?
    /// <p>The message about the failure.</p>
    public let message: String?
    /// <p>The type of the failure.</p>
    public let type: FailureType?

    public init (
        externalExecutionId: String? = nil,
        message: String? = nil,
        type: FailureType? = nil
    )
    {
        self.externalExecutionId = externalExecutionId
        self.message = message
        self.type = type
    }
}

public enum FailureType {
    case configurationerror
    case jobfailed
    case permissionerror
    case revisionoutofsync
    case revisionunavailable
    case systemunavailable
    case sdkUnknown(String)
}

extension FailureType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FailureType] {
        return [
            .configurationerror,
            .jobfailed,
            .permissionerror,
            .revisionoutofsync,
            .revisionunavailable,
            .systemunavailable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .configurationerror: return "ConfigurationError"
        case .jobfailed: return "JobFailed"
        case .permissionerror: return "PermissionError"
        case .revisionoutofsync: return "RevisionOutOfSync"
        case .revisionunavailable: return "RevisionUnavailable"
        case .systemunavailable: return "SystemUnavailable"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FailureType(rawValue: rawValue) ?? FailureType.sdkUnknown(rawValue)
    }
}

public struct GetActionTypeInputBodyMiddleware: Middleware {
    public let id: String = "GetActionTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetActionTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetActionTypeInput>
    public typealias MOutput = OperationOutput<GetActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetActionTypeOutputError>
}

extension GetActionTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetActionTypeInput(category: \(String(describing: category)), owner: \(String(describing: owner)), provider: \(String(describing: provider)), version: \(String(describing: version)))"}
}

extension GetActionTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case category
        case owner
        case provider
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

public struct GetActionTypeInputHeadersMiddleware: Middleware {
    public let id: String = "GetActionTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetActionTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetActionTypeInput>
    public typealias MOutput = OperationOutput<GetActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetActionTypeOutputError>
}

public struct GetActionTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "GetActionTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetActionTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetActionTypeInput>
    public typealias MOutput = OperationOutput<GetActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetActionTypeOutputError>
}

public struct GetActionTypeInput: Equatable {
    /// <p>Defines what kind of action can be taken in the stage. The following are the valid
    ///             values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>Source</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Build</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Test</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Deploy</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Approval</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Invoke</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let category: ActionCategory?
    /// <p>The creator of an action type that was created with any supported integration model.
    ///             There are two valid values: <code>AWS</code> and <code>ThirdParty</code>.</p>
    public let owner: String?
    /// <p>The provider of the action type being called. The provider name is specified when the
    ///             action type is created.</p>
    public let provider: String?
    /// <p>A string that describes the action type version.</p>
    public let version: String?

    public init (
        category: ActionCategory? = nil,
        owner: String? = nil,
        provider: String? = nil,
        version: String? = nil
    )
    {
        self.category = category
        self.owner = owner
        self.provider = provider
        self.version = version
    }
}

struct GetActionTypeInputBody: Equatable {
    public let category: ActionCategory?
    public let owner: String?
    public let provider: String?
    public let version: String?
}

extension GetActionTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case category
        case owner
        case provider
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryDecoded = try containerValues.decodeIfPresent(ActionCategory.self, forKey: .category)
        category = categoryDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .owner)
        owner = ownerDecoded
        let providerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provider)
        provider = providerDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetActionTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetActionTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ActionTypeNotFoundException" : self = .actionTypeNotFoundException(try ActionTypeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetActionTypeOutputError: Swift.Error, Equatable {
    case actionTypeNotFoundException(ActionTypeNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetActionTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetActionTypeOutputResponse(actionType: \(String(describing: actionType)))"}
}

extension GetActionTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetActionTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actionType = output.actionType
        } else {
            self.actionType = nil
        }
    }
}

public struct GetActionTypeOutputResponse: Equatable {
    /// <p>The action type information for the requested action type, such as the action type
    ///             ID.</p>
    public let actionType: ActionTypeDeclaration?

    public init (
        actionType: ActionTypeDeclaration? = nil
    )
    {
        self.actionType = actionType
    }
}

struct GetActionTypeOutputResponseBody: Equatable {
    public let actionType: ActionTypeDeclaration?
}

extension GetActionTypeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(ActionTypeDeclaration.self, forKey: .actionType)
        actionType = actionTypeDecoded
    }
}

public struct GetJobDetailsInputBodyMiddleware: Middleware {
    public let id: String = "GetJobDetailsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobDetailsInput>
    public typealias MOutput = OperationOutput<GetJobDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobDetailsOutputError>
}

extension GetJobDetailsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobDetailsInput(jobId: \(String(describing: jobId)))"}
}

extension GetJobDetailsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jobId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct GetJobDetailsInputHeadersMiddleware: Middleware {
    public let id: String = "GetJobDetailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobDetailsInput>
    public typealias MOutput = OperationOutput<GetJobDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobDetailsOutputError>
}

public struct GetJobDetailsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetJobDetailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJobDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJobDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJobDetailsInput>
    public typealias MOutput = OperationOutput<GetJobDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJobDetailsOutputError>
}

/// <p>Represents the input of a <code>GetJobDetails</code> action.</p>
public struct GetJobDetailsInput: Equatable {
    /// <p>The unique system-generated ID for the job.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetJobDetailsInputBody: Equatable {
    public let jobId: String?
}

extension GetJobDetailsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension GetJobDetailsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobDetailsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobDetailsOutputError: Swift.Error, Equatable {
    case jobNotFoundException(JobNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobDetailsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJobDetailsOutputResponse(jobDetails: \(String(describing: jobDetails)))"}
}

extension GetJobDetailsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetJobDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobDetails = output.jobDetails
        } else {
            self.jobDetails = nil
        }
    }
}

/// <p>Represents the output of a <code>GetJobDetails</code> action.</p>
public struct GetJobDetailsOutputResponse: Equatable {
    /// <p>The details of the job.</p>
    ///         <note>
    ///             <p>If AWSSessionCredentials is used, a long-running job can call
    ///                     <code>GetJobDetails</code> again to obtain new credentials.</p>
    ///         </note>
    public let jobDetails: JobDetails?

    public init (
        jobDetails: JobDetails? = nil
    )
    {
        self.jobDetails = jobDetails
    }
}

struct GetJobDetailsOutputResponseBody: Equatable {
    public let jobDetails: JobDetails?
}

extension GetJobDetailsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobDetails
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDetailsDecoded = try containerValues.decodeIfPresent(JobDetails.self, forKey: .jobDetails)
        jobDetails = jobDetailsDecoded
    }
}

public struct GetPipelineExecutionInputBodyMiddleware: Middleware {
    public let id: String = "GetPipelineExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPipelineExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPipelineExecutionInput>
    public typealias MOutput = OperationOutput<GetPipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPipelineExecutionOutputError>
}

extension GetPipelineExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPipelineExecutionInput(pipelineExecutionId: \(String(describing: pipelineExecutionId)), pipelineName: \(String(describing: pipelineName)))"}
}

extension GetPipelineExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pipelineExecutionId
        case pipelineName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineExecutionId = pipelineExecutionId {
            try encodeContainer.encode(pipelineExecutionId, forKey: .pipelineExecutionId)
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
    }
}

public struct GetPipelineExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "GetPipelineExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPipelineExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPipelineExecutionInput>
    public typealias MOutput = OperationOutput<GetPipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPipelineExecutionOutputError>
}

public struct GetPipelineExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPipelineExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPipelineExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPipelineExecutionInput>
    public typealias MOutput = OperationOutput<GetPipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPipelineExecutionOutputError>
}

/// <p>Represents the input of a <code>GetPipelineExecution</code> action.</p>
public struct GetPipelineExecutionInput: Equatable {
    /// <p>The ID of the pipeline execution about which you want to get execution
    ///             details.</p>
    public let pipelineExecutionId: String?
    /// <p>The name of the pipeline about which you want to get execution details.</p>
    public let pipelineName: String?

    public init (
        pipelineExecutionId: String? = nil,
        pipelineName: String? = nil
    )
    {
        self.pipelineExecutionId = pipelineExecutionId
        self.pipelineName = pipelineName
    }
}

struct GetPipelineExecutionInputBody: Equatable {
    public let pipelineName: String?
    public let pipelineExecutionId: String?
}

extension GetPipelineExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipelineExecutionId
        case pipelineName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
    }
}

extension GetPipelineExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPipelineExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "PipelineExecutionNotFoundException" : self = .pipelineExecutionNotFoundException(try PipelineExecutionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPipelineExecutionOutputError: Swift.Error, Equatable {
    case pipelineExecutionNotFoundException(PipelineExecutionNotFoundException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPipelineExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPipelineExecutionOutputResponse(pipelineExecution: \(String(describing: pipelineExecution)))"}
}

extension GetPipelineExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPipelineExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pipelineExecution = output.pipelineExecution
        } else {
            self.pipelineExecution = nil
        }
    }
}

/// <p>Represents the output of a <code>GetPipelineExecution</code> action.</p>
public struct GetPipelineExecutionOutputResponse: Equatable {
    /// <p>Represents information about the execution of a pipeline.</p>
    public let pipelineExecution: PipelineExecution?

    public init (
        pipelineExecution: PipelineExecution? = nil
    )
    {
        self.pipelineExecution = pipelineExecution
    }
}

struct GetPipelineExecutionOutputResponseBody: Equatable {
    public let pipelineExecution: PipelineExecution?
}

extension GetPipelineExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipelineExecution
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineExecutionDecoded = try containerValues.decodeIfPresent(PipelineExecution.self, forKey: .pipelineExecution)
        pipelineExecution = pipelineExecutionDecoded
    }
}

public struct GetPipelineInputBodyMiddleware: Middleware {
    public let id: String = "GetPipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPipelineInput>
    public typealias MOutput = OperationOutput<GetPipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPipelineOutputError>
}

extension GetPipelineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPipelineInput(name: \(String(describing: name)), version: \(String(describing: version)))"}
}

extension GetPipelineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

public struct GetPipelineInputHeadersMiddleware: Middleware {
    public let id: String = "GetPipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPipelineInput>
    public typealias MOutput = OperationOutput<GetPipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPipelineOutputError>
}

public struct GetPipelineInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPipelineInput>
    public typealias MOutput = OperationOutput<GetPipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPipelineOutputError>
}

/// <p>Represents the input of a <code>GetPipeline</code> action.</p>
public struct GetPipelineInput: Equatable {
    /// <p>The name of the pipeline for which you want to get information. Pipeline names must
    ///             be unique under an AWS user account.</p>
    public let name: String?
    /// <p>The version number of the pipeline. If you do not specify a version, defaults to
    ///             the current version.</p>
    public let version: Int?

    public init (
        name: String? = nil,
        version: Int? = nil
    )
    {
        self.name = name
        self.version = version
    }
}

struct GetPipelineInputBody: Equatable {
    public let name: String?
    public let version: Int?
}

extension GetPipelineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name
        case version
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetPipelineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPipelineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineVersionNotFoundException" : self = .pipelineVersionNotFoundException(try PipelineVersionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPipelineOutputError: Swift.Error, Equatable {
    case pipelineNotFoundException(PipelineNotFoundException)
    case pipelineVersionNotFoundException(PipelineVersionNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPipelineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPipelineOutputResponse(metadata: \(String(describing: metadata)), pipeline: \(String(describing: pipeline)))"}
}

extension GetPipelineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metadata = output.metadata
            self.pipeline = output.pipeline
        } else {
            self.metadata = nil
            self.pipeline = nil
        }
    }
}

/// <p>Represents the output of a <code>GetPipeline</code> action.</p>
public struct GetPipelineOutputResponse: Equatable {
    /// <p>Represents the pipeline metadata information returned as part of the output of a
    ///                 <code>GetPipeline</code> action.</p>
    public let metadata: PipelineMetadata?
    /// <p>Represents the structure of actions and stages to be performed in the pipeline.
    ///         </p>
    public let pipeline: PipelineDeclaration?

    public init (
        metadata: PipelineMetadata? = nil,
        pipeline: PipelineDeclaration? = nil
    )
    {
        self.metadata = metadata
        self.pipeline = pipeline
    }
}

struct GetPipelineOutputResponseBody: Equatable {
    public let pipeline: PipelineDeclaration?
    public let metadata: PipelineMetadata?
}

extension GetPipelineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metadata
        case pipeline
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(PipelineDeclaration.self, forKey: .pipeline)
        pipeline = pipelineDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(PipelineMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

public struct GetPipelineStateInputBodyMiddleware: Middleware {
    public let id: String = "GetPipelineStateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPipelineStateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPipelineStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPipelineStateInput>
    public typealias MOutput = OperationOutput<GetPipelineStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPipelineStateOutputError>
}

extension GetPipelineStateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPipelineStateInput(name: \(String(describing: name)))"}
}

extension GetPipelineStateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetPipelineStateInputHeadersMiddleware: Middleware {
    public let id: String = "GetPipelineStateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPipelineStateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPipelineStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPipelineStateInput>
    public typealias MOutput = OperationOutput<GetPipelineStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPipelineStateOutputError>
}

public struct GetPipelineStateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPipelineStateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPipelineStateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPipelineStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPipelineStateInput>
    public typealias MOutput = OperationOutput<GetPipelineStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPipelineStateOutputError>
}

/// <p>Represents the input of a <code>GetPipelineState</code> action.</p>
public struct GetPipelineStateInput: Equatable {
    /// <p>The name of the pipeline about which you want to get information.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct GetPipelineStateInputBody: Equatable {
    public let name: String?
}

extension GetPipelineStateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetPipelineStateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPipelineStateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPipelineStateOutputError: Swift.Error, Equatable {
    case pipelineNotFoundException(PipelineNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPipelineStateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPipelineStateOutputResponse(created: \(String(describing: created)), pipelineName: \(String(describing: pipelineName)), pipelineVersion: \(String(describing: pipelineVersion)), stageStates: \(String(describing: stageStates)), updated: \(String(describing: updated)))"}
}

extension GetPipelineStateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPipelineStateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.created = output.created
            self.pipelineName = output.pipelineName
            self.pipelineVersion = output.pipelineVersion
            self.stageStates = output.stageStates
            self.updated = output.updated
        } else {
            self.created = nil
            self.pipelineName = nil
            self.pipelineVersion = nil
            self.stageStates = nil
            self.updated = nil
        }
    }
}

/// <p>Represents the output of a <code>GetPipelineState</code> action.</p>
public struct GetPipelineStateOutputResponse: Equatable {
    /// <p>The date and time the pipeline was created, in timestamp format.</p>
    public let created: Date?
    /// <p>The name of the pipeline for which you want to get the state.</p>
    public let pipelineName: String?
    /// <p>The version number of the pipeline.</p>
    ///         <note>
    ///             <p>A newly created pipeline is always assigned a version number of
    ///                 <code>1</code>.</p>
    ///         </note>
    public let pipelineVersion: Int?
    /// <p>A list of the pipeline stage output information, including stage name, state, most
    ///             recent run details, whether the stage is disabled, and other data.</p>
    public let stageStates: [StageState]?
    /// <p>The date and time the pipeline was last updated, in timestamp format.</p>
    public let updated: Date?

    public init (
        created: Date? = nil,
        pipelineName: String? = nil,
        pipelineVersion: Int? = nil,
        stageStates: [StageState]? = nil,
        updated: Date? = nil
    )
    {
        self.created = created
        self.pipelineName = pipelineName
        self.pipelineVersion = pipelineVersion
        self.stageStates = stageStates
        self.updated = updated
    }
}

struct GetPipelineStateOutputResponseBody: Equatable {
    public let pipelineName: String?
    public let pipelineVersion: Int?
    public let stageStates: [StageState]?
    public let created: Date?
    public let updated: Date?
}

extension GetPipelineStateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case created
        case pipelineName
        case pipelineVersion
        case stageStates
        case updated
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let pipelineVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .pipelineVersion)
        pipelineVersion = pipelineVersionDecoded
        let stageStatesContainer = try containerValues.decodeIfPresent([StageState?].self, forKey: .stageStates)
        var stageStatesDecoded0:[StageState]? = nil
        if let stageStatesContainer = stageStatesContainer {
            stageStatesDecoded0 = [StageState]()
            for structure0 in stageStatesContainer {
                if let structure0 = structure0 {
                    stageStatesDecoded0?.append(structure0)
                }
            }
        }
        stageStates = stageStatesDecoded0
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let updatedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updated)
        updated = updatedDecoded
    }
}

public struct GetThirdPartyJobDetailsInputBodyMiddleware: Middleware {
    public let id: String = "GetThirdPartyJobDetailsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetThirdPartyJobDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetThirdPartyJobDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetThirdPartyJobDetailsInput>
    public typealias MOutput = OperationOutput<GetThirdPartyJobDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetThirdPartyJobDetailsOutputError>
}

extension GetThirdPartyJobDetailsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetThirdPartyJobDetailsInput(clientToken: \(String(describing: clientToken)), jobId: \(String(describing: jobId)))"}
}

extension GetThirdPartyJobDetailsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case jobId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct GetThirdPartyJobDetailsInputHeadersMiddleware: Middleware {
    public let id: String = "GetThirdPartyJobDetailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetThirdPartyJobDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetThirdPartyJobDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetThirdPartyJobDetailsInput>
    public typealias MOutput = OperationOutput<GetThirdPartyJobDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetThirdPartyJobDetailsOutputError>
}

public struct GetThirdPartyJobDetailsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetThirdPartyJobDetailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetThirdPartyJobDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetThirdPartyJobDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetThirdPartyJobDetailsInput>
    public typealias MOutput = OperationOutput<GetThirdPartyJobDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetThirdPartyJobDetailsOutputError>
}

/// <p>Represents the input of a <code>GetThirdPartyJobDetails</code> action.</p>
public struct GetThirdPartyJobDetailsInput: Equatable {
    /// <p>The clientToken portion of the clientId and clientToken pair used to verify that
    ///             the calling entity is allowed access to the job and its details.</p>
    public let clientToken: String?
    /// <p>The unique system-generated ID used for identifying the job.</p>
    public let jobId: String?

    public init (
        clientToken: String? = nil,
        jobId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.jobId = jobId
    }
}

struct GetThirdPartyJobDetailsInputBody: Equatable {
    public let jobId: String?
    public let clientToken: String?
}

extension GetThirdPartyJobDetailsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case jobId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension GetThirdPartyJobDetailsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetThirdPartyJobDetailsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobException" : self = .invalidJobException(try InvalidJobException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetThirdPartyJobDetailsOutputError: Swift.Error, Equatable {
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidJobException(InvalidJobException)
    case jobNotFoundException(JobNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetThirdPartyJobDetailsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetThirdPartyJobDetailsOutputResponse(jobDetails: \(String(describing: jobDetails)))"}
}

extension GetThirdPartyJobDetailsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetThirdPartyJobDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobDetails = output.jobDetails
        } else {
            self.jobDetails = nil
        }
    }
}

/// <p>Represents the output of a <code>GetThirdPartyJobDetails</code> action.</p>
public struct GetThirdPartyJobDetailsOutputResponse: Equatable {
    /// <p>The details of the job, including any protected values defined for the
    ///             job.</p>
    public let jobDetails: ThirdPartyJobDetails?

    public init (
        jobDetails: ThirdPartyJobDetails? = nil
    )
    {
        self.jobDetails = jobDetails
    }
}

struct GetThirdPartyJobDetailsOutputResponseBody: Equatable {
    public let jobDetails: ThirdPartyJobDetails?
}

extension GetThirdPartyJobDetailsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobDetails
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDetailsDecoded = try containerValues.decodeIfPresent(ThirdPartyJobDetails.self, forKey: .jobDetails)
        jobDetails = jobDetailsDecoded
    }
}

extension InputArtifact: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension InputArtifact: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputArtifact(name: \(String(describing: name)))"}
}

/// <p>Represents information about an artifact to be worked on, such as a test or build
///             artifact.</p>
public struct InputArtifact: Equatable {
    /// <p>The name of the artifact to be worked on (for example, "My App").</p>
    ///         <p>The input artifact of an action must exactly match the output artifact declared in
    ///             a preceding action, but the input artifact does not have to be the next action in strict
    ///             sequence from the action that provided the output artifact. Actions in parallel can
    ///             declare different output artifacts, which are in turn consumed by different following
    ///             actions.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension InvalidActionDeclarationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidActionDeclarationException(message: \(String(describing: message)))"}
}

extension InvalidActionDeclarationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidActionDeclarationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The action declaration was specified in an invalid format.</p>
public struct InvalidActionDeclarationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidActionDeclarationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidActionDeclarationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidApprovalTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidApprovalTokenException(message: \(String(describing: message)))"}
}

extension InvalidApprovalTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidApprovalTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The approval request already received a response or has expired.</p>
public struct InvalidApprovalTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidApprovalTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidApprovalTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArnException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidArnException(message: \(String(describing: message)))"}
}

extension InvalidArnException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource ARN is invalid.</p>
public struct InvalidArnException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArnExceptionBody: Equatable {
    public let message: String?
}

extension InvalidArnExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidBlockerDeclarationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidBlockerDeclarationException(message: \(String(describing: message)))"}
}

extension InvalidBlockerDeclarationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidBlockerDeclarationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Reserved for future use.</p>
public struct InvalidBlockerDeclarationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidBlockerDeclarationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidBlockerDeclarationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClientTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidClientTokenException(message: \(String(describing: message)))"}
}

extension InvalidClientTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidClientTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The client token was specified in an invalid format</p>
public struct InvalidClientTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClientTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidClientTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidJobException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidJobException(message: \(String(describing: message)))"}
}

extension InvalidJobException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidJobExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The job was specified in an invalid format or cannot be found.</p>
public struct InvalidJobException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidJobExceptionBody: Equatable {
    public let message: String?
}

extension InvalidJobExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidJobStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidJobStateException(message: \(String(describing: message)))"}
}

extension InvalidJobStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidJobStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The job state was specified in an invalid format.</p>
public struct InvalidJobStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidJobStateExceptionBody: Equatable {
    public let message: String?
}

extension InvalidJobStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The next token was specified in an invalid format. Make sure that the next token
///             you provide is the token returned by a previous call.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNonceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNonceException(message: \(String(describing: message)))"}
}

extension InvalidNonceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNonceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The nonce was specified in an invalid format.</p>
public struct InvalidNonceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNonceExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNonceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStageDeclarationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidStageDeclarationException(message: \(String(describing: message)))"}
}

extension InvalidStageDeclarationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidStageDeclarationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The stage declaration was specified in an invalid format.</p>
public struct InvalidStageDeclarationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStageDeclarationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidStageDeclarationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStructureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidStructureException(message: \(String(describing: message)))"}
}

extension InvalidStructureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidStructureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The structure was specified in an invalid format.</p>
public struct InvalidStructureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStructureExceptionBody: Equatable {
    public let message: String?
}

extension InvalidStructureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidTagsException(message: \(String(describing: message)))"}
}

extension InvalidTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource tags are invalid.</p>
public struct InvalidTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagsExceptionBody: Equatable {
    public let message: String?
}

extension InvalidTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidWebhookAuthenticationParametersException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidWebhookAuthenticationParametersException(message: \(String(describing: message)))"}
}

extension InvalidWebhookAuthenticationParametersException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidWebhookAuthenticationParametersExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified authentication type is in an invalid format.</p>
public struct InvalidWebhookAuthenticationParametersException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidWebhookAuthenticationParametersExceptionBody: Equatable {
    public let message: String?
}

extension InvalidWebhookAuthenticationParametersExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidWebhookFilterPatternException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidWebhookFilterPatternException(message: \(String(describing: message)))"}
}

extension InvalidWebhookFilterPatternException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidWebhookFilterPatternExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified event filter rule is in an invalid format.</p>
public struct InvalidWebhookFilterPatternException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidWebhookFilterPatternExceptionBody: Equatable {
    public let message: String?
}

extension InvalidWebhookFilterPatternExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Job: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId
        case data
        case id
        case nonce
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let nonce = nonce {
            try encodeContainer.encode(nonce, forKey: .nonce)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let dataDecoded = try containerValues.decodeIfPresent(JobData.self, forKey: .data)
        data = dataDecoded
        let nonceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nonce)
        nonce = nonceDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension Job: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Job(accountId: \(String(describing: accountId)), data: \(String(describing: data)), id: \(String(describing: id)), nonce: \(String(describing: nonce)))"}
}

/// <p>Represents information about a job.</p>
public struct Job: Equatable {
    /// <p>The ID of the AWS account to use when performing the job.</p>
    public let accountId: String?
    /// <p>Other data about a job.</p>
    public let data: JobData?
    /// <p>The unique system-generated ID of the job.</p>
    public let id: String?
    /// <p>A system-generated random number that AWS CodePipeline uses to ensure that the job
    ///             is being worked on by only one job worker. Use this number in an <a>AcknowledgeJob</a> request.</p>
    public let nonce: String?

    public init (
        accountId: String? = nil,
        data: JobData? = nil,
        id: String? = nil,
        nonce: String? = nil
    )
    {
        self.accountId = accountId
        self.data = data
        self.id = id
        self.nonce = nonce
    }
}

extension JobData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionConfiguration
        case actionTypeId
        case artifactCredentials
        case continuationToken
        case encryptionKey
        case inputArtifacts
        case outputArtifacts
        case pipelineContext
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionConfiguration = actionConfiguration {
            try encodeContainer.encode(actionConfiguration, forKey: .actionConfiguration)
        }
        if let actionTypeId = actionTypeId {
            try encodeContainer.encode(actionTypeId, forKey: .actionTypeId)
        }
        if let artifactCredentials = artifactCredentials {
            try encodeContainer.encode(artifactCredentials, forKey: .artifactCredentials)
        }
        if let continuationToken = continuationToken {
            try encodeContainer.encode(continuationToken, forKey: .continuationToken)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let inputArtifacts = inputArtifacts {
            var inputArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputArtifacts)
            for artifactlist0 in inputArtifacts {
                try inputArtifactsContainer.encode(artifactlist0)
            }
        }
        if let outputArtifacts = outputArtifacts {
            var outputArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputArtifacts)
            for artifactlist0 in outputArtifacts {
                try outputArtifactsContainer.encode(artifactlist0)
            }
        }
        if let pipelineContext = pipelineContext {
            try encodeContainer.encode(pipelineContext, forKey: .pipelineContext)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeIdDecoded = try containerValues.decodeIfPresent(ActionTypeId.self, forKey: .actionTypeId)
        actionTypeId = actionTypeIdDecoded
        let actionConfigurationDecoded = try containerValues.decodeIfPresent(ActionConfiguration.self, forKey: .actionConfiguration)
        actionConfiguration = actionConfigurationDecoded
        let pipelineContextDecoded = try containerValues.decodeIfPresent(PipelineContext.self, forKey: .pipelineContext)
        pipelineContext = pipelineContextDecoded
        let inputArtifactsContainer = try containerValues.decodeIfPresent([Artifact?].self, forKey: .inputArtifacts)
        var inputArtifactsDecoded0:[Artifact]? = nil
        if let inputArtifactsContainer = inputArtifactsContainer {
            inputArtifactsDecoded0 = [Artifact]()
            for structure0 in inputArtifactsContainer {
                if let structure0 = structure0 {
                    inputArtifactsDecoded0?.append(structure0)
                }
            }
        }
        inputArtifacts = inputArtifactsDecoded0
        let outputArtifactsContainer = try containerValues.decodeIfPresent([Artifact?].self, forKey: .outputArtifacts)
        var outputArtifactsDecoded0:[Artifact]? = nil
        if let outputArtifactsContainer = outputArtifactsContainer {
            outputArtifactsDecoded0 = [Artifact]()
            for structure0 in outputArtifactsContainer {
                if let structure0 = structure0 {
                    outputArtifactsDecoded0?.append(structure0)
                }
            }
        }
        outputArtifacts = outputArtifactsDecoded0
        let artifactCredentialsDecoded = try containerValues.decodeIfPresent(AWSSessionCredentials.self, forKey: .artifactCredentials)
        artifactCredentials = artifactCredentialsDecoded
        let continuationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .continuationToken)
        continuationToken = continuationTokenDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(EncryptionKey.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
    }
}

extension JobData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobData(actionConfiguration: \(String(describing: actionConfiguration)), actionTypeId: \(String(describing: actionTypeId)), artifactCredentials: \(String(describing: artifactCredentials)), continuationToken: \(String(describing: continuationToken)), encryptionKey: \(String(describing: encryptionKey)), inputArtifacts: \(String(describing: inputArtifacts)), outputArtifacts: \(String(describing: outputArtifacts)), pipelineContext: \(String(describing: pipelineContext)))"}
}

/// <p>Represents other information about a job required for a job worker to complete the
///             job.</p>
public struct JobData: Equatable {
    /// <p>Represents information about an action configuration.</p>
    public let actionConfiguration: ActionConfiguration?
    /// <p>Represents information about an action type.</p>
    public let actionTypeId: ActionTypeId?
    /// <p>Represents an AWS session credentials object. These credentials are temporary
    ///             credentials that are issued by AWS Secure Token Service (STS). They can be used to
    ///             access input and output artifacts in the S3 bucket used to store artifacts for the
    ///             pipeline in AWS CodePipeline.</p>
    public let artifactCredentials: AWSSessionCredentials?
    /// <p>A system-generated token, such as a AWS CodeDeploy deployment ID, required by a job
    ///             to continue the job asynchronously.</p>
    public let continuationToken: String?
    /// <p>Represents information about the key used to encrypt data in the artifact store,
    ///             such as an AWS Key Management Service (AWS KMS) key. </p>
    public let encryptionKey: EncryptionKey?
    /// <p>The artifact supplied to the job.</p>
    public let inputArtifacts: [Artifact]?
    /// <p>The output of the job.</p>
    public let outputArtifacts: [Artifact]?
    /// <p>Represents information about a pipeline to a job worker.</p>
    ///         <note>
    ///             <p>Includes <code>pipelineArn</code> and <code>pipelineExecutionId</code> for
    ///                 custom jobs.</p>
    ///         </note>
    public let pipelineContext: PipelineContext?

    public init (
        actionConfiguration: ActionConfiguration? = nil,
        actionTypeId: ActionTypeId? = nil,
        artifactCredentials: AWSSessionCredentials? = nil,
        continuationToken: String? = nil,
        encryptionKey: EncryptionKey? = nil,
        inputArtifacts: [Artifact]? = nil,
        outputArtifacts: [Artifact]? = nil,
        pipelineContext: PipelineContext? = nil
    )
    {
        self.actionConfiguration = actionConfiguration
        self.actionTypeId = actionTypeId
        self.artifactCredentials = artifactCredentials
        self.continuationToken = continuationToken
        self.encryptionKey = encryptionKey
        self.inputArtifacts = inputArtifacts
        self.outputArtifacts = outputArtifacts
        self.pipelineContext = pipelineContext
    }
}

extension JobDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId
        case data
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let dataDecoded = try containerValues.decodeIfPresent(JobData.self, forKey: .data)
        data = dataDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension JobDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobDetails(accountId: \(String(describing: accountId)), data: \(String(describing: data)), id: \(String(describing: id)))"}
}

/// <p>Represents information about the details of a job.</p>
public struct JobDetails: Equatable {
    /// <p>The AWS account ID associated with the job.</p>
    public let accountId: String?
    /// <p>Represents other information about a job required for a job worker to complete the
    ///             job. </p>
    public let data: JobData?
    /// <p>The unique system-generated ID of the job.</p>
    public let id: String?

    public init (
        accountId: String? = nil,
        data: JobData? = nil,
        id: String? = nil
    )
    {
        self.accountId = accountId
        self.data = data
        self.id = id
    }
}

extension JobNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobNotFoundException(message: \(String(describing: message)))"}
}

extension JobNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: JobNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The job was specified in an invalid format or cannot be found.</p>
public struct JobNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct JobNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension JobNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum JobStatus {
    case created
    case dispatched
    case failed
    case inprogress
    case queued
    case succeeded
    case timedout
    case sdkUnknown(String)
}

extension JobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobStatus] {
        return [
            .created,
            .dispatched,
            .failed,
            .inprogress,
            .queued,
            .succeeded,
            .timedout,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .created: return "Created"
        case .dispatched: return "Dispatched"
        case .failed: return "Failed"
        case .inprogress: return "InProgress"
        case .queued: return "Queued"
        case .succeeded: return "Succeeded"
        case .timedout: return "TimedOut"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
    }
}

extension JobWorkerExecutorConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pollingAccounts
        case pollingServicePrincipals
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pollingAccounts = pollingAccounts {
            var pollingAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pollingAccounts)
            for pollingaccountlist0 in pollingAccounts {
                try pollingAccountsContainer.encode(pollingaccountlist0)
            }
        }
        if let pollingServicePrincipals = pollingServicePrincipals {
            var pollingServicePrincipalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pollingServicePrincipals)
            for pollingserviceprincipallist0 in pollingServicePrincipals {
                try pollingServicePrincipalsContainer.encode(pollingserviceprincipallist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pollingAccountsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .pollingAccounts)
        var pollingAccountsDecoded0:[String]? = nil
        if let pollingAccountsContainer = pollingAccountsContainer {
            pollingAccountsDecoded0 = [String]()
            for string0 in pollingAccountsContainer {
                if let string0 = string0 {
                    pollingAccountsDecoded0?.append(string0)
                }
            }
        }
        pollingAccounts = pollingAccountsDecoded0
        let pollingServicePrincipalsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .pollingServicePrincipals)
        var pollingServicePrincipalsDecoded0:[String]? = nil
        if let pollingServicePrincipalsContainer = pollingServicePrincipalsContainer {
            pollingServicePrincipalsDecoded0 = [String]()
            for string0 in pollingServicePrincipalsContainer {
                if let string0 = string0 {
                    pollingServicePrincipalsDecoded0?.append(string0)
                }
            }
        }
        pollingServicePrincipals = pollingServicePrincipalsDecoded0
    }
}

extension JobWorkerExecutorConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobWorkerExecutorConfiguration(pollingAccounts: \(String(describing: pollingAccounts)), pollingServicePrincipals: \(String(describing: pollingServicePrincipals)))"}
}

/// <p>Details about the polling configuration for the <code>JobWorker</code> action engine,
///             or executor.</p>
public struct JobWorkerExecutorConfiguration: Equatable {
    /// <p>The accounts in which the job worker is configured and might poll for jobs as part of
    ///             the action execution.</p>
    public let pollingAccounts: [String]?
    /// <p>The service Principals in which the job worker is configured and might poll for jobs
    ///             as part of the action execution.</p>
    public let pollingServicePrincipals: [String]?

    public init (
        pollingAccounts: [String]? = nil,
        pollingServicePrincipals: [String]? = nil
    )
    {
        self.pollingAccounts = pollingAccounts
        self.pollingServicePrincipals = pollingServicePrincipals
    }
}

extension LambdaExecutorConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lambdaFunctionArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaFunctionArn = lambdaFunctionArn {
            try encodeContainer.encode(lambdaFunctionArn, forKey: .lambdaFunctionArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaFunctionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lambdaFunctionArn)
        lambdaFunctionArn = lambdaFunctionArnDecoded
    }
}

extension LambdaExecutorConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LambdaExecutorConfiguration(lambdaFunctionArn: \(String(describing: lambdaFunctionArn)))"}
}

/// <p>Details about the configuration for the <code>Lambda</code> action engine, or
///             executor.</p>
public struct LambdaExecutorConfiguration: Equatable {
    /// <p>The ARN of the Lambda function used by the action engine.</p>
    public let lambdaFunctionArn: String?

    public init (
        lambdaFunctionArn: String? = nil
    )
    {
        self.lambdaFunctionArn = lambdaFunctionArn
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of pipelines associated with the AWS account has exceeded the limit
///             allowed for the account.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListActionExecutionsInputBodyMiddleware: Middleware {
    public let id: String = "ListActionExecutionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListActionExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListActionExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListActionExecutionsInput>
    public typealias MOutput = OperationOutput<ListActionExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListActionExecutionsOutputError>
}

extension ListActionExecutionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListActionExecutionsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), pipelineName: \(String(describing: pipelineName)))"}
}

extension ListActionExecutionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter
        case maxResults
        case nextToken
        case pipelineName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
    }
}

public struct ListActionExecutionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListActionExecutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListActionExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListActionExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListActionExecutionsInput>
    public typealias MOutput = OperationOutput<ListActionExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListActionExecutionsOutputError>
}

public struct ListActionExecutionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListActionExecutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListActionExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListActionExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListActionExecutionsInput>
    public typealias MOutput = OperationOutput<ListActionExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListActionExecutionsOutputError>
}

public struct ListActionExecutionsInput: Equatable {
    /// <p>Input information used to filter action execution history.</p>
    public let filter: ActionExecutionFilter?
    /// <p>The maximum number of results to return in a single call. To retrieve the remaining
    ///             results, make another call with the returned nextToken value. Action execution history
    ///             is retained for up to 12 months, based on action execution start times. Default value is
    ///             100. </p>
    ///         <note>
    ///             <p>Detailed execution history is available for executions run on or after February
    ///                 21, 2019.</p>
    ///         </note>
    public let maxResults: Int?
    /// <p>The token that was returned from the previous <code>ListActionExecutions</code> call,
    ///             which can be used to return the next set of action executions in the list.</p>
    public let nextToken: String?
    /// <p> The name of the pipeline for which you want to list action execution history.</p>
    public let pipelineName: String?

    public init (
        filter: ActionExecutionFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        pipelineName: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pipelineName = pipelineName
    }
}

struct ListActionExecutionsInputBody: Equatable {
    public let pipelineName: String?
    public let filter: ActionExecutionFilter?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListActionExecutionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter
        case maxResults
        case nextToken
        case pipelineName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let filterDecoded = try containerValues.decodeIfPresent(ActionExecutionFilter.self, forKey: .filter)
        filter = filterDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListActionExecutionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListActionExecutionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineExecutionNotFoundException" : self = .pipelineExecutionNotFoundException(try PipelineExecutionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListActionExecutionsOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case pipelineExecutionNotFoundException(PipelineExecutionNotFoundException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListActionExecutionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListActionExecutionsOutputResponse(actionExecutionDetails: \(String(describing: actionExecutionDetails)), nextToken: \(String(describing: nextToken)))"}
}

extension ListActionExecutionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListActionExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actionExecutionDetails = output.actionExecutionDetails
            self.nextToken = output.nextToken
        } else {
            self.actionExecutionDetails = nil
            self.nextToken = nil
        }
    }
}

public struct ListActionExecutionsOutputResponse: Equatable {
    /// <p>The details for a list of recent executions, such as action execution ID.</p>
    public let actionExecutionDetails: [ActionExecutionDetail]?
    /// <p>If the amount of returned information is significantly large, an identifier is also
    ///             returned and can be used in a subsequent <code>ListActionExecutions</code> call to
    ///             return the next set of action executions in the list.</p>
    public let nextToken: String?

    public init (
        actionExecutionDetails: [ActionExecutionDetail]? = nil,
        nextToken: String? = nil
    )
    {
        self.actionExecutionDetails = actionExecutionDetails
        self.nextToken = nextToken
    }
}

struct ListActionExecutionsOutputResponseBody: Equatable {
    public let actionExecutionDetails: [ActionExecutionDetail]?
    public let nextToken: String?
}

extension ListActionExecutionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionExecutionDetails
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionExecutionDetailsContainer = try containerValues.decodeIfPresent([ActionExecutionDetail?].self, forKey: .actionExecutionDetails)
        var actionExecutionDetailsDecoded0:[ActionExecutionDetail]? = nil
        if let actionExecutionDetailsContainer = actionExecutionDetailsContainer {
            actionExecutionDetailsDecoded0 = [ActionExecutionDetail]()
            for structure0 in actionExecutionDetailsContainer {
                if let structure0 = structure0 {
                    actionExecutionDetailsDecoded0?.append(structure0)
                }
            }
        }
        actionExecutionDetails = actionExecutionDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListActionTypesInputBodyMiddleware: Middleware {
    public let id: String = "ListActionTypesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListActionTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListActionTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListActionTypesInput>
    public typealias MOutput = OperationOutput<ListActionTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListActionTypesOutputError>
}

extension ListActionTypesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListActionTypesInput(actionOwnerFilter: \(String(describing: actionOwnerFilter)), nextToken: \(String(describing: nextToken)), regionFilter: \(String(describing: regionFilter)))"}
}

extension ListActionTypesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionOwnerFilter
        case nextToken
        case regionFilter
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionOwnerFilter = actionOwnerFilter {
            try encodeContainer.encode(actionOwnerFilter.rawValue, forKey: .actionOwnerFilter)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let regionFilter = regionFilter {
            try encodeContainer.encode(regionFilter, forKey: .regionFilter)
        }
    }
}

public struct ListActionTypesInputHeadersMiddleware: Middleware {
    public let id: String = "ListActionTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListActionTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListActionTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListActionTypesInput>
    public typealias MOutput = OperationOutput<ListActionTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListActionTypesOutputError>
}

public struct ListActionTypesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListActionTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListActionTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListActionTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListActionTypesInput>
    public typealias MOutput = OperationOutput<ListActionTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListActionTypesOutputError>
}

/// <p>Represents the input of a <code>ListActionTypes</code> action.</p>
public struct ListActionTypesInput: Equatable {
    /// <p>Filters the list of action types to those created by a specified entity.</p>
    public let actionOwnerFilter: ActionOwner?
    /// <p>An identifier that was returned from the previous list action types call, which can
    ///             be used to return the next set of action types in the list.</p>
    public let nextToken: String?
    /// <p>The Region to filter on for the list of action types.</p>
    public let regionFilter: String?

    public init (
        actionOwnerFilter: ActionOwner? = nil,
        nextToken: String? = nil,
        regionFilter: String? = nil
    )
    {
        self.actionOwnerFilter = actionOwnerFilter
        self.nextToken = nextToken
        self.regionFilter = regionFilter
    }
}

struct ListActionTypesInputBody: Equatable {
    public let actionOwnerFilter: ActionOwner?
    public let nextToken: String?
    public let regionFilter: String?
}

extension ListActionTypesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionOwnerFilter
        case nextToken
        case regionFilter
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionOwnerFilterDecoded = try containerValues.decodeIfPresent(ActionOwner.self, forKey: .actionOwnerFilter)
        actionOwnerFilter = actionOwnerFilterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let regionFilterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionFilter)
        regionFilter = regionFilterDecoded
    }
}

extension ListActionTypesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListActionTypesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListActionTypesOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListActionTypesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListActionTypesOutputResponse(actionTypes: \(String(describing: actionTypes)), nextToken: \(String(describing: nextToken)))"}
}

extension ListActionTypesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListActionTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actionTypes = output.actionTypes
            self.nextToken = output.nextToken
        } else {
            self.actionTypes = nil
            self.nextToken = nil
        }
    }
}

/// <p>Represents the output of a <code>ListActionTypes</code> action.</p>
public struct ListActionTypesOutputResponse: Equatable {
    /// <p>Provides details of the action types.</p>
    public let actionTypes: [ActionType]?
    /// <p>If the amount of returned information is significantly large, an identifier is also
    ///             returned. It can be used in a subsequent list action types call to return the next set
    ///             of action types in the list.</p>
    public let nextToken: String?

    public init (
        actionTypes: [ActionType]? = nil,
        nextToken: String? = nil
    )
    {
        self.actionTypes = actionTypes
        self.nextToken = nextToken
    }
}

struct ListActionTypesOutputResponseBody: Equatable {
    public let actionTypes: [ActionType]?
    public let nextToken: String?
}

extension ListActionTypesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionTypes
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypesContainer = try containerValues.decodeIfPresent([ActionType?].self, forKey: .actionTypes)
        var actionTypesDecoded0:[ActionType]? = nil
        if let actionTypesContainer = actionTypesContainer {
            actionTypesDecoded0 = [ActionType]()
            for structure0 in actionTypesContainer {
                if let structure0 = structure0 {
                    actionTypesDecoded0?.append(structure0)
                }
            }
        }
        actionTypes = actionTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPipelineExecutionsInputBodyMiddleware: Middleware {
    public let id: String = "ListPipelineExecutionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPipelineExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPipelineExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPipelineExecutionsInput>
    public typealias MOutput = OperationOutput<ListPipelineExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPipelineExecutionsOutputError>
}

extension ListPipelineExecutionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPipelineExecutionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), pipelineName: \(String(describing: pipelineName)))"}
}

extension ListPipelineExecutionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case pipelineName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
    }
}

public struct ListPipelineExecutionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPipelineExecutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPipelineExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPipelineExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPipelineExecutionsInput>
    public typealias MOutput = OperationOutput<ListPipelineExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPipelineExecutionsOutputError>
}

public struct ListPipelineExecutionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPipelineExecutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPipelineExecutionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPipelineExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPipelineExecutionsInput>
    public typealias MOutput = OperationOutput<ListPipelineExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPipelineExecutionsOutputError>
}

/// <p>Represents the input of a <code>ListPipelineExecutions</code> action.</p>
public struct ListPipelineExecutionsInput: Equatable {
    /// <p>The maximum number of results to return in a single call. To retrieve the remaining
    ///             results, make another call with the returned nextToken value. Pipeline history is
    ///             limited to the most recent 12 months, based on pipeline execution start times. Default
    ///             value is 100.</p>
    public let maxResults: Int?
    /// <p>The token that was returned from the previous <code>ListPipelineExecutions</code>
    ///             call, which can be used to return the next set of pipeline executions in the
    ///             list.</p>
    public let nextToken: String?
    /// <p>The name of the pipeline for which you want to get execution summary
    ///             information.</p>
    public let pipelineName: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        pipelineName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pipelineName = pipelineName
    }
}

struct ListPipelineExecutionsInputBody: Equatable {
    public let pipelineName: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListPipelineExecutionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case pipelineName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPipelineExecutionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPipelineExecutionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPipelineExecutionsOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPipelineExecutionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPipelineExecutionsOutputResponse(nextToken: \(String(describing: nextToken)), pipelineExecutionSummaries: \(String(describing: pipelineExecutionSummaries)))"}
}

extension ListPipelineExecutionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPipelineExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pipelineExecutionSummaries = output.pipelineExecutionSummaries
        } else {
            self.nextToken = nil
            self.pipelineExecutionSummaries = nil
        }
    }
}

/// <p>Represents the output of a <code>ListPipelineExecutions</code> action.</p>
public struct ListPipelineExecutionsOutputResponse: Equatable {
    /// <p>A token that can be used in the next <code>ListPipelineExecutions</code> call. To
    ///             view all items in the list, continue to call this operation with each subsequent token
    ///             until no more nextToken values are returned.</p>
    public let nextToken: String?
    /// <p>A list of executions in the history of a pipeline.</p>
    public let pipelineExecutionSummaries: [PipelineExecutionSummary]?

    public init (
        nextToken: String? = nil,
        pipelineExecutionSummaries: [PipelineExecutionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.pipelineExecutionSummaries = pipelineExecutionSummaries
    }
}

struct ListPipelineExecutionsOutputResponseBody: Equatable {
    public let pipelineExecutionSummaries: [PipelineExecutionSummary]?
    public let nextToken: String?
}

extension ListPipelineExecutionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case pipelineExecutionSummaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineExecutionSummariesContainer = try containerValues.decodeIfPresent([PipelineExecutionSummary?].self, forKey: .pipelineExecutionSummaries)
        var pipelineExecutionSummariesDecoded0:[PipelineExecutionSummary]? = nil
        if let pipelineExecutionSummariesContainer = pipelineExecutionSummariesContainer {
            pipelineExecutionSummariesDecoded0 = [PipelineExecutionSummary]()
            for structure0 in pipelineExecutionSummariesContainer {
                if let structure0 = structure0 {
                    pipelineExecutionSummariesDecoded0?.append(structure0)
                }
            }
        }
        pipelineExecutionSummaries = pipelineExecutionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPipelinesInputBodyMiddleware: Middleware {
    public let id: String = "ListPipelinesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPipelinesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPipelinesInput>
    public typealias MOutput = OperationOutput<ListPipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPipelinesOutputError>
}

extension ListPipelinesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPipelinesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPipelinesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPipelinesInputHeadersMiddleware: Middleware {
    public let id: String = "ListPipelinesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPipelinesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPipelinesInput>
    public typealias MOutput = OperationOutput<ListPipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPipelinesOutputError>
}

public struct ListPipelinesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPipelinesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPipelinesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPipelinesInput>
    public typealias MOutput = OperationOutput<ListPipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPipelinesOutputError>
}

/// <p>Represents the input of a <code>ListPipelines</code> action.</p>
public struct ListPipelinesInput: Equatable {
    /// <p>The maximum number of pipelines to return in a single call. To retrieve the remaining
    ///             pipelines, make another call with the returned nextToken value. The minimum value you
    ///             can specify is 1. The maximum accepted value is 1000.</p>
    public let maxResults: Int?
    /// <p>An identifier that was returned from the previous list pipelines call. It can be
    ///             used to return the next set of pipelines in the list.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPipelinesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListPipelinesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPipelinesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPipelinesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPipelinesOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPipelinesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPipelinesOutputResponse(nextToken: \(String(describing: nextToken)), pipelines: \(String(describing: pipelines)))"}
}

extension ListPipelinesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPipelinesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pipelines = output.pipelines
        } else {
            self.nextToken = nil
            self.pipelines = nil
        }
    }
}

/// <p>Represents the output of a <code>ListPipelines</code> action.</p>
public struct ListPipelinesOutputResponse: Equatable {
    /// <p>If the amount of returned information is significantly large, an identifier is also
    ///             returned. It can be used in a subsequent list pipelines call to return the next set of
    ///             pipelines in the list.</p>
    public let nextToken: String?
    /// <p>The list of pipelines.</p>
    public let pipelines: [PipelineSummary]?

    public init (
        nextToken: String? = nil,
        pipelines: [PipelineSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.pipelines = pipelines
    }
}

struct ListPipelinesOutputResponseBody: Equatable {
    public let pipelines: [PipelineSummary]?
    public let nextToken: String?
}

extension ListPipelinesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case pipelines
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelinesContainer = try containerValues.decodeIfPresent([PipelineSummary?].self, forKey: .pipelines)
        var pipelinesDecoded0:[PipelineSummary]? = nil
        if let pipelinesContainer = pipelinesContainer {
            pipelinesDecoded0 = [PipelineSummary]()
            for structure0 in pipelinesContainer {
                if let structure0 = structure0 {
                    pipelinesDecoded0?.append(structure0)
                }
            }
        }
        pipelines = pipelinesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The maximum number of results to return in a single call.</p>
    public let maxResults: Int?
    /// <p>The token that was returned from the previous API call, which would be used to return
    ///             the next page of the list. The ListTagsforResource call lists all available tags in one
    ///             call and does not use pagination.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the resource to get tags for.</p>
    public let resourceArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Equatable {
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>If the amount of returned information is significantly large, an identifier is also
    ///             returned and can be used in a subsequent API call to return the next page of the list.
    ///             The ListTagsforResource call lists all available tags in one call and does not use
    ///             pagination.</p>
    public let nextToken: String?
    /// <p>The tags for the resource.</p>
    public let tags: [Tag]?

    public init (
        nextToken: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let nextToken: String?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWebhookItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case definition
        case errorCode
        case errorMessage
        case lastTriggered
        case tags
        case url
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let lastTriggered = lastTriggered {
            try encodeContainer.encode(lastTriggered.timeIntervalSince1970, forKey: .lastTriggered)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(WebhookDefinition.self, forKey: .definition)
        definition = definitionDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let lastTriggeredDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastTriggered)
        lastTriggered = lastTriggeredDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListWebhookItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWebhookItem(arn: \(String(describing: arn)), definition: \(String(describing: definition)), errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), lastTriggered: \(String(describing: lastTriggered)), tags: \(String(describing: tags)), url: \(String(describing: url)))"}
}

/// <p>The detail returned for each webhook after listing webhooks, such as the webhook
///             URL, the webhook name, and the webhook ARN.</p>
public struct ListWebhookItem: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the webhook.</p>
    public let arn: String?
    /// <p>The detail returned for each webhook, such as the webhook authentication type and
    ///             filter rules.</p>
    public let definition: WebhookDefinition?
    /// <p>The number code of the error.</p>
    public let errorCode: String?
    /// <p>The text of the error message about the webhook.</p>
    public let errorMessage: String?
    /// <p>The date and time a webhook was last successfully triggered, in timestamp
    ///             format.</p>
    public let lastTriggered: Date?
    /// <p>Specifies the tags applied to the webhook.</p>
    public let tags: [Tag]?
    /// <p>A unique URL generated by CodePipeline. When a POST request is made to this URL,
    ///             the defined pipeline is started as long as the body of the post request satisfies the
    ///             defined authentication and filtering conditions. Deleting and re-creating a webhook
    ///             makes the old URL invalid and generates a new one.</p>
    public let url: String?

    public init (
        arn: String? = nil,
        definition: WebhookDefinition? = nil,
        errorCode: String? = nil,
        errorMessage: String? = nil,
        lastTriggered: Date? = nil,
        tags: [Tag]? = nil,
        url: String? = nil
    )
    {
        self.arn = arn
        self.definition = definition
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.lastTriggered = lastTriggered
        self.tags = tags
        self.url = url
    }
}

public struct ListWebhooksInputBodyMiddleware: Middleware {
    public let id: String = "ListWebhooksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWebhooksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWebhooksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWebhooksInput>
    public typealias MOutput = OperationOutput<ListWebhooksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWebhooksOutputError>
}

extension ListWebhooksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWebhooksInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListWebhooksInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListWebhooksInputHeadersMiddleware: Middleware {
    public let id: String = "ListWebhooksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWebhooksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWebhooksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWebhooksInput>
    public typealias MOutput = OperationOutput<ListWebhooksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWebhooksOutputError>
}

public struct ListWebhooksInputQueryItemMiddleware: Middleware {
    public let id: String = "ListWebhooksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWebhooksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWebhooksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWebhooksInput>
    public typealias MOutput = OperationOutput<ListWebhooksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWebhooksOutputError>
}

public struct ListWebhooksInput: Equatable {
    /// <p>The maximum number of results to return in a single call. To retrieve the remaining
    ///             results, make another call with the returned nextToken value.</p>
    public let maxResults: Int?
    /// <p>The token that was returned from the previous ListWebhooks call, which can be used
    ///             to return the next set of webhooks in the list.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWebhooksInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListWebhooksInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWebhooksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWebhooksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWebhooksOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWebhooksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWebhooksOutputResponse(nextToken: \(String(describing: nextToken)), webhooks: \(String(describing: webhooks)))"}
}

extension ListWebhooksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWebhooksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.webhooks = output.webhooks
        } else {
            self.nextToken = nil
            self.webhooks = nil
        }
    }
}

public struct ListWebhooksOutputResponse: Equatable {
    /// <p>If the amount of returned information is significantly large, an identifier is also
    ///             returned and can be used in a subsequent ListWebhooks call to return the next set of
    ///             webhooks in the list. </p>
    public let nextToken: String?
    /// <p>The JSON detail returned for each webhook in the list output for the ListWebhooks
    ///             call.</p>
    public let webhooks: [ListWebhookItem]?

    public init (
        nextToken: String? = nil,
        webhooks: [ListWebhookItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.webhooks = webhooks
    }
}

struct ListWebhooksOutputResponseBody: Equatable {
    public let webhooks: [ListWebhookItem]?
    public let nextToken: String?
}

extension ListWebhooksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case webhooks
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhooksContainer = try containerValues.decodeIfPresent([ListWebhookItem?].self, forKey: .webhooks)
        var webhooksDecoded0:[ListWebhookItem]? = nil
        if let webhooksContainer = webhooksContainer {
            webhooksDecoded0 = [ListWebhookItem]()
            for structure0 in webhooksContainer {
                if let structure0 = structure0 {
                    webhooksDecoded0?.append(structure0)
                }
            }
        }
        webhooks = webhooksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension NotLatestPipelineExecutionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotLatestPipelineExecutionException(message: \(String(describing: message)))"}
}

extension NotLatestPipelineExecutionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotLatestPipelineExecutionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The stage has failed in a later run of the pipeline and the pipelineExecutionId
///             associated with the request is out of date.</p>
public struct NotLatestPipelineExecutionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotLatestPipelineExecutionExceptionBody: Equatable {
    public let message: String?
}

extension NotLatestPipelineExecutionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OutputArtifact: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension OutputArtifact: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputArtifact(name: \(String(describing: name)))"}
}

/// <p>Represents information about the output of an action.</p>
public struct OutputArtifact: Equatable {
    /// <p>The name of the output of an artifact, such as "My App".</p>
    ///         <p>The input artifact of an action must exactly match the output artifact declared in
    ///             a preceding action, but the input artifact does not have to be the next action in strict
    ///             sequence from the action that provided the output artifact. Actions in parallel can
    ///             declare different output artifacts, which are in turn consumed by different following
    ///             actions.</p>
    ///         <p>Output artifact names must be unique within a pipeline.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension OutputVariablesSizeExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputVariablesSizeExceededException(message: \(String(describing: message)))"}
}

extension OutputVariablesSizeExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OutputVariablesSizeExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exceeded the total size limit for all variables in the pipeline.</p>
public struct OutputVariablesSizeExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OutputVariablesSizeExceededExceptionBody: Equatable {
    public let message: String?
}

extension OutputVariablesSizeExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PipelineContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
        case pipelineArn
        case pipelineExecutionId
        case pipelineName
        case stage
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let pipelineArn = pipelineArn {
            try encodeContainer.encode(pipelineArn, forKey: .pipelineArn)
        }
        if let pipelineExecutionId = pipelineExecutionId {
            try encodeContainer.encode(pipelineExecutionId, forKey: .pipelineExecutionId)
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let stage = stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let stageDecoded = try containerValues.decodeIfPresent(StageContext.self, forKey: .stage)
        stage = stageDecoded
        let actionDecoded = try containerValues.decodeIfPresent(ActionContext.self, forKey: .action)
        action = actionDecoded
        let pipelineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineArn)
        pipelineArn = pipelineArnDecoded
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
    }
}

extension PipelineContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PipelineContext(action: \(String(describing: action)), pipelineArn: \(String(describing: pipelineArn)), pipelineExecutionId: \(String(describing: pipelineExecutionId)), pipelineName: \(String(describing: pipelineName)), stage: \(String(describing: stage)))"}
}

/// <p>Represents information about a pipeline to a job worker.</p>
///         <note>
///             <p>PipelineContext contains <code>pipelineArn</code> and
///                     <code>pipelineExecutionId</code> for custom action jobs. The
///                     <code>pipelineArn</code> and <code>pipelineExecutionId</code> fields are not
///                 populated for ThirdParty action jobs.</p>
///         </note>
public struct PipelineContext: Equatable {
    /// <p>The context of an action to a job worker in the stage of a pipeline.</p>
    public let action: ActionContext?
    /// <p>The Amazon Resource Name (ARN) of the pipeline.</p>
    public let pipelineArn: String?
    /// <p>The execution ID of the pipeline.</p>
    public let pipelineExecutionId: String?
    /// <p>The name of the pipeline. This is a user-specified value. Pipeline names must be
    ///             unique across all pipeline names under an Amazon Web Services account.</p>
    public let pipelineName: String?
    /// <p>The stage of the pipeline.</p>
    public let stage: StageContext?

    public init (
        action: ActionContext? = nil,
        pipelineArn: String? = nil,
        pipelineExecutionId: String? = nil,
        pipelineName: String? = nil,
        stage: StageContext? = nil
    )
    {
        self.action = action
        self.pipelineArn = pipelineArn
        self.pipelineExecutionId = pipelineExecutionId
        self.pipelineName = pipelineName
        self.stage = stage
    }
}

extension PipelineDeclaration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifactStore
        case artifactStores
        case name
        case roleArn
        case stages
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactStore = artifactStore {
            try encodeContainer.encode(artifactStore, forKey: .artifactStore)
        }
        if let artifactStores = artifactStores {
            var artifactStoresContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .artifactStores)
            for (dictKey0, artifactstoremap0) in artifactStores {
                try artifactStoresContainer.encode(artifactstoremap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stages = stages {
            var stagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stages)
            for pipelinestagedeclarationlist0 in stages {
                try stagesContainer.encode(pipelinestagedeclarationlist0)
            }
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let artifactStoreDecoded = try containerValues.decodeIfPresent(ArtifactStore.self, forKey: .artifactStore)
        artifactStore = artifactStoreDecoded
        let artifactStoresContainer = try containerValues.decodeIfPresent([String: ArtifactStore?].self, forKey: .artifactStores)
        var artifactStoresDecoded0: [String:ArtifactStore]? = nil
        if let artifactStoresContainer = artifactStoresContainer {
            artifactStoresDecoded0 = [String:ArtifactStore]()
            for (key0, artifactstore0) in artifactStoresContainer {
                if let artifactstore0 = artifactstore0 {
                    artifactStoresDecoded0?[key0] = artifactstore0
                }
            }
        }
        artifactStores = artifactStoresDecoded0
        let stagesContainer = try containerValues.decodeIfPresent([StageDeclaration?].self, forKey: .stages)
        var stagesDecoded0:[StageDeclaration]? = nil
        if let stagesContainer = stagesContainer {
            stagesDecoded0 = [StageDeclaration]()
            for structure0 in stagesContainer {
                if let structure0 = structure0 {
                    stagesDecoded0?.append(structure0)
                }
            }
        }
        stages = stagesDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .version)
        version = versionDecoded
    }
}

extension PipelineDeclaration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PipelineDeclaration(artifactStore: \(String(describing: artifactStore)), artifactStores: \(String(describing: artifactStores)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), stages: \(String(describing: stages)), version: \(String(describing: version)))"}
}

/// <p>Represents the structure of actions and stages to be performed in the
///             pipeline.</p>
public struct PipelineDeclaration: Equatable {
    /// <p>Represents information about the S3 bucket where artifacts are stored for the
    ///             pipeline.</p>
    ///         <note>
    ///             <p>You must include either <code>artifactStore</code> or
    ///                     <code>artifactStores</code> in your pipeline, but you cannot use both. If you
    ///                 create a cross-region action in your pipeline, you must use
    ///                     <code>artifactStores</code>.</p>
    ///         </note>
    public let artifactStore: ArtifactStore?
    /// <p>A mapping of <code>artifactStore</code> objects and their corresponding AWS
    ///             Regions. There must be an artifact store for the pipeline Region and for each
    ///             cross-region action in the pipeline.</p>
    ///         <note>
    ///             <p>You must include either <code>artifactStore</code> or
    ///                     <code>artifactStores</code> in your pipeline, but you cannot use both. If you
    ///                 create a cross-region action in your pipeline, you must use
    ///                     <code>artifactStores</code>.</p>
    ///         </note>
    public let artifactStores: [String:ArtifactStore]?
    /// <p>The name of the pipeline.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) for AWS CodePipeline to use to either perform
    ///             actions with no <code>actionRoleArn</code>, or to use to assume roles for actions with
    ///             an <code>actionRoleArn</code>.</p>
    public let roleArn: String?
    /// <p>The stage in which to perform the action.</p>
    public let stages: [StageDeclaration]?
    /// <p>The version number of the pipeline. A new pipeline always has a version number of
    ///             1. This number is incremented when a pipeline is updated.</p>
    public let version: Int?

    public init (
        artifactStore: ArtifactStore? = nil,
        artifactStores: [String:ArtifactStore]? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        stages: [StageDeclaration]? = nil,
        version: Int? = nil
    )
    {
        self.artifactStore = artifactStore
        self.artifactStores = artifactStores
        self.name = name
        self.roleArn = roleArn
        self.stages = stages
        self.version = version
    }
}

extension PipelineExecution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case artifactRevisions
        case pipelineExecutionId
        case pipelineName
        case pipelineVersion
        case status
        case statusSummary
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactRevisions = artifactRevisions {
            var artifactRevisionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .artifactRevisions)
            for artifactrevisionlist0 in artifactRevisions {
                try artifactRevisionsContainer.encode(artifactrevisionlist0)
            }
        }
        if let pipelineExecutionId = pipelineExecutionId {
            try encodeContainer.encode(pipelineExecutionId, forKey: .pipelineExecutionId)
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let pipelineVersion = pipelineVersion {
            try encodeContainer.encode(pipelineVersion, forKey: .pipelineVersion)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusSummary = statusSummary {
            try encodeContainer.encode(statusSummary, forKey: .statusSummary)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let pipelineVersionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .pipelineVersion)
        pipelineVersion = pipelineVersionDecoded
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PipelineExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusSummaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusSummary)
        statusSummary = statusSummaryDecoded
        let artifactRevisionsContainer = try containerValues.decodeIfPresent([ArtifactRevision?].self, forKey: .artifactRevisions)
        var artifactRevisionsDecoded0:[ArtifactRevision]? = nil
        if let artifactRevisionsContainer = artifactRevisionsContainer {
            artifactRevisionsDecoded0 = [ArtifactRevision]()
            for structure0 in artifactRevisionsContainer {
                if let structure0 = structure0 {
                    artifactRevisionsDecoded0?.append(structure0)
                }
            }
        }
        artifactRevisions = artifactRevisionsDecoded0
    }
}

extension PipelineExecution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PipelineExecution(artifactRevisions: \(String(describing: artifactRevisions)), pipelineExecutionId: \(String(describing: pipelineExecutionId)), pipelineName: \(String(describing: pipelineName)), pipelineVersion: \(String(describing: pipelineVersion)), status: \(String(describing: status)), statusSummary: \(String(describing: statusSummary)))"}
}

/// <p>Represents information about an execution of a pipeline.</p>
public struct PipelineExecution: Equatable {
    /// <p>A list of <code>ArtifactRevision</code> objects included in a pipeline
    ///             execution.</p>
    public let artifactRevisions: [ArtifactRevision]?
    /// <p>The ID of the pipeline execution.</p>
    public let pipelineExecutionId: String?
    /// <p>The name of the pipeline with the specified pipeline execution.</p>
    public let pipelineName: String?
    /// <p>The version number of the pipeline with the specified pipeline execution.</p>
    public let pipelineVersion: Int?
    /// <p>The status of the pipeline execution.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>Cancelled: The pipelines definition was updated before the pipeline
    ///                     execution could be completed.</p>
    ///             </li>
    ///             <li>
    ///                 <p>InProgress: The pipeline execution is currently running.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Stopped: The pipeline execution was manually stopped. For more information,
    ///                     see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/concepts.html#concepts-executions-stopped">Stopped Executions</a>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Stopping: The pipeline execution received a request to be manually stopped.
    ///                     Depending on the selected stop mode, the execution is either completing or
    ///                     abandoning in-progress actions. For more information, see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/concepts.html#concepts-executions-stopped">Stopped Executions</a>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Succeeded: The pipeline execution was completed successfully. </p>
    ///             </li>
    ///             <li>
    ///                 <p>Superseded: While this pipeline execution was waiting for the next stage to
    ///                     be completed, a newer pipeline execution advanced and continued through the
    ///                     pipeline instead. For more information, see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/concepts.html#concepts-superseded">Superseded Executions</a>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Failed: The pipeline execution was not completed successfully.</p>
    ///             </li>
    ///          </ul>
    public let status: PipelineExecutionStatus?
    /// <p>A summary that contains a description of the pipeline execution status.</p>
    public let statusSummary: String?

    public init (
        artifactRevisions: [ArtifactRevision]? = nil,
        pipelineExecutionId: String? = nil,
        pipelineName: String? = nil,
        pipelineVersion: Int? = nil,
        status: PipelineExecutionStatus? = nil,
        statusSummary: String? = nil
    )
    {
        self.artifactRevisions = artifactRevisions
        self.pipelineExecutionId = pipelineExecutionId
        self.pipelineName = pipelineName
        self.pipelineVersion = pipelineVersion
        self.status = status
        self.statusSummary = statusSummary
    }
}

extension PipelineExecutionNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PipelineExecutionNotFoundException(message: \(String(describing: message)))"}
}

extension PipelineExecutionNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PipelineExecutionNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pipeline execution was specified in an invalid format or cannot be found, or an
///             execution ID does not belong to the specified pipeline. </p>
public struct PipelineExecutionNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PipelineExecutionNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension PipelineExecutionNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PipelineExecutionNotStoppableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PipelineExecutionNotStoppableException(message: \(String(describing: message)))"}
}

extension PipelineExecutionNotStoppableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PipelineExecutionNotStoppableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Unable to stop the pipeline execution. The execution might already be in a
///                 <code>Stopped</code> state, or it might no longer be in progress.</p>
public struct PipelineExecutionNotStoppableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PipelineExecutionNotStoppableExceptionBody: Equatable {
    public let message: String?
}

extension PipelineExecutionNotStoppableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum PipelineExecutionStatus {
    case cancelled
    case failed
    case inprogress
    case stopped
    case stopping
    case succeeded
    case superseded
    case sdkUnknown(String)
}

extension PipelineExecutionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PipelineExecutionStatus] {
        return [
            .cancelled,
            .failed,
            .inprogress,
            .stopped,
            .stopping,
            .succeeded,
            .superseded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "Cancelled"
        case .failed: return "Failed"
        case .inprogress: return "InProgress"
        case .stopped: return "Stopped"
        case .stopping: return "Stopping"
        case .succeeded: return "Succeeded"
        case .superseded: return "Superseded"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PipelineExecutionStatus(rawValue: rawValue) ?? PipelineExecutionStatus.sdkUnknown(rawValue)
    }
}

extension PipelineExecutionSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lastUpdateTime
        case pipelineExecutionId
        case sourceRevisions
        case startTime
        case status
        case stopTrigger
        case trigger
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let pipelineExecutionId = pipelineExecutionId {
            try encodeContainer.encode(pipelineExecutionId, forKey: .pipelineExecutionId)
        }
        if let sourceRevisions = sourceRevisions {
            var sourceRevisionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceRevisions)
            for sourcerevisionlist0 in sourceRevisions {
                try sourceRevisionsContainer.encode(sourcerevisionlist0)
            }
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopTrigger = stopTrigger {
            try encodeContainer.encode(stopTrigger, forKey: .stopTrigger)
        }
        if let trigger = trigger {
            try encodeContainer.encode(trigger, forKey: .trigger)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(PipelineExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let sourceRevisionsContainer = try containerValues.decodeIfPresent([SourceRevision?].self, forKey: .sourceRevisions)
        var sourceRevisionsDecoded0:[SourceRevision]? = nil
        if let sourceRevisionsContainer = sourceRevisionsContainer {
            sourceRevisionsDecoded0 = [SourceRevision]()
            for structure0 in sourceRevisionsContainer {
                if let structure0 = structure0 {
                    sourceRevisionsDecoded0?.append(structure0)
                }
            }
        }
        sourceRevisions = sourceRevisionsDecoded0
        let triggerDecoded = try containerValues.decodeIfPresent(ExecutionTrigger.self, forKey: .trigger)
        trigger = triggerDecoded
        let stopTriggerDecoded = try containerValues.decodeIfPresent(StopExecutionTrigger.self, forKey: .stopTrigger)
        stopTrigger = stopTriggerDecoded
    }
}

extension PipelineExecutionSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PipelineExecutionSummary(lastUpdateTime: \(String(describing: lastUpdateTime)), pipelineExecutionId: \(String(describing: pipelineExecutionId)), sourceRevisions: \(String(describing: sourceRevisions)), startTime: \(String(describing: startTime)), status: \(String(describing: status)), stopTrigger: \(String(describing: stopTrigger)), trigger: \(String(describing: trigger)))"}
}

/// <p>Summary information about a pipeline execution.</p>
public struct PipelineExecutionSummary: Equatable {
    /// <p>The date and time of the last change to the pipeline execution, in timestamp
    ///             format.</p>
    public let lastUpdateTime: Date?
    /// <p>The ID of the pipeline execution.</p>
    public let pipelineExecutionId: String?
    /// <p>A list of the source artifact revisions that initiated a pipeline
    ///             execution.</p>
    public let sourceRevisions: [SourceRevision]?
    /// <p>The date and time when the pipeline execution began, in timestamp format.</p>
    public let startTime: Date?
    /// <p>The status of the pipeline execution.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>InProgress: The pipeline execution is currently running.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Stopped: The pipeline execution was manually stopped. For more information,
    ///                     see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/concepts.html#concepts-executions-stopped">Stopped Executions</a>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Stopping: The pipeline execution received a request to be manually stopped.
    ///                     Depending on the selected stop mode, the execution is either completing or
    ///                     abandoning in-progress actions. For more information, see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/concepts.html#concepts-executions-stopped">Stopped Executions</a>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Succeeded: The pipeline execution was completed successfully. </p>
    ///             </li>
    ///             <li>
    ///                 <p>Superseded: While this pipeline execution was waiting for the next stage to
    ///                     be completed, a newer pipeline execution advanced and continued through the
    ///                     pipeline instead. For more information, see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/concepts.html#concepts-superseded">Superseded Executions</a>.</p>
    ///             </li>
    ///             <li>
    ///                 <p>Failed: The pipeline execution was not completed successfully.</p>
    ///             </li>
    ///          </ul>
    public let status: PipelineExecutionStatus?
    /// <p>The interaction that stopped a pipeline execution.</p>
    public let stopTrigger: StopExecutionTrigger?
    /// <p>The interaction or event that started a pipeline execution, such as automated change
    ///             detection or a <code>StartPipelineExecution</code> API call.</p>
    public let trigger: ExecutionTrigger?

    public init (
        lastUpdateTime: Date? = nil,
        pipelineExecutionId: String? = nil,
        sourceRevisions: [SourceRevision]? = nil,
        startTime: Date? = nil,
        status: PipelineExecutionStatus? = nil,
        stopTrigger: StopExecutionTrigger? = nil,
        trigger: ExecutionTrigger? = nil
    )
    {
        self.lastUpdateTime = lastUpdateTime
        self.pipelineExecutionId = pipelineExecutionId
        self.sourceRevisions = sourceRevisions
        self.startTime = startTime
        self.status = status
        self.stopTrigger = stopTrigger
        self.trigger = trigger
    }
}

extension PipelineMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case created
        case pipelineArn
        case updated
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let pipelineArn = pipelineArn {
            try encodeContainer.encode(pipelineArn, forKey: .pipelineArn)
        }
        if let updated = updated {
            try encodeContainer.encode(updated.timeIntervalSince1970, forKey: .updated)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineArn)
        pipelineArn = pipelineArnDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let updatedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updated)
        updated = updatedDecoded
    }
}

extension PipelineMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PipelineMetadata(created: \(String(describing: created)), pipelineArn: \(String(describing: pipelineArn)), updated: \(String(describing: updated)))"}
}

/// <p>Information about a pipeline.</p>
public struct PipelineMetadata: Equatable {
    /// <p>The date and time the pipeline was created, in timestamp format.</p>
    public let created: Date?
    /// <p>The Amazon Resource Name (ARN) of the pipeline.</p>
    public let pipelineArn: String?
    /// <p>The date and time the pipeline was last updated, in timestamp format.</p>
    public let updated: Date?

    public init (
        created: Date? = nil,
        pipelineArn: String? = nil,
        updated: Date? = nil
    )
    {
        self.created = created
        self.pipelineArn = pipelineArn
        self.updated = updated
    }
}

extension PipelineNameInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PipelineNameInUseException(message: \(String(describing: message)))"}
}

extension PipelineNameInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PipelineNameInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified pipeline name is already in use.</p>
public struct PipelineNameInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PipelineNameInUseExceptionBody: Equatable {
    public let message: String?
}

extension PipelineNameInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PipelineNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PipelineNotFoundException(message: \(String(describing: message)))"}
}

extension PipelineNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PipelineNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pipeline was specified in an invalid format or cannot be found.</p>
public struct PipelineNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PipelineNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension PipelineNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PipelineSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case created
        case name
        case updated
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updated = updated {
            try encodeContainer.encode(updated.timeIntervalSince1970, forKey: .updated)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .version)
        version = versionDecoded
        let createdDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .created)
        created = createdDecoded
        let updatedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updated)
        updated = updatedDecoded
    }
}

extension PipelineSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PipelineSummary(created: \(String(describing: created)), name: \(String(describing: name)), updated: \(String(describing: updated)), version: \(String(describing: version)))"}
}

/// <p>Returns a summary of a pipeline.</p>
public struct PipelineSummary: Equatable {
    /// <p>The date and time the pipeline was created, in timestamp format.</p>
    public let created: Date?
    /// <p>The name of the pipeline.</p>
    public let name: String?
    /// <p>The date and time of the last update to the pipeline, in timestamp
    ///             format.</p>
    public let updated: Date?
    /// <p>The version number of the pipeline.</p>
    public let version: Int?

    public init (
        created: Date? = nil,
        name: String? = nil,
        updated: Date? = nil,
        version: Int? = nil
    )
    {
        self.created = created
        self.name = name
        self.updated = updated
        self.version = version
    }
}

extension PipelineVersionNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PipelineVersionNotFoundException(message: \(String(describing: message)))"}
}

extension PipelineVersionNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PipelineVersionNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pipeline version was specified in an invalid format or cannot be
///             found.</p>
public struct PipelineVersionNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PipelineVersionNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension PipelineVersionNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PollForJobsInputBodyMiddleware: Middleware {
    public let id: String = "PollForJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PollForJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<PollForJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PollForJobsInput>
    public typealias MOutput = OperationOutput<PollForJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PollForJobsOutputError>
}

extension PollForJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PollForJobsInput(actionTypeId: \(String(describing: actionTypeId)), maxBatchSize: \(String(describing: maxBatchSize)), queryParam: \(String(describing: queryParam)))"}
}

extension PollForJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionTypeId
        case maxBatchSize
        case queryParam
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionTypeId = actionTypeId {
            try encodeContainer.encode(actionTypeId, forKey: .actionTypeId)
        }
        if let maxBatchSize = maxBatchSize {
            try encodeContainer.encode(maxBatchSize, forKey: .maxBatchSize)
        }
        if let queryParam = queryParam {
            var queryParamContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .queryParam)
            for (dictKey0, queryparammap0) in queryParam {
                try queryParamContainer.encode(queryparammap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct PollForJobsInputHeadersMiddleware: Middleware {
    public let id: String = "PollForJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PollForJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<PollForJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PollForJobsInput>
    public typealias MOutput = OperationOutput<PollForJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PollForJobsOutputError>
}

public struct PollForJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "PollForJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PollForJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<PollForJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PollForJobsInput>
    public typealias MOutput = OperationOutput<PollForJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PollForJobsOutputError>
}

/// <p>Represents the input of a <code>PollForJobs</code> action.</p>
public struct PollForJobsInput: Equatable {
    /// <p>Represents information about an action type.</p>
    public let actionTypeId: ActionTypeId?
    /// <p>The maximum number of jobs to return in a poll for jobs call.</p>
    public let maxBatchSize: Int?
    /// <p>A map of property names and values. For an action type with no queryable
    ///             properties, this value must be null or an empty map. For an action type with a queryable
    ///             property, you must supply that property as a key in the map. Only jobs whose action
    ///             configuration matches the mapped value are returned.</p>
    public let queryParam: [String:String]?

    public init (
        actionTypeId: ActionTypeId? = nil,
        maxBatchSize: Int? = nil,
        queryParam: [String:String]? = nil
    )
    {
        self.actionTypeId = actionTypeId
        self.maxBatchSize = maxBatchSize
        self.queryParam = queryParam
    }
}

struct PollForJobsInputBody: Equatable {
    public let actionTypeId: ActionTypeId?
    public let maxBatchSize: Int?
    public let queryParam: [String:String]?
}

extension PollForJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionTypeId
        case maxBatchSize
        case queryParam
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeIdDecoded = try containerValues.decodeIfPresent(ActionTypeId.self, forKey: .actionTypeId)
        actionTypeId = actionTypeIdDecoded
        let maxBatchSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxBatchSize)
        maxBatchSize = maxBatchSizeDecoded
        let queryParamContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .queryParam)
        var queryParamDecoded0: [String:String]? = nil
        if let queryParamContainer = queryParamContainer {
            queryParamDecoded0 = [String:String]()
            for (key0, actionconfigurationqueryablevalue0) in queryParamContainer {
                if let actionconfigurationqueryablevalue0 = actionconfigurationqueryablevalue0 {
                    queryParamDecoded0?[key0] = actionconfigurationqueryablevalue0
                }
            }
        }
        queryParam = queryParamDecoded0
    }
}

extension PollForJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PollForJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ActionTypeNotFoundException" : self = .actionTypeNotFoundException(try ActionTypeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PollForJobsOutputError: Swift.Error, Equatable {
    case actionTypeNotFoundException(ActionTypeNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PollForJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PollForJobsOutputResponse(jobs: \(String(describing: jobs)))"}
}

extension PollForJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PollForJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
        } else {
            self.jobs = nil
        }
    }
}

/// <p>Represents the output of a <code>PollForJobs</code> action.</p>
public struct PollForJobsOutputResponse: Equatable {
    /// <p>Information about the jobs to take action on.</p>
    public let jobs: [Job]?

    public init (
        jobs: [Job]? = nil
    )
    {
        self.jobs = jobs
    }
}

struct PollForJobsOutputResponseBody: Equatable {
    public let jobs: [Job]?
}

extension PollForJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobs
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([Job?].self, forKey: .jobs)
        var jobsDecoded0:[Job]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [Job]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
    }
}

public struct PollForThirdPartyJobsInputBodyMiddleware: Middleware {
    public let id: String = "PollForThirdPartyJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PollForThirdPartyJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<PollForThirdPartyJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PollForThirdPartyJobsInput>
    public typealias MOutput = OperationOutput<PollForThirdPartyJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PollForThirdPartyJobsOutputError>
}

extension PollForThirdPartyJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PollForThirdPartyJobsInput(actionTypeId: \(String(describing: actionTypeId)), maxBatchSize: \(String(describing: maxBatchSize)))"}
}

extension PollForThirdPartyJobsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionTypeId
        case maxBatchSize
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionTypeId = actionTypeId {
            try encodeContainer.encode(actionTypeId, forKey: .actionTypeId)
        }
        if let maxBatchSize = maxBatchSize {
            try encodeContainer.encode(maxBatchSize, forKey: .maxBatchSize)
        }
    }
}

public struct PollForThirdPartyJobsInputHeadersMiddleware: Middleware {
    public let id: String = "PollForThirdPartyJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PollForThirdPartyJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<PollForThirdPartyJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PollForThirdPartyJobsInput>
    public typealias MOutput = OperationOutput<PollForThirdPartyJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PollForThirdPartyJobsOutputError>
}

public struct PollForThirdPartyJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "PollForThirdPartyJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PollForThirdPartyJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<PollForThirdPartyJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PollForThirdPartyJobsInput>
    public typealias MOutput = OperationOutput<PollForThirdPartyJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PollForThirdPartyJobsOutputError>
}

/// <p>Represents the input of a <code>PollForThirdPartyJobs</code> action.</p>
public struct PollForThirdPartyJobsInput: Equatable {
    /// <p>Represents information about an action type.</p>
    public let actionTypeId: ActionTypeId?
    /// <p>The maximum number of jobs to return in a poll for jobs call.</p>
    public let maxBatchSize: Int?

    public init (
        actionTypeId: ActionTypeId? = nil,
        maxBatchSize: Int? = nil
    )
    {
        self.actionTypeId = actionTypeId
        self.maxBatchSize = maxBatchSize
    }
}

struct PollForThirdPartyJobsInputBody: Equatable {
    public let actionTypeId: ActionTypeId?
    public let maxBatchSize: Int?
}

extension PollForThirdPartyJobsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionTypeId
        case maxBatchSize
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeIdDecoded = try containerValues.decodeIfPresent(ActionTypeId.self, forKey: .actionTypeId)
        actionTypeId = actionTypeIdDecoded
        let maxBatchSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxBatchSize)
        maxBatchSize = maxBatchSizeDecoded
    }
}

extension PollForThirdPartyJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PollForThirdPartyJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ActionTypeNotFoundException" : self = .actionTypeNotFoundException(try ActionTypeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PollForThirdPartyJobsOutputError: Swift.Error, Equatable {
    case actionTypeNotFoundException(ActionTypeNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PollForThirdPartyJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PollForThirdPartyJobsOutputResponse(jobs: \(String(describing: jobs)))"}
}

extension PollForThirdPartyJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PollForThirdPartyJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
        } else {
            self.jobs = nil
        }
    }
}

/// <p>Represents the output of a <code>PollForThirdPartyJobs</code> action.</p>
public struct PollForThirdPartyJobsOutputResponse: Equatable {
    /// <p>Information about the jobs to take action on.</p>
    public let jobs: [ThirdPartyJob]?

    public init (
        jobs: [ThirdPartyJob]? = nil
    )
    {
        self.jobs = jobs
    }
}

struct PollForThirdPartyJobsOutputResponseBody: Equatable {
    public let jobs: [ThirdPartyJob]?
}

extension PollForThirdPartyJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobs
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([ThirdPartyJob?].self, forKey: .jobs)
        var jobsDecoded0:[ThirdPartyJob]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [ThirdPartyJob]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
    }
}

public struct PutActionRevisionInputBodyMiddleware: Middleware {
    public let id: String = "PutActionRevisionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutActionRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutActionRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutActionRevisionInput>
    public typealias MOutput = OperationOutput<PutActionRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutActionRevisionOutputError>
}

extension PutActionRevisionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutActionRevisionInput(actionName: \(String(describing: actionName)), actionRevision: \(String(describing: actionRevision)), pipelineName: \(String(describing: pipelineName)), stageName: \(String(describing: stageName)))"}
}

extension PutActionRevisionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionName
        case actionRevision
        case pipelineName
        case stageName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionName = actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let actionRevision = actionRevision {
            try encodeContainer.encode(actionRevision, forKey: .actionRevision)
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
    }
}

public struct PutActionRevisionInputHeadersMiddleware: Middleware {
    public let id: String = "PutActionRevisionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutActionRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutActionRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutActionRevisionInput>
    public typealias MOutput = OperationOutput<PutActionRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutActionRevisionOutputError>
}

public struct PutActionRevisionInputQueryItemMiddleware: Middleware {
    public let id: String = "PutActionRevisionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutActionRevisionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutActionRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutActionRevisionInput>
    public typealias MOutput = OperationOutput<PutActionRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutActionRevisionOutputError>
}

/// <p>Represents the input of a <code>PutActionRevision</code> action.</p>
public struct PutActionRevisionInput: Equatable {
    /// <p>The name of the action that processes the revision.</p>
    public let actionName: String?
    /// <p>Represents information about the version (or revision) of an action.</p>
    public let actionRevision: ActionRevision?
    /// <p>The name of the pipeline that starts processing the revision to the
    ///             source.</p>
    public let pipelineName: String?
    /// <p>The name of the stage that contains the action that acts on the revision.</p>
    public let stageName: String?

    public init (
        actionName: String? = nil,
        actionRevision: ActionRevision? = nil,
        pipelineName: String? = nil,
        stageName: String? = nil
    )
    {
        self.actionName = actionName
        self.actionRevision = actionRevision
        self.pipelineName = pipelineName
        self.stageName = stageName
    }
}

struct PutActionRevisionInputBody: Equatable {
    public let pipelineName: String?
    public let stageName: String?
    public let actionName: String?
    public let actionRevision: ActionRevision?
}

extension PutActionRevisionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionName
        case actionRevision
        case pipelineName
        case stageName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let actionRevisionDecoded = try containerValues.decodeIfPresent(ActionRevision.self, forKey: .actionRevision)
        actionRevision = actionRevisionDecoded
    }
}

extension PutActionRevisionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutActionRevisionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ActionNotFoundException" : self = .actionNotFoundException(try ActionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StageNotFoundException" : self = .stageNotFoundException(try StageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutActionRevisionOutputError: Swift.Error, Equatable {
    case actionNotFoundException(ActionNotFoundException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case stageNotFoundException(StageNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutActionRevisionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutActionRevisionOutputResponse(newRevision: \(String(describing: newRevision)), pipelineExecutionId: \(String(describing: pipelineExecutionId)))"}
}

extension PutActionRevisionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutActionRevisionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.newRevision = output.newRevision
            self.pipelineExecutionId = output.pipelineExecutionId
        } else {
            self.newRevision = false
            self.pipelineExecutionId = nil
        }
    }
}

/// <p>Represents the output of a <code>PutActionRevision</code> action.</p>
public struct PutActionRevisionOutputResponse: Equatable {
    /// <p>Indicates whether the artifact revision was previously used in an execution of the
    ///             specified pipeline.</p>
    public let newRevision: Bool
    /// <p>The ID of the current workflow state of the pipeline.</p>
    public let pipelineExecutionId: String?

    public init (
        newRevision: Bool = false,
        pipelineExecutionId: String? = nil
    )
    {
        self.newRevision = newRevision
        self.pipelineExecutionId = pipelineExecutionId
    }
}

struct PutActionRevisionOutputResponseBody: Equatable {
    public let newRevision: Bool
    public let pipelineExecutionId: String?
}

extension PutActionRevisionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case newRevision
        case pipelineExecutionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let newRevisionDecoded = try containerValues.decode(Bool.self, forKey: .newRevision)
        newRevision = newRevisionDecoded
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
    }
}

public struct PutApprovalResultInputBodyMiddleware: Middleware {
    public let id: String = "PutApprovalResultInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutApprovalResultInput>,
                  next: H) -> Swift.Result<OperationOutput<PutApprovalResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutApprovalResultInput>
    public typealias MOutput = OperationOutput<PutApprovalResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutApprovalResultOutputError>
}

extension PutApprovalResultInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutApprovalResultInput(actionName: \(String(describing: actionName)), pipelineName: \(String(describing: pipelineName)), result: \(String(describing: result)), stageName: \(String(describing: stageName)), token: \(String(describing: token)))"}
}

extension PutApprovalResultInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionName
        case pipelineName
        case result
        case stageName
        case token
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionName = actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let result = result {
            try encodeContainer.encode(result, forKey: .result)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let token = token {
            try encodeContainer.encode(token, forKey: .token)
        }
    }
}

public struct PutApprovalResultInputHeadersMiddleware: Middleware {
    public let id: String = "PutApprovalResultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutApprovalResultInput>,
                  next: H) -> Swift.Result<OperationOutput<PutApprovalResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutApprovalResultInput>
    public typealias MOutput = OperationOutput<PutApprovalResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutApprovalResultOutputError>
}

public struct PutApprovalResultInputQueryItemMiddleware: Middleware {
    public let id: String = "PutApprovalResultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutApprovalResultInput>,
                  next: H) -> Swift.Result<OperationOutput<PutApprovalResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutApprovalResultInput>
    public typealias MOutput = OperationOutput<PutApprovalResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutApprovalResultOutputError>
}

/// <p>Represents the input of a <code>PutApprovalResult</code> action.</p>
public struct PutApprovalResultInput: Equatable {
    /// <p>The name of the action for which approval is requested.</p>
    public let actionName: String?
    /// <p>The name of the pipeline that contains the action. </p>
    public let pipelineName: String?
    /// <p>Represents information about the result of the approval request.</p>
    public let result: ApprovalResult?
    /// <p>The name of the stage that contains the action.</p>
    public let stageName: String?
    /// <p>The system-generated token used to identify a unique approval request. The token
    ///             for each open approval request can be obtained using the <a>GetPipelineState</a> action. It is used to validate that the approval
    ///             request corresponding to this token is still valid.</p>
    public let token: String?

    public init (
        actionName: String? = nil,
        pipelineName: String? = nil,
        result: ApprovalResult? = nil,
        stageName: String? = nil,
        token: String? = nil
    )
    {
        self.actionName = actionName
        self.pipelineName = pipelineName
        self.result = result
        self.stageName = stageName
        self.token = token
    }
}

struct PutApprovalResultInputBody: Equatable {
    public let pipelineName: String?
    public let stageName: String?
    public let actionName: String?
    public let result: ApprovalResult?
    public let token: String?
}

extension PutApprovalResultInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionName
        case pipelineName
        case result
        case stageName
        case token
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let resultDecoded = try containerValues.decodeIfPresent(ApprovalResult.self, forKey: .result)
        result = resultDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .token)
        token = tokenDecoded
    }
}

extension PutApprovalResultOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutApprovalResultOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ActionNotFoundException" : self = .actionNotFoundException(try ActionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalAlreadyCompletedException" : self = .approvalAlreadyCompletedException(try ApprovalAlreadyCompletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalTokenException" : self = .invalidApprovalTokenException(try InvalidApprovalTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StageNotFoundException" : self = .stageNotFoundException(try StageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutApprovalResultOutputError: Swift.Error, Equatable {
    case actionNotFoundException(ActionNotFoundException)
    case approvalAlreadyCompletedException(ApprovalAlreadyCompletedException)
    case invalidApprovalTokenException(InvalidApprovalTokenException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case stageNotFoundException(StageNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutApprovalResultOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutApprovalResultOutputResponse(approvedAt: \(String(describing: approvedAt)))"}
}

extension PutApprovalResultOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutApprovalResultOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.approvedAt = output.approvedAt
        } else {
            self.approvedAt = nil
        }
    }
}

/// <p>Represents the output of a <code>PutApprovalResult</code> action.</p>
public struct PutApprovalResultOutputResponse: Equatable {
    /// <p>The timestamp showing when the approval or rejection was submitted.</p>
    public let approvedAt: Date?

    public init (
        approvedAt: Date? = nil
    )
    {
        self.approvedAt = approvedAt
    }
}

struct PutApprovalResultOutputResponseBody: Equatable {
    public let approvedAt: Date?
}

extension PutApprovalResultOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case approvedAt
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .approvedAt)
        approvedAt = approvedAtDecoded
    }
}

public struct PutJobFailureResultInputBodyMiddleware: Middleware {
    public let id: String = "PutJobFailureResultInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutJobFailureResultInput>,
                  next: H) -> Swift.Result<OperationOutput<PutJobFailureResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutJobFailureResultInput>
    public typealias MOutput = OperationOutput<PutJobFailureResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutJobFailureResultOutputError>
}

extension PutJobFailureResultInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutJobFailureResultInput(failureDetails: \(String(describing: failureDetails)), jobId: \(String(describing: jobId)))"}
}

extension PutJobFailureResultInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failureDetails
        case jobId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct PutJobFailureResultInputHeadersMiddleware: Middleware {
    public let id: String = "PutJobFailureResultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutJobFailureResultInput>,
                  next: H) -> Swift.Result<OperationOutput<PutJobFailureResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutJobFailureResultInput>
    public typealias MOutput = OperationOutput<PutJobFailureResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutJobFailureResultOutputError>
}

public struct PutJobFailureResultInputQueryItemMiddleware: Middleware {
    public let id: String = "PutJobFailureResultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutJobFailureResultInput>,
                  next: H) -> Swift.Result<OperationOutput<PutJobFailureResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutJobFailureResultInput>
    public typealias MOutput = OperationOutput<PutJobFailureResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutJobFailureResultOutputError>
}

/// <p>Represents the input of a <code>PutJobFailureResult</code> action.</p>
public struct PutJobFailureResultInput: Equatable {
    /// <p>The details about the failure of a job.</p>
    public let failureDetails: FailureDetails?
    /// <p>The unique system-generated ID of the job that failed. This is the same ID returned
    ///             from <code>PollForJobs</code>.</p>
    public let jobId: String?

    public init (
        failureDetails: FailureDetails? = nil,
        jobId: String? = nil
    )
    {
        self.failureDetails = failureDetails
        self.jobId = jobId
    }
}

struct PutJobFailureResultInputBody: Equatable {
    public let jobId: String?
    public let failureDetails: FailureDetails?
}

extension PutJobFailureResultInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failureDetails
        case jobId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
    }
}

extension PutJobFailureResultOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutJobFailureResultOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutJobFailureResultOutputError: Swift.Error, Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case jobNotFoundException(JobNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutJobFailureResultOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutJobFailureResultOutputResponse()"}
}

extension PutJobFailureResultOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutJobFailureResultOutputResponse: Equatable {

    public init() {}
}

struct PutJobFailureResultOutputResponseBody: Equatable {
}

extension PutJobFailureResultOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutJobSuccessResultInputBodyMiddleware: Middleware {
    public let id: String = "PutJobSuccessResultInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutJobSuccessResultInput>,
                  next: H) -> Swift.Result<OperationOutput<PutJobSuccessResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutJobSuccessResultInput>
    public typealias MOutput = OperationOutput<PutJobSuccessResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutJobSuccessResultOutputError>
}

extension PutJobSuccessResultInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutJobSuccessResultInput(continuationToken: \(String(describing: continuationToken)), currentRevision: \(String(describing: currentRevision)), executionDetails: \(String(describing: executionDetails)), jobId: \(String(describing: jobId)), outputVariables: \(String(describing: outputVariables)))"}
}

extension PutJobSuccessResultInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case continuationToken
        case currentRevision
        case executionDetails
        case jobId
        case outputVariables
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let continuationToken = continuationToken {
            try encodeContainer.encode(continuationToken, forKey: .continuationToken)
        }
        if let currentRevision = currentRevision {
            try encodeContainer.encode(currentRevision, forKey: .currentRevision)
        }
        if let executionDetails = executionDetails {
            try encodeContainer.encode(executionDetails, forKey: .executionDetails)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let outputVariables = outputVariables {
            var outputVariablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .outputVariables)
            for (dictKey0, outputvariablesmap0) in outputVariables {
                try outputVariablesContainer.encode(outputvariablesmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct PutJobSuccessResultInputHeadersMiddleware: Middleware {
    public let id: String = "PutJobSuccessResultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutJobSuccessResultInput>,
                  next: H) -> Swift.Result<OperationOutput<PutJobSuccessResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutJobSuccessResultInput>
    public typealias MOutput = OperationOutput<PutJobSuccessResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutJobSuccessResultOutputError>
}

public struct PutJobSuccessResultInputQueryItemMiddleware: Middleware {
    public let id: String = "PutJobSuccessResultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutJobSuccessResultInput>,
                  next: H) -> Swift.Result<OperationOutput<PutJobSuccessResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutJobSuccessResultInput>
    public typealias MOutput = OperationOutput<PutJobSuccessResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutJobSuccessResultOutputError>
}

/// <p>Represents the input of a <code>PutJobSuccessResult</code> action.</p>
public struct PutJobSuccessResultInput: Equatable {
    /// <p>A token generated by a job worker, such as an AWS CodeDeploy deployment ID, that a
    ///             successful job provides to identify a custom action in progress. Future jobs use this
    ///             token to identify the running instance of the action. It can be reused to return more
    ///             information about the progress of the custom action. When the action is complete, no
    ///             continuation token should be supplied.</p>
    public let continuationToken: String?
    /// <p>The ID of the current revision of the artifact successfully worked on by the
    ///             job.</p>
    public let currentRevision: CurrentRevision?
    /// <p>The execution details of the successful job, such as the actions taken by the job
    ///             worker.</p>
    public let executionDetails: ExecutionDetails?
    /// <p>The unique system-generated ID of the job that succeeded. This is the same ID
    ///             returned from <code>PollForJobs</code>.</p>
    public let jobId: String?
    /// <p>Key-value pairs produced as output by a job worker that can be made available to a
    ///             downstream action configuration. <code>outputVariables</code> can be included only when
    ///             there is no continuation token on the request.</p>
    public let outputVariables: [String:String]?

    public init (
        continuationToken: String? = nil,
        currentRevision: CurrentRevision? = nil,
        executionDetails: ExecutionDetails? = nil,
        jobId: String? = nil,
        outputVariables: [String:String]? = nil
    )
    {
        self.continuationToken = continuationToken
        self.currentRevision = currentRevision
        self.executionDetails = executionDetails
        self.jobId = jobId
        self.outputVariables = outputVariables
    }
}

struct PutJobSuccessResultInputBody: Equatable {
    public let jobId: String?
    public let currentRevision: CurrentRevision?
    public let continuationToken: String?
    public let executionDetails: ExecutionDetails?
    public let outputVariables: [String:String]?
}

extension PutJobSuccessResultInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case continuationToken
        case currentRevision
        case executionDetails
        case jobId
        case outputVariables
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let currentRevisionDecoded = try containerValues.decodeIfPresent(CurrentRevision.self, forKey: .currentRevision)
        currentRevision = currentRevisionDecoded
        let continuationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .continuationToken)
        continuationToken = continuationTokenDecoded
        let executionDetailsDecoded = try containerValues.decodeIfPresent(ExecutionDetails.self, forKey: .executionDetails)
        executionDetails = executionDetailsDecoded
        let outputVariablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .outputVariables)
        var outputVariablesDecoded0: [String:String]? = nil
        if let outputVariablesContainer = outputVariablesContainer {
            outputVariablesDecoded0 = [String:String]()
            for (key0, outputvariablesvalue0) in outputVariablesContainer {
                if let outputvariablesvalue0 = outputvariablesvalue0 {
                    outputVariablesDecoded0?[key0] = outputvariablesvalue0
                }
            }
        }
        outputVariables = outputVariablesDecoded0
    }
}

extension PutJobSuccessResultOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutJobSuccessResultOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OutputVariablesSizeExceededException" : self = .outputVariablesSizeExceededException(try OutputVariablesSizeExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutJobSuccessResultOutputError: Swift.Error, Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case jobNotFoundException(JobNotFoundException)
    case outputVariablesSizeExceededException(OutputVariablesSizeExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutJobSuccessResultOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutJobSuccessResultOutputResponse()"}
}

extension PutJobSuccessResultOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutJobSuccessResultOutputResponse: Equatable {

    public init() {}
}

struct PutJobSuccessResultOutputResponseBody: Equatable {
}

extension PutJobSuccessResultOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutThirdPartyJobFailureResultInputBodyMiddleware: Middleware {
    public let id: String = "PutThirdPartyJobFailureResultInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutThirdPartyJobFailureResultInput>,
                  next: H) -> Swift.Result<OperationOutput<PutThirdPartyJobFailureResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutThirdPartyJobFailureResultInput>
    public typealias MOutput = OperationOutput<PutThirdPartyJobFailureResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutThirdPartyJobFailureResultOutputError>
}

extension PutThirdPartyJobFailureResultInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutThirdPartyJobFailureResultInput(clientToken: \(String(describing: clientToken)), failureDetails: \(String(describing: failureDetails)), jobId: \(String(describing: jobId)))"}
}

extension PutThirdPartyJobFailureResultInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case failureDetails
        case jobId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct PutThirdPartyJobFailureResultInputHeadersMiddleware: Middleware {
    public let id: String = "PutThirdPartyJobFailureResultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutThirdPartyJobFailureResultInput>,
                  next: H) -> Swift.Result<OperationOutput<PutThirdPartyJobFailureResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutThirdPartyJobFailureResultInput>
    public typealias MOutput = OperationOutput<PutThirdPartyJobFailureResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutThirdPartyJobFailureResultOutputError>
}

public struct PutThirdPartyJobFailureResultInputQueryItemMiddleware: Middleware {
    public let id: String = "PutThirdPartyJobFailureResultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutThirdPartyJobFailureResultInput>,
                  next: H) -> Swift.Result<OperationOutput<PutThirdPartyJobFailureResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutThirdPartyJobFailureResultInput>
    public typealias MOutput = OperationOutput<PutThirdPartyJobFailureResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutThirdPartyJobFailureResultOutputError>
}

/// <p>Represents the input of a <code>PutThirdPartyJobFailureResult</code>
///             action.</p>
public struct PutThirdPartyJobFailureResultInput: Equatable {
    /// <p>The clientToken portion of the clientId and clientToken pair used to verify that
    ///             the calling entity is allowed access to the job and its details.</p>
    public let clientToken: String?
    /// <p>Represents information about failure details.</p>
    public let failureDetails: FailureDetails?
    /// <p>The ID of the job that failed. This is the same ID returned from
    ///                 <code>PollForThirdPartyJobs</code>.</p>
    public let jobId: String?

    public init (
        clientToken: String? = nil,
        failureDetails: FailureDetails? = nil,
        jobId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.failureDetails = failureDetails
        self.jobId = jobId
    }
}

struct PutThirdPartyJobFailureResultInputBody: Equatable {
    public let jobId: String?
    public let clientToken: String?
    public let failureDetails: FailureDetails?
}

extension PutThirdPartyJobFailureResultInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case failureDetails
        case jobId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
    }
}

extension PutThirdPartyJobFailureResultOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutThirdPartyJobFailureResultOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutThirdPartyJobFailureResultOutputError: Swift.Error, Equatable {
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidJobStateException(InvalidJobStateException)
    case jobNotFoundException(JobNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutThirdPartyJobFailureResultOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutThirdPartyJobFailureResultOutputResponse()"}
}

extension PutThirdPartyJobFailureResultOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutThirdPartyJobFailureResultOutputResponse: Equatable {

    public init() {}
}

struct PutThirdPartyJobFailureResultOutputResponseBody: Equatable {
}

extension PutThirdPartyJobFailureResultOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutThirdPartyJobSuccessResultInputBodyMiddleware: Middleware {
    public let id: String = "PutThirdPartyJobSuccessResultInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutThirdPartyJobSuccessResultInput>,
                  next: H) -> Swift.Result<OperationOutput<PutThirdPartyJobSuccessResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutThirdPartyJobSuccessResultInput>
    public typealias MOutput = OperationOutput<PutThirdPartyJobSuccessResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutThirdPartyJobSuccessResultOutputError>
}

extension PutThirdPartyJobSuccessResultInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutThirdPartyJobSuccessResultInput(clientToken: \(String(describing: clientToken)), continuationToken: \(String(describing: continuationToken)), currentRevision: \(String(describing: currentRevision)), executionDetails: \(String(describing: executionDetails)), jobId: \(String(describing: jobId)))"}
}

extension PutThirdPartyJobSuccessResultInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case continuationToken
        case currentRevision
        case executionDetails
        case jobId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let continuationToken = continuationToken {
            try encodeContainer.encode(continuationToken, forKey: .continuationToken)
        }
        if let currentRevision = currentRevision {
            try encodeContainer.encode(currentRevision, forKey: .currentRevision)
        }
        if let executionDetails = executionDetails {
            try encodeContainer.encode(executionDetails, forKey: .executionDetails)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct PutThirdPartyJobSuccessResultInputHeadersMiddleware: Middleware {
    public let id: String = "PutThirdPartyJobSuccessResultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutThirdPartyJobSuccessResultInput>,
                  next: H) -> Swift.Result<OperationOutput<PutThirdPartyJobSuccessResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutThirdPartyJobSuccessResultInput>
    public typealias MOutput = OperationOutput<PutThirdPartyJobSuccessResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutThirdPartyJobSuccessResultOutputError>
}

public struct PutThirdPartyJobSuccessResultInputQueryItemMiddleware: Middleware {
    public let id: String = "PutThirdPartyJobSuccessResultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutThirdPartyJobSuccessResultInput>,
                  next: H) -> Swift.Result<OperationOutput<PutThirdPartyJobSuccessResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutThirdPartyJobSuccessResultInput>
    public typealias MOutput = OperationOutput<PutThirdPartyJobSuccessResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutThirdPartyJobSuccessResultOutputError>
}

/// <p>Represents the input of a <code>PutThirdPartyJobSuccessResult</code>
///             action.</p>
public struct PutThirdPartyJobSuccessResultInput: Equatable {
    /// <p>The clientToken portion of the clientId and clientToken pair used to verify that
    ///             the calling entity is allowed access to the job and its details.</p>
    public let clientToken: String?
    /// <p>A token generated by a job worker, such as an AWS CodeDeploy deployment ID, that a
    ///             successful job provides to identify a partner action in progress. Future jobs use this
    ///             token to identify the running instance of the action. It can be reused to return more
    ///             information about the progress of the partner action. When the action is complete, no
    ///             continuation token should be supplied.</p>
    public let continuationToken: String?
    /// <p>Represents information about a current revision.</p>
    public let currentRevision: CurrentRevision?
    /// <p>The details of the actions taken and results produced on an artifact as it passes
    ///             through stages in the pipeline. </p>
    public let executionDetails: ExecutionDetails?
    /// <p>The ID of the job that successfully completed. This is the same ID returned from
    ///                 <code>PollForThirdPartyJobs</code>.</p>
    public let jobId: String?

    public init (
        clientToken: String? = nil,
        continuationToken: String? = nil,
        currentRevision: CurrentRevision? = nil,
        executionDetails: ExecutionDetails? = nil,
        jobId: String? = nil
    )
    {
        self.clientToken = clientToken
        self.continuationToken = continuationToken
        self.currentRevision = currentRevision
        self.executionDetails = executionDetails
        self.jobId = jobId
    }
}

struct PutThirdPartyJobSuccessResultInputBody: Equatable {
    public let jobId: String?
    public let clientToken: String?
    public let currentRevision: CurrentRevision?
    public let continuationToken: String?
    public let executionDetails: ExecutionDetails?
}

extension PutThirdPartyJobSuccessResultInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case continuationToken
        case currentRevision
        case executionDetails
        case jobId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let currentRevisionDecoded = try containerValues.decodeIfPresent(CurrentRevision.self, forKey: .currentRevision)
        currentRevision = currentRevisionDecoded
        let continuationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .continuationToken)
        continuationToken = continuationTokenDecoded
        let executionDetailsDecoded = try containerValues.decodeIfPresent(ExecutionDetails.self, forKey: .executionDetails)
        executionDetails = executionDetailsDecoded
    }
}

extension PutThirdPartyJobSuccessResultOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutThirdPartyJobSuccessResultOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutThirdPartyJobSuccessResultOutputError: Swift.Error, Equatable {
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidJobStateException(InvalidJobStateException)
    case jobNotFoundException(JobNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutThirdPartyJobSuccessResultOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutThirdPartyJobSuccessResultOutputResponse()"}
}

extension PutThirdPartyJobSuccessResultOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutThirdPartyJobSuccessResultOutputResponse: Equatable {

    public init() {}
}

struct PutThirdPartyJobSuccessResultOutputResponseBody: Equatable {
}

extension PutThirdPartyJobSuccessResultOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutWebhookInputBodyMiddleware: Middleware {
    public let id: String = "PutWebhookInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<PutWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutWebhookInput>
    public typealias MOutput = OperationOutput<PutWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutWebhookOutputError>
}

extension PutWebhookInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutWebhookInput(tags: \(String(describing: tags)), webhook: \(String(describing: webhook)))"}
}

extension PutWebhookInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
        case webhook
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let webhook = webhook {
            try encodeContainer.encode(webhook, forKey: .webhook)
        }
    }
}

public struct PutWebhookInputHeadersMiddleware: Middleware {
    public let id: String = "PutWebhookInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<PutWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutWebhookInput>
    public typealias MOutput = OperationOutput<PutWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutWebhookOutputError>
}

public struct PutWebhookInputQueryItemMiddleware: Middleware {
    public let id: String = "PutWebhookInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutWebhookInput>,
                  next: H) -> Swift.Result<OperationOutput<PutWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutWebhookInput>
    public typealias MOutput = OperationOutput<PutWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutWebhookOutputError>
}

public struct PutWebhookInput: Equatable {
    /// <p>The tags for the webhook.</p>
    public let tags: [Tag]?
    /// <p>The detail provided in an input file to create the webhook, such as the webhook
    ///             name, the pipeline name, and the action name. Give the webhook a unique name that helps
    ///             you identify it. You might name the webhook after the pipeline and action it targets so
    ///             that you can easily recognize what it's used for later.</p>
    public let webhook: WebhookDefinition?

    public init (
        tags: [Tag]? = nil,
        webhook: WebhookDefinition? = nil
    )
    {
        self.tags = tags
        self.webhook = webhook
    }
}

struct PutWebhookInputBody: Equatable {
    public let webhook: WebhookDefinition?
    public let tags: [Tag]?
}

extension PutWebhookInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
        case webhook
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookDecoded = try containerValues.decodeIfPresent(WebhookDefinition.self, forKey: .webhook)
        webhook = webhookDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutWebhookOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutWebhookOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagsException" : self = .invalidTagsException(try InvalidTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidWebhookAuthenticationParametersException" : self = .invalidWebhookAuthenticationParametersException(try InvalidWebhookAuthenticationParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidWebhookFilterPatternException" : self = .invalidWebhookFilterPatternException(try InvalidWebhookFilterPatternException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutWebhookOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidTagsException(InvalidTagsException)
    case invalidWebhookAuthenticationParametersException(InvalidWebhookAuthenticationParametersException)
    case invalidWebhookFilterPatternException(InvalidWebhookFilterPatternException)
    case limitExceededException(LimitExceededException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutWebhookOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutWebhookOutputResponse(webhook: \(String(describing: webhook)))"}
}

extension PutWebhookOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutWebhookOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.webhook = output.webhook
        } else {
            self.webhook = nil
        }
    }
}

public struct PutWebhookOutputResponse: Equatable {
    /// <p>The detail returned from creating the webhook, such as the webhook name, webhook
    ///             URL, and webhook ARN.</p>
    public let webhook: ListWebhookItem?

    public init (
        webhook: ListWebhookItem? = nil
    )
    {
        self.webhook = webhook
    }
}

struct PutWebhookOutputResponseBody: Equatable {
    public let webhook: ListWebhookItem?
}

extension PutWebhookOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case webhook
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookDecoded = try containerValues.decodeIfPresent(ListWebhookItem.self, forKey: .webhook)
        webhook = webhookDecoded
    }
}

public struct RegisterWebhookWithThirdPartyInputBodyMiddleware: Middleware {
    public let id: String = "RegisterWebhookWithThirdPartyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterWebhookWithThirdPartyInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterWebhookWithThirdPartyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterWebhookWithThirdPartyInput>
    public typealias MOutput = OperationOutput<RegisterWebhookWithThirdPartyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterWebhookWithThirdPartyOutputError>
}

extension RegisterWebhookWithThirdPartyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterWebhookWithThirdPartyInput(webhookName: \(String(describing: webhookName)))"}
}

extension RegisterWebhookWithThirdPartyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case webhookName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let webhookName = webhookName {
            try encodeContainer.encode(webhookName, forKey: .webhookName)
        }
    }
}

public struct RegisterWebhookWithThirdPartyInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterWebhookWithThirdPartyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterWebhookWithThirdPartyInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterWebhookWithThirdPartyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterWebhookWithThirdPartyInput>
    public typealias MOutput = OperationOutput<RegisterWebhookWithThirdPartyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterWebhookWithThirdPartyOutputError>
}

public struct RegisterWebhookWithThirdPartyInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterWebhookWithThirdPartyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterWebhookWithThirdPartyInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterWebhookWithThirdPartyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterWebhookWithThirdPartyInput>
    public typealias MOutput = OperationOutput<RegisterWebhookWithThirdPartyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterWebhookWithThirdPartyOutputError>
}

public struct RegisterWebhookWithThirdPartyInput: Equatable {
    /// <p>The name of an existing webhook created with PutWebhook to register with a
    ///             supported third party. </p>
    public let webhookName: String?

    public init (
        webhookName: String? = nil
    )
    {
        self.webhookName = webhookName
    }
}

struct RegisterWebhookWithThirdPartyInputBody: Equatable {
    public let webhookName: String?
}

extension RegisterWebhookWithThirdPartyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case webhookName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webhookName)
        webhookName = webhookNameDecoded
    }
}

extension RegisterWebhookWithThirdPartyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterWebhookWithThirdPartyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WebhookNotFoundException" : self = .webhookNotFoundException(try WebhookNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterWebhookWithThirdPartyOutputError: Swift.Error, Equatable {
    case validationException(ValidationException)
    case webhookNotFoundException(WebhookNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterWebhookWithThirdPartyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterWebhookWithThirdPartyOutputResponse()"}
}

extension RegisterWebhookWithThirdPartyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RegisterWebhookWithThirdPartyOutputResponse: Equatable {

    public init() {}
}

struct RegisterWebhookWithThirdPartyOutputResponseBody: Equatable {
}

extension RegisterWebhookWithThirdPartyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RequestFailedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestFailedException(message: \(String(describing: message)))"}
}

extension RequestFailedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RequestFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request failed because of an unknown error, exception, or failure.</p>
public struct RequestFailedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RequestFailedExceptionBody: Equatable {
    public let message: String?
}

extension RequestFailedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource was specified in an invalid format.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct RetryStageExecutionInputBodyMiddleware: Middleware {
    public let id: String = "RetryStageExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetryStageExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<RetryStageExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetryStageExecutionInput>
    public typealias MOutput = OperationOutput<RetryStageExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetryStageExecutionOutputError>
}

extension RetryStageExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetryStageExecutionInput(pipelineExecutionId: \(String(describing: pipelineExecutionId)), pipelineName: \(String(describing: pipelineName)), retryMode: \(String(describing: retryMode)), stageName: \(String(describing: stageName)))"}
}

extension RetryStageExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pipelineExecutionId
        case pipelineName
        case retryMode
        case stageName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineExecutionId = pipelineExecutionId {
            try encodeContainer.encode(pipelineExecutionId, forKey: .pipelineExecutionId)
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let retryMode = retryMode {
            try encodeContainer.encode(retryMode.rawValue, forKey: .retryMode)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
    }
}

public struct RetryStageExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "RetryStageExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetryStageExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<RetryStageExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetryStageExecutionInput>
    public typealias MOutput = OperationOutput<RetryStageExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetryStageExecutionOutputError>
}

public struct RetryStageExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "RetryStageExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RetryStageExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<RetryStageExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RetryStageExecutionInput>
    public typealias MOutput = OperationOutput<RetryStageExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RetryStageExecutionOutputError>
}

/// <p>Represents the input of a <code>RetryStageExecution</code> action.</p>
public struct RetryStageExecutionInput: Equatable {
    /// <p>The ID of the pipeline execution in the failed stage to be retried. Use the <a>GetPipelineState</a> action to retrieve the current pipelineExecutionId of
    ///             the failed stage</p>
    public let pipelineExecutionId: String?
    /// <p>The name of the pipeline that contains the failed stage.</p>
    public let pipelineName: String?
    /// <p>The scope of the retry attempt. Currently, the only supported value is
    ///             FAILED_ACTIONS.</p>
    public let retryMode: StageRetryMode?
    /// <p>The name of the failed stage to be retried.</p>
    public let stageName: String?

    public init (
        pipelineExecutionId: String? = nil,
        pipelineName: String? = nil,
        retryMode: StageRetryMode? = nil,
        stageName: String? = nil
    )
    {
        self.pipelineExecutionId = pipelineExecutionId
        self.pipelineName = pipelineName
        self.retryMode = retryMode
        self.stageName = stageName
    }
}

struct RetryStageExecutionInputBody: Equatable {
    public let pipelineName: String?
    public let stageName: String?
    public let pipelineExecutionId: String?
    public let retryMode: StageRetryMode?
}

extension RetryStageExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipelineExecutionId
        case pipelineName
        case retryMode
        case stageName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
        let retryModeDecoded = try containerValues.decodeIfPresent(StageRetryMode.self, forKey: .retryMode)
        retryMode = retryModeDecoded
    }
}

extension RetryStageExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RetryStageExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotLatestPipelineExecutionException" : self = .notLatestPipelineExecutionException(try NotLatestPipelineExecutionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StageNotFoundException" : self = .stageNotFoundException(try StageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StageNotRetryableException" : self = .stageNotRetryableException(try StageNotRetryableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RetryStageExecutionOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case notLatestPipelineExecutionException(NotLatestPipelineExecutionException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case stageNotFoundException(StageNotFoundException)
    case stageNotRetryableException(StageNotRetryableException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RetryStageExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetryStageExecutionOutputResponse(pipelineExecutionId: \(String(describing: pipelineExecutionId)))"}
}

extension RetryStageExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RetryStageExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pipelineExecutionId = output.pipelineExecutionId
        } else {
            self.pipelineExecutionId = nil
        }
    }
}

/// <p>Represents the output of a <code>RetryStageExecution</code> action.</p>
public struct RetryStageExecutionOutputResponse: Equatable {
    /// <p>The ID of the current workflow execution in the failed stage.</p>
    public let pipelineExecutionId: String?

    public init (
        pipelineExecutionId: String? = nil
    )
    {
        self.pipelineExecutionId = pipelineExecutionId
    }
}

struct RetryStageExecutionOutputResponseBody: Equatable {
    public let pipelineExecutionId: String?
}

extension RetryStageExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipelineExecutionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
    }
}

extension S3ArtifactLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucketName
        case objectKey
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let objectKey = objectKey {
            try encodeContainer.encode(objectKey, forKey: .objectKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let objectKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectKey)
        objectKey = objectKeyDecoded
    }
}

extension S3ArtifactLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3ArtifactLocation(bucketName: \(String(describing: bucketName)), objectKey: \(String(describing: objectKey)))"}
}

/// <p>The location of the S3 bucket that contains a revision.</p>
public struct S3ArtifactLocation: Equatable {
    /// <p>The name of the S3 bucket.</p>
    public let bucketName: String?
    /// <p>The key of the object in the S3 bucket, which uniquely identifies the object in the
    ///             bucket.</p>
    public let objectKey: String?

    public init (
        bucketName: String? = nil,
        objectKey: String? = nil
    )
    {
        self.bucketName = bucketName
        self.objectKey = objectKey
    }
}

extension S3Location: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket
        case key
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
    }
}

extension S3Location: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Location(bucket: \(String(describing: bucket)), key: \(String(describing: key)))"}
}

/// <p>The Amazon S3 artifact location for an action's artifacts.</p>
public struct S3Location: Equatable {
    /// <p>The Amazon S3 artifact bucket for an action's artifacts.</p>
    public let bucket: String?
    /// <p>The artifact name.</p>
    public let key: String?

    public init (
        bucket: String? = nil,
        key: String? = nil
    )
    {
        self.bucket = bucket
        self.key = key
    }
}

extension SourceRevision: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionName
        case revisionId
        case revisionSummary
        case revisionUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionName = actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let revisionSummary = revisionSummary {
            try encodeContainer.encode(revisionSummary, forKey: .revisionSummary)
        }
        if let revisionUrl = revisionUrl {
            try encodeContainer.encode(revisionUrl, forKey: .revisionUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let revisionSummaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionSummary)
        revisionSummary = revisionSummaryDecoded
        let revisionUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionUrl)
        revisionUrl = revisionUrlDecoded
    }
}

extension SourceRevision: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceRevision(actionName: \(String(describing: actionName)), revisionId: \(String(describing: revisionId)), revisionSummary: \(String(describing: revisionSummary)), revisionUrl: \(String(describing: revisionUrl)))"}
}

/// <p>Information about the version (or revision) of a source artifact that initiated a
///             pipeline execution.</p>
public struct SourceRevision: Equatable {
    /// <p>The name of the action that processed the revision to the source
    ///             artifact.</p>
    public let actionName: String?
    /// <p>The system-generated unique ID that identifies the revision number of the
    ///             artifact.</p>
    public let revisionId: String?
    /// <p>Summary information about the most recent revision of the artifact. For GitHub and
    ///             AWS CodeCommit repositories, the commit message. For Amazon S3 buckets or actions, the
    ///             user-provided content of a <code>codepipeline-artifact-revision-summary</code> key
    ///             specified in the object metadata.</p>
    public let revisionSummary: String?
    /// <p>The commit ID for the artifact revision. For artifacts stored in GitHub or AWS
    ///             CodeCommit repositories, the commit ID is linked to a commit details page.</p>
    public let revisionUrl: String?

    public init (
        actionName: String? = nil,
        revisionId: String? = nil,
        revisionSummary: String? = nil,
        revisionUrl: String? = nil
    )
    {
        self.actionName = actionName
        self.revisionId = revisionId
        self.revisionSummary = revisionSummary
        self.revisionUrl = revisionUrl
    }
}

extension StageContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension StageContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StageContext(name: \(String(describing: name)))"}
}

/// <p>Represents information about a stage to a job worker.</p>
public struct StageContext: Equatable {
    /// <p>The name of the stage.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

extension StageDeclaration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions
        case blockers
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for stageactiondeclarationlist0 in actions {
                try actionsContainer.encode(stageactiondeclarationlist0)
            }
        }
        if let blockers = blockers {
            var blockersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockers)
            for stageblockerdeclarationlist0 in blockers {
                try blockersContainer.encode(stageblockerdeclarationlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let blockersContainer = try containerValues.decodeIfPresent([BlockerDeclaration?].self, forKey: .blockers)
        var blockersDecoded0:[BlockerDeclaration]? = nil
        if let blockersContainer = blockersContainer {
            blockersDecoded0 = [BlockerDeclaration]()
            for structure0 in blockersContainer {
                if let structure0 = structure0 {
                    blockersDecoded0?.append(structure0)
                }
            }
        }
        blockers = blockersDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([ActionDeclaration?].self, forKey: .actions)
        var actionsDecoded0:[ActionDeclaration]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [ActionDeclaration]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension StageDeclaration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StageDeclaration(actions: \(String(describing: actions)), blockers: \(String(describing: blockers)), name: \(String(describing: name)))"}
}

/// <p>Represents information about a stage and its definition.</p>
public struct StageDeclaration: Equatable {
    /// <p>The actions included in a stage.</p>
    public let actions: [ActionDeclaration]?
    /// <p>Reserved for future use.</p>
    public let blockers: [BlockerDeclaration]?
    /// <p>The name of the stage.</p>
    public let name: String?

    public init (
        actions: [ActionDeclaration]? = nil,
        blockers: [BlockerDeclaration]? = nil,
        name: String? = nil
    )
    {
        self.actions = actions
        self.blockers = blockers
        self.name = name
    }
}

extension StageExecution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pipelineExecutionId
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineExecutionId = pipelineExecutionId {
            try encodeContainer.encode(pipelineExecutionId, forKey: .pipelineExecutionId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(StageExecutionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension StageExecution: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StageExecution(pipelineExecutionId: \(String(describing: pipelineExecutionId)), status: \(String(describing: status)))"}
}

/// <p>Represents information about the run of a stage.</p>
public struct StageExecution: Equatable {
    /// <p>The ID of the pipeline execution associated with the stage.</p>
    public let pipelineExecutionId: String?
    /// <p>The status of the stage, or for a completed stage, the last status of the
    ///             stage.</p>
    ///         <note>
    ///             <p>A status of cancelled means that the pipelines definition was updated before the
    ///                 stage execution could be completed.</p>
    ///         </note>
    public let status: StageExecutionStatus?

    public init (
        pipelineExecutionId: String? = nil,
        status: StageExecutionStatus? = nil
    )
    {
        self.pipelineExecutionId = pipelineExecutionId
        self.status = status
    }
}

public enum StageExecutionStatus {
    case cancelled
    case failed
    case inprogress
    case stopped
    case stopping
    case succeeded
    case sdkUnknown(String)
}

extension StageExecutionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StageExecutionStatus] {
        return [
            .cancelled,
            .failed,
            .inprogress,
            .stopped,
            .stopping,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "Cancelled"
        case .failed: return "Failed"
        case .inprogress: return "InProgress"
        case .stopped: return "Stopped"
        case .stopping: return "Stopping"
        case .succeeded: return "Succeeded"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StageExecutionStatus(rawValue: rawValue) ?? StageExecutionStatus.sdkUnknown(rawValue)
    }
}

extension StageNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StageNotFoundException(message: \(String(describing: message)))"}
}

extension StageNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StageNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The stage was specified in an invalid format or cannot be found.</p>
public struct StageNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StageNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension StageNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StageNotRetryableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StageNotRetryableException(message: \(String(describing: message)))"}
}

extension StageNotRetryableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StageNotRetryableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Unable to retry. The pipeline structure or stage state might have changed while
///             actions awaited retry, or the stage contains no failed
///             actions.</p>
public struct StageNotRetryableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct StageNotRetryableExceptionBody: Equatable {
    public let message: String?
}

extension StageNotRetryableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum StageRetryMode {
    case failedActions
    case sdkUnknown(String)
}

extension StageRetryMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StageRetryMode] {
        return [
            .failedActions,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failedActions: return "FAILED_ACTIONS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StageRetryMode(rawValue: rawValue) ?? StageRetryMode.sdkUnknown(rawValue)
    }
}

extension StageState: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionStates
        case inboundExecution
        case inboundTransitionState
        case latestExecution
        case stageName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionStates = actionStates {
            var actionStatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actionStates)
            for actionstatelist0 in actionStates {
                try actionStatesContainer.encode(actionstatelist0)
            }
        }
        if let inboundExecution = inboundExecution {
            try encodeContainer.encode(inboundExecution, forKey: .inboundExecution)
        }
        if let inboundTransitionState = inboundTransitionState {
            try encodeContainer.encode(inboundTransitionState, forKey: .inboundTransitionState)
        }
        if let latestExecution = latestExecution {
            try encodeContainer.encode(latestExecution, forKey: .latestExecution)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let inboundExecutionDecoded = try containerValues.decodeIfPresent(StageExecution.self, forKey: .inboundExecution)
        inboundExecution = inboundExecutionDecoded
        let inboundTransitionStateDecoded = try containerValues.decodeIfPresent(TransitionState.self, forKey: .inboundTransitionState)
        inboundTransitionState = inboundTransitionStateDecoded
        let actionStatesContainer = try containerValues.decodeIfPresent([ActionState?].self, forKey: .actionStates)
        var actionStatesDecoded0:[ActionState]? = nil
        if let actionStatesContainer = actionStatesContainer {
            actionStatesDecoded0 = [ActionState]()
            for structure0 in actionStatesContainer {
                if let structure0 = structure0 {
                    actionStatesDecoded0?.append(structure0)
                }
            }
        }
        actionStates = actionStatesDecoded0
        let latestExecutionDecoded = try containerValues.decodeIfPresent(StageExecution.self, forKey: .latestExecution)
        latestExecution = latestExecutionDecoded
    }
}

extension StageState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StageState(actionStates: \(String(describing: actionStates)), inboundExecution: \(String(describing: inboundExecution)), inboundTransitionState: \(String(describing: inboundTransitionState)), latestExecution: \(String(describing: latestExecution)), stageName: \(String(describing: stageName)))"}
}

/// <p>Represents information about the state of the stage.</p>
public struct StageState: Equatable {
    /// <p>The state of the stage.</p>
    public let actionStates: [ActionState]?
    /// <p>Represents information about the run of a stage.</p>
    public let inboundExecution: StageExecution?
    /// <p>The state of the inbound transition, which is either enabled or disabled.</p>
    public let inboundTransitionState: TransitionState?
    /// <p>Information about the latest execution in the stage, including its ID and
    ///             status.</p>
    public let latestExecution: StageExecution?
    /// <p>The name of the stage.</p>
    public let stageName: String?

    public init (
        actionStates: [ActionState]? = nil,
        inboundExecution: StageExecution? = nil,
        inboundTransitionState: TransitionState? = nil,
        latestExecution: StageExecution? = nil,
        stageName: String? = nil
    )
    {
        self.actionStates = actionStates
        self.inboundExecution = inboundExecution
        self.inboundTransitionState = inboundTransitionState
        self.latestExecution = latestExecution
        self.stageName = stageName
    }
}

public enum StageTransitionType {
    case inbound
    case outbound
    case sdkUnknown(String)
}

extension StageTransitionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StageTransitionType] {
        return [
            .inbound,
            .outbound,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .inbound: return "Inbound"
        case .outbound: return "Outbound"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StageTransitionType(rawValue: rawValue) ?? StageTransitionType.sdkUnknown(rawValue)
    }
}

public struct StartPipelineExecutionInputBodyMiddleware: Middleware {
    public let id: String = "StartPipelineExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartPipelineExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartPipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartPipelineExecutionInput>
    public typealias MOutput = OperationOutput<StartPipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartPipelineExecutionOutputError>
}

extension StartPipelineExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartPipelineExecutionInput(clientRequestToken: \(String(describing: clientRequestToken)), name: \(String(describing: name)))"}
}

extension StartPipelineExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct StartPipelineExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "StartPipelineExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartPipelineExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartPipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartPipelineExecutionInput>
    public typealias MOutput = OperationOutput<StartPipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartPipelineExecutionOutputError>
}

public struct StartPipelineExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "StartPipelineExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartPipelineExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StartPipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartPipelineExecutionInput>
    public typealias MOutput = OperationOutput<StartPipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartPipelineExecutionOutputError>
}

/// <p>Represents the input of a <code>StartPipelineExecution</code> action.</p>
public struct StartPipelineExecutionInput: Equatable {
    /// <p>The system-generated unique ID used to identify a unique execution
    ///             request.</p>
    public var clientRequestToken: String?
    /// <p>The name of the pipeline to start.</p>
    public let name: String?

    public init (
        clientRequestToken: String? = nil,
        name: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.name = name
    }
}

struct StartPipelineExecutionInputBody: Equatable {
    public let name: String?
    public let clientRequestToken: String?
}

extension StartPipelineExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension StartPipelineExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartPipelineExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartPipelineExecutionOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartPipelineExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartPipelineExecutionOutputResponse(pipelineExecutionId: \(String(describing: pipelineExecutionId)))"}
}

extension StartPipelineExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartPipelineExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pipelineExecutionId = output.pipelineExecutionId
        } else {
            self.pipelineExecutionId = nil
        }
    }
}

/// <p>Represents the output of a <code>StartPipelineExecution</code> action.</p>
public struct StartPipelineExecutionOutputResponse: Equatable {
    /// <p>The unique system-generated ID of the pipeline execution that was
    ///             started.</p>
    public let pipelineExecutionId: String?

    public init (
        pipelineExecutionId: String? = nil
    )
    {
        self.pipelineExecutionId = pipelineExecutionId
    }
}

struct StartPipelineExecutionOutputResponseBody: Equatable {
    public let pipelineExecutionId: String?
}

extension StartPipelineExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipelineExecutionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
    }
}

extension StopExecutionTrigger: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reason
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension StopExecutionTrigger: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopExecutionTrigger(reason: \(String(describing: reason)))"}
}

/// <p>The interaction that stopped a pipeline execution.</p>
public struct StopExecutionTrigger: Equatable {
    /// <p>The user-specified reason the pipeline was stopped.</p>
    public let reason: String?

    public init (
        reason: String? = nil
    )
    {
        self.reason = reason
    }
}

public struct StopPipelineExecutionInputBodyMiddleware: Middleware {
    public let id: String = "StopPipelineExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopPipelineExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StopPipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopPipelineExecutionInput>
    public typealias MOutput = OperationOutput<StopPipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopPipelineExecutionOutputError>
}

extension StopPipelineExecutionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopPipelineExecutionInput(abandon: \(String(describing: abandon)), pipelineExecutionId: \(String(describing: pipelineExecutionId)), pipelineName: \(String(describing: pipelineName)), reason: \(String(describing: reason)))"}
}

extension StopPipelineExecutionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case abandon
        case pipelineExecutionId
        case pipelineName
        case reason
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if abandon != false {
            try encodeContainer.encode(abandon, forKey: .abandon)
        }
        if let pipelineExecutionId = pipelineExecutionId {
            try encodeContainer.encode(pipelineExecutionId, forKey: .pipelineExecutionId)
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }
}

public struct StopPipelineExecutionInputHeadersMiddleware: Middleware {
    public let id: String = "StopPipelineExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopPipelineExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StopPipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopPipelineExecutionInput>
    public typealias MOutput = OperationOutput<StopPipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopPipelineExecutionOutputError>
}

public struct StopPipelineExecutionInputQueryItemMiddleware: Middleware {
    public let id: String = "StopPipelineExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopPipelineExecutionInput>,
                  next: H) -> Swift.Result<OperationOutput<StopPipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopPipelineExecutionInput>
    public typealias MOutput = OperationOutput<StopPipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopPipelineExecutionOutputError>
}

public struct StopPipelineExecutionInput: Equatable {
    /// <p>Use this option to stop the pipeline execution by abandoning, rather than finishing,
    ///             in-progress actions.</p>
    ///         <note>
    ///             <p>This option can lead to failed or out-of-sequence tasks.</p>
    ///         </note>
    public let abandon: Bool
    /// <p>The ID of the pipeline execution to be stopped in the current stage. Use the
    ///                 <code>GetPipelineState</code> action to retrieve the current
    ///             pipelineExecutionId.</p>
    public let pipelineExecutionId: String?
    /// <p>The name of the pipeline to stop.</p>
    public let pipelineName: String?
    /// <p>Use this option to enter comments, such as the reason the pipeline was stopped.</p>
    public let reason: String?

    public init (
        abandon: Bool = false,
        pipelineExecutionId: String? = nil,
        pipelineName: String? = nil,
        reason: String? = nil
    )
    {
        self.abandon = abandon
        self.pipelineExecutionId = pipelineExecutionId
        self.pipelineName = pipelineName
        self.reason = reason
    }
}

struct StopPipelineExecutionInputBody: Equatable {
    public let pipelineName: String?
    public let pipelineExecutionId: String?
    public let abandon: Bool
    public let reason: String?
}

extension StopPipelineExecutionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case abandon
        case pipelineExecutionId
        case pipelineName
        case reason
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
        let abandonDecoded = try containerValues.decode(Bool.self, forKey: .abandon)
        abandon = abandonDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension StopPipelineExecutionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopPipelineExecutionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicatedStopRequestException" : self = .duplicatedStopRequestException(try DuplicatedStopRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineExecutionNotStoppableException" : self = .pipelineExecutionNotStoppableException(try PipelineExecutionNotStoppableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopPipelineExecutionOutputError: Swift.Error, Equatable {
    case conflictException(ConflictException)
    case duplicatedStopRequestException(DuplicatedStopRequestException)
    case pipelineExecutionNotStoppableException(PipelineExecutionNotStoppableException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopPipelineExecutionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopPipelineExecutionOutputResponse(pipelineExecutionId: \(String(describing: pipelineExecutionId)))"}
}

extension StopPipelineExecutionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopPipelineExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pipelineExecutionId = output.pipelineExecutionId
        } else {
            self.pipelineExecutionId = nil
        }
    }
}

public struct StopPipelineExecutionOutputResponse: Equatable {
    /// <p>The unique system-generated ID of the pipeline execution that was stopped.</p>
    public let pipelineExecutionId: String?

    public init (
        pipelineExecutionId: String? = nil
    )
    {
        self.pipelineExecutionId = pipelineExecutionId
    }
}

struct StopPipelineExecutionOutputResponseBody: Equatable {
    public let pipelineExecutionId: String?
}

extension StopPipelineExecutionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipelineExecutionId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A tag is a key-value pair that is used to manage the resource.</p>
public struct Tag: Equatable {
    /// <p>The tag's key.</p>
    public let key: String?
    /// <p>The tag's value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource you want to add tags to.</p>
    public let resourceArn: String?
    /// <p>The tags you want to modify or add to the resource.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagsException" : self = .invalidTagsException(try InvalidTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArnException(InvalidArnException)
    case invalidTagsException(InvalidTagsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThirdPartyJob: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientId
        case jobId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension ThirdPartyJob: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThirdPartyJob(clientId: \(String(describing: clientId)), jobId: \(String(describing: jobId)))"}
}

/// <p>A response to a <code>PollForThirdPartyJobs</code> request returned by AWS
///             CodePipeline when there is a job to be worked on by a partner action.</p>
public struct ThirdPartyJob: Equatable {
    /// <p>The <code>clientToken</code> portion of the <code>clientId</code> and
    ///                 <code>clientToken</code> pair used to verify that the calling entity is allowed
    ///             access to the job and its details.</p>
    public let clientId: String?
    /// <p>The identifier used to identify the job in AWS CodePipeline.</p>
    public let jobId: String?

    public init (
        clientId: String? = nil,
        jobId: String? = nil
    )
    {
        self.clientId = clientId
        self.jobId = jobId
    }
}

extension ThirdPartyJobData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionConfiguration
        case actionTypeId
        case artifactCredentials
        case continuationToken
        case encryptionKey
        case inputArtifacts
        case outputArtifacts
        case pipelineContext
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionConfiguration = actionConfiguration {
            try encodeContainer.encode(actionConfiguration, forKey: .actionConfiguration)
        }
        if let actionTypeId = actionTypeId {
            try encodeContainer.encode(actionTypeId, forKey: .actionTypeId)
        }
        if let artifactCredentials = artifactCredentials {
            try encodeContainer.encode(artifactCredentials, forKey: .artifactCredentials)
        }
        if let continuationToken = continuationToken {
            try encodeContainer.encode(continuationToken, forKey: .continuationToken)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let inputArtifacts = inputArtifacts {
            var inputArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputArtifacts)
            for artifactlist0 in inputArtifacts {
                try inputArtifactsContainer.encode(artifactlist0)
            }
        }
        if let outputArtifacts = outputArtifacts {
            var outputArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputArtifacts)
            for artifactlist0 in outputArtifacts {
                try outputArtifactsContainer.encode(artifactlist0)
            }
        }
        if let pipelineContext = pipelineContext {
            try encodeContainer.encode(pipelineContext, forKey: .pipelineContext)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeIdDecoded = try containerValues.decodeIfPresent(ActionTypeId.self, forKey: .actionTypeId)
        actionTypeId = actionTypeIdDecoded
        let actionConfigurationDecoded = try containerValues.decodeIfPresent(ActionConfiguration.self, forKey: .actionConfiguration)
        actionConfiguration = actionConfigurationDecoded
        let pipelineContextDecoded = try containerValues.decodeIfPresent(PipelineContext.self, forKey: .pipelineContext)
        pipelineContext = pipelineContextDecoded
        let inputArtifactsContainer = try containerValues.decodeIfPresent([Artifact?].self, forKey: .inputArtifacts)
        var inputArtifactsDecoded0:[Artifact]? = nil
        if let inputArtifactsContainer = inputArtifactsContainer {
            inputArtifactsDecoded0 = [Artifact]()
            for structure0 in inputArtifactsContainer {
                if let structure0 = structure0 {
                    inputArtifactsDecoded0?.append(structure0)
                }
            }
        }
        inputArtifacts = inputArtifactsDecoded0
        let outputArtifactsContainer = try containerValues.decodeIfPresent([Artifact?].self, forKey: .outputArtifacts)
        var outputArtifactsDecoded0:[Artifact]? = nil
        if let outputArtifactsContainer = outputArtifactsContainer {
            outputArtifactsDecoded0 = [Artifact]()
            for structure0 in outputArtifactsContainer {
                if let structure0 = structure0 {
                    outputArtifactsDecoded0?.append(structure0)
                }
            }
        }
        outputArtifacts = outputArtifactsDecoded0
        let artifactCredentialsDecoded = try containerValues.decodeIfPresent(AWSSessionCredentials.self, forKey: .artifactCredentials)
        artifactCredentials = artifactCredentialsDecoded
        let continuationTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .continuationToken)
        continuationToken = continuationTokenDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(EncryptionKey.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
    }
}

extension ThirdPartyJobData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThirdPartyJobData(actionConfiguration: \(String(describing: actionConfiguration)), actionTypeId: \(String(describing: actionTypeId)), artifactCredentials: \(String(describing: artifactCredentials)), continuationToken: \(String(describing: continuationToken)), encryptionKey: \(String(describing: encryptionKey)), inputArtifacts: \(String(describing: inputArtifacts)), outputArtifacts: \(String(describing: outputArtifacts)), pipelineContext: \(String(describing: pipelineContext)))"}
}

/// <p>Represents information about the job data for a partner action.</p>
public struct ThirdPartyJobData: Equatable {
    /// <p>Represents information about an action configuration.</p>
    public let actionConfiguration: ActionConfiguration?
    /// <p>Represents information about an action type.</p>
    public let actionTypeId: ActionTypeId?
    /// <p>Represents an AWS session credentials object. These credentials are temporary
    ///             credentials that are issued by AWS Secure Token Service (STS). They can be used to
    ///             access input and output artifacts in the S3 bucket used to store artifact for the
    ///             pipeline in AWS CodePipeline. </p>
    public let artifactCredentials: AWSSessionCredentials?
    /// <p>A system-generated token, such as a AWS CodeDeploy deployment ID, that a job
    ///             requires to continue the job asynchronously.</p>
    public let continuationToken: String?
    /// <p>The encryption key used to encrypt and decrypt data in the artifact store for the
    ///             pipeline, such as an AWS Key Management Service (AWS KMS) key. This is optional and
    ///             might not be present.</p>
    public let encryptionKey: EncryptionKey?
    /// <p>The name of the artifact that is worked on by the action, if any. This name might
    ///             be system-generated, such as "MyApp", or it might be defined by the user when the action
    ///             is created. The input artifact name must match the name of an output artifact generated
    ///             by an action in an earlier action or stage of the pipeline.</p>
    public let inputArtifacts: [Artifact]?
    /// <p>The name of the artifact that is the result of the action, if any. This name might
    ///             be system-generated, such as "MyBuiltApp", or it might be defined by the user when the
    ///             action is created.</p>
    public let outputArtifacts: [Artifact]?
    /// <p>Represents information about a pipeline to a job worker.</p>
    ///         <note>
    ///             <p>Does not include <code>pipelineArn</code> and <code>pipelineExecutionId</code>
    ///                 for ThirdParty jobs.</p>
    ///         </note>
    public let pipelineContext: PipelineContext?

    public init (
        actionConfiguration: ActionConfiguration? = nil,
        actionTypeId: ActionTypeId? = nil,
        artifactCredentials: AWSSessionCredentials? = nil,
        continuationToken: String? = nil,
        encryptionKey: EncryptionKey? = nil,
        inputArtifacts: [Artifact]? = nil,
        outputArtifacts: [Artifact]? = nil,
        pipelineContext: PipelineContext? = nil
    )
    {
        self.actionConfiguration = actionConfiguration
        self.actionTypeId = actionTypeId
        self.artifactCredentials = artifactCredentials
        self.continuationToken = continuationToken
        self.encryptionKey = encryptionKey
        self.inputArtifacts = inputArtifacts
        self.outputArtifacts = outputArtifacts
        self.pipelineContext = pipelineContext
    }
}

extension ThirdPartyJobDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case data
        case id
        case nonce
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let nonce = nonce {
            try encodeContainer.encode(nonce, forKey: .nonce)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let dataDecoded = try containerValues.decodeIfPresent(ThirdPartyJobData.self, forKey: .data)
        data = dataDecoded
        let nonceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nonce)
        nonce = nonceDecoded
    }
}

extension ThirdPartyJobDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThirdPartyJobDetails(data: \(String(describing: data)), id: \(String(describing: id)), nonce: \(String(describing: nonce)))"}
}

/// <p>The details of a job sent in response to a <code>GetThirdPartyJobDetails</code>
///             request.</p>
public struct ThirdPartyJobDetails: Equatable {
    /// <p>The data to be returned by the third party job worker.</p>
    public let data: ThirdPartyJobData?
    /// <p>The identifier used to identify the job details in AWS CodePipeline.</p>
    public let id: String?
    /// <p>A system-generated random number that AWS CodePipeline uses to ensure that the job
    ///             is being worked on by only one job worker. Use this number in an <a>AcknowledgeThirdPartyJob</a> request.</p>
    public let nonce: String?

    public init (
        data: ThirdPartyJobData? = nil,
        id: String? = nil,
        nonce: String? = nil
    )
    {
        self.data = data
        self.id = id
        self.nonce = nonce
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The tags limit for a resource has been exceeded.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TransitionState: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case disabledReason
        case enabled
        case lastChangedAt
        case lastChangedBy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabledReason = disabledReason {
            try encodeContainer.encode(disabledReason, forKey: .disabledReason)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let lastChangedAt = lastChangedAt {
            try encodeContainer.encode(lastChangedAt.timeIntervalSince1970, forKey: .lastChangedAt)
        }
        if let lastChangedBy = lastChangedBy {
            try encodeContainer.encode(lastChangedBy, forKey: .lastChangedBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let lastChangedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastChangedBy)
        lastChangedBy = lastChangedByDecoded
        let lastChangedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastChangedAt)
        lastChangedAt = lastChangedAtDecoded
        let disabledReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .disabledReason)
        disabledReason = disabledReasonDecoded
    }
}

extension TransitionState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TransitionState(disabledReason: \(String(describing: disabledReason)), enabled: \(String(describing: enabled)), lastChangedAt: \(String(describing: lastChangedAt)), lastChangedBy: \(String(describing: lastChangedBy)))"}
}

/// <p>Represents information about the state of transitions between one stage and another
///             stage.</p>
public struct TransitionState: Equatable {
    /// <p>The user-specified reason why the transition between two stages of a pipeline was
    ///             disabled.</p>
    public let disabledReason: String?
    /// <p>Whether the transition between stages is enabled (true) or disabled
    ///             (false).</p>
    public let enabled: Bool
    /// <p>The timestamp when the transition state was last changed.</p>
    public let lastChangedAt: Date?
    /// <p>The ID of the user who last changed the transition state.</p>
    public let lastChangedBy: String?

    public init (
        disabledReason: String? = nil,
        enabled: Bool = false,
        lastChangedAt: Date? = nil,
        lastChangedBy: String? = nil
    )
    {
        self.disabledReason = disabledReason
        self.enabled = enabled
        self.lastChangedAt = lastChangedAt
        self.lastChangedBy = lastChangedBy
    }
}

public enum TriggerType {
    case cloudwatchevent
    case createpipeline
    case pollforsourcechanges
    case putactionrevision
    case startpipelineexecution
    case webhook
    case sdkUnknown(String)
}

extension TriggerType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TriggerType] {
        return [
            .cloudwatchevent,
            .createpipeline,
            .pollforsourcechanges,
            .putactionrevision,
            .startpipelineexecution,
            .webhook,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cloudwatchevent: return "CloudWatchEvent"
        case .createpipeline: return "CreatePipeline"
        case .pollforsourcechanges: return "PollForSourceChanges"
        case .putactionrevision: return "PutActionRevision"
        case .startpipelineexecution: return "StartPipelineExecution"
        case .webhook: return "Webhook"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TriggerType(rawValue: rawValue) ?? TriggerType.sdkUnknown(rawValue)
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p> The Amazon Resource Name (ARN) of the resource to remove tags from.</p>
    public let resourceArn: String?
    /// <p>The list of keys for the tags to be removed from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagsException" : self = .invalidTagsException(try InvalidTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArnException(InvalidArnException)
    case invalidTagsException(InvalidTagsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateActionTypeInputBodyMiddleware: Middleware {
    public let id: String = "UpdateActionTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateActionTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateActionTypeInput>
    public typealias MOutput = OperationOutput<UpdateActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateActionTypeOutputError>
}

extension UpdateActionTypeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateActionTypeInput(actionType: \(String(describing: actionType)))"}
}

extension UpdateActionTypeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionType = actionType {
            try encodeContainer.encode(actionType, forKey: .actionType)
        }
    }
}

public struct UpdateActionTypeInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateActionTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateActionTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateActionTypeInput>
    public typealias MOutput = OperationOutput<UpdateActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateActionTypeOutputError>
}

public struct UpdateActionTypeInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateActionTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateActionTypeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateActionTypeInput>
    public typealias MOutput = OperationOutput<UpdateActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateActionTypeOutputError>
}

public struct UpdateActionTypeInput: Equatable {
    /// <p>The action type definition for the action type to be updated.</p>
    public let actionType: ActionTypeDeclaration?

    public init (
        actionType: ActionTypeDeclaration? = nil
    )
    {
        self.actionType = actionType
    }
}

struct UpdateActionTypeInputBody: Equatable {
    public let actionType: ActionTypeDeclaration?
}

extension UpdateActionTypeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(ActionTypeDeclaration.self, forKey: .actionType)
        actionType = actionTypeDecoded
    }
}

extension UpdateActionTypeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateActionTypeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ActionTypeNotFoundException" : self = .actionTypeNotFoundException(try ActionTypeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateActionTypeOutputError: Swift.Error, Equatable {
    case actionTypeNotFoundException(ActionTypeNotFoundException)
    case requestFailedException(RequestFailedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateActionTypeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateActionTypeOutputResponse()"}
}

extension UpdateActionTypeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateActionTypeOutputResponse: Equatable {

    public init() {}
}

struct UpdateActionTypeOutputResponseBody: Equatable {
}

extension UpdateActionTypeOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdatePipelineInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePipelineInput>
    public typealias MOutput = OperationOutput<UpdatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePipelineOutputError>
}

extension UpdatePipelineInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePipelineInput(pipeline: \(String(describing: pipeline)))"}
}

extension UpdatePipelineInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pipeline
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipeline = pipeline {
            try encodeContainer.encode(pipeline, forKey: .pipeline)
        }
    }
}

public struct UpdatePipelineInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePipelineInput>
    public typealias MOutput = OperationOutput<UpdatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePipelineOutputError>
}

public struct UpdatePipelineInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePipelineInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePipelineInput>
    public typealias MOutput = OperationOutput<UpdatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePipelineOutputError>
}

/// <p>Represents the input of an <code>UpdatePipeline</code> action.</p>
public struct UpdatePipelineInput: Equatable {
    /// <p>The name of the pipeline to be updated.</p>
    public let pipeline: PipelineDeclaration?

    public init (
        pipeline: PipelineDeclaration? = nil
    )
    {
        self.pipeline = pipeline
    }
}

struct UpdatePipelineInputBody: Equatable {
    public let pipeline: PipelineDeclaration?
}

extension UpdatePipelineInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipeline
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(PipelineDeclaration.self, forKey: .pipeline)
        pipeline = pipelineDecoded
    }
}

extension UpdatePipelineOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePipelineOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidActionDeclarationException" : self = .invalidActionDeclarationException(try InvalidActionDeclarationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBlockerDeclarationException" : self = .invalidBlockerDeclarationException(try InvalidBlockerDeclarationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStageDeclarationException" : self = .invalidStageDeclarationException(try InvalidStageDeclarationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStructureException" : self = .invalidStructureException(try InvalidStructureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePipelineOutputError: Swift.Error, Equatable {
    case invalidActionDeclarationException(InvalidActionDeclarationException)
    case invalidBlockerDeclarationException(InvalidBlockerDeclarationException)
    case invalidStageDeclarationException(InvalidStageDeclarationException)
    case invalidStructureException(InvalidStructureException)
    case limitExceededException(LimitExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePipelineOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePipelineOutputResponse(pipeline: \(String(describing: pipeline)))"}
}

extension UpdatePipelineOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pipeline = output.pipeline
        } else {
            self.pipeline = nil
        }
    }
}

/// <p>Represents the output of an <code>UpdatePipeline</code> action.</p>
public struct UpdatePipelineOutputResponse: Equatable {
    /// <p>The structure of the updated pipeline.</p>
    public let pipeline: PipelineDeclaration?

    public init (
        pipeline: PipelineDeclaration? = nil
    )
    {
        self.pipeline = pipeline
    }
}

struct UpdatePipelineOutputResponseBody: Equatable {
    public let pipeline: PipelineDeclaration?
}

extension UpdatePipelineOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pipeline
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(PipelineDeclaration.self, forKey: .pipeline)
        pipeline = pipelineDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The validation was specified in an invalid format.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WebhookAuthConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedIPRange = "AllowedIPRange"
        case secretToken = "SecretToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedIPRange = allowedIPRange {
            try encodeContainer.encode(allowedIPRange, forKey: .allowedIPRange)
        }
        if let secretToken = secretToken {
            try encodeContainer.encode(secretToken, forKey: .secretToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedIPRangeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .allowedIPRange)
        allowedIPRange = allowedIPRangeDecoded
        let secretTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretToken)
        secretToken = secretTokenDecoded
    }
}

extension WebhookAuthConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WebhookAuthConfiguration(allowedIPRange: \(String(describing: allowedIPRange)), secretToken: \(String(describing: secretToken)))"}
}

/// <p>The authentication applied to incoming webhook trigger requests.</p>
public struct WebhookAuthConfiguration: Equatable {
    /// <p>The property used to configure acceptance of webhooks in an IP address range. For
    ///             IP, only the <code>AllowedIPRange</code> property must be set. This property must be set
    ///             to a valid CIDR range.</p>
    public let allowedIPRange: String?
    /// <p>The property used to configure GitHub authentication. For GITHUB_HMAC, only the
    ///                 <code>SecretToken</code> property must be set.</p>
    public let secretToken: String?

    public init (
        allowedIPRange: String? = nil,
        secretToken: String? = nil
    )
    {
        self.allowedIPRange = allowedIPRange
        self.secretToken = secretToken
    }
}

public enum WebhookAuthenticationType {
    case githubHmac
    case ip
    case unauthenticated
    case sdkUnknown(String)
}

extension WebhookAuthenticationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WebhookAuthenticationType] {
        return [
            .githubHmac,
            .ip,
            .unauthenticated,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .githubHmac: return "GITHUB_HMAC"
        case .ip: return "IP"
        case .unauthenticated: return "UNAUTHENTICATED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WebhookAuthenticationType(rawValue: rawValue) ?? WebhookAuthenticationType.sdkUnknown(rawValue)
    }
}

extension WebhookDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authentication
        case authenticationConfiguration
        case filters
        case name
        case targetAction
        case targetPipeline
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authentication = authentication {
            try encodeContainer.encode(authentication.rawValue, forKey: .authentication)
        }
        if let authenticationConfiguration = authenticationConfiguration {
            try encodeContainer.encode(authenticationConfiguration, forKey: .authenticationConfiguration)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for webhookfilters0 in filters {
                try filtersContainer.encode(webhookfilters0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let targetAction = targetAction {
            try encodeContainer.encode(targetAction, forKey: .targetAction)
        }
        if let targetPipeline = targetPipeline {
            try encodeContainer.encode(targetPipeline, forKey: .targetPipeline)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let targetPipelineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetPipeline)
        targetPipeline = targetPipelineDecoded
        let targetActionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetAction)
        targetAction = targetActionDecoded
        let filtersContainer = try containerValues.decodeIfPresent([WebhookFilterRule?].self, forKey: .filters)
        var filtersDecoded0:[WebhookFilterRule]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [WebhookFilterRule]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let authenticationDecoded = try containerValues.decodeIfPresent(WebhookAuthenticationType.self, forKey: .authentication)
        authentication = authenticationDecoded
        let authenticationConfigurationDecoded = try containerValues.decodeIfPresent(WebhookAuthConfiguration.self, forKey: .authenticationConfiguration)
        authenticationConfiguration = authenticationConfigurationDecoded
    }
}

extension WebhookDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WebhookDefinition(authentication: \(String(describing: authentication)), authenticationConfiguration: \(String(describing: authenticationConfiguration)), filters: \(String(describing: filters)), name: \(String(describing: name)), targetAction: \(String(describing: targetAction)), targetPipeline: \(String(describing: targetPipeline)))"}
}

/// <p>Represents information about a webhook and its definition.</p>
public struct WebhookDefinition: Equatable {
    /// <p>Supported options are GITHUB_HMAC, IP, and UNAUTHENTICATED.</p>
    ///         <ul>
    ///             <li>
    ///                 <p>For information about the authentication scheme implemented by GITHUB_HMAC,
    ///                     see <a href="https://developer.github.com/webhooks/securing/">Securing your
    ///                         webhooks</a> on the GitHub Developer website.</p>
    ///             </li>
    ///             <li>
    ///                 <p> IP rejects webhooks trigger requests unless they originate from an IP
    ///                     address in the IP range whitelisted in the authentication
    ///                     configuration.</p>
    ///             </li>
    ///             <li>
    ///                 <p> UNAUTHENTICATED accepts all webhook trigger requests regardless of
    ///                     origin.</p>
    ///             </li>
    ///          </ul>
    public let authentication: WebhookAuthenticationType?
    /// <p>Properties that configure the authentication applied to incoming webhook trigger
    ///             requests. The required properties depend on the authentication type. For GITHUB_HMAC,
    ///             only the <code>SecretToken </code>property must be set. For IP, only the
    ///                 <code>AllowedIPRange </code>property must be set to a valid CIDR range. For
    ///             UNAUTHENTICATED, no properties can be set.</p>
    public let authenticationConfiguration: WebhookAuthConfiguration?
    /// <p>A list of rules applied to the body/payload sent in the POST request to a webhook
    ///             URL. All defined rules must pass for the request to be accepted and the pipeline
    ///             started.</p>
    public let filters: [WebhookFilterRule]?
    /// <p>The name of the webhook.</p>
    public let name: String?
    /// <p>The name of the action in a pipeline you want to connect to the webhook. The action
    ///             must be from the source (first) stage of the pipeline.</p>
    public let targetAction: String?
    /// <p>The name of the pipeline you want to connect to the webhook.</p>
    public let targetPipeline: String?

    public init (
        authentication: WebhookAuthenticationType? = nil,
        authenticationConfiguration: WebhookAuthConfiguration? = nil,
        filters: [WebhookFilterRule]? = nil,
        name: String? = nil,
        targetAction: String? = nil,
        targetPipeline: String? = nil
    )
    {
        self.authentication = authentication
        self.authenticationConfiguration = authenticationConfiguration
        self.filters = filters
        self.name = name
        self.targetAction = targetAction
        self.targetPipeline = targetPipeline
    }
}

extension WebhookFilterRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case jsonPath
        case matchEquals
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jsonPath = jsonPath {
            try encodeContainer.encode(jsonPath, forKey: .jsonPath)
        }
        if let matchEquals = matchEquals {
            try encodeContainer.encode(matchEquals, forKey: .matchEquals)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jsonPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jsonPath)
        jsonPath = jsonPathDecoded
        let matchEqualsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .matchEquals)
        matchEquals = matchEqualsDecoded
    }
}

extension WebhookFilterRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WebhookFilterRule(jsonPath: \(String(describing: jsonPath)), matchEquals: \(String(describing: matchEquals)))"}
}

/// <p>The event criteria that specify when a webhook notification is sent to your
///             URL.</p>
public struct WebhookFilterRule: Equatable {
    /// <p>A JsonPath expression that is applied to the body/payload of the webhook. The value
    ///             selected by the JsonPath expression must match the value specified in the
    ///                 <code>MatchEquals</code> field. Otherwise, the request is ignored. For more
    ///             information, see <a href="https://github.com/json-path/JsonPath">Java JsonPath
    ///                 implementation</a> in GitHub.</p>
    public let jsonPath: String?
    /// <p>The value selected by the <code>JsonPath</code> expression must match what is
    ///             supplied in the <code>MatchEquals</code> field. Otherwise, the request is ignored.
    ///             Properties from the target action configuration can be included as placeholders in this
    ///             value by surrounding the action configuration key with curly brackets. For example, if
    ///             the value supplied here is "refs/heads/{Branch}" and the target action has an action
    ///             configuration property called "Branch" with a value of "master", the
    ///                 <code>MatchEquals</code> value is evaluated as "refs/heads/master". For a list of
    ///             action configuration properties for built-in action types, see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html#action-requirements">Pipeline Structure Reference Action Requirements</a>.</p>
    public let matchEquals: String?

    public init (
        jsonPath: String? = nil,
        matchEquals: String? = nil
    )
    {
        self.jsonPath = jsonPath
        self.matchEquals = matchEquals
    }
}

extension WebhookNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WebhookNotFoundException()"}
}

extension WebhookNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified webhook was entered in an invalid format or cannot be
///             found.</p>
public struct WebhookNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client

    public init() {}
}
