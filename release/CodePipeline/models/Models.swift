// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CodePipelineClientTypes.AWSSessionCredentials: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId
        case secretAccessKey
        case sessionToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let secretAccessKey = secretAccessKey {
            try encodeContainer.encode(secretAccessKey, forKey: .secretAccessKey)
        }
        if let sessionToken = sessionToken {
            try encodeContainer.encode(sessionToken, forKey: .sessionToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
    }
}

extension CodePipelineClientTypes.AWSSessionCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CodePipelineClientTypes {
    /// <p>Represents an AWS session credentials object. These credentials are temporary
    ///             credentials that are issued by AWS Secure Token Service (STS). They can be used to
    ///             access input and output artifacts in the S3 bucket used to store artifact for the
    ///             pipeline in AWS CodePipeline.</p>
    public struct AWSSessionCredentials: Swift.Equatable {
        /// <p>The access key for the session.</p>
        public let accessKeyId: Swift.String?
        /// <p>The secret access key for the session.</p>
        public let secretAccessKey: Swift.String?
        /// <p>The token for the session.</p>
        public let sessionToken: Swift.String?

        public init (
            accessKeyId: Swift.String? = nil,
            secretAccessKey: Swift.String? = nil,
            sessionToken: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.secretAccessKey = secretAccessKey
            self.sessionToken = sessionToken
        }
    }

}

public struct AcknowledgeJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcknowledgeJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcknowledgeJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcknowledgeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcknowledgeJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcknowledgeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcknowledgeJobOutputError>
}

extension AcknowledgeJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcknowledgeJobInput(jobId: \(Swift.String(describing: jobId)), nonce: \(Swift.String(describing: nonce)))"}
}

extension AcknowledgeJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
        case nonce
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let nonce = nonce {
            try encodeContainer.encode(nonce, forKey: .nonce)
        }
    }
}

public struct AcknowledgeJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcknowledgeJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcknowledgeJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcknowledgeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcknowledgeJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcknowledgeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcknowledgeJobOutputError>
}

public struct AcknowledgeJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcknowledgeJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcknowledgeJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcknowledgeJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcknowledgeJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcknowledgeJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcknowledgeJobOutputError>
}

/// <p>Represents the input of an AcknowledgeJob action.</p>
public struct AcknowledgeJobInput: Swift.Equatable {
    /// <p>The unique system-generated ID of the job for which you want to confirm
    ///             receipt.</p>
    public let jobId: Swift.String?
    /// <p>A system-generated random number that AWS CodePipeline uses to ensure that the job
    ///             is being worked on by only one job worker. Get this number from the response of the
    ///                 <a>PollForJobs</a> request that returned this job.</p>
    public let nonce: Swift.String?

    public init (
        jobId: Swift.String? = nil,
        nonce: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.nonce = nonce
    }
}

struct AcknowledgeJobInputBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let nonce: Swift.String?
}

extension AcknowledgeJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
        case nonce
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let nonceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nonce)
        nonce = nonceDecoded
    }
}

extension AcknowledgeJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcknowledgeJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNonceException" : self = .invalidNonceException(try InvalidNonceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcknowledgeJobOutputError: Swift.Error, Swift.Equatable {
    case invalidNonceException(InvalidNonceException)
    case jobNotFoundException(JobNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcknowledgeJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcknowledgeJobOutputResponse(status: \(Swift.String(describing: status)))"}
}

extension AcknowledgeJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AcknowledgeJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

/// <p>Represents the output of an AcknowledgeJob action.</p>
public struct AcknowledgeJobOutputResponse: Swift.Equatable {
    /// <p>Whether the job worker has received the specified job.</p>
    public let status: CodePipelineClientTypes.JobStatus?

    public init (
        status: CodePipelineClientTypes.JobStatus? = nil
    )
    {
        self.status = status
    }
}

struct AcknowledgeJobOutputResponseBody: Swift.Equatable {
    public let status: CodePipelineClientTypes.JobStatus?
}

extension AcknowledgeJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct AcknowledgeThirdPartyJobInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcknowledgeThirdPartyJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcknowledgeThirdPartyJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcknowledgeThirdPartyJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcknowledgeThirdPartyJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcknowledgeThirdPartyJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcknowledgeThirdPartyJobOutputError>
}

extension AcknowledgeThirdPartyJobInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcknowledgeThirdPartyJobInput(clientToken: \(Swift.String(describing: clientToken)), jobId: \(Swift.String(describing: jobId)), nonce: \(Swift.String(describing: nonce)))"}
}

extension AcknowledgeThirdPartyJobInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case jobId
        case nonce
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let nonce = nonce {
            try encodeContainer.encode(nonce, forKey: .nonce)
        }
    }
}

public struct AcknowledgeThirdPartyJobInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcknowledgeThirdPartyJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcknowledgeThirdPartyJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcknowledgeThirdPartyJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcknowledgeThirdPartyJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcknowledgeThirdPartyJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcknowledgeThirdPartyJobOutputError>
}

public struct AcknowledgeThirdPartyJobInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcknowledgeThirdPartyJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcknowledgeThirdPartyJobInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcknowledgeThirdPartyJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcknowledgeThirdPartyJobInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcknowledgeThirdPartyJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcknowledgeThirdPartyJobOutputError>
}

/// <p>Represents the input of an AcknowledgeThirdPartyJob action.</p>
public struct AcknowledgeThirdPartyJobInput: Swift.Equatable {
    /// <p>The clientToken portion of the clientId and clientToken pair used to verify that
    ///             the calling entity is allowed access to the job and its details.</p>
    public let clientToken: Swift.String?
    /// <p>The unique system-generated ID of the job.</p>
    public let jobId: Swift.String?
    /// <p>A system-generated random number that AWS CodePipeline uses to ensure that the job
    ///             is being worked on by only one job worker. Get this number from the response to a <a>GetThirdPartyJobDetails</a> request.</p>
    public let nonce: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        jobId: Swift.String? = nil,
        nonce: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.jobId = jobId
        self.nonce = nonce
    }
}

struct AcknowledgeThirdPartyJobInputBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let nonce: Swift.String?
    public let clientToken: Swift.String?
}

extension AcknowledgeThirdPartyJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case jobId
        case nonce
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let nonceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nonce)
        nonce = nonceDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AcknowledgeThirdPartyJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcknowledgeThirdPartyJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNonceException" : self = .invalidNonceException(try InvalidNonceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcknowledgeThirdPartyJobOutputError: Swift.Error, Swift.Equatable {
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidNonceException(InvalidNonceException)
    case jobNotFoundException(JobNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcknowledgeThirdPartyJobOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcknowledgeThirdPartyJobOutputResponse(status: \(Swift.String(describing: status)))"}
}

extension AcknowledgeThirdPartyJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AcknowledgeThirdPartyJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

/// <p>Represents the output of an AcknowledgeThirdPartyJob action.</p>
public struct AcknowledgeThirdPartyJobOutputResponse: Swift.Equatable {
    /// <p>The status information for the third party job, if any.</p>
    public let status: CodePipelineClientTypes.JobStatus?

    public init (
        status: CodePipelineClientTypes.JobStatus? = nil
    )
    {
        self.status = status
    }
}

struct AcknowledgeThirdPartyJobOutputResponseBody: Swift.Equatable {
    public let status: CodePipelineClientTypes.JobStatus?
}

extension AcknowledgeThirdPartyJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CodePipelineClientTypes {
    public enum ActionCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approval
        case build
        case deploy
        case invoke
        case source
        case test
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionCategory] {
            return [
                .approval,
                .build,
                .deploy,
                .invoke,
                .source,
                .test,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approval: return "Approval"
            case .build: return "Build"
            case .deploy: return "Deploy"
            case .invoke: return "Invoke"
            case .source: return "Source"
            case .test: return "Test"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionCategory(rawValue: rawValue) ?? ActionCategory.sdkUnknown(rawValue)
        }
    }
}

extension CodePipelineClientTypes.ActionConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            var configurationContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configuration)
            for (dictKey0, actionconfigurationmap0) in configuration {
                try configurationContainer.encode(actionconfigurationmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .configuration)
        var configurationDecoded0: [Swift.String:Swift.String]? = nil
        if let configurationContainer = configurationContainer {
            configurationDecoded0 = [Swift.String:Swift.String]()
            for (key0, actionconfigurationvalue0) in configurationContainer {
                if let actionconfigurationvalue0 = actionconfigurationvalue0 {
                    configurationDecoded0?[key0] = actionconfigurationvalue0
                }
            }
        }
        configuration = configurationDecoded0
    }
}

extension CodePipelineClientTypes.ActionConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionConfiguration(configuration: \(Swift.String(describing: configuration)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about an action configuration.</p>
    public struct ActionConfiguration: Swift.Equatable {
        /// <p>The configuration data for the action.</p>
        public let configuration: [Swift.String:Swift.String]?

        public init (
            configuration: [Swift.String:Swift.String]? = nil
        )
        {
            self.configuration = configuration
        }
    }

}

extension CodePipelineClientTypes.ActionConfigurationProperty: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case key
        case name
        case queryable
        case `required` = "required"
        case secret
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if key != false {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if queryable != false {
            try encodeContainer.encode(queryable, forKey: .queryable)
        }
        if `required` != false {
            try encodeContainer.encode(`required`, forKey: .`required`)
        }
        if secret != false {
            try encodeContainer.encode(secret, forKey: .secret)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let requiredDecoded = try containerValues.decode(Swift.Bool.self, forKey: .required)
        `required` = requiredDecoded
        let keyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .key)
        key = keyDecoded
        let secretDecoded = try containerValues.decode(Swift.Bool.self, forKey: .secret)
        secret = secretDecoded
        let queryableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .queryable)
        queryable = queryableDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionConfigurationPropertyType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CodePipelineClientTypes.ActionConfigurationProperty: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionConfigurationProperty(description: \(Swift.String(describing: description)), key: \(Swift.String(describing: key)), name: \(Swift.String(describing: name)), queryable: \(Swift.String(describing: queryable)), required: \(Swift.String(describing: `required`)), secret: \(Swift.String(describing: secret)), type: \(Swift.String(describing: type)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about an action configuration property.</p>
    public struct ActionConfigurationProperty: Swift.Equatable {
        /// <p>Whether the configuration property is a required value.</p>
        public let `required`: Swift.Bool
        /// <p>The description of the action configuration property that is displayed to
        ///             users.</p>
        public let description: Swift.String?
        /// <p>Whether the configuration property is a key.</p>
        public let key: Swift.Bool
        /// <p>The name of the action configuration property.</p>
        public let name: Swift.String?
        /// <p>Indicates that the property is used with <code>PollForJobs</code>. When creating a
        ///             custom action, an action can have up to one queryable property. If it has one, that
        ///             property must be both required and not secret.</p>
        ///         <p>If you create a pipeline with a custom action type, and that custom action contains
        ///             a queryable property, the value for that configuration property is subject to other
        ///             restrictions. The value must be less than or equal to twenty (20) characters. The value
        ///             can contain only alphanumeric characters, underscores, and hyphens.</p>
        public let queryable: Swift.Bool
        /// <p>Whether the configuration property is secret. Secrets are hidden from all calls
        ///             except for <code>GetJobDetails</code>, <code>GetThirdPartyJobDetails</code>,
        ///                 <code>PollForJobs</code>, and <code>PollForThirdPartyJobs</code>.</p>
        ///         <p>When updating a pipeline, passing * * * * * without changing any other values of
        ///             the action preserves the previous value of the secret.</p>
        public let secret: Swift.Bool
        /// <p>The type of the configuration property.</p>
        public let type: CodePipelineClientTypes.ActionConfigurationPropertyType?

        public init (
            `required`: Swift.Bool = false,
            description: Swift.String? = nil,
            key: Swift.Bool = false,
            name: Swift.String? = nil,
            queryable: Swift.Bool = false,
            secret: Swift.Bool = false,
            type: CodePipelineClientTypes.ActionConfigurationPropertyType? = nil
        )
        {
            self.`required` = `required`
            self.description = description
            self.key = key
            self.name = name
            self.queryable = queryable
            self.secret = secret
            self.type = type
        }
    }

}

extension CodePipelineClientTypes {
    public enum ActionConfigurationPropertyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case number
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionConfigurationPropertyType] {
            return [
                .boolean,
                .number,
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "Boolean"
            case .number: return "Number"
            case .string: return "String"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionConfigurationPropertyType(rawValue: rawValue) ?? ActionConfigurationPropertyType.sdkUnknown(rawValue)
        }
    }
}

extension CodePipelineClientTypes.ActionContext: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionExecutionId
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionExecutionId = actionExecutionId {
            try encodeContainer.encode(actionExecutionId, forKey: .actionExecutionId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let actionExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionExecutionId)
        actionExecutionId = actionExecutionIdDecoded
    }
}

extension CodePipelineClientTypes.ActionContext: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionContext(actionExecutionId: \(Swift.String(describing: actionExecutionId)), name: \(Swift.String(describing: name)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents the context of an action in the stage of a pipeline to a job
    ///             worker.</p>
    public struct ActionContext: Swift.Equatable {
        /// <p>The system-generated unique ID that corresponds to an action's execution.</p>
        public let actionExecutionId: Swift.String?
        /// <p>The name of the action in the context of a job.</p>
        public let name: Swift.String?

        public init (
            actionExecutionId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.actionExecutionId = actionExecutionId
            self.name = name
        }
    }

}

extension CodePipelineClientTypes.ActionDeclaration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionTypeId
        case configuration
        case inputArtifacts
        case name
        case namespace
        case outputArtifacts
        case region
        case roleArn
        case runOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionTypeId = actionTypeId {
            try encodeContainer.encode(actionTypeId, forKey: .actionTypeId)
        }
        if let configuration = configuration {
            var configurationContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configuration)
            for (dictKey0, actionconfigurationmap0) in configuration {
                try configurationContainer.encode(actionconfigurationmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let inputArtifacts = inputArtifacts {
            var inputArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputArtifacts)
            for inputartifactlist0 in inputArtifacts {
                try inputArtifactsContainer.encode(inputartifactlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let outputArtifacts = outputArtifacts {
            var outputArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputArtifacts)
            for outputartifactlist0 in outputArtifacts {
                try outputArtifactsContainer.encode(outputartifactlist0)
            }
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let runOrder = runOrder {
            try encodeContainer.encode(runOrder, forKey: .runOrder)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let actionTypeIdDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionTypeId.self, forKey: .actionTypeId)
        actionTypeId = actionTypeIdDecoded
        let runOrderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .runOrder)
        runOrder = runOrderDecoded
        let configurationContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .configuration)
        var configurationDecoded0: [Swift.String:Swift.String]? = nil
        if let configurationContainer = configurationContainer {
            configurationDecoded0 = [Swift.String:Swift.String]()
            for (key0, actionconfigurationvalue0) in configurationContainer {
                if let actionconfigurationvalue0 = actionconfigurationvalue0 {
                    configurationDecoded0?[key0] = actionconfigurationvalue0
                }
            }
        }
        configuration = configurationDecoded0
        let outputArtifactsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.OutputArtifact?].self, forKey: .outputArtifacts)
        var outputArtifactsDecoded0:[CodePipelineClientTypes.OutputArtifact]? = nil
        if let outputArtifactsContainer = outputArtifactsContainer {
            outputArtifactsDecoded0 = [CodePipelineClientTypes.OutputArtifact]()
            for structure0 in outputArtifactsContainer {
                if let structure0 = structure0 {
                    outputArtifactsDecoded0?.append(structure0)
                }
            }
        }
        outputArtifacts = outputArtifactsDecoded0
        let inputArtifactsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.InputArtifact?].self, forKey: .inputArtifacts)
        var inputArtifactsDecoded0:[CodePipelineClientTypes.InputArtifact]? = nil
        if let inputArtifactsContainer = inputArtifactsContainer {
            inputArtifactsDecoded0 = [CodePipelineClientTypes.InputArtifact]()
            for structure0 in inputArtifactsContainer {
                if let structure0 = structure0 {
                    inputArtifactsDecoded0?.append(structure0)
                }
            }
        }
        inputArtifacts = inputArtifactsDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension CodePipelineClientTypes.ActionDeclaration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionDeclaration(actionTypeId: \(Swift.String(describing: actionTypeId)), configuration: \(Swift.String(describing: configuration)), inputArtifacts: \(Swift.String(describing: inputArtifacts)), name: \(Swift.String(describing: name)), namespace: \(Swift.String(describing: namespace)), outputArtifacts: \(Swift.String(describing: outputArtifacts)), region: \(Swift.String(describing: region)), roleArn: \(Swift.String(describing: roleArn)), runOrder: \(Swift.String(describing: runOrder)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about an action declaration.</p>
    public struct ActionDeclaration: Swift.Equatable {
        /// <p>Specifies the action type and the provider of the action.</p>
        public let actionTypeId: CodePipelineClientTypes.ActionTypeId?
        /// <p>The action's configuration. These are key-value pairs that specify input values for
        ///             an action. For more information, see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html#action-requirements">Action Structure Requirements in CodePipeline</a>. For the list of
        ///             configuration properties for the AWS CloudFormation action type in CodePipeline, see
        ///                 <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-action-reference.html">Configuration Properties Reference</a> in the <i>AWS CloudFormation User
        ///                 Guide</i>. For template snippets with examples, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/continuous-delivery-codepipeline-parameter-override-functions.html">Using Parameter Override Functions with CodePipeline Pipelines</a> in the
        ///                 <i>AWS CloudFormation User Guide</i>.</p>
        ///         <p>The values can be represented in either JSON or YAML format. For example, the JSON
        ///             configuration item format is as follows: </p>
        ///         <p>
        ///             <i>JSON:</i>
        ///          </p>
        ///         <p>
        ///             <code>"Configuration" : { Key : Value },</code>
        ///         </p>
        public let configuration: [Swift.String:Swift.String]?
        /// <p>The name or ID of the artifact consumed by the action, such as a test or build
        ///             artifact.</p>
        public let inputArtifacts: [CodePipelineClientTypes.InputArtifact]?
        /// <p>The action declaration's name.</p>
        public let name: Swift.String?
        /// <p>The variable namespace associated with the action. All variables produced as output by
        ///             this action fall under this namespace.</p>
        public let namespace: Swift.String?
        /// <p>The name or ID of the result of the action declaration, such as a test or build
        ///             artifact.</p>
        public let outputArtifacts: [CodePipelineClientTypes.OutputArtifact]?
        /// <p>The action declaration's AWS Region, such as us-east-1.</p>
        public let region: Swift.String?
        /// <p>The ARN of the IAM service role that performs the declared action. This is assumed
        ///             through the roleArn for the pipeline.</p>
        public let roleArn: Swift.String?
        /// <p>The order in which actions are run.</p>
        public let runOrder: Swift.Int?

        public init (
            actionTypeId: CodePipelineClientTypes.ActionTypeId? = nil,
            configuration: [Swift.String:Swift.String]? = nil,
            inputArtifacts: [CodePipelineClientTypes.InputArtifact]? = nil,
            name: Swift.String? = nil,
            namespace: Swift.String? = nil,
            outputArtifacts: [CodePipelineClientTypes.OutputArtifact]? = nil,
            region: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            runOrder: Swift.Int? = nil
        )
        {
            self.actionTypeId = actionTypeId
            self.configuration = configuration
            self.inputArtifacts = inputArtifacts
            self.name = name
            self.namespace = namespace
            self.outputArtifacts = outputArtifacts
            self.region = region
            self.roleArn = roleArn
            self.runOrder = runOrder
        }
    }

}

extension CodePipelineClientTypes.ActionExecution: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionExecutionId
        case errorDetails
        case externalExecutionId
        case externalExecutionUrl
        case lastStatusChange
        case lastUpdatedBy
        case percentComplete
        case status
        case summary
        case token
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionExecutionId = actionExecutionId {
            try encodeContainer.encode(actionExecutionId, forKey: .actionExecutionId)
        }
        if let errorDetails = errorDetails {
            try encodeContainer.encode(errorDetails, forKey: .errorDetails)
        }
        if let externalExecutionId = externalExecutionId {
            try encodeContainer.encode(externalExecutionId, forKey: .externalExecutionId)
        }
        if let externalExecutionUrl = externalExecutionUrl {
            try encodeContainer.encode(externalExecutionUrl, forKey: .externalExecutionUrl)
        }
        if let lastStatusChange = lastStatusChange {
            try encodeContainer.encode(lastStatusChange.timeIntervalSince1970, forKey: .lastStatusChange)
        }
        if let lastUpdatedBy = lastUpdatedBy {
            try encodeContainer.encode(lastUpdatedBy, forKey: .lastUpdatedBy)
        }
        if let percentComplete = percentComplete {
            try encodeContainer.encode(percentComplete, forKey: .percentComplete)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let summary = summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let token = token {
            try encodeContainer.encode(token, forKey: .token)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionExecutionId)
        actionExecutionId = actionExecutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .summary)
        summary = summaryDecoded
        let lastStatusChangeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastStatusChange)
        lastStatusChange = lastStatusChangeDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
        let externalExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalExecutionId)
        externalExecutionId = externalExecutionIdDecoded
        let externalExecutionUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalExecutionUrl)
        externalExecutionUrl = externalExecutionUrlDecoded
        let percentCompleteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .percentComplete)
        percentComplete = percentCompleteDecoded
        let errorDetailsDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ErrorDetails.self, forKey: .errorDetails)
        errorDetails = errorDetailsDecoded
    }
}

extension CodePipelineClientTypes.ActionExecution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionExecution(actionExecutionId: \(Swift.String(describing: actionExecutionId)), errorDetails: \(Swift.String(describing: errorDetails)), externalExecutionId: \(Swift.String(describing: externalExecutionId)), externalExecutionUrl: \(Swift.String(describing: externalExecutionUrl)), lastStatusChange: \(Swift.String(describing: lastStatusChange)), lastUpdatedBy: \(Swift.String(describing: lastUpdatedBy)), percentComplete: \(Swift.String(describing: percentComplete)), status: \(Swift.String(describing: status)), summary: \(Swift.String(describing: summary)), token: \(Swift.String(describing: token)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about the run of an action.</p>
    public struct ActionExecution: Swift.Equatable {
        /// <p>ID of the workflow action execution in the current stage. Use the <a>GetPipelineState</a> action to retrieve the current action execution details
        ///             of the current stage.</p>
        ///         <note>
        ///             <p>For older executions, this field might be empty. The action execution ID is
        ///                 available for executions run on or after March 2020.</p>
        ///         </note>
        public let actionExecutionId: Swift.String?
        /// <p>The details of an error returned by a URL external to AWS.</p>
        public let errorDetails: CodePipelineClientTypes.ErrorDetails?
        /// <p>The external ID of the run of the action.</p>
        public let externalExecutionId: Swift.String?
        /// <p>The URL of a resource external to AWS that is used when running the action (for
        ///             example, an external repository URL).</p>
        public let externalExecutionUrl: Swift.String?
        /// <p>The last status change of the action.</p>
        public let lastStatusChange: ClientRuntime.Date?
        /// <p>The ARN of the user who last changed the pipeline.</p>
        public let lastUpdatedBy: Swift.String?
        /// <p>A percentage of completeness of the action as it runs.</p>
        public let percentComplete: Swift.Int?
        /// <p>The status of the action, or for a completed action, the last status of the
        ///             action.</p>
        public let status: CodePipelineClientTypes.ActionExecutionStatus?
        /// <p>A summary of the run of the action.</p>
        public let summary: Swift.String?
        /// <p>The system-generated token used to identify a unique approval request. The token
        ///             for each open approval request can be obtained using the <code>GetPipelineState</code>
        ///             command. It is used to validate that the approval request corresponding to this token is
        ///             still valid.</p>
        public let token: Swift.String?

        public init (
            actionExecutionId: Swift.String? = nil,
            errorDetails: CodePipelineClientTypes.ErrorDetails? = nil,
            externalExecutionId: Swift.String? = nil,
            externalExecutionUrl: Swift.String? = nil,
            lastStatusChange: ClientRuntime.Date? = nil,
            lastUpdatedBy: Swift.String? = nil,
            percentComplete: Swift.Int? = nil,
            status: CodePipelineClientTypes.ActionExecutionStatus? = nil,
            summary: Swift.String? = nil,
            token: Swift.String? = nil
        )
        {
            self.actionExecutionId = actionExecutionId
            self.errorDetails = errorDetails
            self.externalExecutionId = externalExecutionId
            self.externalExecutionUrl = externalExecutionUrl
            self.lastStatusChange = lastStatusChange
            self.lastUpdatedBy = lastUpdatedBy
            self.percentComplete = percentComplete
            self.status = status
            self.summary = summary
            self.token = token
        }
    }

}

extension CodePipelineClientTypes.ActionExecutionDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionExecutionId
        case actionName
        case input
        case lastUpdateTime
        case output
        case pipelineExecutionId
        case pipelineVersion
        case stageName
        case startTime
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionExecutionId = actionExecutionId {
            try encodeContainer.encode(actionExecutionId, forKey: .actionExecutionId)
        }
        if let actionName = actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let output = output {
            try encodeContainer.encode(output, forKey: .output)
        }
        if let pipelineExecutionId = pipelineExecutionId {
            try encodeContainer.encode(pipelineExecutionId, forKey: .pipelineExecutionId)
        }
        if let pipelineVersion = pipelineVersion {
            try encodeContainer.encode(pipelineVersion, forKey: .pipelineVersion)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
        let actionExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionExecutionId)
        actionExecutionId = actionExecutionIdDecoded
        let pipelineVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pipelineVersion)
        pipelineVersion = pipelineVersionDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let inputDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionExecutionInput.self, forKey: .input)
        input = inputDecoded
        let outputDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionExecutionOutput.self, forKey: .output)
        output = outputDecoded
    }
}

extension CodePipelineClientTypes.ActionExecutionDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionExecutionDetail(actionExecutionId: \(Swift.String(describing: actionExecutionId)), actionName: \(Swift.String(describing: actionName)), input: \(Swift.String(describing: input)), lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), output: \(Swift.String(describing: output)), pipelineExecutionId: \(Swift.String(describing: pipelineExecutionId)), pipelineVersion: \(Swift.String(describing: pipelineVersion)), stageName: \(Swift.String(describing: stageName)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)))"}
}

extension CodePipelineClientTypes {
    /// <p>Returns information about an execution of an action, including the action execution
    ///             ID, and the name, version, and timing of the action. </p>
    public struct ActionExecutionDetail: Swift.Equatable {
        /// <p>The action execution ID.</p>
        public let actionExecutionId: Swift.String?
        /// <p>The name of the action.</p>
        public let actionName: Swift.String?
        /// <p>Input details for the action execution, such as role ARN, Region, and input
        ///             artifacts.</p>
        public let input: CodePipelineClientTypes.ActionExecutionInput?
        /// <p>The last update time of the action execution.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>Output details for the action execution, such as the action execution result.</p>
        public let output: CodePipelineClientTypes.ActionExecutionOutput?
        /// <p>The pipeline execution ID for the action execution.</p>
        public let pipelineExecutionId: Swift.String?
        /// <p>The version of the pipeline where the action was run.</p>
        public let pipelineVersion: Swift.Int?
        /// <p>The name of the stage that contains the action.</p>
        public let stageName: Swift.String?
        /// <p>The start time of the action execution.</p>
        public let startTime: ClientRuntime.Date?
        /// <p> The status of the action execution. Status categories are <code>InProgress</code>,
        ///                 <code>Succeeded</code>, and <code>Failed</code>.</p>
        public let status: CodePipelineClientTypes.ActionExecutionStatus?

        public init (
            actionExecutionId: Swift.String? = nil,
            actionName: Swift.String? = nil,
            input: CodePipelineClientTypes.ActionExecutionInput? = nil,
            lastUpdateTime: ClientRuntime.Date? = nil,
            output: CodePipelineClientTypes.ActionExecutionOutput? = nil,
            pipelineExecutionId: Swift.String? = nil,
            pipelineVersion: Swift.Int? = nil,
            stageName: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: CodePipelineClientTypes.ActionExecutionStatus? = nil
        )
        {
            self.actionExecutionId = actionExecutionId
            self.actionName = actionName
            self.input = input
            self.lastUpdateTime = lastUpdateTime
            self.output = output
            self.pipelineExecutionId = pipelineExecutionId
            self.pipelineVersion = pipelineVersion
            self.stageName = stageName
            self.startTime = startTime
            self.status = status
        }
    }

}

extension CodePipelineClientTypes.ActionExecutionFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineExecutionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineExecutionId = pipelineExecutionId {
            try encodeContainer.encode(pipelineExecutionId, forKey: .pipelineExecutionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
    }
}

extension CodePipelineClientTypes.ActionExecutionFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionExecutionFilter(pipelineExecutionId: \(Swift.String(describing: pipelineExecutionId)))"}
}

extension CodePipelineClientTypes {
    /// <p>Filter values for the action execution.</p>
    public struct ActionExecutionFilter: Swift.Equatable {
        /// <p>The pipeline execution ID used to filter action execution history.</p>
        public let pipelineExecutionId: Swift.String?

        public init (
            pipelineExecutionId: Swift.String? = nil
        )
        {
            self.pipelineExecutionId = pipelineExecutionId
        }
    }

}

extension CodePipelineClientTypes.ActionExecutionInput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionTypeId
        case configuration
        case inputArtifacts
        case namespace
        case region
        case resolvedConfiguration
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionTypeId = actionTypeId {
            try encodeContainer.encode(actionTypeId, forKey: .actionTypeId)
        }
        if let configuration = configuration {
            var configurationContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .configuration)
            for (dictKey0, actionconfigurationmap0) in configuration {
                try configurationContainer.encode(actionconfigurationmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let inputArtifacts = inputArtifacts {
            var inputArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputArtifacts)
            for artifactdetaillist0 in inputArtifacts {
                try inputArtifactsContainer.encode(artifactdetaillist0)
            }
        }
        if let namespace = namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resolvedConfiguration = resolvedConfiguration {
            var resolvedConfigurationContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .resolvedConfiguration)
            for (dictKey0, resolvedactionconfigurationmap0) in resolvedConfiguration {
                try resolvedConfigurationContainer.encode(resolvedactionconfigurationmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeIdDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionTypeId.self, forKey: .actionTypeId)
        actionTypeId = actionTypeIdDecoded
        let configurationContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .configuration)
        var configurationDecoded0: [Swift.String:Swift.String]? = nil
        if let configurationContainer = configurationContainer {
            configurationDecoded0 = [Swift.String:Swift.String]()
            for (key0, actionconfigurationvalue0) in configurationContainer {
                if let actionconfigurationvalue0 = actionconfigurationvalue0 {
                    configurationDecoded0?[key0] = actionconfigurationvalue0
                }
            }
        }
        configuration = configurationDecoded0
        let resolvedConfigurationContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .resolvedConfiguration)
        var resolvedConfigurationDecoded0: [Swift.String:Swift.String]? = nil
        if let resolvedConfigurationContainer = resolvedConfigurationContainer {
            resolvedConfigurationDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in resolvedConfigurationContainer {
                if let string0 = string0 {
                    resolvedConfigurationDecoded0?[key0] = string0
                }
            }
        }
        resolvedConfiguration = resolvedConfigurationDecoded0
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let inputArtifactsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.ArtifactDetail?].self, forKey: .inputArtifacts)
        var inputArtifactsDecoded0:[CodePipelineClientTypes.ArtifactDetail]? = nil
        if let inputArtifactsContainer = inputArtifactsContainer {
            inputArtifactsDecoded0 = [CodePipelineClientTypes.ArtifactDetail]()
            for structure0 in inputArtifactsContainer {
                if let structure0 = structure0 {
                    inputArtifactsDecoded0?.append(structure0)
                }
            }
        }
        inputArtifacts = inputArtifactsDecoded0
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
    }
}

extension CodePipelineClientTypes.ActionExecutionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionExecutionInput(actionTypeId: \(Swift.String(describing: actionTypeId)), configuration: \(Swift.String(describing: configuration)), inputArtifacts: \(Swift.String(describing: inputArtifacts)), namespace: \(Swift.String(describing: namespace)), region: \(Swift.String(describing: region)), resolvedConfiguration: \(Swift.String(describing: resolvedConfiguration)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension CodePipelineClientTypes {
    /// <p>Input information used for an action execution.</p>
    public struct ActionExecutionInput: Swift.Equatable {
        /// <p>Represents information about an action type.</p>
        public let actionTypeId: CodePipelineClientTypes.ActionTypeId?
        /// <p>Configuration data for an action execution.</p>
        public let configuration: [Swift.String:Swift.String]?
        /// <p>Details of input artifacts of the action that correspond to the action
        ///             execution.</p>
        public let inputArtifacts: [CodePipelineClientTypes.ArtifactDetail]?
        /// <p>The variable namespace associated with the action. All variables produced as output by
        ///             this action fall under this namespace.</p>
        public let namespace: Swift.String?
        /// <p>The AWS Region for the action, such as us-east-1.</p>
        public let region: Swift.String?
        /// <p>Configuration data for an action execution with all variable references replaced with
        ///             their real values for the execution.</p>
        public let resolvedConfiguration: [Swift.String:Swift.String]?
        /// <p>The ARN of the IAM service role that performs the declared action. This is assumed
        ///             through the roleArn for the pipeline. </p>
        public let roleArn: Swift.String?

        public init (
            actionTypeId: CodePipelineClientTypes.ActionTypeId? = nil,
            configuration: [Swift.String:Swift.String]? = nil,
            inputArtifacts: [CodePipelineClientTypes.ArtifactDetail]? = nil,
            namespace: Swift.String? = nil,
            region: Swift.String? = nil,
            resolvedConfiguration: [Swift.String:Swift.String]? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.actionTypeId = actionTypeId
            self.configuration = configuration
            self.inputArtifacts = inputArtifacts
            self.namespace = namespace
            self.region = region
            self.resolvedConfiguration = resolvedConfiguration
            self.roleArn = roleArn
        }
    }

}

extension CodePipelineClientTypes.ActionExecutionOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionResult
        case outputArtifacts
        case outputVariables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionResult = executionResult {
            try encodeContainer.encode(executionResult, forKey: .executionResult)
        }
        if let outputArtifacts = outputArtifacts {
            var outputArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputArtifacts)
            for artifactdetaillist0 in outputArtifacts {
                try outputArtifactsContainer.encode(artifactdetaillist0)
            }
        }
        if let outputVariables = outputVariables {
            var outputVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .outputVariables)
            for (dictKey0, outputvariablesmap0) in outputVariables {
                try outputVariablesContainer.encode(outputvariablesmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputArtifactsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.ArtifactDetail?].self, forKey: .outputArtifacts)
        var outputArtifactsDecoded0:[CodePipelineClientTypes.ArtifactDetail]? = nil
        if let outputArtifactsContainer = outputArtifactsContainer {
            outputArtifactsDecoded0 = [CodePipelineClientTypes.ArtifactDetail]()
            for structure0 in outputArtifactsContainer {
                if let structure0 = structure0 {
                    outputArtifactsDecoded0?.append(structure0)
                }
            }
        }
        outputArtifacts = outputArtifactsDecoded0
        let executionResultDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionExecutionResult.self, forKey: .executionResult)
        executionResult = executionResultDecoded
        let outputVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .outputVariables)
        var outputVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let outputVariablesContainer = outputVariablesContainer {
            outputVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, outputvariablesvalue0) in outputVariablesContainer {
                if let outputvariablesvalue0 = outputvariablesvalue0 {
                    outputVariablesDecoded0?[key0] = outputvariablesvalue0
                }
            }
        }
        outputVariables = outputVariablesDecoded0
    }
}

extension CodePipelineClientTypes.ActionExecutionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionExecutionOutput(executionResult: \(Swift.String(describing: executionResult)), outputArtifacts: \(Swift.String(describing: outputArtifacts)), outputVariables: \(Swift.String(describing: outputVariables)))"}
}

extension CodePipelineClientTypes {
    /// <p>Output details listed for an action execution, such as the action execution
    ///             result.</p>
    public struct ActionExecutionOutput: Swift.Equatable {
        /// <p>Execution result information listed in the output details for an action
        ///             execution.</p>
        public let executionResult: CodePipelineClientTypes.ActionExecutionResult?
        /// <p>Details of output artifacts of the action that correspond to the action
        ///             execution.</p>
        public let outputArtifacts: [CodePipelineClientTypes.ArtifactDetail]?
        /// <p>The outputVariables field shows the key-value pairs that were output as part of that
        ///             execution.</p>
        public let outputVariables: [Swift.String:Swift.String]?

        public init (
            executionResult: CodePipelineClientTypes.ActionExecutionResult? = nil,
            outputArtifacts: [CodePipelineClientTypes.ArtifactDetail]? = nil,
            outputVariables: [Swift.String:Swift.String]? = nil
        )
        {
            self.executionResult = executionResult
            self.outputArtifacts = outputArtifacts
            self.outputVariables = outputVariables
        }
    }

}

extension CodePipelineClientTypes.ActionExecutionResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalExecutionId
        case externalExecutionSummary
        case externalExecutionUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalExecutionId = externalExecutionId {
            try encodeContainer.encode(externalExecutionId, forKey: .externalExecutionId)
        }
        if let externalExecutionSummary = externalExecutionSummary {
            try encodeContainer.encode(externalExecutionSummary, forKey: .externalExecutionSummary)
        }
        if let externalExecutionUrl = externalExecutionUrl {
            try encodeContainer.encode(externalExecutionUrl, forKey: .externalExecutionUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let externalExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalExecutionId)
        externalExecutionId = externalExecutionIdDecoded
        let externalExecutionSummaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalExecutionSummary)
        externalExecutionSummary = externalExecutionSummaryDecoded
        let externalExecutionUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalExecutionUrl)
        externalExecutionUrl = externalExecutionUrlDecoded
    }
}

extension CodePipelineClientTypes.ActionExecutionResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionExecutionResult(externalExecutionId: \(Swift.String(describing: externalExecutionId)), externalExecutionSummary: \(Swift.String(describing: externalExecutionSummary)), externalExecutionUrl: \(Swift.String(describing: externalExecutionUrl)))"}
}

extension CodePipelineClientTypes {
    /// <p>Execution result information, such as the external execution ID.</p>
    public struct ActionExecutionResult: Swift.Equatable {
        /// <p>The action provider's external ID for the action execution.</p>
        public let externalExecutionId: Swift.String?
        /// <p>The action provider's summary for the action execution.</p>
        public let externalExecutionSummary: Swift.String?
        /// <p>The deepest external link to the external resource (for example, a repository URL or
        ///             deployment endpoint) that is used when running the action.</p>
        public let externalExecutionUrl: Swift.String?

        public init (
            externalExecutionId: Swift.String? = nil,
            externalExecutionSummary: Swift.String? = nil,
            externalExecutionUrl: Swift.String? = nil
        )
        {
            self.externalExecutionId = externalExecutionId
            self.externalExecutionSummary = externalExecutionSummary
            self.externalExecutionUrl = externalExecutionUrl
        }
    }

}

extension CodePipelineClientTypes {
    public enum ActionExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case abandoned
        case failed
        case inprogress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionExecutionStatus] {
            return [
                .abandoned,
                .failed,
                .inprogress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .abandoned: return "Abandoned"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .succeeded: return "Succeeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionExecutionStatus(rawValue: rawValue) ?? ActionExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension ActionNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ActionNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ActionNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified action cannot be found.</p>
public struct ActionNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ActionNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ActionNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodePipelineClientTypes {
    public enum ActionOwner: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aws
        case custom
        case thirdparty
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionOwner] {
            return [
                .aws,
                .custom,
                .thirdparty,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .custom: return "Custom"
            case .thirdparty: return "ThirdParty"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionOwner(rawValue: rawValue) ?? ActionOwner.sdkUnknown(rawValue)
        }
    }
}

extension CodePipelineClientTypes.ActionRevision: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created
        case revisionChangeId
        case revisionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let revisionChangeId = revisionChangeId {
            try encodeContainer.encode(revisionChangeId, forKey: .revisionChangeId)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let revisionChangeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionChangeId)
        revisionChangeId = revisionChangeIdDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
    }
}

extension CodePipelineClientTypes.ActionRevision: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionRevision(created: \(Swift.String(describing: created)), revisionChangeId: \(Swift.String(describing: revisionChangeId)), revisionId: \(Swift.String(describing: revisionId)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about the version (or revision) of an action.</p>
    public struct ActionRevision: Swift.Equatable {
        /// <p>The date and time when the most recent version of the action was created, in
        ///             timestamp format.</p>
        public let created: ClientRuntime.Date?
        /// <p>The unique identifier of the change that set the state to this revision (for
        ///             example, a deployment ID or timestamp).</p>
        public let revisionChangeId: Swift.String?
        /// <p>The system-generated unique ID that identifies the revision number of the
        ///             action.</p>
        public let revisionId: Swift.String?

        public init (
            created: ClientRuntime.Date? = nil,
            revisionChangeId: Swift.String? = nil,
            revisionId: Swift.String? = nil
        )
        {
            self.created = created
            self.revisionChangeId = revisionChangeId
            self.revisionId = revisionId
        }
    }

}

extension CodePipelineClientTypes.ActionState: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionName
        case currentRevision
        case entityUrl
        case latestExecution
        case revisionUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionName = actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let currentRevision = currentRevision {
            try encodeContainer.encode(currentRevision, forKey: .currentRevision)
        }
        if let entityUrl = entityUrl {
            try encodeContainer.encode(entityUrl, forKey: .entityUrl)
        }
        if let latestExecution = latestExecution {
            try encodeContainer.encode(latestExecution, forKey: .latestExecution)
        }
        if let revisionUrl = revisionUrl {
            try encodeContainer.encode(revisionUrl, forKey: .revisionUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let currentRevisionDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionRevision.self, forKey: .currentRevision)
        currentRevision = currentRevisionDecoded
        let latestExecutionDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionExecution.self, forKey: .latestExecution)
        latestExecution = latestExecutionDecoded
        let entityUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityUrl)
        entityUrl = entityUrlDecoded
        let revisionUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionUrl)
        revisionUrl = revisionUrlDecoded
    }
}

extension CodePipelineClientTypes.ActionState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionState(actionName: \(Swift.String(describing: actionName)), currentRevision: \(Swift.String(describing: currentRevision)), entityUrl: \(Swift.String(describing: entityUrl)), latestExecution: \(Swift.String(describing: latestExecution)), revisionUrl: \(Swift.String(describing: revisionUrl)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about the state of an action.</p>
    public struct ActionState: Swift.Equatable {
        /// <p>The name of the action.</p>
        public let actionName: Swift.String?
        /// <p>Represents information about the version (or revision) of an action.</p>
        public let currentRevision: CodePipelineClientTypes.ActionRevision?
        /// <p>A URL link for more information about the state of the action, such as a deployment
        ///             group details page.</p>
        public let entityUrl: Swift.String?
        /// <p>Represents information about the run of an action.</p>
        public let latestExecution: CodePipelineClientTypes.ActionExecution?
        /// <p>A URL link for more information about the revision, such as a commit details
        ///             page.</p>
        public let revisionUrl: Swift.String?

        public init (
            actionName: Swift.String? = nil,
            currentRevision: CodePipelineClientTypes.ActionRevision? = nil,
            entityUrl: Swift.String? = nil,
            latestExecution: CodePipelineClientTypes.ActionExecution? = nil,
            revisionUrl: Swift.String? = nil
        )
        {
            self.actionName = actionName
            self.currentRevision = currentRevision
            self.entityUrl = entityUrl
            self.latestExecution = latestExecution
            self.revisionUrl = revisionUrl
        }
    }

}

extension CodePipelineClientTypes.ActionType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionConfigurationProperties
        case id
        case inputArtifactDetails
        case outputArtifactDetails
        case settings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionConfigurationProperties = actionConfigurationProperties {
            var actionConfigurationPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actionConfigurationProperties)
            for actionconfigurationpropertylist0 in actionConfigurationProperties {
                try actionConfigurationPropertiesContainer.encode(actionconfigurationpropertylist0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let inputArtifactDetails = inputArtifactDetails {
            try encodeContainer.encode(inputArtifactDetails, forKey: .inputArtifactDetails)
        }
        if let outputArtifactDetails = outputArtifactDetails {
            try encodeContainer.encode(outputArtifactDetails, forKey: .outputArtifactDetails)
        }
        if let settings = settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionTypeId.self, forKey: .id)
        id = idDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionTypeSettings.self, forKey: .settings)
        settings = settingsDecoded
        let actionConfigurationPropertiesContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.ActionConfigurationProperty?].self, forKey: .actionConfigurationProperties)
        var actionConfigurationPropertiesDecoded0:[CodePipelineClientTypes.ActionConfigurationProperty]? = nil
        if let actionConfigurationPropertiesContainer = actionConfigurationPropertiesContainer {
            actionConfigurationPropertiesDecoded0 = [CodePipelineClientTypes.ActionConfigurationProperty]()
            for structure0 in actionConfigurationPropertiesContainer {
                if let structure0 = structure0 {
                    actionConfigurationPropertiesDecoded0?.append(structure0)
                }
            }
        }
        actionConfigurationProperties = actionConfigurationPropertiesDecoded0
        let inputArtifactDetailsDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ArtifactDetails.self, forKey: .inputArtifactDetails)
        inputArtifactDetails = inputArtifactDetailsDecoded
        let outputArtifactDetailsDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ArtifactDetails.self, forKey: .outputArtifactDetails)
        outputArtifactDetails = outputArtifactDetailsDecoded
    }
}

extension CodePipelineClientTypes.ActionType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionType(actionConfigurationProperties: \(Swift.String(describing: actionConfigurationProperties)), id: \(Swift.String(describing: id)), inputArtifactDetails: \(Swift.String(describing: inputArtifactDetails)), outputArtifactDetails: \(Swift.String(describing: outputArtifactDetails)), settings: \(Swift.String(describing: settings)))"}
}

extension CodePipelineClientTypes {
    /// <p>Returns information about the details of an action type.</p>
    public struct ActionType: Swift.Equatable {
        /// <p>The configuration properties for the action type.</p>
        public let actionConfigurationProperties: [CodePipelineClientTypes.ActionConfigurationProperty]?
        /// <p>Represents information about an action type.</p>
        public let id: CodePipelineClientTypes.ActionTypeId?
        /// <p>The details of the input artifact for the action, such as its commit ID.</p>
        public let inputArtifactDetails: CodePipelineClientTypes.ArtifactDetails?
        /// <p>The details of the output artifact of the action, such as its commit ID.</p>
        public let outputArtifactDetails: CodePipelineClientTypes.ArtifactDetails?
        /// <p>The settings for the action type.</p>
        public let settings: CodePipelineClientTypes.ActionTypeSettings?

        public init (
            actionConfigurationProperties: [CodePipelineClientTypes.ActionConfigurationProperty]? = nil,
            id: CodePipelineClientTypes.ActionTypeId? = nil,
            inputArtifactDetails: CodePipelineClientTypes.ArtifactDetails? = nil,
            outputArtifactDetails: CodePipelineClientTypes.ArtifactDetails? = nil,
            settings: CodePipelineClientTypes.ActionTypeSettings? = nil
        )
        {
            self.actionConfigurationProperties = actionConfigurationProperties
            self.id = id
            self.inputArtifactDetails = inputArtifactDetails
            self.outputArtifactDetails = outputArtifactDetails
            self.settings = settings
        }
    }

}

extension CodePipelineClientTypes.ActionTypeArtifactDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximumCount
        case minimumCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maximumCount != 0 {
            try encodeContainer.encode(maximumCount, forKey: .maximumCount)
        }
        if minimumCount != 0 {
            try encodeContainer.encode(minimumCount, forKey: .minimumCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minimumCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .minimumCount)
        minimumCount = minimumCountDecoded
        let maximumCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .maximumCount)
        maximumCount = maximumCountDecoded
    }
}

extension CodePipelineClientTypes.ActionTypeArtifactDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionTypeArtifactDetails(maximumCount: \(Swift.String(describing: maximumCount)), minimumCount: \(Swift.String(describing: minimumCount)))"}
}

extension CodePipelineClientTypes {
    /// <p>Information about parameters for artifacts associated with the action type, such as
    ///             the minimum and maximum artifacts allowed.</p>
    public struct ActionTypeArtifactDetails: Swift.Equatable {
        /// <p>The maximum number of artifacts that can be used with the actiontype. For example, you
        ///             should specify a minimum and maximum of zero input artifacts for an action type with a
        ///             category of <code>source</code>.</p>
        public let maximumCount: Swift.Int
        /// <p>The minimum number of artifacts that can be used with the action type. For example,
        ///             you should specify a minimum and maximum of zero input artifacts for an action type with
        ///             a category of <code>source</code>.</p>
        public let minimumCount: Swift.Int

        public init (
            maximumCount: Swift.Int = 0,
            minimumCount: Swift.Int = 0
        )
        {
            self.maximumCount = maximumCount
            self.minimumCount = minimumCount
        }
    }

}

extension CodePipelineClientTypes.ActionTypeDeclaration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case executor
        case id
        case inputArtifactDetails
        case outputArtifactDetails
        case permissions
        case properties
        case urls
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let executor = executor {
            try encodeContainer.encode(executor, forKey: .executor)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let inputArtifactDetails = inputArtifactDetails {
            try encodeContainer.encode(inputArtifactDetails, forKey: .inputArtifactDetails)
        }
        if let outputArtifactDetails = outputArtifactDetails {
            try encodeContainer.encode(outputArtifactDetails, forKey: .outputArtifactDetails)
        }
        if let permissions = permissions {
            try encodeContainer.encode(permissions, forKey: .permissions)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for actiontypeproperties0 in properties {
                try propertiesContainer.encode(actiontypeproperties0)
            }
        }
        if let urls = urls {
            try encodeContainer.encode(urls, forKey: .urls)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let executorDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionTypeExecutor.self, forKey: .executor)
        executor = executorDecoded
        let idDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionTypeIdentifier.self, forKey: .id)
        id = idDecoded
        let inputArtifactDetailsDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionTypeArtifactDetails.self, forKey: .inputArtifactDetails)
        inputArtifactDetails = inputArtifactDetailsDecoded
        let outputArtifactDetailsDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionTypeArtifactDetails.self, forKey: .outputArtifactDetails)
        outputArtifactDetails = outputArtifactDetailsDecoded
        let permissionsDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionTypePermissions.self, forKey: .permissions)
        permissions = permissionsDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.ActionTypeProperty?].self, forKey: .properties)
        var propertiesDecoded0:[CodePipelineClientTypes.ActionTypeProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [CodePipelineClientTypes.ActionTypeProperty]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
        let urlsDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionTypeUrls.self, forKey: .urls)
        urls = urlsDecoded
    }
}

extension CodePipelineClientTypes.ActionTypeDeclaration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionTypeDeclaration(description: \(Swift.String(describing: description)), executor: \(Swift.String(describing: executor)), id: \(Swift.String(describing: id)), inputArtifactDetails: \(Swift.String(describing: inputArtifactDetails)), outputArtifactDetails: \(Swift.String(describing: outputArtifactDetails)), permissions: \(Swift.String(describing: permissions)), properties: \(Swift.String(describing: properties)), urls: \(Swift.String(describing: urls)))"}
}

extension CodePipelineClientTypes {
    /// <p>The parameters for the action type definition that are provided when the action type
    ///             is created or updated.</p>
    public struct ActionTypeDeclaration: Swift.Equatable {
        /// <p>The description for the action type to be updated.</p>
        public let description: Swift.String?
        /// <p>Information about the executor for an action type that was created with any supported
        ///             integration model.</p>
        public let executor: CodePipelineClientTypes.ActionTypeExecutor?
        /// <p>The action category, owner, provider, and version of the action type to be
        ///             updated.</p>
        public let id: CodePipelineClientTypes.ActionTypeIdentifier?
        /// <p>Details for the artifacts, such as application files, to be worked on by the action.
        ///             For example, the minimum and maximum number of input artifacts allowed.</p>
        public let inputArtifactDetails: CodePipelineClientTypes.ActionTypeArtifactDetails?
        /// <p>Details for the output artifacts, such as a built application, that are the result of
        ///             the action. For example, the minimum and maximum number of output artifacts
        ///             allowed.</p>
        public let outputArtifactDetails: CodePipelineClientTypes.ActionTypeArtifactDetails?
        /// <p>Details identifying the accounts with permissions to use the action type.</p>
        public let permissions: CodePipelineClientTypes.ActionTypePermissions?
        /// <p>The properties of the action type to be updated.</p>
        public let properties: [CodePipelineClientTypes.ActionTypeProperty]?
        /// <p>The links associated with the action type to be updated.</p>
        public let urls: CodePipelineClientTypes.ActionTypeUrls?

        public init (
            description: Swift.String? = nil,
            executor: CodePipelineClientTypes.ActionTypeExecutor? = nil,
            id: CodePipelineClientTypes.ActionTypeIdentifier? = nil,
            inputArtifactDetails: CodePipelineClientTypes.ActionTypeArtifactDetails? = nil,
            outputArtifactDetails: CodePipelineClientTypes.ActionTypeArtifactDetails? = nil,
            permissions: CodePipelineClientTypes.ActionTypePermissions? = nil,
            properties: [CodePipelineClientTypes.ActionTypeProperty]? = nil,
            urls: CodePipelineClientTypes.ActionTypeUrls? = nil
        )
        {
            self.description = description
            self.executor = executor
            self.id = id
            self.inputArtifactDetails = inputArtifactDetails
            self.outputArtifactDetails = outputArtifactDetails
            self.permissions = permissions
            self.properties = properties
            self.urls = urls
        }
    }

}

extension CodePipelineClientTypes.ActionTypeExecutor: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case jobTimeout
        case policyStatementsTemplate
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let jobTimeout = jobTimeout {
            try encodeContainer.encode(jobTimeout, forKey: .jobTimeout)
        }
        if let policyStatementsTemplate = policyStatementsTemplate {
            try encodeContainer.encode(policyStatementsTemplate, forKey: .policyStatementsTemplate)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ExecutorConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ExecutorType.self, forKey: .type)
        type = typeDecoded
        let policyStatementsTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyStatementsTemplate)
        policyStatementsTemplate = policyStatementsTemplateDecoded
        let jobTimeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .jobTimeout)
        jobTimeout = jobTimeoutDecoded
    }
}

extension CodePipelineClientTypes.ActionTypeExecutor: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionTypeExecutor(configuration: \(Swift.String(describing: configuration)), jobTimeout: \(Swift.String(describing: jobTimeout)), policyStatementsTemplate: \(Swift.String(describing: policyStatementsTemplate)), type: \(Swift.String(describing: type)))"}
}

extension CodePipelineClientTypes {
    /// <p>The action engine, or executor, for an action type created for a provider, where the
    ///             action is to be used by customers of the provider. The action engine is associated with
    ///             the model used to create and update the action, such as the Lambda integration
    ///             model.</p>
    public struct ActionTypeExecutor: Swift.Equatable {
        /// <p>The action configuration properties for the action type. These properties are
        ///             specified in the action definition when the action type is created.</p>
        public let configuration: CodePipelineClientTypes.ExecutorConfiguration?
        /// <p>The timeout in seconds for the job. An action execution can have multiple jobs. This
        ///             is the timeout for a single job, not the entire action execution.</p>
        public let jobTimeout: Swift.Int?
        /// <p>The policy statement that specifies the permissions in the CodePipeline customers
        ///             account that are needed to successfully run an action.</p>
        ///         <p>To grant permission to another account, specify the account ID as the Principal, a
        ///             domain-style identifier defined by the service, for example
        ///                 <code>codepipeline.amazonaws.com</code>.</p>
        ///         <note>
        ///             <p>The size of the passed JSON policy document cannot exceed 2048 characters.</p>
        ///         </note>
        public let policyStatementsTemplate: Swift.String?
        /// <p>The integration model used to create and update the action type, <code>Lambda</code>
        ///             or <code>JobWorker</code>. </p>
        public let type: CodePipelineClientTypes.ExecutorType?

        public init (
            configuration: CodePipelineClientTypes.ExecutorConfiguration? = nil,
            jobTimeout: Swift.Int? = nil,
            policyStatementsTemplate: Swift.String? = nil,
            type: CodePipelineClientTypes.ExecutorType? = nil
        )
        {
            self.configuration = configuration
            self.jobTimeout = jobTimeout
            self.policyStatementsTemplate = policyStatementsTemplate
            self.type = type
        }
    }

}

extension CodePipelineClientTypes.ActionTypeId: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category
        case owner
        case provider
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let owner = owner {
            try encodeContainer.encode(owner.rawValue, forKey: .owner)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionCategory.self, forKey: .category)
        category = categoryDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionOwner.self, forKey: .owner)
        owner = ownerDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension CodePipelineClientTypes.ActionTypeId: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionTypeId(category: \(Swift.String(describing: category)), owner: \(Swift.String(describing: owner)), provider: \(Swift.String(describing: provider)), version: \(Swift.String(describing: version)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about an action type.</p>
    public struct ActionTypeId: Swift.Equatable {
        /// <p>A category defines what kind of action can be taken in the stage, and constrains
        ///             the provider type for the action. Valid categories are limited to one of the following
        ///             values. </p>
        ///         <ul>
        ///             <li>
        ///                 <p>Source</p>
        ///             </li>
        ///             <li>
        ///                 <p>Build</p>
        ///             </li>
        ///             <li>
        ///                 <p>Test</p>
        ///             </li>
        ///             <li>
        ///                 <p>Deploy</p>
        ///             </li>
        ///             <li>
        ///                 <p>Invoke</p>
        ///             </li>
        ///             <li>
        ///                 <p>Approval</p>
        ///             </li>
        ///          </ul>
        public let category: CodePipelineClientTypes.ActionCategory?
        /// <p>The creator of the action being called. There are three valid values for the
        ///                 <code>Owner</code> field in the action category section within your pipeline
        ///             structure: <code>AWS</code>, <code>ThirdParty</code>, and <code>Custom</code>. For more
        ///             information, see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html#actions-valid-providers">Valid Action Types and Providers in CodePipeline</a>.</p>
        public let owner: CodePipelineClientTypes.ActionOwner?
        /// <p>The provider of the service being called by the action. Valid providers are
        ///             determined by the action category. For example, an action in the Deploy category type
        ///             might have a provider of AWS CodeDeploy, which would be specified as CodeDeploy. For
        ///             more information, see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html#actions-valid-providers">Valid Action Types and Providers in CodePipeline</a>.</p>
        public let provider: Swift.String?
        /// <p>A string that describes the action version.</p>
        public let version: Swift.String?

        public init (
            category: CodePipelineClientTypes.ActionCategory? = nil,
            owner: CodePipelineClientTypes.ActionOwner? = nil,
            provider: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.category = category
            self.owner = owner
            self.provider = provider
            self.version = version
        }
    }

}

extension CodePipelineClientTypes.ActionTypeIdentifier: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category
        case owner
        case provider
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionCategory.self, forKey: .category)
        category = categoryDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension CodePipelineClientTypes.ActionTypeIdentifier: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionTypeIdentifier(category: \(Swift.String(describing: category)), owner: \(Swift.String(describing: owner)), provider: \(Swift.String(describing: provider)), version: \(Swift.String(describing: version)))"}
}

extension CodePipelineClientTypes {
    /// <p>Specifies the category, owner, provider, and version of the action type.</p>
    public struct ActionTypeIdentifier: Swift.Equatable {
        /// <p>Defines what kind of action can be taken in the stage, one of the following:</p>
        ///         <ul>
        ///             <li>
        ///                 <p>
        ///                   <code>Source</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <code>Build</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <code>Test</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <code>Deploy</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <code>Approval</code>
        ///                </p>
        ///             </li>
        ///             <li>
        ///                 <p>
        ///                   <code>Invoke</code>
        ///                </p>
        ///             </li>
        ///          </ul>
        public let category: CodePipelineClientTypes.ActionCategory?
        /// <p>The creator of the action type being called: <code>AWS</code> or
        ///                 <code>ThirdParty</code>.</p>
        public let owner: Swift.String?
        /// <p>The provider of the action type being called. The provider name is supplied when the
        ///             action type is created.</p>
        public let provider: Swift.String?
        /// <p>A string that describes the action type version.</p>
        public let version: Swift.String?

        public init (
            category: CodePipelineClientTypes.ActionCategory? = nil,
            owner: Swift.String? = nil,
            provider: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.category = category
            self.owner = owner
            self.provider = provider
            self.version = version
        }
    }

}

extension ActionTypeNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionTypeNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ActionTypeNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ActionTypeNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified action type cannot be found.</p>
public struct ActionTypeNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ActionTypeNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ActionTypeNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodePipelineClientTypes.ActionTypePermissions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedAccounts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedAccounts = allowedAccounts {
            var allowedAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedAccounts)
            for allowedaccounts0 in allowedAccounts {
                try allowedAccountsContainer.encode(allowedaccounts0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedAccounts)
        var allowedAccountsDecoded0:[Swift.String]? = nil
        if let allowedAccountsContainer = allowedAccountsContainer {
            allowedAccountsDecoded0 = [Swift.String]()
            for string0 in allowedAccountsContainer {
                if let string0 = string0 {
                    allowedAccountsDecoded0?.append(string0)
                }
            }
        }
        allowedAccounts = allowedAccountsDecoded0
    }
}

extension CodePipelineClientTypes.ActionTypePermissions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionTypePermissions(allowedAccounts: \(Swift.String(describing: allowedAccounts)))"}
}

extension CodePipelineClientTypes {
    /// <p>Details identifying the users with permissions to use the action type.</p>
    public struct ActionTypePermissions: Swift.Equatable {
        /// <p>A list of AWS account IDs with access to use the action type in their
        ///             pipelines.</p>
        public let allowedAccounts: [Swift.String]?

        public init (
            allowedAccounts: [Swift.String]? = nil
        )
        {
            self.allowedAccounts = allowedAccounts
        }
    }

}

extension CodePipelineClientTypes.ActionTypeProperty: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case key
        case name
        case noEcho
        case `optional` = "optional"
        case queryable
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if key != false {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if noEcho != false {
            try encodeContainer.encode(noEcho, forKey: .noEcho)
        }
        if `optional` != false {
            try encodeContainer.encode(`optional`, forKey: .`optional`)
        }
        if queryable != false {
            try encodeContainer.encode(queryable, forKey: .queryable)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let optionalDecoded = try containerValues.decode(Swift.Bool.self, forKey: .optional)
        `optional` = optionalDecoded
        let keyDecoded = try containerValues.decode(Swift.Bool.self, forKey: .key)
        key = keyDecoded
        let noEchoDecoded = try containerValues.decode(Swift.Bool.self, forKey: .noEcho)
        noEcho = noEchoDecoded
        let queryableDecoded = try containerValues.decode(Swift.Bool.self, forKey: .queryable)
        queryable = queryableDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CodePipelineClientTypes.ActionTypeProperty: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionTypeProperty(description: \(Swift.String(describing: description)), key: \(Swift.String(describing: key)), name: \(Swift.String(describing: name)), noEcho: \(Swift.String(describing: noEcho)), optional: \(Swift.String(describing: `optional`)), queryable: \(Swift.String(describing: queryable)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about each property specified in the action configuration, such
    ///             as the description and key name that display for the customer using the action
    ///             type.</p>
    public struct ActionTypeProperty: Swift.Equatable {
        /// <p>Whether the configuration property is an optional value.</p>
        public let `optional`: Swift.Bool
        /// <p>The description of the property that is displayed to users.</p>
        public let description: Swift.String?
        /// <p>Whether the configuration property is a key.</p>
        public let key: Swift.Bool
        /// <p>The property name that is displayed to users.</p>
        public let name: Swift.String?
        /// <p>Whether to omit the field value entered by the customer in the log. If
        ///                 <code>true</code>, the value is not saved in CloudTrail logs for the action
        ///             execution.</p>
        public let noEcho: Swift.Bool
        /// <p>Indicates that the property is used with polling. An action type can have up to one
        ///             queryable property. If it has one, that property must be both required and not
        ///             secret.</p>
        public let queryable: Swift.Bool

        public init (
            `optional`: Swift.Bool = false,
            description: Swift.String? = nil,
            key: Swift.Bool = false,
            name: Swift.String? = nil,
            noEcho: Swift.Bool = false,
            queryable: Swift.Bool = false
        )
        {
            self.`optional` = `optional`
            self.description = description
            self.key = key
            self.name = name
            self.noEcho = noEcho
            self.queryable = queryable
        }
    }

}

extension CodePipelineClientTypes.ActionTypeSettings: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityUrlTemplate
        case executionUrlTemplate
        case revisionUrlTemplate
        case thirdPartyConfigurationUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityUrlTemplate = entityUrlTemplate {
            try encodeContainer.encode(entityUrlTemplate, forKey: .entityUrlTemplate)
        }
        if let executionUrlTemplate = executionUrlTemplate {
            try encodeContainer.encode(executionUrlTemplate, forKey: .executionUrlTemplate)
        }
        if let revisionUrlTemplate = revisionUrlTemplate {
            try encodeContainer.encode(revisionUrlTemplate, forKey: .revisionUrlTemplate)
        }
        if let thirdPartyConfigurationUrl = thirdPartyConfigurationUrl {
            try encodeContainer.encode(thirdPartyConfigurationUrl, forKey: .thirdPartyConfigurationUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thirdPartyConfigurationUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thirdPartyConfigurationUrl)
        thirdPartyConfigurationUrl = thirdPartyConfigurationUrlDecoded
        let entityUrlTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityUrlTemplate)
        entityUrlTemplate = entityUrlTemplateDecoded
        let executionUrlTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionUrlTemplate)
        executionUrlTemplate = executionUrlTemplateDecoded
        let revisionUrlTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionUrlTemplate)
        revisionUrlTemplate = revisionUrlTemplateDecoded
    }
}

extension CodePipelineClientTypes.ActionTypeSettings: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionTypeSettings(entityUrlTemplate: \(Swift.String(describing: entityUrlTemplate)), executionUrlTemplate: \(Swift.String(describing: executionUrlTemplate)), revisionUrlTemplate: \(Swift.String(describing: revisionUrlTemplate)), thirdPartyConfigurationUrl: \(Swift.String(describing: thirdPartyConfigurationUrl)))"}
}

extension CodePipelineClientTypes {
    /// <p>Returns information about the settings for an action type.</p>
    public struct ActionTypeSettings: Swift.Equatable {
        /// <p>The URL returned to the AWS CodePipeline console that provides a deep link to the
        ///             resources of the external system, such as the configuration page for an AWS CodeDeploy
        ///             deployment group. This link is provided as part of the action display in the
        ///             pipeline.</p>
        public let entityUrlTemplate: Swift.String?
        /// <p>The URL returned to the AWS CodePipeline console that contains a link to the
        ///             top-level landing page for the external system, such as the console page for AWS
        ///             CodeDeploy. This link is shown on the pipeline view page in the AWS CodePipeline console
        ///             and provides a link to the execution entity of the external action.</p>
        public let executionUrlTemplate: Swift.String?
        /// <p>The URL returned to the AWS CodePipeline console that contains a link to the page
        ///             where customers can update or change the configuration of the external action.</p>
        public let revisionUrlTemplate: Swift.String?
        /// <p>The URL of a sign-up page where users can sign up for an external service and
        ///             perform initial configuration of the action provided by that service.</p>
        public let thirdPartyConfigurationUrl: Swift.String?

        public init (
            entityUrlTemplate: Swift.String? = nil,
            executionUrlTemplate: Swift.String? = nil,
            revisionUrlTemplate: Swift.String? = nil,
            thirdPartyConfigurationUrl: Swift.String? = nil
        )
        {
            self.entityUrlTemplate = entityUrlTemplate
            self.executionUrlTemplate = executionUrlTemplate
            self.revisionUrlTemplate = revisionUrlTemplate
            self.thirdPartyConfigurationUrl = thirdPartyConfigurationUrl
        }
    }

}

extension CodePipelineClientTypes.ActionTypeUrls: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationUrl
        case entityUrlTemplate
        case executionUrlTemplate
        case revisionUrlTemplate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationUrl = configurationUrl {
            try encodeContainer.encode(configurationUrl, forKey: .configurationUrl)
        }
        if let entityUrlTemplate = entityUrlTemplate {
            try encodeContainer.encode(entityUrlTemplate, forKey: .entityUrlTemplate)
        }
        if let executionUrlTemplate = executionUrlTemplate {
            try encodeContainer.encode(executionUrlTemplate, forKey: .executionUrlTemplate)
        }
        if let revisionUrlTemplate = revisionUrlTemplate {
            try encodeContainer.encode(revisionUrlTemplate, forKey: .revisionUrlTemplate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configurationUrl)
        configurationUrl = configurationUrlDecoded
        let entityUrlTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityUrlTemplate)
        entityUrlTemplate = entityUrlTemplateDecoded
        let executionUrlTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionUrlTemplate)
        executionUrlTemplate = executionUrlTemplateDecoded
        let revisionUrlTemplateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionUrlTemplate)
        revisionUrlTemplate = revisionUrlTemplateDecoded
    }
}

extension CodePipelineClientTypes.ActionTypeUrls: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActionTypeUrls(configurationUrl: \(Swift.String(describing: configurationUrl)), entityUrlTemplate: \(Swift.String(describing: entityUrlTemplate)), executionUrlTemplate: \(Swift.String(describing: executionUrlTemplate)), revisionUrlTemplate: \(Swift.String(describing: revisionUrlTemplate)))"}
}

extension CodePipelineClientTypes {
    /// <p>Returns information about URLs for web pages that display to customers as links on the
    ///             pipeline view, such as an external configuration page for the action type.</p>
    public struct ActionTypeUrls: Swift.Equatable {
        /// <p>The URL returned to the CodePipeline console that contains a link to the page where
        ///             customers can configure the external action.</p>
        public let configurationUrl: Swift.String?
        /// <p>The URL returned to the CodePipeline console that provides a deep link to the
        ///             resources of the external system, such as a status page. This link is provided as part
        ///             of the action display in the pipeline.</p>
        public let entityUrlTemplate: Swift.String?
        /// <p>The link to an execution page for the action type in progress. For example, for a
        ///             CodeDeploy action, this link is shown on the pipeline view page in the CodePipeline
        ///             console, and it links to a CodeDeploy status page.</p>
        public let executionUrlTemplate: Swift.String?
        /// <p>The URL returned to the CodePipeline console that contains a link to the page where
        ///             customers can update or change the configuration of the external action.</p>
        public let revisionUrlTemplate: Swift.String?

        public init (
            configurationUrl: Swift.String? = nil,
            entityUrlTemplate: Swift.String? = nil,
            executionUrlTemplate: Swift.String? = nil,
            revisionUrlTemplate: Swift.String? = nil
        )
        {
            self.configurationUrl = configurationUrl
            self.entityUrlTemplate = entityUrlTemplate
            self.executionUrlTemplate = executionUrlTemplate
            self.revisionUrlTemplate = revisionUrlTemplate
        }
    }

}

extension ApprovalAlreadyCompletedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApprovalAlreadyCompletedException(message: \(Swift.String(describing: message)))"}
}

extension ApprovalAlreadyCompletedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ApprovalAlreadyCompletedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The approval action has already been approved or rejected.</p>
public struct ApprovalAlreadyCompletedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ApprovalAlreadyCompletedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ApprovalAlreadyCompletedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodePipelineClientTypes.ApprovalResult: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case summary
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let summary = summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .summary)
        summary = summaryDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ApprovalStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CodePipelineClientTypes.ApprovalResult: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ApprovalResult(status: \(Swift.String(describing: status)), summary: \(Swift.String(describing: summary)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about the result of an approval request.</p>
    public struct ApprovalResult: Swift.Equatable {
        /// <p>The response submitted by a reviewer assigned to an approval action
        ///             request.</p>
        public let status: CodePipelineClientTypes.ApprovalStatus?
        /// <p>The summary of the current status of the approval request.</p>
        public let summary: Swift.String?

        public init (
            status: CodePipelineClientTypes.ApprovalStatus? = nil,
            summary: Swift.String? = nil
        )
        {
            self.status = status
            self.summary = summary
        }
    }

}

extension CodePipelineClientTypes {
    public enum ApprovalStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [ApprovalStatus] {
            return [
                .approved,
                .rejected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "Approved"
            case .rejected: return "Rejected"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApprovalStatus(rawValue: rawValue) ?? ApprovalStatus.sdkUnknown(rawValue)
        }
    }
}

extension CodePipelineClientTypes.Artifact: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case location
        case name
        case revision
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ArtifactLocation.self, forKey: .location)
        location = locationDecoded
    }
}

extension CodePipelineClientTypes.Artifact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Artifact(location: \(Swift.String(describing: location)), name: \(Swift.String(describing: name)), revision: \(Swift.String(describing: revision)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about an artifact that is worked on by actions in the
    ///             pipeline.</p>
    public struct Artifact: Swift.Equatable {
        /// <p>The location of an artifact.</p>
        public let location: CodePipelineClientTypes.ArtifactLocation?
        /// <p>The artifact's name.</p>
        public let name: Swift.String?
        /// <p>The artifact's revision ID. Depending on the type of object, this could be a commit
        ///             ID (GitHub) or a revision ID (Amazon S3).</p>
        public let revision: Swift.String?

        public init (
            location: CodePipelineClientTypes.ArtifactLocation? = nil,
            name: Swift.String? = nil,
            revision: Swift.String? = nil
        )
        {
            self.location = location
            self.name = name
            self.revision = revision
        }
    }

}

extension CodePipelineClientTypes.ArtifactDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case s3location
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3location = s3location {
            try encodeContainer.encode(s3location, forKey: .s3location)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3locationDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.S3Location.self, forKey: .s3location)
        s3location = s3locationDecoded
    }
}

extension CodePipelineClientTypes.ArtifactDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ArtifactDetail(name: \(Swift.String(describing: name)), s3location: \(Swift.String(describing: s3location)))"}
}

extension CodePipelineClientTypes {
    /// <p>Artifact details for the action execution, such as the artifact location.</p>
    public struct ArtifactDetail: Swift.Equatable {
        /// <p>The artifact object name for the action execution.</p>
        public let name: Swift.String?
        /// <p>The Amazon S3 artifact location for the action execution.</p>
        public let s3location: CodePipelineClientTypes.S3Location?

        public init (
            name: Swift.String? = nil,
            s3location: CodePipelineClientTypes.S3Location? = nil
        )
        {
            self.name = name
            self.s3location = s3location
        }
    }

}

extension CodePipelineClientTypes.ArtifactDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximumCount
        case minimumCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maximumCount != 0 {
            try encodeContainer.encode(maximumCount, forKey: .maximumCount)
        }
        if minimumCount != 0 {
            try encodeContainer.encode(minimumCount, forKey: .minimumCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minimumCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .minimumCount)
        minimumCount = minimumCountDecoded
        let maximumCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .maximumCount)
        maximumCount = maximumCountDecoded
    }
}

extension CodePipelineClientTypes.ArtifactDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ArtifactDetails(maximumCount: \(Swift.String(describing: maximumCount)), minimumCount: \(Swift.String(describing: minimumCount)))"}
}

extension CodePipelineClientTypes {
    /// <p>Returns information about the details of an artifact.</p>
    public struct ArtifactDetails: Swift.Equatable {
        /// <p>The maximum number of artifacts allowed for the action type.</p>
        public let maximumCount: Swift.Int
        /// <p>The minimum number of artifacts allowed for the action type.</p>
        public let minimumCount: Swift.Int

        public init (
            maximumCount: Swift.Int = 0,
            minimumCount: Swift.Int = 0
        )
        {
            self.maximumCount = maximumCount
            self.minimumCount = minimumCount
        }
    }

}

extension CodePipelineClientTypes.ArtifactLocation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Location
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ArtifactLocationType.self, forKey: .type)
        type = typeDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.S3ArtifactLocation.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension CodePipelineClientTypes.ArtifactLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ArtifactLocation(s3Location: \(Swift.String(describing: s3Location)), type: \(Swift.String(describing: type)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about the location of an artifact.</p>
    public struct ArtifactLocation: Swift.Equatable {
        /// <p>The S3 bucket that contains the artifact.</p>
        public let s3Location: CodePipelineClientTypes.S3ArtifactLocation?
        /// <p>The type of artifact in the location.</p>
        public let type: CodePipelineClientTypes.ArtifactLocationType?

        public init (
            s3Location: CodePipelineClientTypes.S3ArtifactLocation? = nil,
            type: CodePipelineClientTypes.ArtifactLocationType? = nil
        )
        {
            self.s3Location = s3Location
            self.type = type
        }
    }

}

extension CodePipelineClientTypes {
    public enum ArtifactLocationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactLocationType] {
            return [
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArtifactLocationType(rawValue: rawValue) ?? ArtifactLocationType.sdkUnknown(rawValue)
        }
    }
}

extension CodePipelineClientTypes.ArtifactRevision: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created
        case name
        case revisionChangeIdentifier
        case revisionId
        case revisionSummary
        case revisionUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let revisionChangeIdentifier = revisionChangeIdentifier {
            try encodeContainer.encode(revisionChangeIdentifier, forKey: .revisionChangeIdentifier)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let revisionSummary = revisionSummary {
            try encodeContainer.encode(revisionSummary, forKey: .revisionSummary)
        }
        if let revisionUrl = revisionUrl {
            try encodeContainer.encode(revisionUrl, forKey: .revisionUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let revisionChangeIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionChangeIdentifier)
        revisionChangeIdentifier = revisionChangeIdentifierDecoded
        let revisionSummaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionSummary)
        revisionSummary = revisionSummaryDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let revisionUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionUrl)
        revisionUrl = revisionUrlDecoded
    }
}

extension CodePipelineClientTypes.ArtifactRevision: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ArtifactRevision(created: \(Swift.String(describing: created)), name: \(Swift.String(describing: name)), revisionChangeIdentifier: \(Swift.String(describing: revisionChangeIdentifier)), revisionId: \(Swift.String(describing: revisionId)), revisionSummary: \(Swift.String(describing: revisionSummary)), revisionUrl: \(Swift.String(describing: revisionUrl)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents revision details of an artifact. </p>
    public struct ArtifactRevision: Swift.Equatable {
        /// <p>The date and time when the most recent revision of the artifact was created, in
        ///             timestamp format.</p>
        public let created: ClientRuntime.Date?
        /// <p>The name of an artifact. This name might be system-generated, such as "MyApp", or
        ///             defined by the user when an action is created.</p>
        public let name: Swift.String?
        /// <p>An additional identifier for a revision, such as a commit date or, for artifacts
        ///             stored in Amazon S3 buckets, the ETag value.</p>
        public let revisionChangeIdentifier: Swift.String?
        /// <p>The revision ID of the artifact.</p>
        public let revisionId: Swift.String?
        /// <p>Summary information about the most recent revision of the artifact. For GitHub and
        ///             AWS CodeCommit repositories, the commit message. For Amazon S3 buckets or actions, the
        ///             user-provided content of a <code>codepipeline-artifact-revision-summary</code> key
        ///             specified in the object metadata.</p>
        public let revisionSummary: Swift.String?
        /// <p>The commit ID for the artifact revision. For artifacts stored in GitHub or AWS
        ///             CodeCommit repositories, the commit ID is linked to a commit details page.</p>
        public let revisionUrl: Swift.String?

        public init (
            created: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            revisionChangeIdentifier: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            revisionSummary: Swift.String? = nil,
            revisionUrl: Swift.String? = nil
        )
        {
            self.created = created
            self.name = name
            self.revisionChangeIdentifier = revisionChangeIdentifier
            self.revisionId = revisionId
            self.revisionSummary = revisionSummary
            self.revisionUrl = revisionUrl
        }
    }

}

extension CodePipelineClientTypes.ArtifactStore: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionKey
        case location
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ArtifactStoreType.self, forKey: .type)
        type = typeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.EncryptionKey.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
    }
}

extension CodePipelineClientTypes.ArtifactStore: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ArtifactStore(encryptionKey: \(Swift.String(describing: encryptionKey)), location: \(Swift.String(describing: location)), type: \(Swift.String(describing: type)))"}
}

extension CodePipelineClientTypes {
    /// <p>The S3 bucket where artifacts for the pipeline are stored.</p>
    ///         <note>
    ///             <p>You must include either <code>artifactStore</code> or
    ///                     <code>artifactStores</code> in your pipeline, but you cannot use both. If you
    ///                 create a cross-region action in your pipeline, you must use
    ///                     <code>artifactStores</code>.</p>
    ///         </note>
    public struct ArtifactStore: Swift.Equatable {
        /// <p>The encryption key used to encrypt the data in the artifact store, such as an AWS
        ///             Key Management Service (AWS KMS) key. If this is undefined, the default key for Amazon
        ///             S3 is used.</p>
        public let encryptionKey: CodePipelineClientTypes.EncryptionKey?
        /// <p>The S3 bucket used for storing the artifacts for a pipeline. You can specify the
        ///             name of an S3 bucket but not a folder in the bucket. A folder to contain the pipeline
        ///             artifacts is created for you based on the name of the pipeline. You can use any S3
        ///             bucket in the same AWS Region as the pipeline to store your pipeline
        ///             artifacts.</p>
        public let location: Swift.String?
        /// <p>The type of the artifact store, such as S3.</p>
        public let type: CodePipelineClientTypes.ArtifactStoreType?

        public init (
            encryptionKey: CodePipelineClientTypes.EncryptionKey? = nil,
            location: Swift.String? = nil,
            type: CodePipelineClientTypes.ArtifactStoreType? = nil
        )
        {
            self.encryptionKey = encryptionKey
            self.location = location
            self.type = type
        }
    }

}

extension CodePipelineClientTypes {
    public enum ArtifactStoreType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactStoreType] {
            return [
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArtifactStoreType(rawValue: rawValue) ?? ArtifactStoreType.sdkUnknown(rawValue)
        }
    }
}

extension CodePipelineClientTypes.BlockerDeclaration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.BlockerType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CodePipelineClientTypes.BlockerDeclaration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BlockerDeclaration(name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)))"}
}

extension CodePipelineClientTypes {
    /// <p>Reserved for future use.</p>
    public struct BlockerDeclaration: Swift.Equatable {
        /// <p>Reserved for future use.</p>
        public let name: Swift.String?
        /// <p>Reserved for future use.</p>
        public let type: CodePipelineClientTypes.BlockerType?

        public init (
            name: Swift.String? = nil,
            type: CodePipelineClientTypes.BlockerType? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension CodePipelineClientTypes {
    public enum BlockerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case schedule
        case sdkUnknown(Swift.String)

        public static var allCases: [BlockerType] {
            return [
                .schedule,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .schedule: return "Schedule"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BlockerType(rawValue: rawValue) ?? BlockerType.sdkUnknown(rawValue)
        }
    }
}

extension ConcurrentModificationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConcurrentModificationException(message: \(Swift.String(describing: message)))"}
}

extension ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Unable to modify the tag due to a simultaneous update request.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictException(message: \(Swift.String(describing: message)))"}
}

extension ConflictException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request cannot be handled because the pipeline is busy handling ongoing
///             activities. Try again later.</p>
public struct ConflictException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateCustomActionTypeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCustomActionTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCustomActionTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCustomActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCustomActionTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCustomActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCustomActionTypeOutputError>
}

extension CreateCustomActionTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCustomActionTypeInput(category: \(Swift.String(describing: category)), configurationProperties: \(Swift.String(describing: configurationProperties)), inputArtifactDetails: \(Swift.String(describing: inputArtifactDetails)), outputArtifactDetails: \(Swift.String(describing: outputArtifactDetails)), provider: \(Swift.String(describing: provider)), settings: \(Swift.String(describing: settings)), tags: \(Swift.String(describing: tags)), version: \(Swift.String(describing: version)))"}
}

extension CreateCustomActionTypeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category
        case configurationProperties
        case inputArtifactDetails
        case outputArtifactDetails
        case provider
        case settings
        case tags
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let configurationProperties = configurationProperties {
            var configurationPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .configurationProperties)
            for actionconfigurationpropertylist0 in configurationProperties {
                try configurationPropertiesContainer.encode(actionconfigurationpropertylist0)
            }
        }
        if let inputArtifactDetails = inputArtifactDetails {
            try encodeContainer.encode(inputArtifactDetails, forKey: .inputArtifactDetails)
        }
        if let outputArtifactDetails = outputArtifactDetails {
            try encodeContainer.encode(outputArtifactDetails, forKey: .outputArtifactDetails)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let settings = settings {
            try encodeContainer.encode(settings, forKey: .settings)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

public struct CreateCustomActionTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCustomActionTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCustomActionTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCustomActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCustomActionTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCustomActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCustomActionTypeOutputError>
}

public struct CreateCustomActionTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateCustomActionTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateCustomActionTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateCustomActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateCustomActionTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateCustomActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateCustomActionTypeOutputError>
}

/// <p>Represents the input of a CreateCustomActionType operation.</p>
public struct CreateCustomActionTypeInput: Swift.Equatable {
    /// <p>The category of the custom action, such as a build action or a test
    ///             action.</p>
    public let category: CodePipelineClientTypes.ActionCategory?
    /// <p>The configuration properties for the custom action.</p>
    ///         <note>
    ///             <p>You can refer to a name in the configuration properties of the custom action
    ///                 within the URL templates by following the format of {Config:name}, as long as the
    ///                 configuration property is both required and not secret. For more information, see
    ///                     <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/how-to-create-custom-action.html">Create a
    ///                     Custom Action for a Pipeline</a>.</p>
    ///         </note>
    public let configurationProperties: [CodePipelineClientTypes.ActionConfigurationProperty]?
    /// <p>The details of the input artifact for the action, such as its commit ID.</p>
    public let inputArtifactDetails: CodePipelineClientTypes.ArtifactDetails?
    /// <p>The details of the output artifact of the action, such as its commit ID.</p>
    public let outputArtifactDetails: CodePipelineClientTypes.ArtifactDetails?
    /// <p>The provider of the service used in the custom action, such as AWS
    ///             CodeDeploy.</p>
    public let provider: Swift.String?
    /// <p>URLs that provide users information about this custom action.</p>
    public let settings: CodePipelineClientTypes.ActionTypeSettings?
    /// <p>The tags for the custom action.</p>
    public let tags: [CodePipelineClientTypes.Tag]?
    /// <p>The version identifier of the custom action.</p>
    public let version: Swift.String?

    public init (
        category: CodePipelineClientTypes.ActionCategory? = nil,
        configurationProperties: [CodePipelineClientTypes.ActionConfigurationProperty]? = nil,
        inputArtifactDetails: CodePipelineClientTypes.ArtifactDetails? = nil,
        outputArtifactDetails: CodePipelineClientTypes.ArtifactDetails? = nil,
        provider: Swift.String? = nil,
        settings: CodePipelineClientTypes.ActionTypeSettings? = nil,
        tags: [CodePipelineClientTypes.Tag]? = nil,
        version: Swift.String? = nil
    )
    {
        self.category = category
        self.configurationProperties = configurationProperties
        self.inputArtifactDetails = inputArtifactDetails
        self.outputArtifactDetails = outputArtifactDetails
        self.provider = provider
        self.settings = settings
        self.tags = tags
        self.version = version
    }
}

struct CreateCustomActionTypeInputBody: Swift.Equatable {
    public let category: CodePipelineClientTypes.ActionCategory?
    public let provider: Swift.String?
    public let version: Swift.String?
    public let settings: CodePipelineClientTypes.ActionTypeSettings?
    public let configurationProperties: [CodePipelineClientTypes.ActionConfigurationProperty]?
    public let inputArtifactDetails: CodePipelineClientTypes.ArtifactDetails?
    public let outputArtifactDetails: CodePipelineClientTypes.ArtifactDetails?
    public let tags: [CodePipelineClientTypes.Tag]?
}

extension CreateCustomActionTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category
        case configurationProperties
        case inputArtifactDetails
        case outputArtifactDetails
        case provider
        case settings
        case tags
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionCategory.self, forKey: .category)
        category = categoryDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let settingsDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionTypeSettings.self, forKey: .settings)
        settings = settingsDecoded
        let configurationPropertiesContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.ActionConfigurationProperty?].self, forKey: .configurationProperties)
        var configurationPropertiesDecoded0:[CodePipelineClientTypes.ActionConfigurationProperty]? = nil
        if let configurationPropertiesContainer = configurationPropertiesContainer {
            configurationPropertiesDecoded0 = [CodePipelineClientTypes.ActionConfigurationProperty]()
            for structure0 in configurationPropertiesContainer {
                if let structure0 = structure0 {
                    configurationPropertiesDecoded0?.append(structure0)
                }
            }
        }
        configurationProperties = configurationPropertiesDecoded0
        let inputArtifactDetailsDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ArtifactDetails.self, forKey: .inputArtifactDetails)
        inputArtifactDetails = inputArtifactDetailsDecoded
        let outputArtifactDetailsDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ArtifactDetails.self, forKey: .outputArtifactDetails)
        outputArtifactDetails = outputArtifactDetailsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodePipelineClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodePipelineClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCustomActionTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCustomActionTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagsException" : self = .invalidTagsException(try InvalidTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCustomActionTypeOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidTagsException(InvalidTagsException)
    case limitExceededException(LimitExceededException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCustomActionTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateCustomActionTypeOutputResponse(actionType: \(Swift.String(describing: actionType)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateCustomActionTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateCustomActionTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actionType = output.actionType
            self.tags = output.tags
        } else {
            self.actionType = nil
            self.tags = nil
        }
    }
}

/// <p>Represents the output of a <code>CreateCustomActionType</code> operation.</p>
public struct CreateCustomActionTypeOutputResponse: Swift.Equatable {
    /// <p>Returns information about the details of an action type.</p>
    public let actionType: CodePipelineClientTypes.ActionType?
    /// <p>Specifies the tags applied to the custom action.</p>
    public let tags: [CodePipelineClientTypes.Tag]?

    public init (
        actionType: CodePipelineClientTypes.ActionType? = nil,
        tags: [CodePipelineClientTypes.Tag]? = nil
    )
    {
        self.actionType = actionType
        self.tags = tags
    }
}

struct CreateCustomActionTypeOutputResponseBody: Swift.Equatable {
    public let actionType: CodePipelineClientTypes.ActionType?
    public let tags: [CodePipelineClientTypes.Tag]?
}

extension CreateCustomActionTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodePipelineClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodePipelineClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreatePipelineInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePipelineOutputError>
}

extension CreatePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePipelineInput(pipeline: \(Swift.String(describing: pipeline)), tags: \(Swift.String(describing: tags)))"}
}

extension CreatePipelineInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipeline
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipeline = pipeline {
            try encodeContainer.encode(pipeline, forKey: .pipeline)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreatePipelineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePipelineOutputError>
}

public struct CreatePipelineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePipelineOutputError>
}

/// <p>Represents the input of a <code>CreatePipeline</code> action.</p>
public struct CreatePipelineInput: Swift.Equatable {
    /// <p>Represents the structure of actions and stages to be performed in the pipeline.
    ///         </p>
    public let pipeline: CodePipelineClientTypes.PipelineDeclaration?
    /// <p>The tags for the pipeline.</p>
    public let tags: [CodePipelineClientTypes.Tag]?

    public init (
        pipeline: CodePipelineClientTypes.PipelineDeclaration? = nil,
        tags: [CodePipelineClientTypes.Tag]? = nil
    )
    {
        self.pipeline = pipeline
        self.tags = tags
    }
}

struct CreatePipelineInputBody: Swift.Equatable {
    public let pipeline: CodePipelineClientTypes.PipelineDeclaration?
    public let tags: [CodePipelineClientTypes.Tag]?
}

extension CreatePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipeline
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.PipelineDeclaration.self, forKey: .pipeline)
        pipeline = pipelineDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodePipelineClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodePipelineClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidActionDeclarationException" : self = .invalidActionDeclarationException(try InvalidActionDeclarationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBlockerDeclarationException" : self = .invalidBlockerDeclarationException(try InvalidBlockerDeclarationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStageDeclarationException" : self = .invalidStageDeclarationException(try InvalidStageDeclarationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStructureException" : self = .invalidStructureException(try InvalidStructureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagsException" : self = .invalidTagsException(try InvalidTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNameInUseException" : self = .pipelineNameInUseException(try PipelineNameInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePipelineOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidActionDeclarationException(InvalidActionDeclarationException)
    case invalidBlockerDeclarationException(InvalidBlockerDeclarationException)
    case invalidStageDeclarationException(InvalidStageDeclarationException)
    case invalidStructureException(InvalidStructureException)
    case invalidTagsException(InvalidTagsException)
    case limitExceededException(LimitExceededException)
    case pipelineNameInUseException(PipelineNameInUseException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePipelineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePipelineOutputResponse(pipeline: \(Swift.String(describing: pipeline)), tags: \(Swift.String(describing: tags)))"}
}

extension CreatePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pipeline = output.pipeline
            self.tags = output.tags
        } else {
            self.pipeline = nil
            self.tags = nil
        }
    }
}

/// <p>Represents the output of a <code>CreatePipeline</code> action.</p>
public struct CreatePipelineOutputResponse: Swift.Equatable {
    /// <p>Represents the structure of actions and stages to be performed in the pipeline.
    ///         </p>
    public let pipeline: CodePipelineClientTypes.PipelineDeclaration?
    /// <p>Specifies the tags applied to the pipeline.</p>
    public let tags: [CodePipelineClientTypes.Tag]?

    public init (
        pipeline: CodePipelineClientTypes.PipelineDeclaration? = nil,
        tags: [CodePipelineClientTypes.Tag]? = nil
    )
    {
        self.pipeline = pipeline
        self.tags = tags
    }
}

struct CreatePipelineOutputResponseBody: Swift.Equatable {
    public let pipeline: CodePipelineClientTypes.PipelineDeclaration?
    public let tags: [CodePipelineClientTypes.Tag]?
}

extension CreatePipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipeline
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.PipelineDeclaration.self, forKey: .pipeline)
        pipeline = pipelineDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodePipelineClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodePipelineClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CodePipelineClientTypes.CurrentRevision: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeIdentifier
        case created
        case revision
        case revisionSummary
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeIdentifier = changeIdentifier {
            try encodeContainer.encode(changeIdentifier, forKey: .changeIdentifier)
        }
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let revision = revision {
            try encodeContainer.encode(revision, forKey: .revision)
        }
        if let revisionSummary = revisionSummary {
            try encodeContainer.encode(revisionSummary, forKey: .revisionSummary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let revisionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revision)
        revision = revisionDecoded
        let changeIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changeIdentifier)
        changeIdentifier = changeIdentifierDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let revisionSummaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionSummary)
        revisionSummary = revisionSummaryDecoded
    }
}

extension CodePipelineClientTypes.CurrentRevision: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CurrentRevision(changeIdentifier: \(Swift.String(describing: changeIdentifier)), created: \(Swift.String(describing: created)), revision: \(Swift.String(describing: revision)), revisionSummary: \(Swift.String(describing: revisionSummary)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about a current revision.</p>
    public struct CurrentRevision: Swift.Equatable {
        /// <p>The change identifier for the current revision.</p>
        public let changeIdentifier: Swift.String?
        /// <p>The date and time when the most recent revision of the artifact was created, in
        ///             timestamp format.</p>
        public let created: ClientRuntime.Date?
        /// <p>The revision ID of the current version of an artifact.</p>
        public let revision: Swift.String?
        /// <p>The summary of the most recent revision of the artifact.</p>
        public let revisionSummary: Swift.String?

        public init (
            changeIdentifier: Swift.String? = nil,
            created: ClientRuntime.Date? = nil,
            revision: Swift.String? = nil,
            revisionSummary: Swift.String? = nil
        )
        {
            self.changeIdentifier = changeIdentifier
            self.created = created
            self.revision = revision
            self.revisionSummary = revisionSummary
        }
    }

}

public struct DeleteCustomActionTypeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCustomActionTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCustomActionTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCustomActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCustomActionTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCustomActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCustomActionTypeOutputError>
}

extension DeleteCustomActionTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCustomActionTypeInput(category: \(Swift.String(describing: category)), provider: \(Swift.String(describing: provider)), version: \(Swift.String(describing: version)))"}
}

extension DeleteCustomActionTypeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category
        case provider
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

public struct DeleteCustomActionTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCustomActionTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCustomActionTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCustomActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCustomActionTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCustomActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCustomActionTypeOutputError>
}

public struct DeleteCustomActionTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteCustomActionTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteCustomActionTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteCustomActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteCustomActionTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteCustomActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteCustomActionTypeOutputError>
}

/// <p>Represents the input of a <code>DeleteCustomActionType</code> operation. The custom
///             action will be marked as deleted.</p>
public struct DeleteCustomActionTypeInput: Swift.Equatable {
    /// <p>The category of the custom action that you want to delete, such as source or
    ///             deploy.</p>
    public let category: CodePipelineClientTypes.ActionCategory?
    /// <p>The provider of the service used in the custom action, such as AWS
    ///             CodeDeploy.</p>
    public let provider: Swift.String?
    /// <p>The version of the custom action to delete.</p>
    public let version: Swift.String?

    public init (
        category: CodePipelineClientTypes.ActionCategory? = nil,
        provider: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.category = category
        self.provider = provider
        self.version = version
    }
}

struct DeleteCustomActionTypeInputBody: Swift.Equatable {
    public let category: CodePipelineClientTypes.ActionCategory?
    public let provider: Swift.String?
    public let version: Swift.String?
}

extension DeleteCustomActionTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category
        case provider
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionCategory.self, forKey: .category)
        category = categoryDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension DeleteCustomActionTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCustomActionTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCustomActionTypeOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCustomActionTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteCustomActionTypeOutputResponse()"}
}

extension DeleteCustomActionTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCustomActionTypeOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteCustomActionTypeOutputResponseBody: Swift.Equatable {
}

extension DeleteCustomActionTypeOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeletePipelineInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePipelineOutputError>
}

extension DeletePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePipelineInput(name: \(Swift.String(describing: name)))"}
}

extension DeletePipelineInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeletePipelineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePipelineOutputError>
}

public struct DeletePipelineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePipelineOutputError>
}

/// <p>Represents the input of a <code>DeletePipeline</code> action.</p>
public struct DeletePipelineInput: Swift.Equatable {
    /// <p>The name of the pipeline to be deleted.</p>
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeletePipelineInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeletePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeletePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePipelineOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePipelineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePipelineOutputResponse()"}
}

extension DeletePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePipelineOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeletePipelineOutputResponseBody: Swift.Equatable {
}

extension DeletePipelineOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteWebhookInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWebhookInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWebhookInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWebhookInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWebhookOutputError>
}

extension DeleteWebhookInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteWebhookInput(name: \(Swift.String(describing: name)))"}
}

extension DeleteWebhookInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteWebhookInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWebhookInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWebhookInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWebhookInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWebhookOutputError>
}

public struct DeleteWebhookInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteWebhookInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteWebhookInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteWebhookInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteWebhookOutputError>
}

public struct DeleteWebhookInput: Swift.Equatable {
    /// <p>The name of the webhook you want to delete.</p>
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteWebhookInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension DeleteWebhookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteWebhookOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWebhookOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWebhookOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWebhookOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteWebhookOutputResponse()"}
}

extension DeleteWebhookOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWebhookOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteWebhookOutputResponseBody: Swift.Equatable {
}

extension DeleteWebhookOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeregisterWebhookWithThirdPartyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterWebhookWithThirdPartyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterWebhookWithThirdPartyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterWebhookWithThirdPartyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterWebhookWithThirdPartyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterWebhookWithThirdPartyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterWebhookWithThirdPartyOutputError>
}

extension DeregisterWebhookWithThirdPartyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterWebhookWithThirdPartyInput(webhookName: \(Swift.String(describing: webhookName)))"}
}

extension DeregisterWebhookWithThirdPartyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case webhookName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let webhookName = webhookName {
            try encodeContainer.encode(webhookName, forKey: .webhookName)
        }
    }
}

public struct DeregisterWebhookWithThirdPartyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterWebhookWithThirdPartyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterWebhookWithThirdPartyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterWebhookWithThirdPartyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterWebhookWithThirdPartyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterWebhookWithThirdPartyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterWebhookWithThirdPartyOutputError>
}

public struct DeregisterWebhookWithThirdPartyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeregisterWebhookWithThirdPartyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeregisterWebhookWithThirdPartyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeregisterWebhookWithThirdPartyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeregisterWebhookWithThirdPartyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeregisterWebhookWithThirdPartyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeregisterWebhookWithThirdPartyOutputError>
}

public struct DeregisterWebhookWithThirdPartyInput: Swift.Equatable {
    /// <p>The name of the webhook you want to deregister.</p>
    public let webhookName: Swift.String?

    public init (
        webhookName: Swift.String? = nil
    )
    {
        self.webhookName = webhookName
    }
}

struct DeregisterWebhookWithThirdPartyInputBody: Swift.Equatable {
    public let webhookName: Swift.String?
}

extension DeregisterWebhookWithThirdPartyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case webhookName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webhookName)
        webhookName = webhookNameDecoded
    }
}

extension DeregisterWebhookWithThirdPartyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterWebhookWithThirdPartyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WebhookNotFoundException" : self = .webhookNotFoundException(try WebhookNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterWebhookWithThirdPartyOutputError: Swift.Error, Swift.Equatable {
    case validationException(ValidationException)
    case webhookNotFoundException(WebhookNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterWebhookWithThirdPartyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeregisterWebhookWithThirdPartyOutputResponse()"}
}

extension DeregisterWebhookWithThirdPartyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterWebhookWithThirdPartyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeregisterWebhookWithThirdPartyOutputResponseBody: Swift.Equatable {
}

extension DeregisterWebhookWithThirdPartyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DisableStageTransitionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableStageTransitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableStageTransitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableStageTransitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableStageTransitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableStageTransitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableStageTransitionOutputError>
}

extension DisableStageTransitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableStageTransitionInput(pipelineName: \(Swift.String(describing: pipelineName)), reason: \(Swift.String(describing: reason)), stageName: \(Swift.String(describing: stageName)), transitionType: \(Swift.String(describing: transitionType)))"}
}

extension DisableStageTransitionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineName
        case reason
        case stageName
        case transitionType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let transitionType = transitionType {
            try encodeContainer.encode(transitionType.rawValue, forKey: .transitionType)
        }
    }
}

public struct DisableStageTransitionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableStageTransitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableStageTransitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableStageTransitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableStageTransitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableStageTransitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableStageTransitionOutputError>
}

public struct DisableStageTransitionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableStageTransitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableStageTransitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableStageTransitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableStageTransitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableStageTransitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableStageTransitionOutputError>
}

/// <p>Represents the input of a <code>DisableStageTransition</code> action.</p>
public struct DisableStageTransitionInput: Swift.Equatable {
    /// <p>The name of the pipeline in which you want to disable the flow of artifacts from
    ///             one stage to another.</p>
    public let pipelineName: Swift.String?
    /// <p>The reason given to the user that a stage is disabled, such as waiting for manual
    ///             approval or manual tests. This message is displayed in the pipeline console
    ///             UI.</p>
    public let reason: Swift.String?
    /// <p>The name of the stage where you want to disable the inbound or outbound transition
    ///             of artifacts.</p>
    public let stageName: Swift.String?
    /// <p>Specifies whether artifacts are prevented from transitioning into the stage and
    ///             being processed by the actions in that stage (inbound), or prevented from transitioning
    ///             from the stage after they have been processed by the actions in that stage
    ///             (outbound).</p>
    public let transitionType: CodePipelineClientTypes.StageTransitionType?

    public init (
        pipelineName: Swift.String? = nil,
        reason: Swift.String? = nil,
        stageName: Swift.String? = nil,
        transitionType: CodePipelineClientTypes.StageTransitionType? = nil
    )
    {
        self.pipelineName = pipelineName
        self.reason = reason
        self.stageName = stageName
        self.transitionType = transitionType
    }
}

struct DisableStageTransitionInputBody: Swift.Equatable {
    public let pipelineName: Swift.String?
    public let stageName: Swift.String?
    public let transitionType: CodePipelineClientTypes.StageTransitionType?
    public let reason: Swift.String?
}

extension DisableStageTransitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineName
        case reason
        case stageName
        case transitionType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let transitionTypeDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.StageTransitionType.self, forKey: .transitionType)
        transitionType = transitionTypeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension DisableStageTransitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableStageTransitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StageNotFoundException" : self = .stageNotFoundException(try StageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableStageTransitionOutputError: Swift.Error, Swift.Equatable {
    case pipelineNotFoundException(PipelineNotFoundException)
    case stageNotFoundException(StageNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableStageTransitionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableStageTransitionOutputResponse()"}
}

extension DisableStageTransitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisableStageTransitionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisableStageTransitionOutputResponseBody: Swift.Equatable {
}

extension DisableStageTransitionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DuplicatedStopRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DuplicatedStopRequestException(message: \(Swift.String(describing: message)))"}
}

extension DuplicatedStopRequestException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DuplicatedStopRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pipeline execution is already in a <code>Stopping</code> state. If you already
///             chose to stop and wait, you cannot make that request again. You can choose to stop and
///             abandon now, but be aware that this option can lead to failed tasks or out of sequence
///             tasks. If you already chose to stop and abandon, you cannot make that request
///             again.</p>
public struct DuplicatedStopRequestException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicatedStopRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DuplicatedStopRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct EnableStageTransitionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableStageTransitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableStageTransitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableStageTransitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableStageTransitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableStageTransitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableStageTransitionOutputError>
}

extension EnableStageTransitionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableStageTransitionInput(pipelineName: \(Swift.String(describing: pipelineName)), stageName: \(Swift.String(describing: stageName)), transitionType: \(Swift.String(describing: transitionType)))"}
}

extension EnableStageTransitionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineName
        case stageName
        case transitionType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let transitionType = transitionType {
            try encodeContainer.encode(transitionType.rawValue, forKey: .transitionType)
        }
    }
}

public struct EnableStageTransitionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableStageTransitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableStageTransitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableStageTransitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableStageTransitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableStageTransitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableStageTransitionOutputError>
}

public struct EnableStageTransitionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableStageTransitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableStageTransitionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableStageTransitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableStageTransitionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableStageTransitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableStageTransitionOutputError>
}

/// <p>Represents the input of an <code>EnableStageTransition</code> action.</p>
public struct EnableStageTransitionInput: Swift.Equatable {
    /// <p>The name of the pipeline in which you want to enable the flow of artifacts from one
    ///             stage to another.</p>
    public let pipelineName: Swift.String?
    /// <p>The name of the stage where you want to enable the transition of artifacts, either
    ///             into the stage (inbound) or from that stage to the next stage (outbound).</p>
    public let stageName: Swift.String?
    /// <p>Specifies whether artifacts are allowed to enter the stage and be processed by the
    ///             actions in that stage (inbound) or whether already processed artifacts are allowed to
    ///             transition to the next stage (outbound).</p>
    public let transitionType: CodePipelineClientTypes.StageTransitionType?

    public init (
        pipelineName: Swift.String? = nil,
        stageName: Swift.String? = nil,
        transitionType: CodePipelineClientTypes.StageTransitionType? = nil
    )
    {
        self.pipelineName = pipelineName
        self.stageName = stageName
        self.transitionType = transitionType
    }
}

struct EnableStageTransitionInputBody: Swift.Equatable {
    public let pipelineName: Swift.String?
    public let stageName: Swift.String?
    public let transitionType: CodePipelineClientTypes.StageTransitionType?
}

extension EnableStageTransitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineName
        case stageName
        case transitionType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let transitionTypeDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.StageTransitionType.self, forKey: .transitionType)
        transitionType = transitionTypeDecoded
    }
}

extension EnableStageTransitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableStageTransitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StageNotFoundException" : self = .stageNotFoundException(try StageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableStageTransitionOutputError: Swift.Error, Swift.Equatable {
    case pipelineNotFoundException(PipelineNotFoundException)
    case stageNotFoundException(StageNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableStageTransitionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableStageTransitionOutputResponse()"}
}

extension EnableStageTransitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct EnableStageTransitionOutputResponse: Swift.Equatable {

    public init() {}
}

struct EnableStageTransitionOutputResponseBody: Swift.Equatable {
}

extension EnableStageTransitionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CodePipelineClientTypes.EncryptionKey: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.EncryptionKeyType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CodePipelineClientTypes.EncryptionKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EncryptionKey(id: \(Swift.String(describing: id)), type: \(Swift.String(describing: type)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about the key used to encrypt data in the artifact store,
    ///             such as an AWS Key Management Service (AWS KMS) key.</p>
    public struct EncryptionKey: Swift.Equatable {
        /// <p>The ID used to identify the key. For an AWS KMS key, you can use the key ID, the
        ///             key ARN, or the alias ARN.</p>
        ///         <note>
        ///             <p>Aliases are recognized only in the account that created the customer master key
        ///                 (CMK). For cross-account actions, you can only use the key ID or key ARN to identify
        ///                 the key.</p>
        ///         </note>
        public let id: Swift.String?
        /// <p>The type of encryption key, such as an AWS Key Management Service (AWS KMS) key.
        ///             When creating or updating a pipeline, the value must be set to 'KMS'.</p>
        public let type: CodePipelineClientTypes.EncryptionKeyType?

        public init (
            id: Swift.String? = nil,
            type: CodePipelineClientTypes.EncryptionKeyType? = nil
        )
        {
            self.id = id
            self.type = type
        }
    }

}

extension CodePipelineClientTypes {
    public enum EncryptionKeyType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kms
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionKeyType] {
            return [
                .kms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kms: return "KMS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionKeyType(rawValue: rawValue) ?? EncryptionKeyType.sdkUnknown(rawValue)
        }
    }
}

extension CodePipelineClientTypes.ErrorDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodePipelineClientTypes.ErrorDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ErrorDetails(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about an error in AWS CodePipeline.</p>
    public struct ErrorDetails: Swift.Equatable {
        /// <p>The system ID or number code of the error.</p>
        public let code: Swift.String?
        /// <p>The text of the error message.</p>
        public let message: Swift.String?

        public init (
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension CodePipelineClientTypes.ExecutionDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalExecutionId
        case percentComplete
        case summary
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalExecutionId = externalExecutionId {
            try encodeContainer.encode(externalExecutionId, forKey: .externalExecutionId)
        }
        if let percentComplete = percentComplete {
            try encodeContainer.encode(percentComplete, forKey: .percentComplete)
        }
        if let summary = summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let summaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .summary)
        summary = summaryDecoded
        let externalExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalExecutionId)
        externalExecutionId = externalExecutionIdDecoded
        let percentCompleteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .percentComplete)
        percentComplete = percentCompleteDecoded
    }
}

extension CodePipelineClientTypes.ExecutionDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecutionDetails(externalExecutionId: \(Swift.String(describing: externalExecutionId)), percentComplete: \(Swift.String(describing: percentComplete)), summary: \(Swift.String(describing: summary)))"}
}

extension CodePipelineClientTypes {
    /// <p>The details of the actions taken and results produced on an artifact as it passes
    ///             through stages in the pipeline.</p>
    public struct ExecutionDetails: Swift.Equatable {
        /// <p>The system-generated unique ID of this action used to identify this job worker in
        ///             any external systems, such as AWS CodeDeploy.</p>
        public let externalExecutionId: Swift.String?
        /// <p>The percentage of work completed on the action, represented on a scale of 0 to 100
        ///             percent.</p>
        public let percentComplete: Swift.Int?
        /// <p>The summary of the current status of the actions.</p>
        public let summary: Swift.String?

        public init (
            externalExecutionId: Swift.String? = nil,
            percentComplete: Swift.Int? = nil,
            summary: Swift.String? = nil
        )
        {
            self.externalExecutionId = externalExecutionId
            self.percentComplete = percentComplete
            self.summary = summary
        }
    }

}

extension CodePipelineClientTypes.ExecutionTrigger: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case triggerDetail
        case triggerType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let triggerDetail = triggerDetail {
            try encodeContainer.encode(triggerDetail, forKey: .triggerDetail)
        }
        if let triggerType = triggerType {
            try encodeContainer.encode(triggerType.rawValue, forKey: .triggerType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let triggerTypeDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.TriggerType.self, forKey: .triggerType)
        triggerType = triggerTypeDecoded
        let triggerDetailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .triggerDetail)
        triggerDetail = triggerDetailDecoded
    }
}

extension CodePipelineClientTypes.ExecutionTrigger: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecutionTrigger(triggerDetail: \(Swift.String(describing: triggerDetail)), triggerType: \(Swift.String(describing: triggerType)))"}
}

extension CodePipelineClientTypes {
    /// <p>The interaction or event that started a pipeline execution.</p>
    public struct ExecutionTrigger: Swift.Equatable {
        /// <p>Detail related to the event that started a pipeline execution, such as the webhook ARN
        ///             of the webhook that triggered the pipeline execution or the user ARN for a
        ///             user-initiated <code>start-pipeline-execution</code> CLI command.</p>
        public let triggerDetail: Swift.String?
        /// <p>The type of change-detection method, command, or user interaction that started a
        ///             pipeline execution.</p>
        public let triggerType: CodePipelineClientTypes.TriggerType?

        public init (
            triggerDetail: Swift.String? = nil,
            triggerType: CodePipelineClientTypes.TriggerType? = nil
        )
        {
            self.triggerDetail = triggerDetail
            self.triggerType = triggerType
        }
    }

}

extension CodePipelineClientTypes.ExecutorConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobWorkerExecutorConfiguration
        case lambdaExecutorConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobWorkerExecutorConfiguration = jobWorkerExecutorConfiguration {
            try encodeContainer.encode(jobWorkerExecutorConfiguration, forKey: .jobWorkerExecutorConfiguration)
        }
        if let lambdaExecutorConfiguration = lambdaExecutorConfiguration {
            try encodeContainer.encode(lambdaExecutorConfiguration, forKey: .lambdaExecutorConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaExecutorConfigurationDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.LambdaExecutorConfiguration.self, forKey: .lambdaExecutorConfiguration)
        lambdaExecutorConfiguration = lambdaExecutorConfigurationDecoded
        let jobWorkerExecutorConfigurationDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.JobWorkerExecutorConfiguration.self, forKey: .jobWorkerExecutorConfiguration)
        jobWorkerExecutorConfiguration = jobWorkerExecutorConfigurationDecoded
    }
}

extension CodePipelineClientTypes.ExecutorConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecutorConfiguration(jobWorkerExecutorConfiguration: \(Swift.String(describing: jobWorkerExecutorConfiguration)), lambdaExecutorConfiguration: \(Swift.String(describing: lambdaExecutorConfiguration)))"}
}

extension CodePipelineClientTypes {
    /// <p>The action engine, or executor, related to the supported integration model used to
    ///             create and update the action type. The available executor types are <code>Lambda</code>
    ///             and <code>JobWorker</code>.</p>
    public struct ExecutorConfiguration: Swift.Equatable {
        /// <p>Details about the <code>JobWorker</code> executor of the action type.</p>
        public let jobWorkerExecutorConfiguration: CodePipelineClientTypes.JobWorkerExecutorConfiguration?
        /// <p>Details about the <code>Lambda</code> executor of the action type.</p>
        public let lambdaExecutorConfiguration: CodePipelineClientTypes.LambdaExecutorConfiguration?

        public init (
            jobWorkerExecutorConfiguration: CodePipelineClientTypes.JobWorkerExecutorConfiguration? = nil,
            lambdaExecutorConfiguration: CodePipelineClientTypes.LambdaExecutorConfiguration? = nil
        )
        {
            self.jobWorkerExecutorConfiguration = jobWorkerExecutorConfiguration
            self.lambdaExecutorConfiguration = lambdaExecutorConfiguration
        }
    }

}

extension CodePipelineClientTypes {
    public enum ExecutorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jobworker
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutorType] {
            return [
                .jobworker,
                .lambda,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jobworker: return "JobWorker"
            case .lambda: return "Lambda"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutorType(rawValue: rawValue) ?? ExecutorType.sdkUnknown(rawValue)
        }
    }
}

extension CodePipelineClientTypes.FailureDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case externalExecutionId
        case message
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let externalExecutionId = externalExecutionId {
            try encodeContainer.encode(externalExecutionId, forKey: .externalExecutionId)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.FailureType.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let externalExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .externalExecutionId)
        externalExecutionId = externalExecutionIdDecoded
    }
}

extension CodePipelineClientTypes.FailureDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FailureDetails(externalExecutionId: \(Swift.String(describing: externalExecutionId)), message: \(Swift.String(describing: message)), type: \(Swift.String(describing: type)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about failure details.</p>
    public struct FailureDetails: Swift.Equatable {
        /// <p>The external ID of the run of the action that failed.</p>
        public let externalExecutionId: Swift.String?
        /// <p>The message about the failure.</p>
        public let message: Swift.String?
        /// <p>The type of the failure.</p>
        public let type: CodePipelineClientTypes.FailureType?

        public init (
            externalExecutionId: Swift.String? = nil,
            message: Swift.String? = nil,
            type: CodePipelineClientTypes.FailureType? = nil
        )
        {
            self.externalExecutionId = externalExecutionId
            self.message = message
            self.type = type
        }
    }

}

extension CodePipelineClientTypes {
    public enum FailureType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case configurationerror
        case jobfailed
        case permissionerror
        case revisionoutofsync
        case revisionunavailable
        case systemunavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [FailureType] {
            return [
                .configurationerror,
                .jobfailed,
                .permissionerror,
                .revisionoutofsync,
                .revisionunavailable,
                .systemunavailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .configurationerror: return "ConfigurationError"
            case .jobfailed: return "JobFailed"
            case .permissionerror: return "PermissionError"
            case .revisionoutofsync: return "RevisionOutOfSync"
            case .revisionunavailable: return "RevisionUnavailable"
            case .systemunavailable: return "SystemUnavailable"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailureType(rawValue: rawValue) ?? FailureType.sdkUnknown(rawValue)
        }
    }
}

public struct GetActionTypeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetActionTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetActionTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetActionTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetActionTypeOutputError>
}

extension GetActionTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetActionTypeInput(category: \(Swift.String(describing: category)), owner: \(Swift.String(describing: owner)), provider: \(Swift.String(describing: provider)), version: \(Swift.String(describing: version)))"}
}

extension GetActionTypeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category
        case owner
        case provider
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

public struct GetActionTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetActionTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetActionTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetActionTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetActionTypeOutputError>
}

public struct GetActionTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetActionTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetActionTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetActionTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetActionTypeOutputError>
}

public struct GetActionTypeInput: Swift.Equatable {
    /// <p>Defines what kind of action can be taken in the stage. The following are the valid
    ///             values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>Source</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Build</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Test</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Deploy</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Approval</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>Invoke</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let category: CodePipelineClientTypes.ActionCategory?
    /// <p>The creator of an action type that was created with any supported integration model.
    ///             There are two valid values: <code>AWS</code> and <code>ThirdParty</code>.</p>
    public let owner: Swift.String?
    /// <p>The provider of the action type being called. The provider name is specified when the
    ///             action type is created.</p>
    public let provider: Swift.String?
    /// <p>A string that describes the action type version.</p>
    public let version: Swift.String?

    public init (
        category: CodePipelineClientTypes.ActionCategory? = nil,
        owner: Swift.String? = nil,
        provider: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.category = category
        self.owner = owner
        self.provider = provider
        self.version = version
    }
}

struct GetActionTypeInputBody: Swift.Equatable {
    public let category: CodePipelineClientTypes.ActionCategory?
    public let owner: Swift.String?
    public let provider: Swift.String?
    public let version: Swift.String?
}

extension GetActionTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category
        case owner
        case provider
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionCategory.self, forKey: .category)
        category = categoryDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let providerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provider)
        provider = providerDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetActionTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetActionTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ActionTypeNotFoundException" : self = .actionTypeNotFoundException(try ActionTypeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetActionTypeOutputError: Swift.Error, Swift.Equatable {
    case actionTypeNotFoundException(ActionTypeNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetActionTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetActionTypeOutputResponse(actionType: \(Swift.String(describing: actionType)))"}
}

extension GetActionTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetActionTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actionType = output.actionType
        } else {
            self.actionType = nil
        }
    }
}

public struct GetActionTypeOutputResponse: Swift.Equatable {
    /// <p>The action type information for the requested action type, such as the action type
    ///             ID.</p>
    public let actionType: CodePipelineClientTypes.ActionTypeDeclaration?

    public init (
        actionType: CodePipelineClientTypes.ActionTypeDeclaration? = nil
    )
    {
        self.actionType = actionType
    }
}

struct GetActionTypeOutputResponseBody: Swift.Equatable {
    public let actionType: CodePipelineClientTypes.ActionTypeDeclaration?
}

extension GetActionTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionTypeDeclaration.self, forKey: .actionType)
        actionType = actionTypeDecoded
    }
}

public struct GetJobDetailsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetJobDetailsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetJobDetailsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetJobDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetJobDetailsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetJobDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetJobDetailsOutputError>
}

extension GetJobDetailsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetJobDetailsInput(jobId: \(Swift.String(describing: jobId)))"}
}

extension GetJobDetailsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct GetJobDetailsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetJobDetailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetJobDetailsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetJobDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetJobDetailsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetJobDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetJobDetailsOutputError>
}

public struct GetJobDetailsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetJobDetailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetJobDetailsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetJobDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetJobDetailsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetJobDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetJobDetailsOutputError>
}

/// <p>Represents the input of a <code>GetJobDetails</code> action.</p>
public struct GetJobDetailsInput: Swift.Equatable {
    /// <p>The unique system-generated ID for the job.</p>
    public let jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct GetJobDetailsInputBody: Swift.Equatable {
    public let jobId: Swift.String?
}

extension GetJobDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension GetJobDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJobDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJobDetailsOutputError: Swift.Error, Swift.Equatable {
    case jobNotFoundException(JobNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJobDetailsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetJobDetailsOutputResponse(jobDetails: \(Swift.String(describing: jobDetails)))"}
}

extension GetJobDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetJobDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobDetails = output.jobDetails
        } else {
            self.jobDetails = nil
        }
    }
}

/// <p>Represents the output of a <code>GetJobDetails</code> action.</p>
public struct GetJobDetailsOutputResponse: Swift.Equatable {
    /// <p>The details of the job.</p>
    ///         <note>
    ///             <p>If AWSSessionCredentials is used, a long-running job can call
    ///                     <code>GetJobDetails</code> again to obtain new credentials.</p>
    ///         </note>
    public let jobDetails: CodePipelineClientTypes.JobDetails?

    public init (
        jobDetails: CodePipelineClientTypes.JobDetails? = nil
    )
    {
        self.jobDetails = jobDetails
    }
}

struct GetJobDetailsOutputResponseBody: Swift.Equatable {
    public let jobDetails: CodePipelineClientTypes.JobDetails?
}

extension GetJobDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobDetails
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDetailsDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.JobDetails.self, forKey: .jobDetails)
        jobDetails = jobDetailsDecoded
    }
}

public struct GetPipelineExecutionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPipelineExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPipelineExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPipelineExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPipelineExecutionOutputError>
}

extension GetPipelineExecutionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPipelineExecutionInput(pipelineExecutionId: \(Swift.String(describing: pipelineExecutionId)), pipelineName: \(Swift.String(describing: pipelineName)))"}
}

extension GetPipelineExecutionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineExecutionId
        case pipelineName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineExecutionId = pipelineExecutionId {
            try encodeContainer.encode(pipelineExecutionId, forKey: .pipelineExecutionId)
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
    }
}

public struct GetPipelineExecutionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPipelineExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPipelineExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPipelineExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPipelineExecutionOutputError>
}

public struct GetPipelineExecutionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPipelineExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPipelineExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPipelineExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPipelineExecutionOutputError>
}

/// <p>Represents the input of a <code>GetPipelineExecution</code> action.</p>
public struct GetPipelineExecutionInput: Swift.Equatable {
    /// <p>The ID of the pipeline execution about which you want to get execution
    ///             details.</p>
    public let pipelineExecutionId: Swift.String?
    /// <p>The name of the pipeline about which you want to get execution details.</p>
    public let pipelineName: Swift.String?

    public init (
        pipelineExecutionId: Swift.String? = nil,
        pipelineName: Swift.String? = nil
    )
    {
        self.pipelineExecutionId = pipelineExecutionId
        self.pipelineName = pipelineName
    }
}

struct GetPipelineExecutionInputBody: Swift.Equatable {
    public let pipelineName: Swift.String?
    public let pipelineExecutionId: Swift.String?
}

extension GetPipelineExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineExecutionId
        case pipelineName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
    }
}

extension GetPipelineExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPipelineExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "PipelineExecutionNotFoundException" : self = .pipelineExecutionNotFoundException(try PipelineExecutionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPipelineExecutionOutputError: Swift.Error, Swift.Equatable {
    case pipelineExecutionNotFoundException(PipelineExecutionNotFoundException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPipelineExecutionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPipelineExecutionOutputResponse(pipelineExecution: \(Swift.String(describing: pipelineExecution)))"}
}

extension GetPipelineExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPipelineExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pipelineExecution = output.pipelineExecution
        } else {
            self.pipelineExecution = nil
        }
    }
}

/// <p>Represents the output of a <code>GetPipelineExecution</code> action.</p>
public struct GetPipelineExecutionOutputResponse: Swift.Equatable {
    /// <p>Represents information about the execution of a pipeline.</p>
    public let pipelineExecution: CodePipelineClientTypes.PipelineExecution?

    public init (
        pipelineExecution: CodePipelineClientTypes.PipelineExecution? = nil
    )
    {
        self.pipelineExecution = pipelineExecution
    }
}

struct GetPipelineExecutionOutputResponseBody: Swift.Equatable {
    public let pipelineExecution: CodePipelineClientTypes.PipelineExecution?
}

extension GetPipelineExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineExecution
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineExecutionDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.PipelineExecution.self, forKey: .pipelineExecution)
        pipelineExecution = pipelineExecutionDecoded
    }
}

public struct GetPipelineInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPipelineOutputError>
}

extension GetPipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPipelineInput(name: \(Swift.String(describing: name)), version: \(Swift.String(describing: version)))"}
}

extension GetPipelineInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }
}

public struct GetPipelineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPipelineOutputError>
}

public struct GetPipelineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPipelineOutputError>
}

/// <p>Represents the input of a <code>GetPipeline</code> action.</p>
public struct GetPipelineInput: Swift.Equatable {
    /// <p>The name of the pipeline for which you want to get information. Pipeline names must
    ///             be unique under an AWS user account.</p>
    public let name: Swift.String?
    /// <p>The version number of the pipeline. If you do not specify a version, defaults to
    ///             the current version.</p>
    public let version: Swift.Int?

    public init (
        name: Swift.String? = nil,
        version: Swift.Int? = nil
    )
    {
        self.name = name
        self.version = version
    }
}

struct GetPipelineInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let version: Swift.Int?
}

extension GetPipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case version
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version)
        version = versionDecoded
    }
}

extension GetPipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineVersionNotFoundException" : self = .pipelineVersionNotFoundException(try PipelineVersionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPipelineOutputError: Swift.Error, Swift.Equatable {
    case pipelineNotFoundException(PipelineNotFoundException)
    case pipelineVersionNotFoundException(PipelineVersionNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPipelineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPipelineOutputResponse(metadata: \(Swift.String(describing: metadata)), pipeline: \(Swift.String(describing: pipeline)))"}
}

extension GetPipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.metadata = output.metadata
            self.pipeline = output.pipeline
        } else {
            self.metadata = nil
            self.pipeline = nil
        }
    }
}

/// <p>Represents the output of a <code>GetPipeline</code> action.</p>
public struct GetPipelineOutputResponse: Swift.Equatable {
    /// <p>Represents the pipeline metadata information returned as part of the output of a
    ///                 <code>GetPipeline</code> action.</p>
    public let metadata: CodePipelineClientTypes.PipelineMetadata?
    /// <p>Represents the structure of actions and stages to be performed in the pipeline.
    ///         </p>
    public let pipeline: CodePipelineClientTypes.PipelineDeclaration?

    public init (
        metadata: CodePipelineClientTypes.PipelineMetadata? = nil,
        pipeline: CodePipelineClientTypes.PipelineDeclaration? = nil
    )
    {
        self.metadata = metadata
        self.pipeline = pipeline
    }
}

struct GetPipelineOutputResponseBody: Swift.Equatable {
    public let pipeline: CodePipelineClientTypes.PipelineDeclaration?
    public let metadata: CodePipelineClientTypes.PipelineMetadata?
}

extension GetPipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata
        case pipeline
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.PipelineDeclaration.self, forKey: .pipeline)
        pipeline = pipelineDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.PipelineMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

public struct GetPipelineStateInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPipelineStateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPipelineStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPipelineStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPipelineStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPipelineStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPipelineStateOutputError>
}

extension GetPipelineStateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPipelineStateInput(name: \(Swift.String(describing: name)))"}
}

extension GetPipelineStateInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct GetPipelineStateInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPipelineStateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPipelineStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPipelineStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPipelineStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPipelineStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPipelineStateOutputError>
}

public struct GetPipelineStateInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetPipelineStateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetPipelineStateInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetPipelineStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetPipelineStateInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetPipelineStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetPipelineStateOutputError>
}

/// <p>Represents the input of a <code>GetPipelineState</code> action.</p>
public struct GetPipelineStateInput: Swift.Equatable {
    /// <p>The name of the pipeline about which you want to get information.</p>
    public let name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetPipelineStateInputBody: Swift.Equatable {
    public let name: Swift.String?
}

extension GetPipelineStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GetPipelineStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPipelineStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPipelineStateOutputError: Swift.Error, Swift.Equatable {
    case pipelineNotFoundException(PipelineNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPipelineStateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPipelineStateOutputResponse(created: \(Swift.String(describing: created)), pipelineName: \(Swift.String(describing: pipelineName)), pipelineVersion: \(Swift.String(describing: pipelineVersion)), stageStates: \(Swift.String(describing: stageStates)), updated: \(Swift.String(describing: updated)))"}
}

extension GetPipelineStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetPipelineStateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.created = output.created
            self.pipelineName = output.pipelineName
            self.pipelineVersion = output.pipelineVersion
            self.stageStates = output.stageStates
            self.updated = output.updated
        } else {
            self.created = nil
            self.pipelineName = nil
            self.pipelineVersion = nil
            self.stageStates = nil
            self.updated = nil
        }
    }
}

/// <p>Represents the output of a <code>GetPipelineState</code> action.</p>
public struct GetPipelineStateOutputResponse: Swift.Equatable {
    /// <p>The date and time the pipeline was created, in timestamp format.</p>
    public let created: ClientRuntime.Date?
    /// <p>The name of the pipeline for which you want to get the state.</p>
    public let pipelineName: Swift.String?
    /// <p>The version number of the pipeline.</p>
    ///         <note>
    ///             <p>A newly created pipeline is always assigned a version number of
    ///                 <code>1</code>.</p>
    ///         </note>
    public let pipelineVersion: Swift.Int?
    /// <p>A list of the pipeline stage output information, including stage name, state, most
    ///             recent run details, whether the stage is disabled, and other data.</p>
    public let stageStates: [CodePipelineClientTypes.StageState]?
    /// <p>The date and time the pipeline was last updated, in timestamp format.</p>
    public let updated: ClientRuntime.Date?

    public init (
        created: ClientRuntime.Date? = nil,
        pipelineName: Swift.String? = nil,
        pipelineVersion: Swift.Int? = nil,
        stageStates: [CodePipelineClientTypes.StageState]? = nil,
        updated: ClientRuntime.Date? = nil
    )
    {
        self.created = created
        self.pipelineName = pipelineName
        self.pipelineVersion = pipelineVersion
        self.stageStates = stageStates
        self.updated = updated
    }
}

struct GetPipelineStateOutputResponseBody: Swift.Equatable {
    public let pipelineName: Swift.String?
    public let pipelineVersion: Swift.Int?
    public let stageStates: [CodePipelineClientTypes.StageState]?
    public let created: ClientRuntime.Date?
    public let updated: ClientRuntime.Date?
}

extension GetPipelineStateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created
        case pipelineName
        case pipelineVersion
        case stageStates
        case updated
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let pipelineVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pipelineVersion)
        pipelineVersion = pipelineVersionDecoded
        let stageStatesContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.StageState?].self, forKey: .stageStates)
        var stageStatesDecoded0:[CodePipelineClientTypes.StageState]? = nil
        if let stageStatesContainer = stageStatesContainer {
            stageStatesDecoded0 = [CodePipelineClientTypes.StageState]()
            for structure0 in stageStatesContainer {
                if let structure0 = structure0 {
                    stageStatesDecoded0?.append(structure0)
                }
            }
        }
        stageStates = stageStatesDecoded0
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let updatedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updated)
        updated = updatedDecoded
    }
}

public struct GetThirdPartyJobDetailsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetThirdPartyJobDetailsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetThirdPartyJobDetailsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetThirdPartyJobDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetThirdPartyJobDetailsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetThirdPartyJobDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetThirdPartyJobDetailsOutputError>
}

extension GetThirdPartyJobDetailsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetThirdPartyJobDetailsInput(clientToken: \(Swift.String(describing: clientToken)), jobId: \(Swift.String(describing: jobId)))"}
}

extension GetThirdPartyJobDetailsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case jobId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct GetThirdPartyJobDetailsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetThirdPartyJobDetailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetThirdPartyJobDetailsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetThirdPartyJobDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetThirdPartyJobDetailsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetThirdPartyJobDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetThirdPartyJobDetailsOutputError>
}

public struct GetThirdPartyJobDetailsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetThirdPartyJobDetailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetThirdPartyJobDetailsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetThirdPartyJobDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetThirdPartyJobDetailsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetThirdPartyJobDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetThirdPartyJobDetailsOutputError>
}

/// <p>Represents the input of a <code>GetThirdPartyJobDetails</code> action.</p>
public struct GetThirdPartyJobDetailsInput: Swift.Equatable {
    /// <p>The clientToken portion of the clientId and clientToken pair used to verify that
    ///             the calling entity is allowed access to the job and its details.</p>
    public let clientToken: Swift.String?
    /// <p>The unique system-generated ID used for identifying the job.</p>
    public let jobId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.jobId = jobId
    }
}

struct GetThirdPartyJobDetailsInputBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let clientToken: Swift.String?
}

extension GetThirdPartyJobDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case jobId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension GetThirdPartyJobDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetThirdPartyJobDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobException" : self = .invalidJobException(try InvalidJobException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetThirdPartyJobDetailsOutputError: Swift.Error, Swift.Equatable {
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidJobException(InvalidJobException)
    case jobNotFoundException(JobNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetThirdPartyJobDetailsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetThirdPartyJobDetailsOutputResponse(jobDetails: \(Swift.String(describing: jobDetails)))"}
}

extension GetThirdPartyJobDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetThirdPartyJobDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobDetails = output.jobDetails
        } else {
            self.jobDetails = nil
        }
    }
}

/// <p>Represents the output of a <code>GetThirdPartyJobDetails</code> action.</p>
public struct GetThirdPartyJobDetailsOutputResponse: Swift.Equatable {
    /// <p>The details of the job, including any protected values defined for the
    ///             job.</p>
    public let jobDetails: CodePipelineClientTypes.ThirdPartyJobDetails?

    public init (
        jobDetails: CodePipelineClientTypes.ThirdPartyJobDetails? = nil
    )
    {
        self.jobDetails = jobDetails
    }
}

struct GetThirdPartyJobDetailsOutputResponseBody: Swift.Equatable {
    public let jobDetails: CodePipelineClientTypes.ThirdPartyJobDetails?
}

extension GetThirdPartyJobDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobDetails
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDetailsDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ThirdPartyJobDetails.self, forKey: .jobDetails)
        jobDetails = jobDetailsDecoded
    }
}

extension CodePipelineClientTypes.InputArtifact: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CodePipelineClientTypes.InputArtifact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InputArtifact(name: \(Swift.String(describing: name)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about an artifact to be worked on, such as a test or build
    ///             artifact.</p>
    public struct InputArtifact: Swift.Equatable {
        /// <p>The name of the artifact to be worked on (for example, "My App").</p>
        ///         <p>The input artifact of an action must exactly match the output artifact declared in
        ///             a preceding action, but the input artifact does not have to be the next action in strict
        ///             sequence from the action that provided the output artifact. Actions in parallel can
        ///             declare different output artifacts, which are in turn consumed by different following
        ///             actions.</p>
        public let name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension InvalidActionDeclarationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidActionDeclarationException(message: \(Swift.String(describing: message)))"}
}

extension InvalidActionDeclarationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidActionDeclarationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The action declaration was specified in an invalid format.</p>
public struct InvalidActionDeclarationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidActionDeclarationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidActionDeclarationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidApprovalTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidApprovalTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidApprovalTokenException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidApprovalTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The approval request already received a response or has expired.</p>
public struct InvalidApprovalTokenException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidApprovalTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidApprovalTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidArnException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidArnException(message: \(Swift.String(describing: message)))"}
}

extension InvalidArnException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidArnExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource ARN is invalid.</p>
public struct InvalidArnException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArnExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidArnExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidBlockerDeclarationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidBlockerDeclarationException(message: \(Swift.String(describing: message)))"}
}

extension InvalidBlockerDeclarationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidBlockerDeclarationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Reserved for future use.</p>
public struct InvalidBlockerDeclarationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidBlockerDeclarationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidBlockerDeclarationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidClientTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidClientTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidClientTokenException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidClientTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The client token was specified in an invalid format</p>
public struct InvalidClientTokenException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidClientTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidClientTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidJobException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidJobException(message: \(Swift.String(describing: message)))"}
}

extension InvalidJobException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidJobExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The job was specified in an invalid format or cannot be found.</p>
public struct InvalidJobException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidJobExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidJobExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidJobStateException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidJobStateException(message: \(Swift.String(describing: message)))"}
}

extension InvalidJobStateException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidJobStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The job state was specified in an invalid format.</p>
public struct InvalidJobStateException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidJobStateExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidJobStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidNextTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The next token was specified in an invalid format. Make sure that the next token
///             you provide is the token returned by a previous call.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNonceException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidNonceException(message: \(Swift.String(describing: message)))"}
}

extension InvalidNonceException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNonceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The nonce was specified in an invalid format.</p>
public struct InvalidNonceException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNonceExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidNonceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStageDeclarationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidStageDeclarationException(message: \(Swift.String(describing: message)))"}
}

extension InvalidStageDeclarationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidStageDeclarationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The stage declaration was specified in an invalid format.</p>
public struct InvalidStageDeclarationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStageDeclarationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidStageDeclarationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStructureException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidStructureException(message: \(Swift.String(describing: message)))"}
}

extension InvalidStructureException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidStructureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The structure was specified in an invalid format.</p>
public struct InvalidStructureException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStructureExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidStructureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidTagsException(message: \(Swift.String(describing: message)))"}
}

extension InvalidTagsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource tags are invalid.</p>
public struct InvalidTagsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidTagsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidWebhookAuthenticationParametersException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidWebhookAuthenticationParametersException(message: \(Swift.String(describing: message)))"}
}

extension InvalidWebhookAuthenticationParametersException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidWebhookAuthenticationParametersExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified authentication type is in an invalid format.</p>
public struct InvalidWebhookAuthenticationParametersException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidWebhookAuthenticationParametersExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidWebhookAuthenticationParametersExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidWebhookFilterPatternException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidWebhookFilterPatternException(message: \(Swift.String(describing: message)))"}
}

extension InvalidWebhookFilterPatternException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidWebhookFilterPatternExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified event filter rule is in an invalid format.</p>
public struct InvalidWebhookFilterPatternException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidWebhookFilterPatternExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidWebhookFilterPatternExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodePipelineClientTypes.Job: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case data
        case id
        case nonce
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let nonce = nonce {
            try encodeContainer.encode(nonce, forKey: .nonce)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let dataDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.JobData.self, forKey: .data)
        data = dataDecoded
        let nonceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nonce)
        nonce = nonceDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension CodePipelineClientTypes.Job: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Job(accountId: \(Swift.String(describing: accountId)), data: \(Swift.String(describing: data)), id: \(Swift.String(describing: id)), nonce: \(Swift.String(describing: nonce)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about a job.</p>
    public struct Job: Swift.Equatable {
        /// <p>The ID of the AWS account to use when performing the job.</p>
        public let accountId: Swift.String?
        /// <p>Other data about a job.</p>
        public let data: CodePipelineClientTypes.JobData?
        /// <p>The unique system-generated ID of the job.</p>
        public let id: Swift.String?
        /// <p>A system-generated random number that AWS CodePipeline uses to ensure that the job
        ///             is being worked on by only one job worker. Use this number in an <a>AcknowledgeJob</a> request.</p>
        public let nonce: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            data: CodePipelineClientTypes.JobData? = nil,
            id: Swift.String? = nil,
            nonce: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.data = data
            self.id = id
            self.nonce = nonce
        }
    }

}

extension CodePipelineClientTypes.JobData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionConfiguration
        case actionTypeId
        case artifactCredentials
        case continuationToken
        case encryptionKey
        case inputArtifacts
        case outputArtifacts
        case pipelineContext
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionConfiguration = actionConfiguration {
            try encodeContainer.encode(actionConfiguration, forKey: .actionConfiguration)
        }
        if let actionTypeId = actionTypeId {
            try encodeContainer.encode(actionTypeId, forKey: .actionTypeId)
        }
        if let artifactCredentials = artifactCredentials {
            try encodeContainer.encode(artifactCredentials, forKey: .artifactCredentials)
        }
        if let continuationToken = continuationToken {
            try encodeContainer.encode(continuationToken, forKey: .continuationToken)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let inputArtifacts = inputArtifacts {
            var inputArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputArtifacts)
            for artifactlist0 in inputArtifacts {
                try inputArtifactsContainer.encode(artifactlist0)
            }
        }
        if let outputArtifacts = outputArtifacts {
            var outputArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputArtifacts)
            for artifactlist0 in outputArtifacts {
                try outputArtifactsContainer.encode(artifactlist0)
            }
        }
        if let pipelineContext = pipelineContext {
            try encodeContainer.encode(pipelineContext, forKey: .pipelineContext)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeIdDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionTypeId.self, forKey: .actionTypeId)
        actionTypeId = actionTypeIdDecoded
        let actionConfigurationDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionConfiguration.self, forKey: .actionConfiguration)
        actionConfiguration = actionConfigurationDecoded
        let pipelineContextDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.PipelineContext.self, forKey: .pipelineContext)
        pipelineContext = pipelineContextDecoded
        let inputArtifactsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.Artifact?].self, forKey: .inputArtifacts)
        var inputArtifactsDecoded0:[CodePipelineClientTypes.Artifact]? = nil
        if let inputArtifactsContainer = inputArtifactsContainer {
            inputArtifactsDecoded0 = [CodePipelineClientTypes.Artifact]()
            for structure0 in inputArtifactsContainer {
                if let structure0 = structure0 {
                    inputArtifactsDecoded0?.append(structure0)
                }
            }
        }
        inputArtifacts = inputArtifactsDecoded0
        let outputArtifactsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.Artifact?].self, forKey: .outputArtifacts)
        var outputArtifactsDecoded0:[CodePipelineClientTypes.Artifact]? = nil
        if let outputArtifactsContainer = outputArtifactsContainer {
            outputArtifactsDecoded0 = [CodePipelineClientTypes.Artifact]()
            for structure0 in outputArtifactsContainer {
                if let structure0 = structure0 {
                    outputArtifactsDecoded0?.append(structure0)
                }
            }
        }
        outputArtifacts = outputArtifactsDecoded0
        let artifactCredentialsDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.AWSSessionCredentials.self, forKey: .artifactCredentials)
        artifactCredentials = artifactCredentialsDecoded
        let continuationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .continuationToken)
        continuationToken = continuationTokenDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.EncryptionKey.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
    }
}

extension CodePipelineClientTypes.JobData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobData(actionConfiguration: \(Swift.String(describing: actionConfiguration)), actionTypeId: \(Swift.String(describing: actionTypeId)), artifactCredentials: \(Swift.String(describing: artifactCredentials)), continuationToken: \(Swift.String(describing: continuationToken)), encryptionKey: \(Swift.String(describing: encryptionKey)), inputArtifacts: \(Swift.String(describing: inputArtifacts)), outputArtifacts: \(Swift.String(describing: outputArtifacts)), pipelineContext: \(Swift.String(describing: pipelineContext)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents other information about a job required for a job worker to complete the
    ///             job.</p>
    public struct JobData: Swift.Equatable {
        /// <p>Represents information about an action configuration.</p>
        public let actionConfiguration: CodePipelineClientTypes.ActionConfiguration?
        /// <p>Represents information about an action type.</p>
        public let actionTypeId: CodePipelineClientTypes.ActionTypeId?
        /// <p>Represents an AWS session credentials object. These credentials are temporary
        ///             credentials that are issued by AWS Secure Token Service (STS). They can be used to
        ///             access input and output artifacts in the S3 bucket used to store artifacts for the
        ///             pipeline in AWS CodePipeline.</p>
        public let artifactCredentials: CodePipelineClientTypes.AWSSessionCredentials?
        /// <p>A system-generated token, such as a AWS CodeDeploy deployment ID, required by a job
        ///             to continue the job asynchronously.</p>
        public let continuationToken: Swift.String?
        /// <p>Represents information about the key used to encrypt data in the artifact store,
        ///             such as an AWS Key Management Service (AWS KMS) key. </p>
        public let encryptionKey: CodePipelineClientTypes.EncryptionKey?
        /// <p>The artifact supplied to the job.</p>
        public let inputArtifacts: [CodePipelineClientTypes.Artifact]?
        /// <p>The output of the job.</p>
        public let outputArtifacts: [CodePipelineClientTypes.Artifact]?
        /// <p>Represents information about a pipeline to a job worker.</p>
        ///         <note>
        ///             <p>Includes <code>pipelineArn</code> and <code>pipelineExecutionId</code> for
        ///                 custom jobs.</p>
        ///         </note>
        public let pipelineContext: CodePipelineClientTypes.PipelineContext?

        public init (
            actionConfiguration: CodePipelineClientTypes.ActionConfiguration? = nil,
            actionTypeId: CodePipelineClientTypes.ActionTypeId? = nil,
            artifactCredentials: CodePipelineClientTypes.AWSSessionCredentials? = nil,
            continuationToken: Swift.String? = nil,
            encryptionKey: CodePipelineClientTypes.EncryptionKey? = nil,
            inputArtifacts: [CodePipelineClientTypes.Artifact]? = nil,
            outputArtifacts: [CodePipelineClientTypes.Artifact]? = nil,
            pipelineContext: CodePipelineClientTypes.PipelineContext? = nil
        )
        {
            self.actionConfiguration = actionConfiguration
            self.actionTypeId = actionTypeId
            self.artifactCredentials = artifactCredentials
            self.continuationToken = continuationToken
            self.encryptionKey = encryptionKey
            self.inputArtifacts = inputArtifacts
            self.outputArtifacts = outputArtifacts
            self.pipelineContext = pipelineContext
        }
    }

}

extension CodePipelineClientTypes.JobDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case data
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let dataDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.JobData.self, forKey: .data)
        data = dataDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension CodePipelineClientTypes.JobDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobDetails(accountId: \(Swift.String(describing: accountId)), data: \(Swift.String(describing: data)), id: \(Swift.String(describing: id)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about the details of a job.</p>
    public struct JobDetails: Swift.Equatable {
        /// <p>The AWS account ID associated with the job.</p>
        public let accountId: Swift.String?
        /// <p>Represents other information about a job required for a job worker to complete the
        ///             job. </p>
        public let data: CodePipelineClientTypes.JobData?
        /// <p>The unique system-generated ID of the job.</p>
        public let id: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            data: CodePipelineClientTypes.JobData? = nil,
            id: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.data = data
            self.id = id
        }
    }

}

extension JobNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension JobNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: JobNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The job was specified in an invalid format or cannot be found.</p>
public struct JobNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct JobNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension JobNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodePipelineClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case dispatched
        case failed
        case inprogress
        case queued
        case succeeded
        case timedout
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .created,
                .dispatched,
                .failed,
                .inprogress,
                .queued,
                .succeeded,
                .timedout,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "Created"
            case .dispatched: return "Dispatched"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .queued: return "Queued"
            case .succeeded: return "Succeeded"
            case .timedout: return "TimedOut"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension CodePipelineClientTypes.JobWorkerExecutorConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pollingAccounts
        case pollingServicePrincipals
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pollingAccounts = pollingAccounts {
            var pollingAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pollingAccounts)
            for pollingaccountlist0 in pollingAccounts {
                try pollingAccountsContainer.encode(pollingaccountlist0)
            }
        }
        if let pollingServicePrincipals = pollingServicePrincipals {
            var pollingServicePrincipalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pollingServicePrincipals)
            for pollingserviceprincipallist0 in pollingServicePrincipals {
                try pollingServicePrincipalsContainer.encode(pollingserviceprincipallist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pollingAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pollingAccounts)
        var pollingAccountsDecoded0:[Swift.String]? = nil
        if let pollingAccountsContainer = pollingAccountsContainer {
            pollingAccountsDecoded0 = [Swift.String]()
            for string0 in pollingAccountsContainer {
                if let string0 = string0 {
                    pollingAccountsDecoded0?.append(string0)
                }
            }
        }
        pollingAccounts = pollingAccountsDecoded0
        let pollingServicePrincipalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .pollingServicePrincipals)
        var pollingServicePrincipalsDecoded0:[Swift.String]? = nil
        if let pollingServicePrincipalsContainer = pollingServicePrincipalsContainer {
            pollingServicePrincipalsDecoded0 = [Swift.String]()
            for string0 in pollingServicePrincipalsContainer {
                if let string0 = string0 {
                    pollingServicePrincipalsDecoded0?.append(string0)
                }
            }
        }
        pollingServicePrincipals = pollingServicePrincipalsDecoded0
    }
}

extension CodePipelineClientTypes.JobWorkerExecutorConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "JobWorkerExecutorConfiguration(pollingAccounts: \(Swift.String(describing: pollingAccounts)), pollingServicePrincipals: \(Swift.String(describing: pollingServicePrincipals)))"}
}

extension CodePipelineClientTypes {
    /// <p>Details about the polling configuration for the <code>JobWorker</code> action engine,
    ///             or executor.</p>
    public struct JobWorkerExecutorConfiguration: Swift.Equatable {
        /// <p>The accounts in which the job worker is configured and might poll for jobs as part of
        ///             the action execution.</p>
        public let pollingAccounts: [Swift.String]?
        /// <p>The service Principals in which the job worker is configured and might poll for jobs
        ///             as part of the action execution.</p>
        public let pollingServicePrincipals: [Swift.String]?

        public init (
            pollingAccounts: [Swift.String]? = nil,
            pollingServicePrincipals: [Swift.String]? = nil
        )
        {
            self.pollingAccounts = pollingAccounts
            self.pollingServicePrincipals = pollingServicePrincipals
        }
    }

}

extension CodePipelineClientTypes.LambdaExecutorConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lambdaFunctionArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaFunctionArn = lambdaFunctionArn {
            try encodeContainer.encode(lambdaFunctionArn, forKey: .lambdaFunctionArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaFunctionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lambdaFunctionArn)
        lambdaFunctionArn = lambdaFunctionArnDecoded
    }
}

extension CodePipelineClientTypes.LambdaExecutorConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LambdaExecutorConfiguration(lambdaFunctionArn: \(Swift.String(describing: lambdaFunctionArn)))"}
}

extension CodePipelineClientTypes {
    /// <p>Details about the configuration for the <code>Lambda</code> action engine, or
    ///             executor.</p>
    public struct LambdaExecutorConfiguration: Swift.Equatable {
        /// <p>The ARN of the Lambda function used by the action engine.</p>
        public let lambdaFunctionArn: Swift.String?

        public init (
            lambdaFunctionArn: Swift.String? = nil
        )
        {
            self.lambdaFunctionArn = lambdaFunctionArn
        }
    }

}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of pipelines associated with the AWS account has exceeded the limit
///             allowed for the account.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListActionExecutionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListActionExecutionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListActionExecutionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListActionExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListActionExecutionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListActionExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListActionExecutionsOutputError>
}

extension ListActionExecutionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListActionExecutionsInput(filter: \(Swift.String(describing: filter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), pipelineName: \(Swift.String(describing: pipelineName)))"}
}

extension ListActionExecutionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
        case pipelineName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
    }
}

public struct ListActionExecutionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListActionExecutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListActionExecutionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListActionExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListActionExecutionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListActionExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListActionExecutionsOutputError>
}

public struct ListActionExecutionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListActionExecutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListActionExecutionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListActionExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListActionExecutionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListActionExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListActionExecutionsOutputError>
}

public struct ListActionExecutionsInput: Swift.Equatable {
    /// <p>Input information used to filter action execution history.</p>
    public let filter: CodePipelineClientTypes.ActionExecutionFilter?
    /// <p>The maximum number of results to return in a single call. To retrieve the remaining
    ///             results, make another call with the returned nextToken value. Action execution history
    ///             is retained for up to 12 months, based on action execution start times. Default value is
    ///             100. </p>
    ///         <note>
    ///             <p>Detailed execution history is available for executions run on or after February
    ///                 21, 2019.</p>
    ///         </note>
    public let maxResults: Swift.Int?
    /// <p>The token that was returned from the previous <code>ListActionExecutions</code> call,
    ///             which can be used to return the next set of action executions in the list.</p>
    public let nextToken: Swift.String?
    /// <p> The name of the pipeline for which you want to list action execution history.</p>
    public let pipelineName: Swift.String?

    public init (
        filter: CodePipelineClientTypes.ActionExecutionFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pipelineName: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pipelineName = pipelineName
    }
}

struct ListActionExecutionsInputBody: Swift.Equatable {
    public let pipelineName: Swift.String?
    public let filter: CodePipelineClientTypes.ActionExecutionFilter?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListActionExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
        case pipelineName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let filterDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionExecutionFilter.self, forKey: .filter)
        filter = filterDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListActionExecutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListActionExecutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineExecutionNotFoundException" : self = .pipelineExecutionNotFoundException(try PipelineExecutionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListActionExecutionsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case pipelineExecutionNotFoundException(PipelineExecutionNotFoundException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListActionExecutionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListActionExecutionsOutputResponse(actionExecutionDetails: \(Swift.String(describing: actionExecutionDetails)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListActionExecutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListActionExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actionExecutionDetails = output.actionExecutionDetails
            self.nextToken = output.nextToken
        } else {
            self.actionExecutionDetails = nil
            self.nextToken = nil
        }
    }
}

public struct ListActionExecutionsOutputResponse: Swift.Equatable {
    /// <p>The details for a list of recent executions, such as action execution ID.</p>
    public let actionExecutionDetails: [CodePipelineClientTypes.ActionExecutionDetail]?
    /// <p>If the amount of returned information is significantly large, an identifier is also
    ///             returned and can be used in a subsequent <code>ListActionExecutions</code> call to
    ///             return the next set of action executions in the list.</p>
    public let nextToken: Swift.String?

    public init (
        actionExecutionDetails: [CodePipelineClientTypes.ActionExecutionDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionExecutionDetails = actionExecutionDetails
        self.nextToken = nextToken
    }
}

struct ListActionExecutionsOutputResponseBody: Swift.Equatable {
    public let actionExecutionDetails: [CodePipelineClientTypes.ActionExecutionDetail]?
    public let nextToken: Swift.String?
}

extension ListActionExecutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionExecutionDetails
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionExecutionDetailsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.ActionExecutionDetail?].self, forKey: .actionExecutionDetails)
        var actionExecutionDetailsDecoded0:[CodePipelineClientTypes.ActionExecutionDetail]? = nil
        if let actionExecutionDetailsContainer = actionExecutionDetailsContainer {
            actionExecutionDetailsDecoded0 = [CodePipelineClientTypes.ActionExecutionDetail]()
            for structure0 in actionExecutionDetailsContainer {
                if let structure0 = structure0 {
                    actionExecutionDetailsDecoded0?.append(structure0)
                }
            }
        }
        actionExecutionDetails = actionExecutionDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListActionTypesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListActionTypesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListActionTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListActionTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListActionTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListActionTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListActionTypesOutputError>
}

extension ListActionTypesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListActionTypesInput(actionOwnerFilter: \(Swift.String(describing: actionOwnerFilter)), nextToken: \(Swift.String(describing: nextToken)), regionFilter: \(Swift.String(describing: regionFilter)))"}
}

extension ListActionTypesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionOwnerFilter
        case nextToken
        case regionFilter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionOwnerFilter = actionOwnerFilter {
            try encodeContainer.encode(actionOwnerFilter.rawValue, forKey: .actionOwnerFilter)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let regionFilter = regionFilter {
            try encodeContainer.encode(regionFilter, forKey: .regionFilter)
        }
    }
}

public struct ListActionTypesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListActionTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListActionTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListActionTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListActionTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListActionTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListActionTypesOutputError>
}

public struct ListActionTypesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListActionTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListActionTypesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListActionTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListActionTypesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListActionTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListActionTypesOutputError>
}

/// <p>Represents the input of a <code>ListActionTypes</code> action.</p>
public struct ListActionTypesInput: Swift.Equatable {
    /// <p>Filters the list of action types to those created by a specified entity.</p>
    public let actionOwnerFilter: CodePipelineClientTypes.ActionOwner?
    /// <p>An identifier that was returned from the previous list action types call, which can
    ///             be used to return the next set of action types in the list.</p>
    public let nextToken: Swift.String?
    /// <p>The Region to filter on for the list of action types.</p>
    public let regionFilter: Swift.String?

    public init (
        actionOwnerFilter: CodePipelineClientTypes.ActionOwner? = nil,
        nextToken: Swift.String? = nil,
        regionFilter: Swift.String? = nil
    )
    {
        self.actionOwnerFilter = actionOwnerFilter
        self.nextToken = nextToken
        self.regionFilter = regionFilter
    }
}

struct ListActionTypesInputBody: Swift.Equatable {
    public let actionOwnerFilter: CodePipelineClientTypes.ActionOwner?
    public let nextToken: Swift.String?
    public let regionFilter: Swift.String?
}

extension ListActionTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionOwnerFilter
        case nextToken
        case regionFilter
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionOwnerFilterDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionOwner.self, forKey: .actionOwnerFilter)
        actionOwnerFilter = actionOwnerFilterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let regionFilterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionFilter)
        regionFilter = regionFilterDecoded
    }
}

extension ListActionTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListActionTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListActionTypesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListActionTypesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListActionTypesOutputResponse(actionTypes: \(Swift.String(describing: actionTypes)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListActionTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListActionTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actionTypes = output.actionTypes
            self.nextToken = output.nextToken
        } else {
            self.actionTypes = nil
            self.nextToken = nil
        }
    }
}

/// <p>Represents the output of a <code>ListActionTypes</code> action.</p>
public struct ListActionTypesOutputResponse: Swift.Equatable {
    /// <p>Provides details of the action types.</p>
    public let actionTypes: [CodePipelineClientTypes.ActionType]?
    /// <p>If the amount of returned information is significantly large, an identifier is also
    ///             returned. It can be used in a subsequent list action types call to return the next set
    ///             of action types in the list.</p>
    public let nextToken: Swift.String?

    public init (
        actionTypes: [CodePipelineClientTypes.ActionType]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionTypes = actionTypes
        self.nextToken = nextToken
    }
}

struct ListActionTypesOutputResponseBody: Swift.Equatable {
    public let actionTypes: [CodePipelineClientTypes.ActionType]?
    public let nextToken: Swift.String?
}

extension ListActionTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionTypes
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypesContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.ActionType?].self, forKey: .actionTypes)
        var actionTypesDecoded0:[CodePipelineClientTypes.ActionType]? = nil
        if let actionTypesContainer = actionTypesContainer {
            actionTypesDecoded0 = [CodePipelineClientTypes.ActionType]()
            for structure0 in actionTypesContainer {
                if let structure0 = structure0 {
                    actionTypesDecoded0?.append(structure0)
                }
            }
        }
        actionTypes = actionTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPipelineExecutionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPipelineExecutionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPipelineExecutionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPipelineExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPipelineExecutionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPipelineExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPipelineExecutionsOutputError>
}

extension ListPipelineExecutionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPipelineExecutionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), pipelineName: \(Swift.String(describing: pipelineName)))"}
}

extension ListPipelineExecutionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case pipelineName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
    }
}

public struct ListPipelineExecutionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPipelineExecutionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPipelineExecutionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPipelineExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPipelineExecutionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPipelineExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPipelineExecutionsOutputError>
}

public struct ListPipelineExecutionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPipelineExecutionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPipelineExecutionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPipelineExecutionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPipelineExecutionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPipelineExecutionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPipelineExecutionsOutputError>
}

/// <p>Represents the input of a <code>ListPipelineExecutions</code> action.</p>
public struct ListPipelineExecutionsInput: Swift.Equatable {
    /// <p>The maximum number of results to return in a single call. To retrieve the remaining
    ///             results, make another call with the returned nextToken value. Pipeline history is
    ///             limited to the most recent 12 months, based on pipeline execution start times. Default
    ///             value is 100.</p>
    public let maxResults: Swift.Int?
    /// <p>The token that was returned from the previous <code>ListPipelineExecutions</code>
    ///             call, which can be used to return the next set of pipeline executions in the
    ///             list.</p>
    public let nextToken: Swift.String?
    /// <p>The name of the pipeline for which you want to get execution summary
    ///             information.</p>
    public let pipelineName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pipelineName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pipelineName = pipelineName
    }
}

struct ListPipelineExecutionsInputBody: Swift.Equatable {
    public let pipelineName: Swift.String?
    public let maxResults: Swift.Int?
    public let nextToken: Swift.String?
}

extension ListPipelineExecutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case pipelineName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPipelineExecutionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPipelineExecutionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPipelineExecutionsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPipelineExecutionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPipelineExecutionsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), pipelineExecutionSummaries: \(Swift.String(describing: pipelineExecutionSummaries)))"}
}

extension ListPipelineExecutionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPipelineExecutionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pipelineExecutionSummaries = output.pipelineExecutionSummaries
        } else {
            self.nextToken = nil
            self.pipelineExecutionSummaries = nil
        }
    }
}

/// <p>Represents the output of a <code>ListPipelineExecutions</code> action.</p>
public struct ListPipelineExecutionsOutputResponse: Swift.Equatable {
    /// <p>A token that can be used in the next <code>ListPipelineExecutions</code> call. To
    ///             view all items in the list, continue to call this operation with each subsequent token
    ///             until no more nextToken values are returned.</p>
    public let nextToken: Swift.String?
    /// <p>A list of executions in the history of a pipeline.</p>
    public let pipelineExecutionSummaries: [CodePipelineClientTypes.PipelineExecutionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        pipelineExecutionSummaries: [CodePipelineClientTypes.PipelineExecutionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.pipelineExecutionSummaries = pipelineExecutionSummaries
    }
}

struct ListPipelineExecutionsOutputResponseBody: Swift.Equatable {
    public let pipelineExecutionSummaries: [CodePipelineClientTypes.PipelineExecutionSummary]?
    public let nextToken: Swift.String?
}

extension ListPipelineExecutionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case pipelineExecutionSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineExecutionSummariesContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.PipelineExecutionSummary?].self, forKey: .pipelineExecutionSummaries)
        var pipelineExecutionSummariesDecoded0:[CodePipelineClientTypes.PipelineExecutionSummary]? = nil
        if let pipelineExecutionSummariesContainer = pipelineExecutionSummariesContainer {
            pipelineExecutionSummariesDecoded0 = [CodePipelineClientTypes.PipelineExecutionSummary]()
            for structure0 in pipelineExecutionSummariesContainer {
                if let structure0 = structure0 {
                    pipelineExecutionSummariesDecoded0?.append(structure0)
                }
            }
        }
        pipelineExecutionSummaries = pipelineExecutionSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPipelinesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPipelinesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPipelinesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPipelinesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPipelinesOutputError>
}

extension ListPipelinesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPipelinesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPipelinesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPipelinesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPipelinesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPipelinesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPipelinesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPipelinesOutputError>
}

public struct ListPipelinesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPipelinesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPipelinesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPipelinesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPipelinesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPipelinesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPipelinesOutputError>
}

/// <p>Represents the input of a <code>ListPipelines</code> action.</p>
public struct ListPipelinesInput: Swift.Equatable {
    /// <p>The maximum number of pipelines to return in a single call. To retrieve the remaining
    ///             pipelines, make another call with the returned nextToken value. The minimum value you
    ///             can specify is 1. The maximum accepted value is 1000.</p>
    public let maxResults: Swift.Int?
    /// <p>An identifier that was returned from the previous list pipelines call. It can be
    ///             used to return the next set of pipelines in the list.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPipelinesInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListPipelinesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPipelinesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPipelinesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPipelinesOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPipelinesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPipelinesOutputResponse(nextToken: \(Swift.String(describing: nextToken)), pipelines: \(Swift.String(describing: pipelines)))"}
}

extension ListPipelinesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPipelinesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pipelines = output.pipelines
        } else {
            self.nextToken = nil
            self.pipelines = nil
        }
    }
}

/// <p>Represents the output of a <code>ListPipelines</code> action.</p>
public struct ListPipelinesOutputResponse: Swift.Equatable {
    /// <p>If the amount of returned information is significantly large, an identifier is also
    ///             returned. It can be used in a subsequent list pipelines call to return the next set of
    ///             pipelines in the list.</p>
    public let nextToken: Swift.String?
    /// <p>The list of pipelines.</p>
    public let pipelines: [CodePipelineClientTypes.PipelineSummary]?

    public init (
        nextToken: Swift.String? = nil,
        pipelines: [CodePipelineClientTypes.PipelineSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.pipelines = pipelines
    }
}

struct ListPipelinesOutputResponseBody: Swift.Equatable {
    public let pipelines: [CodePipelineClientTypes.PipelineSummary]?
    public let nextToken: Swift.String?
}

extension ListPipelinesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case pipelines
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelinesContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.PipelineSummary?].self, forKey: .pipelines)
        var pipelinesDecoded0:[CodePipelineClientTypes.PipelineSummary]? = nil
        if let pipelinesContainer = pipelinesContainer {
            pipelinesDecoded0 = [CodePipelineClientTypes.PipelineSummary]()
            for structure0 in pipelinesContainer {
                if let structure0 = structure0 {
                    pipelinesDecoded0?.append(structure0)
                }
            }
        }
        pipelines = pipelinesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>The maximum number of results to return in a single call.</p>
    public let maxResults: Swift.Int?
    /// <p>The token that was returned from the previous API call, which would be used to return
    ///             the next page of the list. The ListTagsforResource call lists all available tags in one
    ///             call and does not use pagination.</p>
    public let nextToken: Swift.String?
    /// <p>The Amazon Resource Name (ARN) of the resource to get tags for.</p>
    public let resourceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidArnException(InvalidArnException)
    case invalidNextTokenException(InvalidNextTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(nextToken: \(Swift.String(describing: nextToken)), tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>If the amount of returned information is significantly large, an identifier is also
    ///             returned and can be used in a subsequent API call to return the next page of the list.
    ///             The ListTagsforResource call lists all available tags in one call and does not use
    ///             pagination.</p>
    public let nextToken: Swift.String?
    /// <p>The tags for the resource.</p>
    public let tags: [CodePipelineClientTypes.Tag]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [CodePipelineClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [CodePipelineClientTypes.Tag]?
    public let nextToken: Swift.String?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodePipelineClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodePipelineClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CodePipelineClientTypes.ListWebhookItem: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case definition
        case errorCode
        case errorMessage
        case lastTriggered
        case tags
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let lastTriggered = lastTriggered {
            try encodeContainer.encode(lastTriggered.timeIntervalSince1970, forKey: .lastTriggered)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.WebhookDefinition.self, forKey: .definition)
        definition = definitionDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let lastTriggeredDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastTriggered)
        lastTriggered = lastTriggeredDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodePipelineClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodePipelineClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CodePipelineClientTypes.ListWebhookItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWebhookItem(arn: \(Swift.String(describing: arn)), definition: \(Swift.String(describing: definition)), errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), lastTriggered: \(Swift.String(describing: lastTriggered)), tags: \(Swift.String(describing: tags)), url: \(Swift.String(describing: url)))"}
}

extension CodePipelineClientTypes {
    /// <p>The detail returned for each webhook after listing webhooks, such as the webhook
    ///             URL, the webhook name, and the webhook ARN.</p>
    public struct ListWebhookItem: Swift.Equatable {
        /// <p>The Amazon Resource Name (ARN) of the webhook.</p>
        public let arn: Swift.String?
        /// <p>The detail returned for each webhook, such as the webhook authentication type and
        ///             filter rules.</p>
        public let definition: CodePipelineClientTypes.WebhookDefinition?
        /// <p>The number code of the error.</p>
        public let errorCode: Swift.String?
        /// <p>The text of the error message about the webhook.</p>
        public let errorMessage: Swift.String?
        /// <p>The date and time a webhook was last successfully triggered, in timestamp
        ///             format.</p>
        public let lastTriggered: ClientRuntime.Date?
        /// <p>Specifies the tags applied to the webhook.</p>
        public let tags: [CodePipelineClientTypes.Tag]?
        /// <p>A unique URL generated by CodePipeline. When a POST request is made to this URL,
        ///             the defined pipeline is started as long as the body of the post request satisfies the
        ///             defined authentication and filtering conditions. Deleting and re-creating a webhook
        ///             makes the old URL invalid and generates a new one.</p>
        public let url: Swift.String?

        public init (
            arn: Swift.String? = nil,
            definition: CodePipelineClientTypes.WebhookDefinition? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            lastTriggered: ClientRuntime.Date? = nil,
            tags: [CodePipelineClientTypes.Tag]? = nil,
            url: Swift.String? = nil
        )
        {
            self.arn = arn
            self.definition = definition
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.lastTriggered = lastTriggered
            self.tags = tags
            self.url = url
        }
    }

}

public struct ListWebhooksInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWebhooksInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWebhooksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWebhooksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWebhooksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWebhooksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWebhooksOutputError>
}

extension ListWebhooksInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWebhooksInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListWebhooksInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListWebhooksInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWebhooksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWebhooksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWebhooksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWebhooksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWebhooksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWebhooksOutputError>
}

public struct ListWebhooksInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListWebhooksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListWebhooksInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListWebhooksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListWebhooksInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListWebhooksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListWebhooksOutputError>
}

public struct ListWebhooksInput: Swift.Equatable {
    /// <p>The maximum number of results to return in a single call. To retrieve the remaining
    ///             results, make another call with the returned nextToken value.</p>
    public let maxResults: Swift.Int?
    /// <p>The token that was returned from the previous ListWebhooks call, which can be used
    ///             to return the next set of webhooks in the list.</p>
    public let nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWebhooksInputBody: Swift.Equatable {
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListWebhooksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListWebhooksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWebhooksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWebhooksOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWebhooksOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWebhooksOutputResponse(nextToken: \(Swift.String(describing: nextToken)), webhooks: \(Swift.String(describing: webhooks)))"}
}

extension ListWebhooksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListWebhooksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.webhooks = output.webhooks
        } else {
            self.nextToken = nil
            self.webhooks = nil
        }
    }
}

public struct ListWebhooksOutputResponse: Swift.Equatable {
    /// <p>If the amount of returned information is significantly large, an identifier is also
    ///             returned and can be used in a subsequent ListWebhooks call to return the next set of
    ///             webhooks in the list. </p>
    public let nextToken: Swift.String?
    /// <p>The JSON detail returned for each webhook in the list output for the ListWebhooks
    ///             call.</p>
    public let webhooks: [CodePipelineClientTypes.ListWebhookItem]?

    public init (
        nextToken: Swift.String? = nil,
        webhooks: [CodePipelineClientTypes.ListWebhookItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.webhooks = webhooks
    }
}

struct ListWebhooksOutputResponseBody: Swift.Equatable {
    public let webhooks: [CodePipelineClientTypes.ListWebhookItem]?
    public let nextToken: Swift.String?
}

extension ListWebhooksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case webhooks
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhooksContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.ListWebhookItem?].self, forKey: .webhooks)
        var webhooksDecoded0:[CodePipelineClientTypes.ListWebhookItem]? = nil
        if let webhooksContainer = webhooksContainer {
            webhooksDecoded0 = [CodePipelineClientTypes.ListWebhookItem]()
            for structure0 in webhooksContainer {
                if let structure0 = structure0 {
                    webhooksDecoded0?.append(structure0)
                }
            }
        }
        webhooks = webhooksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension NotLatestPipelineExecutionException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "NotLatestPipelineExecutionException(message: \(Swift.String(describing: message)))"}
}

extension NotLatestPipelineExecutionException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotLatestPipelineExecutionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The stage has failed in a later run of the pipeline and the pipelineExecutionId
///             associated with the request is out of date.</p>
public struct NotLatestPipelineExecutionException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotLatestPipelineExecutionExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension NotLatestPipelineExecutionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodePipelineClientTypes.OutputArtifact: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CodePipelineClientTypes.OutputArtifact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OutputArtifact(name: \(Swift.String(describing: name)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about the output of an action.</p>
    public struct OutputArtifact: Swift.Equatable {
        /// <p>The name of the output of an artifact, such as "My App".</p>
        ///         <p>The input artifact of an action must exactly match the output artifact declared in
        ///             a preceding action, but the input artifact does not have to be the next action in strict
        ///             sequence from the action that provided the output artifact. Actions in parallel can
        ///             declare different output artifacts, which are in turn consumed by different following
        ///             actions.</p>
        ///         <p>Output artifact names must be unique within a pipeline.</p>
        public let name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension OutputVariablesSizeExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OutputVariablesSizeExceededException(message: \(Swift.String(describing: message)))"}
}

extension OutputVariablesSizeExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OutputVariablesSizeExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Exceeded the total size limit for all variables in the pipeline.</p>
public struct OutputVariablesSizeExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OutputVariablesSizeExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OutputVariablesSizeExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodePipelineClientTypes.PipelineContext: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case pipelineArn
        case pipelineExecutionId
        case pipelineName
        case stage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let pipelineArn = pipelineArn {
            try encodeContainer.encode(pipelineArn, forKey: .pipelineArn)
        }
        if let pipelineExecutionId = pipelineExecutionId {
            try encodeContainer.encode(pipelineExecutionId, forKey: .pipelineExecutionId)
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let stage = stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let stageDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.StageContext.self, forKey: .stage)
        stage = stageDecoded
        let actionDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionContext.self, forKey: .action)
        action = actionDecoded
        let pipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineArn)
        pipelineArn = pipelineArnDecoded
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
    }
}

extension CodePipelineClientTypes.PipelineContext: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PipelineContext(action: \(Swift.String(describing: action)), pipelineArn: \(Swift.String(describing: pipelineArn)), pipelineExecutionId: \(Swift.String(describing: pipelineExecutionId)), pipelineName: \(Swift.String(describing: pipelineName)), stage: \(Swift.String(describing: stage)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about a pipeline to a job worker.</p>
    ///         <note>
    ///             <p>PipelineContext contains <code>pipelineArn</code> and
    ///                     <code>pipelineExecutionId</code> for custom action jobs. The
    ///                     <code>pipelineArn</code> and <code>pipelineExecutionId</code> fields are not
    ///                 populated for ThirdParty action jobs.</p>
    ///         </note>
    public struct PipelineContext: Swift.Equatable {
        /// <p>The context of an action to a job worker in the stage of a pipeline.</p>
        public let action: CodePipelineClientTypes.ActionContext?
        /// <p>The Amazon Resource Name (ARN) of the pipeline.</p>
        public let pipelineArn: Swift.String?
        /// <p>The execution ID of the pipeline.</p>
        public let pipelineExecutionId: Swift.String?
        /// <p>The name of the pipeline. This is a user-specified value. Pipeline names must be
        ///             unique across all pipeline names under an Amazon Web Services account.</p>
        public let pipelineName: Swift.String?
        /// <p>The stage of the pipeline.</p>
        public let stage: CodePipelineClientTypes.StageContext?

        public init (
            action: CodePipelineClientTypes.ActionContext? = nil,
            pipelineArn: Swift.String? = nil,
            pipelineExecutionId: Swift.String? = nil,
            pipelineName: Swift.String? = nil,
            stage: CodePipelineClientTypes.StageContext? = nil
        )
        {
            self.action = action
            self.pipelineArn = pipelineArn
            self.pipelineExecutionId = pipelineExecutionId
            self.pipelineName = pipelineName
            self.stage = stage
        }
    }

}

extension CodePipelineClientTypes.PipelineDeclaration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactStore
        case artifactStores
        case name
        case roleArn
        case stages
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactStore = artifactStore {
            try encodeContainer.encode(artifactStore, forKey: .artifactStore)
        }
        if let artifactStores = artifactStores {
            var artifactStoresContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .artifactStores)
            for (dictKey0, artifactstoremap0) in artifactStores {
                try artifactStoresContainer.encode(artifactstoremap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let stages = stages {
            var stagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stages)
            for pipelinestagedeclarationlist0 in stages {
                try stagesContainer.encode(pipelinestagedeclarationlist0)
            }
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let artifactStoreDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ArtifactStore.self, forKey: .artifactStore)
        artifactStore = artifactStoreDecoded
        let artifactStoresContainer = try containerValues.decodeIfPresent([Swift.String: CodePipelineClientTypes.ArtifactStore?].self, forKey: .artifactStores)
        var artifactStoresDecoded0: [Swift.String:CodePipelineClientTypes.ArtifactStore]? = nil
        if let artifactStoresContainer = artifactStoresContainer {
            artifactStoresDecoded0 = [Swift.String:CodePipelineClientTypes.ArtifactStore]()
            for (key0, artifactstore0) in artifactStoresContainer {
                if let artifactstore0 = artifactstore0 {
                    artifactStoresDecoded0?[key0] = artifactstore0
                }
            }
        }
        artifactStores = artifactStoresDecoded0
        let stagesContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.StageDeclaration?].self, forKey: .stages)
        var stagesDecoded0:[CodePipelineClientTypes.StageDeclaration]? = nil
        if let stagesContainer = stagesContainer {
            stagesDecoded0 = [CodePipelineClientTypes.StageDeclaration]()
            for structure0 in stagesContainer {
                if let structure0 = structure0 {
                    stagesDecoded0?.append(structure0)
                }
            }
        }
        stages = stagesDecoded0
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version)
        version = versionDecoded
    }
}

extension CodePipelineClientTypes.PipelineDeclaration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PipelineDeclaration(artifactStore: \(Swift.String(describing: artifactStore)), artifactStores: \(Swift.String(describing: artifactStores)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), stages: \(Swift.String(describing: stages)), version: \(Swift.String(describing: version)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents the structure of actions and stages to be performed in the
    ///             pipeline.</p>
    public struct PipelineDeclaration: Swift.Equatable {
        /// <p>Represents information about the S3 bucket where artifacts are stored for the
        ///             pipeline.</p>
        ///         <note>
        ///             <p>You must include either <code>artifactStore</code> or
        ///                     <code>artifactStores</code> in your pipeline, but you cannot use both. If you
        ///                 create a cross-region action in your pipeline, you must use
        ///                     <code>artifactStores</code>.</p>
        ///         </note>
        public let artifactStore: CodePipelineClientTypes.ArtifactStore?
        /// <p>A mapping of <code>artifactStore</code> objects and their corresponding AWS
        ///             Regions. There must be an artifact store for the pipeline Region and for each
        ///             cross-region action in the pipeline.</p>
        ///         <note>
        ///             <p>You must include either <code>artifactStore</code> or
        ///                     <code>artifactStores</code> in your pipeline, but you cannot use both. If you
        ///                 create a cross-region action in your pipeline, you must use
        ///                     <code>artifactStores</code>.</p>
        ///         </note>
        public let artifactStores: [Swift.String:CodePipelineClientTypes.ArtifactStore]?
        /// <p>The name of the pipeline.</p>
        public let name: Swift.String?
        /// <p>The Amazon Resource Name (ARN) for AWS CodePipeline to use to either perform
        ///             actions with no <code>actionRoleArn</code>, or to use to assume roles for actions with
        ///             an <code>actionRoleArn</code>.</p>
        public let roleArn: Swift.String?
        /// <p>The stage in which to perform the action.</p>
        public let stages: [CodePipelineClientTypes.StageDeclaration]?
        /// <p>The version number of the pipeline. A new pipeline always has a version number of
        ///             1. This number is incremented when a pipeline is updated.</p>
        public let version: Swift.Int?

        public init (
            artifactStore: CodePipelineClientTypes.ArtifactStore? = nil,
            artifactStores: [Swift.String:CodePipelineClientTypes.ArtifactStore]? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            stages: [CodePipelineClientTypes.StageDeclaration]? = nil,
            version: Swift.Int? = nil
        )
        {
            self.artifactStore = artifactStore
            self.artifactStores = artifactStores
            self.name = name
            self.roleArn = roleArn
            self.stages = stages
            self.version = version
        }
    }

}

extension CodePipelineClientTypes.PipelineExecution: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactRevisions
        case pipelineExecutionId
        case pipelineName
        case pipelineVersion
        case status
        case statusSummary
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactRevisions = artifactRevisions {
            var artifactRevisionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .artifactRevisions)
            for artifactrevisionlist0 in artifactRevisions {
                try artifactRevisionsContainer.encode(artifactrevisionlist0)
            }
        }
        if let pipelineExecutionId = pipelineExecutionId {
            try encodeContainer.encode(pipelineExecutionId, forKey: .pipelineExecutionId)
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let pipelineVersion = pipelineVersion {
            try encodeContainer.encode(pipelineVersion, forKey: .pipelineVersion)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusSummary = statusSummary {
            try encodeContainer.encode(statusSummary, forKey: .statusSummary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let pipelineVersionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pipelineVersion)
        pipelineVersion = pipelineVersionDecoded
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.PipelineExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let statusSummaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusSummary)
        statusSummary = statusSummaryDecoded
        let artifactRevisionsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.ArtifactRevision?].self, forKey: .artifactRevisions)
        var artifactRevisionsDecoded0:[CodePipelineClientTypes.ArtifactRevision]? = nil
        if let artifactRevisionsContainer = artifactRevisionsContainer {
            artifactRevisionsDecoded0 = [CodePipelineClientTypes.ArtifactRevision]()
            for structure0 in artifactRevisionsContainer {
                if let structure0 = structure0 {
                    artifactRevisionsDecoded0?.append(structure0)
                }
            }
        }
        artifactRevisions = artifactRevisionsDecoded0
    }
}

extension CodePipelineClientTypes.PipelineExecution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PipelineExecution(artifactRevisions: \(Swift.String(describing: artifactRevisions)), pipelineExecutionId: \(Swift.String(describing: pipelineExecutionId)), pipelineName: \(Swift.String(describing: pipelineName)), pipelineVersion: \(Swift.String(describing: pipelineVersion)), status: \(Swift.String(describing: status)), statusSummary: \(Swift.String(describing: statusSummary)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about an execution of a pipeline.</p>
    public struct PipelineExecution: Swift.Equatable {
        /// <p>A list of <code>ArtifactRevision</code> objects included in a pipeline
        ///             execution.</p>
        public let artifactRevisions: [CodePipelineClientTypes.ArtifactRevision]?
        /// <p>The ID of the pipeline execution.</p>
        public let pipelineExecutionId: Swift.String?
        /// <p>The name of the pipeline with the specified pipeline execution.</p>
        public let pipelineName: Swift.String?
        /// <p>The version number of the pipeline with the specified pipeline execution.</p>
        public let pipelineVersion: Swift.Int?
        /// <p>The status of the pipeline execution.</p>
        ///         <ul>
        ///             <li>
        ///                 <p>Cancelled: The pipelines definition was updated before the pipeline
        ///                     execution could be completed.</p>
        ///             </li>
        ///             <li>
        ///                 <p>InProgress: The pipeline execution is currently running.</p>
        ///             </li>
        ///             <li>
        ///                 <p>Stopped: The pipeline execution was manually stopped. For more information,
        ///                     see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/concepts.html#concepts-executions-stopped">Stopped Executions</a>.</p>
        ///             </li>
        ///             <li>
        ///                 <p>Stopping: The pipeline execution received a request to be manually stopped.
        ///                     Depending on the selected stop mode, the execution is either completing or
        ///                     abandoning in-progress actions. For more information, see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/concepts.html#concepts-executions-stopped">Stopped Executions</a>.</p>
        ///             </li>
        ///             <li>
        ///                 <p>Succeeded: The pipeline execution was completed successfully. </p>
        ///             </li>
        ///             <li>
        ///                 <p>Superseded: While this pipeline execution was waiting for the next stage to
        ///                     be completed, a newer pipeline execution advanced and continued through the
        ///                     pipeline instead. For more information, see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/concepts.html#concepts-superseded">Superseded Executions</a>.</p>
        ///             </li>
        ///             <li>
        ///                 <p>Failed: The pipeline execution was not completed successfully.</p>
        ///             </li>
        ///          </ul>
        public let status: CodePipelineClientTypes.PipelineExecutionStatus?
        /// <p>A summary that contains a description of the pipeline execution status.</p>
        public let statusSummary: Swift.String?

        public init (
            artifactRevisions: [CodePipelineClientTypes.ArtifactRevision]? = nil,
            pipelineExecutionId: Swift.String? = nil,
            pipelineName: Swift.String? = nil,
            pipelineVersion: Swift.Int? = nil,
            status: CodePipelineClientTypes.PipelineExecutionStatus? = nil,
            statusSummary: Swift.String? = nil
        )
        {
            self.artifactRevisions = artifactRevisions
            self.pipelineExecutionId = pipelineExecutionId
            self.pipelineName = pipelineName
            self.pipelineVersion = pipelineVersion
            self.status = status
            self.statusSummary = statusSummary
        }
    }

}

extension PipelineExecutionNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PipelineExecutionNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension PipelineExecutionNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PipelineExecutionNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pipeline execution was specified in an invalid format or cannot be found, or an
///             execution ID does not belong to the specified pipeline. </p>
public struct PipelineExecutionNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PipelineExecutionNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PipelineExecutionNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PipelineExecutionNotStoppableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PipelineExecutionNotStoppableException(message: \(Swift.String(describing: message)))"}
}

extension PipelineExecutionNotStoppableException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PipelineExecutionNotStoppableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Unable to stop the pipeline execution. The execution might already be in a
///                 <code>Stopped</code> state, or it might no longer be in progress.</p>
public struct PipelineExecutionNotStoppableException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PipelineExecutionNotStoppableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PipelineExecutionNotStoppableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodePipelineClientTypes {
    public enum PipelineExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case failed
        case inprogress
        case stopped
        case stopping
        case succeeded
        case superseded
        case sdkUnknown(Swift.String)

        public static var allCases: [PipelineExecutionStatus] {
            return [
                .cancelled,
                .failed,
                .inprogress,
                .stopped,
                .stopping,
                .succeeded,
                .superseded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case .succeeded: return "Succeeded"
            case .superseded: return "Superseded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PipelineExecutionStatus(rawValue: rawValue) ?? PipelineExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension CodePipelineClientTypes.PipelineExecutionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastUpdateTime
        case pipelineExecutionId
        case sourceRevisions
        case startTime
        case status
        case stopTrigger
        case trigger
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastUpdateTime = lastUpdateTime {
            try encodeContainer.encode(lastUpdateTime.timeIntervalSince1970, forKey: .lastUpdateTime)
        }
        if let pipelineExecutionId = pipelineExecutionId {
            try encodeContainer.encode(pipelineExecutionId, forKey: .pipelineExecutionId)
        }
        if let sourceRevisions = sourceRevisions {
            var sourceRevisionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceRevisions)
            for sourcerevisionlist0 in sourceRevisions {
                try sourceRevisionsContainer.encode(sourcerevisionlist0)
            }
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let stopTrigger = stopTrigger {
            try encodeContainer.encode(stopTrigger, forKey: .stopTrigger)
        }
        if let trigger = trigger {
            try encodeContainer.encode(trigger, forKey: .trigger)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.PipelineExecutionStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let lastUpdateTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateTime)
        lastUpdateTime = lastUpdateTimeDecoded
        let sourceRevisionsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.SourceRevision?].self, forKey: .sourceRevisions)
        var sourceRevisionsDecoded0:[CodePipelineClientTypes.SourceRevision]? = nil
        if let sourceRevisionsContainer = sourceRevisionsContainer {
            sourceRevisionsDecoded0 = [CodePipelineClientTypes.SourceRevision]()
            for structure0 in sourceRevisionsContainer {
                if let structure0 = structure0 {
                    sourceRevisionsDecoded0?.append(structure0)
                }
            }
        }
        sourceRevisions = sourceRevisionsDecoded0
        let triggerDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ExecutionTrigger.self, forKey: .trigger)
        trigger = triggerDecoded
        let stopTriggerDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.StopExecutionTrigger.self, forKey: .stopTrigger)
        stopTrigger = stopTriggerDecoded
    }
}

extension CodePipelineClientTypes.PipelineExecutionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PipelineExecutionSummary(lastUpdateTime: \(Swift.String(describing: lastUpdateTime)), pipelineExecutionId: \(Swift.String(describing: pipelineExecutionId)), sourceRevisions: \(Swift.String(describing: sourceRevisions)), startTime: \(Swift.String(describing: startTime)), status: \(Swift.String(describing: status)), stopTrigger: \(Swift.String(describing: stopTrigger)), trigger: \(Swift.String(describing: trigger)))"}
}

extension CodePipelineClientTypes {
    /// <p>Summary information about a pipeline execution.</p>
    public struct PipelineExecutionSummary: Swift.Equatable {
        /// <p>The date and time of the last change to the pipeline execution, in timestamp
        ///             format.</p>
        public let lastUpdateTime: ClientRuntime.Date?
        /// <p>The ID of the pipeline execution.</p>
        public let pipelineExecutionId: Swift.String?
        /// <p>A list of the source artifact revisions that initiated a pipeline
        ///             execution.</p>
        public let sourceRevisions: [CodePipelineClientTypes.SourceRevision]?
        /// <p>The date and time when the pipeline execution began, in timestamp format.</p>
        public let startTime: ClientRuntime.Date?
        /// <p>The status of the pipeline execution.</p>
        ///         <ul>
        ///             <li>
        ///                 <p>InProgress: The pipeline execution is currently running.</p>
        ///             </li>
        ///             <li>
        ///                 <p>Stopped: The pipeline execution was manually stopped. For more information,
        ///                     see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/concepts.html#concepts-executions-stopped">Stopped Executions</a>.</p>
        ///             </li>
        ///             <li>
        ///                 <p>Stopping: The pipeline execution received a request to be manually stopped.
        ///                     Depending on the selected stop mode, the execution is either completing or
        ///                     abandoning in-progress actions. For more information, see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/concepts.html#concepts-executions-stopped">Stopped Executions</a>.</p>
        ///             </li>
        ///             <li>
        ///                 <p>Succeeded: The pipeline execution was completed successfully. </p>
        ///             </li>
        ///             <li>
        ///                 <p>Superseded: While this pipeline execution was waiting for the next stage to
        ///                     be completed, a newer pipeline execution advanced and continued through the
        ///                     pipeline instead. For more information, see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/concepts.html#concepts-superseded">Superseded Executions</a>.</p>
        ///             </li>
        ///             <li>
        ///                 <p>Failed: The pipeline execution was not completed successfully.</p>
        ///             </li>
        ///          </ul>
        public let status: CodePipelineClientTypes.PipelineExecutionStatus?
        /// <p>The interaction that stopped a pipeline execution.</p>
        public let stopTrigger: CodePipelineClientTypes.StopExecutionTrigger?
        /// <p>The interaction or event that started a pipeline execution, such as automated change
        ///             detection or a <code>StartPipelineExecution</code> API call.</p>
        public let trigger: CodePipelineClientTypes.ExecutionTrigger?

        public init (
            lastUpdateTime: ClientRuntime.Date? = nil,
            pipelineExecutionId: Swift.String? = nil,
            sourceRevisions: [CodePipelineClientTypes.SourceRevision]? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: CodePipelineClientTypes.PipelineExecutionStatus? = nil,
            stopTrigger: CodePipelineClientTypes.StopExecutionTrigger? = nil,
            trigger: CodePipelineClientTypes.ExecutionTrigger? = nil
        )
        {
            self.lastUpdateTime = lastUpdateTime
            self.pipelineExecutionId = pipelineExecutionId
            self.sourceRevisions = sourceRevisions
            self.startTime = startTime
            self.status = status
            self.stopTrigger = stopTrigger
            self.trigger = trigger
        }
    }

}

extension CodePipelineClientTypes.PipelineMetadata: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created
        case pipelineArn
        case updated
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let pipelineArn = pipelineArn {
            try encodeContainer.encode(pipelineArn, forKey: .pipelineArn)
        }
        if let updated = updated {
            try encodeContainer.encode(updated.timeIntervalSince1970, forKey: .updated)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineArn)
        pipelineArn = pipelineArnDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let updatedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updated)
        updated = updatedDecoded
    }
}

extension CodePipelineClientTypes.PipelineMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PipelineMetadata(created: \(Swift.String(describing: created)), pipelineArn: \(Swift.String(describing: pipelineArn)), updated: \(Swift.String(describing: updated)))"}
}

extension CodePipelineClientTypes {
    /// <p>Information about a pipeline.</p>
    public struct PipelineMetadata: Swift.Equatable {
        /// <p>The date and time the pipeline was created, in timestamp format.</p>
        public let created: ClientRuntime.Date?
        /// <p>The Amazon Resource Name (ARN) of the pipeline.</p>
        public let pipelineArn: Swift.String?
        /// <p>The date and time the pipeline was last updated, in timestamp format.</p>
        public let updated: ClientRuntime.Date?

        public init (
            created: ClientRuntime.Date? = nil,
            pipelineArn: Swift.String? = nil,
            updated: ClientRuntime.Date? = nil
        )
        {
            self.created = created
            self.pipelineArn = pipelineArn
            self.updated = updated
        }
    }

}

extension PipelineNameInUseException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PipelineNameInUseException(message: \(Swift.String(describing: message)))"}
}

extension PipelineNameInUseException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PipelineNameInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified pipeline name is already in use.</p>
public struct PipelineNameInUseException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PipelineNameInUseExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PipelineNameInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PipelineNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PipelineNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension PipelineNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PipelineNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pipeline was specified in an invalid format or cannot be found.</p>
public struct PipelineNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PipelineNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PipelineNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodePipelineClientTypes.PipelineSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case created
        case name
        case updated
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let created = created {
            try encodeContainer.encode(created.timeIntervalSince1970, forKey: .created)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updated = updated {
            try encodeContainer.encode(updated.timeIntervalSince1970, forKey: .updated)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let createdDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .created)
        created = createdDecoded
        let updatedDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updated)
        updated = updatedDecoded
    }
}

extension CodePipelineClientTypes.PipelineSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PipelineSummary(created: \(Swift.String(describing: created)), name: \(Swift.String(describing: name)), updated: \(Swift.String(describing: updated)), version: \(Swift.String(describing: version)))"}
}

extension CodePipelineClientTypes {
    /// <p>Returns a summary of a pipeline.</p>
    public struct PipelineSummary: Swift.Equatable {
        /// <p>The date and time the pipeline was created, in timestamp format.</p>
        public let created: ClientRuntime.Date?
        /// <p>The name of the pipeline.</p>
        public let name: Swift.String?
        /// <p>The date and time of the last update to the pipeline, in timestamp
        ///             format.</p>
        public let updated: ClientRuntime.Date?
        /// <p>The version number of the pipeline.</p>
        public let version: Swift.Int?

        public init (
            created: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            updated: ClientRuntime.Date? = nil,
            version: Swift.Int? = nil
        )
        {
            self.created = created
            self.name = name
            self.updated = updated
            self.version = version
        }
    }

}

extension PipelineVersionNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PipelineVersionNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension PipelineVersionNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PipelineVersionNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pipeline version was specified in an invalid format or cannot be
///             found.</p>
public struct PipelineVersionNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct PipelineVersionNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension PipelineVersionNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PollForJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PollForJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PollForJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PollForJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PollForJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PollForJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PollForJobsOutputError>
}

extension PollForJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PollForJobsInput(actionTypeId: \(Swift.String(describing: actionTypeId)), maxBatchSize: \(Swift.String(describing: maxBatchSize)), queryParam: \(Swift.String(describing: queryParam)))"}
}

extension PollForJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionTypeId
        case maxBatchSize
        case queryParam
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionTypeId = actionTypeId {
            try encodeContainer.encode(actionTypeId, forKey: .actionTypeId)
        }
        if let maxBatchSize = maxBatchSize {
            try encodeContainer.encode(maxBatchSize, forKey: .maxBatchSize)
        }
        if let queryParam = queryParam {
            var queryParamContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .queryParam)
            for (dictKey0, queryparammap0) in queryParam {
                try queryParamContainer.encode(queryparammap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct PollForJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PollForJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PollForJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PollForJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PollForJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PollForJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PollForJobsOutputError>
}

public struct PollForJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PollForJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PollForJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PollForJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PollForJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PollForJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PollForJobsOutputError>
}

/// <p>Represents the input of a <code>PollForJobs</code> action.</p>
public struct PollForJobsInput: Swift.Equatable {
    /// <p>Represents information about an action type.</p>
    public let actionTypeId: CodePipelineClientTypes.ActionTypeId?
    /// <p>The maximum number of jobs to return in a poll for jobs call.</p>
    public let maxBatchSize: Swift.Int?
    /// <p>A map of property names and values. For an action type with no queryable
    ///             properties, this value must be null or an empty map. For an action type with a queryable
    ///             property, you must supply that property as a key in the map. Only jobs whose action
    ///             configuration matches the mapped value are returned.</p>
    public let queryParam: [Swift.String:Swift.String]?

    public init (
        actionTypeId: CodePipelineClientTypes.ActionTypeId? = nil,
        maxBatchSize: Swift.Int? = nil,
        queryParam: [Swift.String:Swift.String]? = nil
    )
    {
        self.actionTypeId = actionTypeId
        self.maxBatchSize = maxBatchSize
        self.queryParam = queryParam
    }
}

struct PollForJobsInputBody: Swift.Equatable {
    public let actionTypeId: CodePipelineClientTypes.ActionTypeId?
    public let maxBatchSize: Swift.Int?
    public let queryParam: [Swift.String:Swift.String]?
}

extension PollForJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionTypeId
        case maxBatchSize
        case queryParam
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeIdDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionTypeId.self, forKey: .actionTypeId)
        actionTypeId = actionTypeIdDecoded
        let maxBatchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBatchSize)
        maxBatchSize = maxBatchSizeDecoded
        let queryParamContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .queryParam)
        var queryParamDecoded0: [Swift.String:Swift.String]? = nil
        if let queryParamContainer = queryParamContainer {
            queryParamDecoded0 = [Swift.String:Swift.String]()
            for (key0, actionconfigurationqueryablevalue0) in queryParamContainer {
                if let actionconfigurationqueryablevalue0 = actionconfigurationqueryablevalue0 {
                    queryParamDecoded0?[key0] = actionconfigurationqueryablevalue0
                }
            }
        }
        queryParam = queryParamDecoded0
    }
}

extension PollForJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PollForJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ActionTypeNotFoundException" : self = .actionTypeNotFoundException(try ActionTypeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PollForJobsOutputError: Swift.Error, Swift.Equatable {
    case actionTypeNotFoundException(ActionTypeNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PollForJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PollForJobsOutputResponse(jobs: \(Swift.String(describing: jobs)))"}
}

extension PollForJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PollForJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
        } else {
            self.jobs = nil
        }
    }
}

/// <p>Represents the output of a <code>PollForJobs</code> action.</p>
public struct PollForJobsOutputResponse: Swift.Equatable {
    /// <p>Information about the jobs to take action on.</p>
    public let jobs: [CodePipelineClientTypes.Job]?

    public init (
        jobs: [CodePipelineClientTypes.Job]? = nil
    )
    {
        self.jobs = jobs
    }
}

struct PollForJobsOutputResponseBody: Swift.Equatable {
    public let jobs: [CodePipelineClientTypes.Job]?
}

extension PollForJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.Job?].self, forKey: .jobs)
        var jobsDecoded0:[CodePipelineClientTypes.Job]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [CodePipelineClientTypes.Job]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
    }
}

public struct PollForThirdPartyJobsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PollForThirdPartyJobsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PollForThirdPartyJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PollForThirdPartyJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PollForThirdPartyJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PollForThirdPartyJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PollForThirdPartyJobsOutputError>
}

extension PollForThirdPartyJobsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PollForThirdPartyJobsInput(actionTypeId: \(Swift.String(describing: actionTypeId)), maxBatchSize: \(Swift.String(describing: maxBatchSize)))"}
}

extension PollForThirdPartyJobsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionTypeId
        case maxBatchSize
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionTypeId = actionTypeId {
            try encodeContainer.encode(actionTypeId, forKey: .actionTypeId)
        }
        if let maxBatchSize = maxBatchSize {
            try encodeContainer.encode(maxBatchSize, forKey: .maxBatchSize)
        }
    }
}

public struct PollForThirdPartyJobsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PollForThirdPartyJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PollForThirdPartyJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PollForThirdPartyJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PollForThirdPartyJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PollForThirdPartyJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PollForThirdPartyJobsOutputError>
}

public struct PollForThirdPartyJobsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PollForThirdPartyJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PollForThirdPartyJobsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PollForThirdPartyJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PollForThirdPartyJobsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PollForThirdPartyJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PollForThirdPartyJobsOutputError>
}

/// <p>Represents the input of a <code>PollForThirdPartyJobs</code> action.</p>
public struct PollForThirdPartyJobsInput: Swift.Equatable {
    /// <p>Represents information about an action type.</p>
    public let actionTypeId: CodePipelineClientTypes.ActionTypeId?
    /// <p>The maximum number of jobs to return in a poll for jobs call.</p>
    public let maxBatchSize: Swift.Int?

    public init (
        actionTypeId: CodePipelineClientTypes.ActionTypeId? = nil,
        maxBatchSize: Swift.Int? = nil
    )
    {
        self.actionTypeId = actionTypeId
        self.maxBatchSize = maxBatchSize
    }
}

struct PollForThirdPartyJobsInputBody: Swift.Equatable {
    public let actionTypeId: CodePipelineClientTypes.ActionTypeId?
    public let maxBatchSize: Swift.Int?
}

extension PollForThirdPartyJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionTypeId
        case maxBatchSize
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeIdDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionTypeId.self, forKey: .actionTypeId)
        actionTypeId = actionTypeIdDecoded
        let maxBatchSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxBatchSize)
        maxBatchSize = maxBatchSizeDecoded
    }
}

extension PollForThirdPartyJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PollForThirdPartyJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ActionTypeNotFoundException" : self = .actionTypeNotFoundException(try ActionTypeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PollForThirdPartyJobsOutputError: Swift.Error, Swift.Equatable {
    case actionTypeNotFoundException(ActionTypeNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PollForThirdPartyJobsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PollForThirdPartyJobsOutputResponse(jobs: \(Swift.String(describing: jobs)))"}
}

extension PollForThirdPartyJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PollForThirdPartyJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobs = output.jobs
        } else {
            self.jobs = nil
        }
    }
}

/// <p>Represents the output of a <code>PollForThirdPartyJobs</code> action.</p>
public struct PollForThirdPartyJobsOutputResponse: Swift.Equatable {
    /// <p>Information about the jobs to take action on.</p>
    public let jobs: [CodePipelineClientTypes.ThirdPartyJob]?

    public init (
        jobs: [CodePipelineClientTypes.ThirdPartyJob]? = nil
    )
    {
        self.jobs = jobs
    }
}

struct PollForThirdPartyJobsOutputResponseBody: Swift.Equatable {
    public let jobs: [CodePipelineClientTypes.ThirdPartyJob]?
}

extension PollForThirdPartyJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.ThirdPartyJob?].self, forKey: .jobs)
        var jobsDecoded0:[CodePipelineClientTypes.ThirdPartyJob]? = nil
        if let jobsContainer = jobsContainer {
            jobsDecoded0 = [CodePipelineClientTypes.ThirdPartyJob]()
            for structure0 in jobsContainer {
                if let structure0 = structure0 {
                    jobsDecoded0?.append(structure0)
                }
            }
        }
        jobs = jobsDecoded0
    }
}

public struct PutActionRevisionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutActionRevisionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutActionRevisionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutActionRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutActionRevisionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutActionRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutActionRevisionOutputError>
}

extension PutActionRevisionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutActionRevisionInput(actionName: \(Swift.String(describing: actionName)), actionRevision: \(Swift.String(describing: actionRevision)), pipelineName: \(Swift.String(describing: pipelineName)), stageName: \(Swift.String(describing: stageName)))"}
}

extension PutActionRevisionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionName
        case actionRevision
        case pipelineName
        case stageName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionName = actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let actionRevision = actionRevision {
            try encodeContainer.encode(actionRevision, forKey: .actionRevision)
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
    }
}

public struct PutActionRevisionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutActionRevisionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutActionRevisionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutActionRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutActionRevisionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutActionRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutActionRevisionOutputError>
}

public struct PutActionRevisionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutActionRevisionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutActionRevisionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutActionRevisionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutActionRevisionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutActionRevisionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutActionRevisionOutputError>
}

/// <p>Represents the input of a <code>PutActionRevision</code> action.</p>
public struct PutActionRevisionInput: Swift.Equatable {
    /// <p>The name of the action that processes the revision.</p>
    public let actionName: Swift.String?
    /// <p>Represents information about the version (or revision) of an action.</p>
    public let actionRevision: CodePipelineClientTypes.ActionRevision?
    /// <p>The name of the pipeline that starts processing the revision to the
    ///             source.</p>
    public let pipelineName: Swift.String?
    /// <p>The name of the stage that contains the action that acts on the revision.</p>
    public let stageName: Swift.String?

    public init (
        actionName: Swift.String? = nil,
        actionRevision: CodePipelineClientTypes.ActionRevision? = nil,
        pipelineName: Swift.String? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.actionName = actionName
        self.actionRevision = actionRevision
        self.pipelineName = pipelineName
        self.stageName = stageName
    }
}

struct PutActionRevisionInputBody: Swift.Equatable {
    public let pipelineName: Swift.String?
    public let stageName: Swift.String?
    public let actionName: Swift.String?
    public let actionRevision: CodePipelineClientTypes.ActionRevision?
}

extension PutActionRevisionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionName
        case actionRevision
        case pipelineName
        case stageName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let actionRevisionDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionRevision.self, forKey: .actionRevision)
        actionRevision = actionRevisionDecoded
    }
}

extension PutActionRevisionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutActionRevisionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ActionNotFoundException" : self = .actionNotFoundException(try ActionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StageNotFoundException" : self = .stageNotFoundException(try StageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutActionRevisionOutputError: Swift.Error, Swift.Equatable {
    case actionNotFoundException(ActionNotFoundException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case stageNotFoundException(StageNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutActionRevisionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutActionRevisionOutputResponse(newRevision: \(Swift.String(describing: newRevision)), pipelineExecutionId: \(Swift.String(describing: pipelineExecutionId)))"}
}

extension PutActionRevisionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutActionRevisionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.newRevision = output.newRevision
            self.pipelineExecutionId = output.pipelineExecutionId
        } else {
            self.newRevision = false
            self.pipelineExecutionId = nil
        }
    }
}

/// <p>Represents the output of a <code>PutActionRevision</code> action.</p>
public struct PutActionRevisionOutputResponse: Swift.Equatable {
    /// <p>Indicates whether the artifact revision was previously used in an execution of the
    ///             specified pipeline.</p>
    public let newRevision: Swift.Bool
    /// <p>The ID of the current workflow state of the pipeline.</p>
    public let pipelineExecutionId: Swift.String?

    public init (
        newRevision: Swift.Bool = false,
        pipelineExecutionId: Swift.String? = nil
    )
    {
        self.newRevision = newRevision
        self.pipelineExecutionId = pipelineExecutionId
    }
}

struct PutActionRevisionOutputResponseBody: Swift.Equatable {
    public let newRevision: Swift.Bool
    public let pipelineExecutionId: Swift.String?
}

extension PutActionRevisionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case newRevision
        case pipelineExecutionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let newRevisionDecoded = try containerValues.decode(Swift.Bool.self, forKey: .newRevision)
        newRevision = newRevisionDecoded
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
    }
}

public struct PutApprovalResultInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutApprovalResultInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutApprovalResultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutApprovalResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutApprovalResultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutApprovalResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutApprovalResultOutputError>
}

extension PutApprovalResultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutApprovalResultInput(actionName: \(Swift.String(describing: actionName)), pipelineName: \(Swift.String(describing: pipelineName)), result: \(Swift.String(describing: result)), stageName: \(Swift.String(describing: stageName)), token: \(Swift.String(describing: token)))"}
}

extension PutApprovalResultInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionName
        case pipelineName
        case result
        case stageName
        case token
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionName = actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let result = result {
            try encodeContainer.encode(result, forKey: .result)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
        if let token = token {
            try encodeContainer.encode(token, forKey: .token)
        }
    }
}

public struct PutApprovalResultInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutApprovalResultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutApprovalResultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutApprovalResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutApprovalResultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutApprovalResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutApprovalResultOutputError>
}

public struct PutApprovalResultInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutApprovalResultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutApprovalResultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutApprovalResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutApprovalResultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutApprovalResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutApprovalResultOutputError>
}

/// <p>Represents the input of a <code>PutApprovalResult</code> action.</p>
public struct PutApprovalResultInput: Swift.Equatable {
    /// <p>The name of the action for which approval is requested.</p>
    public let actionName: Swift.String?
    /// <p>The name of the pipeline that contains the action. </p>
    public let pipelineName: Swift.String?
    /// <p>Represents information about the result of the approval request.</p>
    public let result: CodePipelineClientTypes.ApprovalResult?
    /// <p>The name of the stage that contains the action.</p>
    public let stageName: Swift.String?
    /// <p>The system-generated token used to identify a unique approval request. The token
    ///             for each open approval request can be obtained using the <a>GetPipelineState</a> action. It is used to validate that the approval
    ///             request corresponding to this token is still valid.</p>
    public let token: Swift.String?

    public init (
        actionName: Swift.String? = nil,
        pipelineName: Swift.String? = nil,
        result: CodePipelineClientTypes.ApprovalResult? = nil,
        stageName: Swift.String? = nil,
        token: Swift.String? = nil
    )
    {
        self.actionName = actionName
        self.pipelineName = pipelineName
        self.result = result
        self.stageName = stageName
        self.token = token
    }
}

struct PutApprovalResultInputBody: Swift.Equatable {
    public let pipelineName: Swift.String?
    public let stageName: Swift.String?
    public let actionName: Swift.String?
    public let result: CodePipelineClientTypes.ApprovalResult?
    public let token: Swift.String?
}

extension PutApprovalResultInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionName
        case pipelineName
        case result
        case stageName
        case token
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let resultDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ApprovalResult.self, forKey: .result)
        result = resultDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .token)
        token = tokenDecoded
    }
}

extension PutApprovalResultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutApprovalResultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ActionNotFoundException" : self = .actionNotFoundException(try ActionNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ApprovalAlreadyCompletedException" : self = .approvalAlreadyCompletedException(try ApprovalAlreadyCompletedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidApprovalTokenException" : self = .invalidApprovalTokenException(try InvalidApprovalTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StageNotFoundException" : self = .stageNotFoundException(try StageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutApprovalResultOutputError: Swift.Error, Swift.Equatable {
    case actionNotFoundException(ActionNotFoundException)
    case approvalAlreadyCompletedException(ApprovalAlreadyCompletedException)
    case invalidApprovalTokenException(InvalidApprovalTokenException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case stageNotFoundException(StageNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutApprovalResultOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutApprovalResultOutputResponse(approvedAt: \(Swift.String(describing: approvedAt)))"}
}

extension PutApprovalResultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutApprovalResultOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.approvedAt = output.approvedAt
        } else {
            self.approvedAt = nil
        }
    }
}

/// <p>Represents the output of a <code>PutApprovalResult</code> action.</p>
public struct PutApprovalResultOutputResponse: Swift.Equatable {
    /// <p>The timestamp showing when the approval or rejection was submitted.</p>
    public let approvedAt: ClientRuntime.Date?

    public init (
        approvedAt: ClientRuntime.Date? = nil
    )
    {
        self.approvedAt = approvedAt
    }
}

struct PutApprovalResultOutputResponseBody: Swift.Equatable {
    public let approvedAt: ClientRuntime.Date?
}

extension PutApprovalResultOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approvedAt
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let approvedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .approvedAt)
        approvedAt = approvedAtDecoded
    }
}

public struct PutJobFailureResultInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutJobFailureResultInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutJobFailureResultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutJobFailureResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutJobFailureResultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutJobFailureResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutJobFailureResultOutputError>
}

extension PutJobFailureResultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutJobFailureResultInput(failureDetails: \(Swift.String(describing: failureDetails)), jobId: \(Swift.String(describing: jobId)))"}
}

extension PutJobFailureResultInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureDetails
        case jobId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct PutJobFailureResultInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutJobFailureResultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutJobFailureResultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutJobFailureResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutJobFailureResultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutJobFailureResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutJobFailureResultOutputError>
}

public struct PutJobFailureResultInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutJobFailureResultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutJobFailureResultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutJobFailureResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutJobFailureResultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutJobFailureResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutJobFailureResultOutputError>
}

/// <p>Represents the input of a <code>PutJobFailureResult</code> action.</p>
public struct PutJobFailureResultInput: Swift.Equatable {
    /// <p>The details about the failure of a job.</p>
    public let failureDetails: CodePipelineClientTypes.FailureDetails?
    /// <p>The unique system-generated ID of the job that failed. This is the same ID returned
    ///             from <code>PollForJobs</code>.</p>
    public let jobId: Swift.String?

    public init (
        failureDetails: CodePipelineClientTypes.FailureDetails? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.failureDetails = failureDetails
        self.jobId = jobId
    }
}

struct PutJobFailureResultInputBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let failureDetails: CodePipelineClientTypes.FailureDetails?
}

extension PutJobFailureResultInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureDetails
        case jobId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
    }
}

extension PutJobFailureResultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutJobFailureResultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutJobFailureResultOutputError: Swift.Error, Swift.Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case jobNotFoundException(JobNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutJobFailureResultOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutJobFailureResultOutputResponse()"}
}

extension PutJobFailureResultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutJobFailureResultOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutJobFailureResultOutputResponseBody: Swift.Equatable {
}

extension PutJobFailureResultOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutJobSuccessResultInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutJobSuccessResultInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutJobSuccessResultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutJobSuccessResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutJobSuccessResultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutJobSuccessResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutJobSuccessResultOutputError>
}

extension PutJobSuccessResultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutJobSuccessResultInput(continuationToken: \(Swift.String(describing: continuationToken)), currentRevision: \(Swift.String(describing: currentRevision)), executionDetails: \(Swift.String(describing: executionDetails)), jobId: \(Swift.String(describing: jobId)), outputVariables: \(Swift.String(describing: outputVariables)))"}
}

extension PutJobSuccessResultInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continuationToken
        case currentRevision
        case executionDetails
        case jobId
        case outputVariables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let continuationToken = continuationToken {
            try encodeContainer.encode(continuationToken, forKey: .continuationToken)
        }
        if let currentRevision = currentRevision {
            try encodeContainer.encode(currentRevision, forKey: .currentRevision)
        }
        if let executionDetails = executionDetails {
            try encodeContainer.encode(executionDetails, forKey: .executionDetails)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let outputVariables = outputVariables {
            var outputVariablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .outputVariables)
            for (dictKey0, outputvariablesmap0) in outputVariables {
                try outputVariablesContainer.encode(outputvariablesmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct PutJobSuccessResultInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutJobSuccessResultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutJobSuccessResultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutJobSuccessResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutJobSuccessResultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutJobSuccessResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutJobSuccessResultOutputError>
}

public struct PutJobSuccessResultInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutJobSuccessResultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutJobSuccessResultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutJobSuccessResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutJobSuccessResultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutJobSuccessResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutJobSuccessResultOutputError>
}

/// <p>Represents the input of a <code>PutJobSuccessResult</code> action.</p>
public struct PutJobSuccessResultInput: Swift.Equatable {
    /// <p>A token generated by a job worker, such as an AWS CodeDeploy deployment ID, that a
    ///             successful job provides to identify a custom action in progress. Future jobs use this
    ///             token to identify the running instance of the action. It can be reused to return more
    ///             information about the progress of the custom action. When the action is complete, no
    ///             continuation token should be supplied.</p>
    public let continuationToken: Swift.String?
    /// <p>The ID of the current revision of the artifact successfully worked on by the
    ///             job.</p>
    public let currentRevision: CodePipelineClientTypes.CurrentRevision?
    /// <p>The execution details of the successful job, such as the actions taken by the job
    ///             worker.</p>
    public let executionDetails: CodePipelineClientTypes.ExecutionDetails?
    /// <p>The unique system-generated ID of the job that succeeded. This is the same ID
    ///             returned from <code>PollForJobs</code>.</p>
    public let jobId: Swift.String?
    /// <p>Key-value pairs produced as output by a job worker that can be made available to a
    ///             downstream action configuration. <code>outputVariables</code> can be included only when
    ///             there is no continuation token on the request.</p>
    public let outputVariables: [Swift.String:Swift.String]?

    public init (
        continuationToken: Swift.String? = nil,
        currentRevision: CodePipelineClientTypes.CurrentRevision? = nil,
        executionDetails: CodePipelineClientTypes.ExecutionDetails? = nil,
        jobId: Swift.String? = nil,
        outputVariables: [Swift.String:Swift.String]? = nil
    )
    {
        self.continuationToken = continuationToken
        self.currentRevision = currentRevision
        self.executionDetails = executionDetails
        self.jobId = jobId
        self.outputVariables = outputVariables
    }
}

struct PutJobSuccessResultInputBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let currentRevision: CodePipelineClientTypes.CurrentRevision?
    public let continuationToken: Swift.String?
    public let executionDetails: CodePipelineClientTypes.ExecutionDetails?
    public let outputVariables: [Swift.String:Swift.String]?
}

extension PutJobSuccessResultInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case continuationToken
        case currentRevision
        case executionDetails
        case jobId
        case outputVariables
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let currentRevisionDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.CurrentRevision.self, forKey: .currentRevision)
        currentRevision = currentRevisionDecoded
        let continuationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .continuationToken)
        continuationToken = continuationTokenDecoded
        let executionDetailsDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ExecutionDetails.self, forKey: .executionDetails)
        executionDetails = executionDetailsDecoded
        let outputVariablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .outputVariables)
        var outputVariablesDecoded0: [Swift.String:Swift.String]? = nil
        if let outputVariablesContainer = outputVariablesContainer {
            outputVariablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, outputvariablesvalue0) in outputVariablesContainer {
                if let outputvariablesvalue0 = outputvariablesvalue0 {
                    outputVariablesDecoded0?[key0] = outputvariablesvalue0
                }
            }
        }
        outputVariables = outputVariablesDecoded0
    }
}

extension PutJobSuccessResultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutJobSuccessResultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OutputVariablesSizeExceededException" : self = .outputVariablesSizeExceededException(try OutputVariablesSizeExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutJobSuccessResultOutputError: Swift.Error, Swift.Equatable {
    case invalidJobStateException(InvalidJobStateException)
    case jobNotFoundException(JobNotFoundException)
    case outputVariablesSizeExceededException(OutputVariablesSizeExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutJobSuccessResultOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutJobSuccessResultOutputResponse()"}
}

extension PutJobSuccessResultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutJobSuccessResultOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutJobSuccessResultOutputResponseBody: Swift.Equatable {
}

extension PutJobSuccessResultOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutThirdPartyJobFailureResultInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutThirdPartyJobFailureResultInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutThirdPartyJobFailureResultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutThirdPartyJobFailureResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutThirdPartyJobFailureResultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutThirdPartyJobFailureResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutThirdPartyJobFailureResultOutputError>
}

extension PutThirdPartyJobFailureResultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutThirdPartyJobFailureResultInput(clientToken: \(Swift.String(describing: clientToken)), failureDetails: \(Swift.String(describing: failureDetails)), jobId: \(Swift.String(describing: jobId)))"}
}

extension PutThirdPartyJobFailureResultInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case failureDetails
        case jobId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let failureDetails = failureDetails {
            try encodeContainer.encode(failureDetails, forKey: .failureDetails)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct PutThirdPartyJobFailureResultInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutThirdPartyJobFailureResultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutThirdPartyJobFailureResultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutThirdPartyJobFailureResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutThirdPartyJobFailureResultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutThirdPartyJobFailureResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutThirdPartyJobFailureResultOutputError>
}

public struct PutThirdPartyJobFailureResultInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutThirdPartyJobFailureResultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutThirdPartyJobFailureResultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutThirdPartyJobFailureResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutThirdPartyJobFailureResultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutThirdPartyJobFailureResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutThirdPartyJobFailureResultOutputError>
}

/// <p>Represents the input of a <code>PutThirdPartyJobFailureResult</code>
///             action.</p>
public struct PutThirdPartyJobFailureResultInput: Swift.Equatable {
    /// <p>The clientToken portion of the clientId and clientToken pair used to verify that
    ///             the calling entity is allowed access to the job and its details.</p>
    public let clientToken: Swift.String?
    /// <p>Represents information about failure details.</p>
    public let failureDetails: CodePipelineClientTypes.FailureDetails?
    /// <p>The ID of the job that failed. This is the same ID returned from
    ///                 <code>PollForThirdPartyJobs</code>.</p>
    public let jobId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        failureDetails: CodePipelineClientTypes.FailureDetails? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.failureDetails = failureDetails
        self.jobId = jobId
    }
}

struct PutThirdPartyJobFailureResultInputBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let clientToken: Swift.String?
    public let failureDetails: CodePipelineClientTypes.FailureDetails?
}

extension PutThirdPartyJobFailureResultInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case failureDetails
        case jobId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let failureDetailsDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.FailureDetails.self, forKey: .failureDetails)
        failureDetails = failureDetailsDecoded
    }
}

extension PutThirdPartyJobFailureResultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutThirdPartyJobFailureResultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutThirdPartyJobFailureResultOutputError: Swift.Error, Swift.Equatable {
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidJobStateException(InvalidJobStateException)
    case jobNotFoundException(JobNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutThirdPartyJobFailureResultOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutThirdPartyJobFailureResultOutputResponse()"}
}

extension PutThirdPartyJobFailureResultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutThirdPartyJobFailureResultOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutThirdPartyJobFailureResultOutputResponseBody: Swift.Equatable {
}

extension PutThirdPartyJobFailureResultOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutThirdPartyJobSuccessResultInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutThirdPartyJobSuccessResultInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutThirdPartyJobSuccessResultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutThirdPartyJobSuccessResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutThirdPartyJobSuccessResultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutThirdPartyJobSuccessResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutThirdPartyJobSuccessResultOutputError>
}

extension PutThirdPartyJobSuccessResultInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutThirdPartyJobSuccessResultInput(clientToken: \(Swift.String(describing: clientToken)), continuationToken: \(Swift.String(describing: continuationToken)), currentRevision: \(Swift.String(describing: currentRevision)), executionDetails: \(Swift.String(describing: executionDetails)), jobId: \(Swift.String(describing: jobId)))"}
}

extension PutThirdPartyJobSuccessResultInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case continuationToken
        case currentRevision
        case executionDetails
        case jobId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let continuationToken = continuationToken {
            try encodeContainer.encode(continuationToken, forKey: .continuationToken)
        }
        if let currentRevision = currentRevision {
            try encodeContainer.encode(currentRevision, forKey: .currentRevision)
        }
        if let executionDetails = executionDetails {
            try encodeContainer.encode(executionDetails, forKey: .executionDetails)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }
}

public struct PutThirdPartyJobSuccessResultInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutThirdPartyJobSuccessResultInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutThirdPartyJobSuccessResultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutThirdPartyJobSuccessResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutThirdPartyJobSuccessResultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutThirdPartyJobSuccessResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutThirdPartyJobSuccessResultOutputError>
}

public struct PutThirdPartyJobSuccessResultInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutThirdPartyJobSuccessResultInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutThirdPartyJobSuccessResultInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutThirdPartyJobSuccessResultOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutThirdPartyJobSuccessResultInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutThirdPartyJobSuccessResultOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutThirdPartyJobSuccessResultOutputError>
}

/// <p>Represents the input of a <code>PutThirdPartyJobSuccessResult</code>
///             action.</p>
public struct PutThirdPartyJobSuccessResultInput: Swift.Equatable {
    /// <p>The clientToken portion of the clientId and clientToken pair used to verify that
    ///             the calling entity is allowed access to the job and its details.</p>
    public let clientToken: Swift.String?
    /// <p>A token generated by a job worker, such as an AWS CodeDeploy deployment ID, that a
    ///             successful job provides to identify a partner action in progress. Future jobs use this
    ///             token to identify the running instance of the action. It can be reused to return more
    ///             information about the progress of the partner action. When the action is complete, no
    ///             continuation token should be supplied.</p>
    public let continuationToken: Swift.String?
    /// <p>Represents information about a current revision.</p>
    public let currentRevision: CodePipelineClientTypes.CurrentRevision?
    /// <p>The details of the actions taken and results produced on an artifact as it passes
    ///             through stages in the pipeline. </p>
    public let executionDetails: CodePipelineClientTypes.ExecutionDetails?
    /// <p>The ID of the job that successfully completed. This is the same ID returned from
    ///                 <code>PollForThirdPartyJobs</code>.</p>
    public let jobId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        continuationToken: Swift.String? = nil,
        currentRevision: CodePipelineClientTypes.CurrentRevision? = nil,
        executionDetails: CodePipelineClientTypes.ExecutionDetails? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.continuationToken = continuationToken
        self.currentRevision = currentRevision
        self.executionDetails = executionDetails
        self.jobId = jobId
    }
}

struct PutThirdPartyJobSuccessResultInputBody: Swift.Equatable {
    public let jobId: Swift.String?
    public let clientToken: Swift.String?
    public let currentRevision: CodePipelineClientTypes.CurrentRevision?
    public let continuationToken: Swift.String?
    public let executionDetails: CodePipelineClientTypes.ExecutionDetails?
}

extension PutThirdPartyJobSuccessResultInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case continuationToken
        case currentRevision
        case executionDetails
        case jobId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let currentRevisionDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.CurrentRevision.self, forKey: .currentRevision)
        currentRevision = currentRevisionDecoded
        let continuationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .continuationToken)
        continuationToken = continuationTokenDecoded
        let executionDetailsDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ExecutionDetails.self, forKey: .executionDetails)
        executionDetails = executionDetailsDecoded
    }
}

extension PutThirdPartyJobSuccessResultOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutThirdPartyJobSuccessResultOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidClientTokenException" : self = .invalidClientTokenException(try InvalidClientTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidJobStateException" : self = .invalidJobStateException(try InvalidJobStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "JobNotFoundException" : self = .jobNotFoundException(try JobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutThirdPartyJobSuccessResultOutputError: Swift.Error, Swift.Equatable {
    case invalidClientTokenException(InvalidClientTokenException)
    case invalidJobStateException(InvalidJobStateException)
    case jobNotFoundException(JobNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutThirdPartyJobSuccessResultOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutThirdPartyJobSuccessResultOutputResponse()"}
}

extension PutThirdPartyJobSuccessResultOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutThirdPartyJobSuccessResultOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutThirdPartyJobSuccessResultOutputResponseBody: Swift.Equatable {
}

extension PutThirdPartyJobSuccessResultOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutWebhookInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutWebhookInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutWebhookInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutWebhookInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutWebhookOutputError>
}

extension PutWebhookInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutWebhookInput(tags: \(Swift.String(describing: tags)), webhook: \(Swift.String(describing: webhook)))"}
}

extension PutWebhookInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
        case webhook
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let webhook = webhook {
            try encodeContainer.encode(webhook, forKey: .webhook)
        }
    }
}

public struct PutWebhookInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutWebhookInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutWebhookInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutWebhookInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutWebhookOutputError>
}

public struct PutWebhookInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutWebhookInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutWebhookInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutWebhookOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutWebhookInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutWebhookOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutWebhookOutputError>
}

public struct PutWebhookInput: Swift.Equatable {
    /// <p>The tags for the webhook.</p>
    public let tags: [CodePipelineClientTypes.Tag]?
    /// <p>The detail provided in an input file to create the webhook, such as the webhook
    ///             name, the pipeline name, and the action name. Give the webhook a unique name that helps
    ///             you identify it. You might name the webhook after the pipeline and action it targets so
    ///             that you can easily recognize what it's used for later.</p>
    public let webhook: CodePipelineClientTypes.WebhookDefinition?

    public init (
        tags: [CodePipelineClientTypes.Tag]? = nil,
        webhook: CodePipelineClientTypes.WebhookDefinition? = nil
    )
    {
        self.tags = tags
        self.webhook = webhook
    }
}

struct PutWebhookInputBody: Swift.Equatable {
    public let webhook: CodePipelineClientTypes.WebhookDefinition?
    public let tags: [CodePipelineClientTypes.Tag]?
}

extension PutWebhookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
        case webhook
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.WebhookDefinition.self, forKey: .webhook)
        webhook = webhookDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodePipelineClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodePipelineClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PutWebhookOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutWebhookOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagsException" : self = .invalidTagsException(try InvalidTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidWebhookAuthenticationParametersException" : self = .invalidWebhookAuthenticationParametersException(try InvalidWebhookAuthenticationParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidWebhookFilterPatternException" : self = .invalidWebhookFilterPatternException(try InvalidWebhookFilterPatternException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutWebhookOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidTagsException(InvalidTagsException)
    case invalidWebhookAuthenticationParametersException(InvalidWebhookAuthenticationParametersException)
    case invalidWebhookFilterPatternException(InvalidWebhookFilterPatternException)
    case limitExceededException(LimitExceededException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutWebhookOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutWebhookOutputResponse(webhook: \(Swift.String(describing: webhook)))"}
}

extension PutWebhookOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutWebhookOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.webhook = output.webhook
        } else {
            self.webhook = nil
        }
    }
}

public struct PutWebhookOutputResponse: Swift.Equatable {
    /// <p>The detail returned from creating the webhook, such as the webhook name, webhook
    ///             URL, and webhook ARN.</p>
    public let webhook: CodePipelineClientTypes.ListWebhookItem?

    public init (
        webhook: CodePipelineClientTypes.ListWebhookItem? = nil
    )
    {
        self.webhook = webhook
    }
}

struct PutWebhookOutputResponseBody: Swift.Equatable {
    public let webhook: CodePipelineClientTypes.ListWebhookItem?
}

extension PutWebhookOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case webhook
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ListWebhookItem.self, forKey: .webhook)
        webhook = webhookDecoded
    }
}

public struct RegisterWebhookWithThirdPartyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterWebhookWithThirdPartyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterWebhookWithThirdPartyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterWebhookWithThirdPartyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterWebhookWithThirdPartyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterWebhookWithThirdPartyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterWebhookWithThirdPartyOutputError>
}

extension RegisterWebhookWithThirdPartyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterWebhookWithThirdPartyInput(webhookName: \(Swift.String(describing: webhookName)))"}
}

extension RegisterWebhookWithThirdPartyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case webhookName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let webhookName = webhookName {
            try encodeContainer.encode(webhookName, forKey: .webhookName)
        }
    }
}

public struct RegisterWebhookWithThirdPartyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterWebhookWithThirdPartyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterWebhookWithThirdPartyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterWebhookWithThirdPartyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterWebhookWithThirdPartyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterWebhookWithThirdPartyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterWebhookWithThirdPartyOutputError>
}

public struct RegisterWebhookWithThirdPartyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RegisterWebhookWithThirdPartyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RegisterWebhookWithThirdPartyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RegisterWebhookWithThirdPartyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RegisterWebhookWithThirdPartyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RegisterWebhookWithThirdPartyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RegisterWebhookWithThirdPartyOutputError>
}

public struct RegisterWebhookWithThirdPartyInput: Swift.Equatable {
    /// <p>The name of an existing webhook created with PutWebhook to register with a
    ///             supported third party. </p>
    public let webhookName: Swift.String?

    public init (
        webhookName: Swift.String? = nil
    )
    {
        self.webhookName = webhookName
    }
}

struct RegisterWebhookWithThirdPartyInputBody: Swift.Equatable {
    public let webhookName: Swift.String?
}

extension RegisterWebhookWithThirdPartyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case webhookName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webhookNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .webhookName)
        webhookName = webhookNameDecoded
    }
}

extension RegisterWebhookWithThirdPartyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterWebhookWithThirdPartyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "WebhookNotFoundException" : self = .webhookNotFoundException(try WebhookNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterWebhookWithThirdPartyOutputError: Swift.Error, Swift.Equatable {
    case validationException(ValidationException)
    case webhookNotFoundException(WebhookNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterWebhookWithThirdPartyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterWebhookWithThirdPartyOutputResponse()"}
}

extension RegisterWebhookWithThirdPartyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RegisterWebhookWithThirdPartyOutputResponse: Swift.Equatable {

    public init() {}
}

struct RegisterWebhookWithThirdPartyOutputResponseBody: Swift.Equatable {
}

extension RegisterWebhookWithThirdPartyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension RequestFailedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RequestFailedException(message: \(Swift.String(describing: message)))"}
}

extension RequestFailedException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RequestFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request failed because of an unknown error, exception, or failure.</p>
public struct RequestFailedException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RequestFailedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension RequestFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource was specified in an invalid format.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct RetryStageExecutionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RetryStageExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RetryStageExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RetryStageExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RetryStageExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RetryStageExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RetryStageExecutionOutputError>
}

extension RetryStageExecutionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetryStageExecutionInput(pipelineExecutionId: \(Swift.String(describing: pipelineExecutionId)), pipelineName: \(Swift.String(describing: pipelineName)), retryMode: \(Swift.String(describing: retryMode)), stageName: \(Swift.String(describing: stageName)))"}
}

extension RetryStageExecutionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineExecutionId
        case pipelineName
        case retryMode
        case stageName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineExecutionId = pipelineExecutionId {
            try encodeContainer.encode(pipelineExecutionId, forKey: .pipelineExecutionId)
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let retryMode = retryMode {
            try encodeContainer.encode(retryMode.rawValue, forKey: .retryMode)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
    }
}

public struct RetryStageExecutionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RetryStageExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RetryStageExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RetryStageExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RetryStageExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RetryStageExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RetryStageExecutionOutputError>
}

public struct RetryStageExecutionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RetryStageExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RetryStageExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RetryStageExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RetryStageExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RetryStageExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RetryStageExecutionOutputError>
}

/// <p>Represents the input of a <code>RetryStageExecution</code> action.</p>
public struct RetryStageExecutionInput: Swift.Equatable {
    /// <p>The ID of the pipeline execution in the failed stage to be retried. Use the <a>GetPipelineState</a> action to retrieve the current pipelineExecutionId of
    ///             the failed stage</p>
    public let pipelineExecutionId: Swift.String?
    /// <p>The name of the pipeline that contains the failed stage.</p>
    public let pipelineName: Swift.String?
    /// <p>The scope of the retry attempt. Currently, the only supported value is
    ///             FAILED_ACTIONS.</p>
    public let retryMode: CodePipelineClientTypes.StageRetryMode?
    /// <p>The name of the failed stage to be retried.</p>
    public let stageName: Swift.String?

    public init (
        pipelineExecutionId: Swift.String? = nil,
        pipelineName: Swift.String? = nil,
        retryMode: CodePipelineClientTypes.StageRetryMode? = nil,
        stageName: Swift.String? = nil
    )
    {
        self.pipelineExecutionId = pipelineExecutionId
        self.pipelineName = pipelineName
        self.retryMode = retryMode
        self.stageName = stageName
    }
}

struct RetryStageExecutionInputBody: Swift.Equatable {
    public let pipelineName: Swift.String?
    public let stageName: Swift.String?
    public let pipelineExecutionId: Swift.String?
    public let retryMode: CodePipelineClientTypes.StageRetryMode?
}

extension RetryStageExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineExecutionId
        case pipelineName
        case retryMode
        case stageName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
        let retryModeDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.StageRetryMode.self, forKey: .retryMode)
        retryMode = retryModeDecoded
    }
}

extension RetryStageExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RetryStageExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotLatestPipelineExecutionException" : self = .notLatestPipelineExecutionException(try NotLatestPipelineExecutionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StageNotFoundException" : self = .stageNotFoundException(try StageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StageNotRetryableException" : self = .stageNotRetryableException(try StageNotRetryableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RetryStageExecutionOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case notLatestPipelineExecutionException(NotLatestPipelineExecutionException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case stageNotFoundException(StageNotFoundException)
    case stageNotRetryableException(StageNotRetryableException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RetryStageExecutionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetryStageExecutionOutputResponse(pipelineExecutionId: \(Swift.String(describing: pipelineExecutionId)))"}
}

extension RetryStageExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RetryStageExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pipelineExecutionId = output.pipelineExecutionId
        } else {
            self.pipelineExecutionId = nil
        }
    }
}

/// <p>Represents the output of a <code>RetryStageExecution</code> action.</p>
public struct RetryStageExecutionOutputResponse: Swift.Equatable {
    /// <p>The ID of the current workflow execution in the failed stage.</p>
    public let pipelineExecutionId: Swift.String?

    public init (
        pipelineExecutionId: Swift.String? = nil
    )
    {
        self.pipelineExecutionId = pipelineExecutionId
    }
}

struct RetryStageExecutionOutputResponseBody: Swift.Equatable {
    public let pipelineExecutionId: Swift.String?
}

extension RetryStageExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineExecutionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
    }
}

extension CodePipelineClientTypes.S3ArtifactLocation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
        case objectKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let objectKey = objectKey {
            try encodeContainer.encode(objectKey, forKey: .objectKey)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
        let objectKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .objectKey)
        objectKey = objectKeyDecoded
    }
}

extension CodePipelineClientTypes.S3ArtifactLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3ArtifactLocation(bucketName: \(Swift.String(describing: bucketName)), objectKey: \(Swift.String(describing: objectKey)))"}
}

extension CodePipelineClientTypes {
    /// <p>The location of the S3 bucket that contains a revision.</p>
    public struct S3ArtifactLocation: Swift.Equatable {
        /// <p>The name of the S3 bucket.</p>
        public let bucketName: Swift.String?
        /// <p>The key of the object in the S3 bucket, which uniquely identifies the object in the
        ///             bucket.</p>
        public let objectKey: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            objectKey: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.objectKey = objectKey
        }
    }

}

extension CodePipelineClientTypes.S3Location: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension CodePipelineClientTypes.S3Location: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "S3Location(bucket: \(Swift.String(describing: bucket)), key: \(Swift.String(describing: key)))"}
}

extension CodePipelineClientTypes {
    /// <p>The Amazon S3 artifact location for an action's artifacts.</p>
    public struct S3Location: Swift.Equatable {
        /// <p>The Amazon S3 artifact bucket for an action's artifacts.</p>
        public let bucket: Swift.String?
        /// <p>The artifact name.</p>
        public let key: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }

}

extension CodePipelineClientTypes.SourceRevision: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionName
        case revisionId
        case revisionSummary
        case revisionUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionName = actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let revisionSummary = revisionSummary {
            try encodeContainer.encode(revisionSummary, forKey: .revisionSummary)
        }
        if let revisionUrl = revisionUrl {
            try encodeContainer.encode(revisionUrl, forKey: .revisionUrl)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let revisionSummaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionSummary)
        revisionSummary = revisionSummaryDecoded
        let revisionUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionUrl)
        revisionUrl = revisionUrlDecoded
    }
}

extension CodePipelineClientTypes.SourceRevision: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceRevision(actionName: \(Swift.String(describing: actionName)), revisionId: \(Swift.String(describing: revisionId)), revisionSummary: \(Swift.String(describing: revisionSummary)), revisionUrl: \(Swift.String(describing: revisionUrl)))"}
}

extension CodePipelineClientTypes {
    /// <p>Information about the version (or revision) of a source artifact that initiated a
    ///             pipeline execution.</p>
    public struct SourceRevision: Swift.Equatable {
        /// <p>The name of the action that processed the revision to the source
        ///             artifact.</p>
        public let actionName: Swift.String?
        /// <p>The system-generated unique ID that identifies the revision number of the
        ///             artifact.</p>
        public let revisionId: Swift.String?
        /// <p>Summary information about the most recent revision of the artifact. For GitHub and
        ///             AWS CodeCommit repositories, the commit message. For Amazon S3 buckets or actions, the
        ///             user-provided content of a <code>codepipeline-artifact-revision-summary</code> key
        ///             specified in the object metadata.</p>
        public let revisionSummary: Swift.String?
        /// <p>The commit ID for the artifact revision. For artifacts stored in GitHub or AWS
        ///             CodeCommit repositories, the commit ID is linked to a commit details page.</p>
        public let revisionUrl: Swift.String?

        public init (
            actionName: Swift.String? = nil,
            revisionId: Swift.String? = nil,
            revisionSummary: Swift.String? = nil,
            revisionUrl: Swift.String? = nil
        )
        {
            self.actionName = actionName
            self.revisionId = revisionId
            self.revisionSummary = revisionSummary
            self.revisionUrl = revisionUrl
        }
    }

}

extension CodePipelineClientTypes.StageContext: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CodePipelineClientTypes.StageContext: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StageContext(name: \(Swift.String(describing: name)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about a stage to a job worker.</p>
    public struct StageContext: Swift.Equatable {
        /// <p>The name of the stage.</p>
        public let name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension CodePipelineClientTypes.StageDeclaration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions
        case blockers
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for stageactiondeclarationlist0 in actions {
                try actionsContainer.encode(stageactiondeclarationlist0)
            }
        }
        if let blockers = blockers {
            var blockersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blockers)
            for stageblockerdeclarationlist0 in blockers {
                try blockersContainer.encode(stageblockerdeclarationlist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let blockersContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.BlockerDeclaration?].self, forKey: .blockers)
        var blockersDecoded0:[CodePipelineClientTypes.BlockerDeclaration]? = nil
        if let blockersContainer = blockersContainer {
            blockersDecoded0 = [CodePipelineClientTypes.BlockerDeclaration]()
            for structure0 in blockersContainer {
                if let structure0 = structure0 {
                    blockersDecoded0?.append(structure0)
                }
            }
        }
        blockers = blockersDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.ActionDeclaration?].self, forKey: .actions)
        var actionsDecoded0:[CodePipelineClientTypes.ActionDeclaration]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [CodePipelineClientTypes.ActionDeclaration]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension CodePipelineClientTypes.StageDeclaration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StageDeclaration(actions: \(Swift.String(describing: actions)), blockers: \(Swift.String(describing: blockers)), name: \(Swift.String(describing: name)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about a stage and its definition.</p>
    public struct StageDeclaration: Swift.Equatable {
        /// <p>The actions included in a stage.</p>
        public let actions: [CodePipelineClientTypes.ActionDeclaration]?
        /// <p>Reserved for future use.</p>
        public let blockers: [CodePipelineClientTypes.BlockerDeclaration]?
        /// <p>The name of the stage.</p>
        public let name: Swift.String?

        public init (
            actions: [CodePipelineClientTypes.ActionDeclaration]? = nil,
            blockers: [CodePipelineClientTypes.BlockerDeclaration]? = nil,
            name: Swift.String? = nil
        )
        {
            self.actions = actions
            self.blockers = blockers
            self.name = name
        }
    }

}

extension CodePipelineClientTypes.StageExecution: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineExecutionId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineExecutionId = pipelineExecutionId {
            try encodeContainer.encode(pipelineExecutionId, forKey: .pipelineExecutionId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.StageExecutionStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CodePipelineClientTypes.StageExecution: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StageExecution(pipelineExecutionId: \(Swift.String(describing: pipelineExecutionId)), status: \(Swift.String(describing: status)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about the run of a stage.</p>
    public struct StageExecution: Swift.Equatable {
        /// <p>The ID of the pipeline execution associated with the stage.</p>
        public let pipelineExecutionId: Swift.String?
        /// <p>The status of the stage, or for a completed stage, the last status of the
        ///             stage.</p>
        ///         <note>
        ///             <p>A status of cancelled means that the pipelines definition was updated before the
        ///                 stage execution could be completed.</p>
        ///         </note>
        public let status: CodePipelineClientTypes.StageExecutionStatus?

        public init (
            pipelineExecutionId: Swift.String? = nil,
            status: CodePipelineClientTypes.StageExecutionStatus? = nil
        )
        {
            self.pipelineExecutionId = pipelineExecutionId
            self.status = status
        }
    }

}

extension CodePipelineClientTypes {
    public enum StageExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case failed
        case inprogress
        case stopped
        case stopping
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [StageExecutionStatus] {
            return [
                .cancelled,
                .failed,
                .inprogress,
                .stopped,
                .stopping,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "Cancelled"
            case .failed: return "Failed"
            case .inprogress: return "InProgress"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case .succeeded: return "Succeeded"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StageExecutionStatus(rawValue: rawValue) ?? StageExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension StageNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StageNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension StageNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StageNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The stage was specified in an invalid format or cannot be found.</p>
public struct StageNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StageNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension StageNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StageNotRetryableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StageNotRetryableException(message: \(Swift.String(describing: message)))"}
}

extension StageNotRetryableException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StageNotRetryableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Unable to retry. The pipeline structure or stage state might have changed while
///             actions awaited retry, or the stage contains no failed
///             actions.</p>
public struct StageNotRetryableException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StageNotRetryableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension StageNotRetryableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodePipelineClientTypes {
    public enum StageRetryMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failedActions
        case sdkUnknown(Swift.String)

        public static var allCases: [StageRetryMode] {
            return [
                .failedActions,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failedActions: return "FAILED_ACTIONS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StageRetryMode(rawValue: rawValue) ?? StageRetryMode.sdkUnknown(rawValue)
        }
    }
}

extension CodePipelineClientTypes.StageState: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionStates
        case inboundExecution
        case inboundTransitionState
        case latestExecution
        case stageName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionStates = actionStates {
            var actionStatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actionStates)
            for actionstatelist0 in actionStates {
                try actionStatesContainer.encode(actionstatelist0)
            }
        }
        if let inboundExecution = inboundExecution {
            try encodeContainer.encode(inboundExecution, forKey: .inboundExecution)
        }
        if let inboundTransitionState = inboundTransitionState {
            try encodeContainer.encode(inboundTransitionState, forKey: .inboundTransitionState)
        }
        if let latestExecution = latestExecution {
            try encodeContainer.encode(latestExecution, forKey: .latestExecution)
        }
        if let stageName = stageName {
            try encodeContainer.encode(stageName, forKey: .stageName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageName)
        stageName = stageNameDecoded
        let inboundExecutionDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.StageExecution.self, forKey: .inboundExecution)
        inboundExecution = inboundExecutionDecoded
        let inboundTransitionStateDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.TransitionState.self, forKey: .inboundTransitionState)
        inboundTransitionState = inboundTransitionStateDecoded
        let actionStatesContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.ActionState?].self, forKey: .actionStates)
        var actionStatesDecoded0:[CodePipelineClientTypes.ActionState]? = nil
        if let actionStatesContainer = actionStatesContainer {
            actionStatesDecoded0 = [CodePipelineClientTypes.ActionState]()
            for structure0 in actionStatesContainer {
                if let structure0 = structure0 {
                    actionStatesDecoded0?.append(structure0)
                }
            }
        }
        actionStates = actionStatesDecoded0
        let latestExecutionDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.StageExecution.self, forKey: .latestExecution)
        latestExecution = latestExecutionDecoded
    }
}

extension CodePipelineClientTypes.StageState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StageState(actionStates: \(Swift.String(describing: actionStates)), inboundExecution: \(Swift.String(describing: inboundExecution)), inboundTransitionState: \(Swift.String(describing: inboundTransitionState)), latestExecution: \(Swift.String(describing: latestExecution)), stageName: \(Swift.String(describing: stageName)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about the state of the stage.</p>
    public struct StageState: Swift.Equatable {
        /// <p>The state of the stage.</p>
        public let actionStates: [CodePipelineClientTypes.ActionState]?
        /// <p>Represents information about the run of a stage.</p>
        public let inboundExecution: CodePipelineClientTypes.StageExecution?
        /// <p>The state of the inbound transition, which is either enabled or disabled.</p>
        public let inboundTransitionState: CodePipelineClientTypes.TransitionState?
        /// <p>Information about the latest execution in the stage, including its ID and
        ///             status.</p>
        public let latestExecution: CodePipelineClientTypes.StageExecution?
        /// <p>The name of the stage.</p>
        public let stageName: Swift.String?

        public init (
            actionStates: [CodePipelineClientTypes.ActionState]? = nil,
            inboundExecution: CodePipelineClientTypes.StageExecution? = nil,
            inboundTransitionState: CodePipelineClientTypes.TransitionState? = nil,
            latestExecution: CodePipelineClientTypes.StageExecution? = nil,
            stageName: Swift.String? = nil
        )
        {
            self.actionStates = actionStates
            self.inboundExecution = inboundExecution
            self.inboundTransitionState = inboundTransitionState
            self.latestExecution = latestExecution
            self.stageName = stageName
        }
    }

}

extension CodePipelineClientTypes {
    public enum StageTransitionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inbound
        case outbound
        case sdkUnknown(Swift.String)

        public static var allCases: [StageTransitionType] {
            return [
                .inbound,
                .outbound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inbound: return "Inbound"
            case .outbound: return "Outbound"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StageTransitionType(rawValue: rawValue) ?? StageTransitionType.sdkUnknown(rawValue)
        }
    }
}

public struct StartPipelineExecutionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartPipelineExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartPipelineExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartPipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartPipelineExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartPipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartPipelineExecutionOutputError>
}

extension StartPipelineExecutionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartPipelineExecutionInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), name: \(Swift.String(describing: name)))"}
}

extension StartPipelineExecutionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct StartPipelineExecutionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartPipelineExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartPipelineExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartPipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartPipelineExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartPipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartPipelineExecutionOutputError>
}

public struct StartPipelineExecutionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartPipelineExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartPipelineExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartPipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartPipelineExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartPipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartPipelineExecutionOutputError>
}

/// <p>Represents the input of a <code>StartPipelineExecution</code> action.</p>
public struct StartPipelineExecutionInput: Swift.Equatable {
    /// <p>The system-generated unique ID used to identify a unique execution
    ///             request.</p>
    public var clientRequestToken: Swift.String?
    /// <p>The name of the pipeline to start.</p>
    public let name: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.name = name
    }
}

struct StartPipelineExecutionInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let clientRequestToken: Swift.String?
}

extension StartPipelineExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension StartPipelineExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartPipelineExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartPipelineExecutionOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartPipelineExecutionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartPipelineExecutionOutputResponse(pipelineExecutionId: \(Swift.String(describing: pipelineExecutionId)))"}
}

extension StartPipelineExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartPipelineExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pipelineExecutionId = output.pipelineExecutionId
        } else {
            self.pipelineExecutionId = nil
        }
    }
}

/// <p>Represents the output of a <code>StartPipelineExecution</code> action.</p>
public struct StartPipelineExecutionOutputResponse: Swift.Equatable {
    /// <p>The unique system-generated ID of the pipeline execution that was
    ///             started.</p>
    public let pipelineExecutionId: Swift.String?

    public init (
        pipelineExecutionId: Swift.String? = nil
    )
    {
        self.pipelineExecutionId = pipelineExecutionId
    }
}

struct StartPipelineExecutionOutputResponseBody: Swift.Equatable {
    public let pipelineExecutionId: Swift.String?
}

extension StartPipelineExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineExecutionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
    }
}

extension CodePipelineClientTypes.StopExecutionTrigger: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension CodePipelineClientTypes.StopExecutionTrigger: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopExecutionTrigger(reason: \(Swift.String(describing: reason)))"}
}

extension CodePipelineClientTypes {
    /// <p>The interaction that stopped a pipeline execution.</p>
    public struct StopExecutionTrigger: Swift.Equatable {
        /// <p>The user-specified reason the pipeline was stopped.</p>
        public let reason: Swift.String?

        public init (
            reason: Swift.String? = nil
        )
        {
            self.reason = reason
        }
    }

}

public struct StopPipelineExecutionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopPipelineExecutionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopPipelineExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopPipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopPipelineExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopPipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopPipelineExecutionOutputError>
}

extension StopPipelineExecutionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopPipelineExecutionInput(abandon: \(Swift.String(describing: abandon)), pipelineExecutionId: \(Swift.String(describing: pipelineExecutionId)), pipelineName: \(Swift.String(describing: pipelineName)), reason: \(Swift.String(describing: reason)))"}
}

extension StopPipelineExecutionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abandon
        case pipelineExecutionId
        case pipelineName
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if abandon != false {
            try encodeContainer.encode(abandon, forKey: .abandon)
        }
        if let pipelineExecutionId = pipelineExecutionId {
            try encodeContainer.encode(pipelineExecutionId, forKey: .pipelineExecutionId)
        }
        if let pipelineName = pipelineName {
            try encodeContainer.encode(pipelineName, forKey: .pipelineName)
        }
        if let reason = reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }
}

public struct StopPipelineExecutionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopPipelineExecutionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopPipelineExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopPipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopPipelineExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopPipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopPipelineExecutionOutputError>
}

public struct StopPipelineExecutionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StopPipelineExecutionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StopPipelineExecutionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StopPipelineExecutionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StopPipelineExecutionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StopPipelineExecutionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StopPipelineExecutionOutputError>
}

public struct StopPipelineExecutionInput: Swift.Equatable {
    /// <p>Use this option to stop the pipeline execution by abandoning, rather than finishing,
    ///             in-progress actions.</p>
    ///         <note>
    ///             <p>This option can lead to failed or out-of-sequence tasks.</p>
    ///         </note>
    public let abandon: Swift.Bool
    /// <p>The ID of the pipeline execution to be stopped in the current stage. Use the
    ///                 <code>GetPipelineState</code> action to retrieve the current
    ///             pipelineExecutionId.</p>
    public let pipelineExecutionId: Swift.String?
    /// <p>The name of the pipeline to stop.</p>
    public let pipelineName: Swift.String?
    /// <p>Use this option to enter comments, such as the reason the pipeline was stopped.</p>
    public let reason: Swift.String?

    public init (
        abandon: Swift.Bool = false,
        pipelineExecutionId: Swift.String? = nil,
        pipelineName: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.abandon = abandon
        self.pipelineExecutionId = pipelineExecutionId
        self.pipelineName = pipelineName
        self.reason = reason
    }
}

struct StopPipelineExecutionInputBody: Swift.Equatable {
    public let pipelineName: Swift.String?
    public let pipelineExecutionId: Swift.String?
    public let abandon: Swift.Bool
    public let reason: Swift.String?
}

extension StopPipelineExecutionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abandon
        case pipelineExecutionId
        case pipelineName
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineName)
        pipelineName = pipelineNameDecoded
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
        let abandonDecoded = try containerValues.decode(Swift.Bool.self, forKey: .abandon)
        abandon = abandonDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension StopPipelineExecutionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopPipelineExecutionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicatedStopRequestException" : self = .duplicatedStopRequestException(try DuplicatedStopRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineExecutionNotStoppableException" : self = .pipelineExecutionNotStoppableException(try PipelineExecutionNotStoppableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PipelineNotFoundException" : self = .pipelineNotFoundException(try PipelineNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopPipelineExecutionOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case duplicatedStopRequestException(DuplicatedStopRequestException)
    case pipelineExecutionNotStoppableException(PipelineExecutionNotStoppableException)
    case pipelineNotFoundException(PipelineNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopPipelineExecutionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StopPipelineExecutionOutputResponse(pipelineExecutionId: \(Swift.String(describing: pipelineExecutionId)))"}
}

extension StopPipelineExecutionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StopPipelineExecutionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pipelineExecutionId = output.pipelineExecutionId
        } else {
            self.pipelineExecutionId = nil
        }
    }
}

public struct StopPipelineExecutionOutputResponse: Swift.Equatable {
    /// <p>The unique system-generated ID of the pipeline execution that was stopped.</p>
    public let pipelineExecutionId: Swift.String?

    public init (
        pipelineExecutionId: Swift.String? = nil
    )
    {
        self.pipelineExecutionId = pipelineExecutionId
    }
}

struct StopPipelineExecutionOutputResponseBody: Swift.Equatable {
    public let pipelineExecutionId: Swift.String?
}

extension StopPipelineExecutionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineExecutionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineExecutionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineExecutionId)
        pipelineExecutionId = pipelineExecutionIdDecoded
    }
}

extension CodePipelineClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CodePipelineClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension CodePipelineClientTypes {
    /// <p>A tag is a key-value pair that is used to manage the resource.</p>
    public struct Tag: Swift.Equatable {
        /// <p>The tag's key.</p>
        public let key: Swift.String?
        /// <p>The tag's value.</p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource you want to add tags to.</p>
    public let resourceArn: Swift.String?
    /// <p>The tags you want to modify or add to the resource.</p>
    public let tags: [CodePipelineClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [CodePipelineClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tags: [CodePipelineClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CodePipelineClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CodePipelineClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagsException" : self = .invalidTagsException(try InvalidTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArnException(InvalidArnException)
    case invalidTagsException(InvalidTagsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension CodePipelineClientTypes.ThirdPartyJob: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientId
        case jobId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

extension CodePipelineClientTypes.ThirdPartyJob: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThirdPartyJob(clientId: \(Swift.String(describing: clientId)), jobId: \(Swift.String(describing: jobId)))"}
}

extension CodePipelineClientTypes {
    /// <p>A response to a <code>PollForThirdPartyJobs</code> request returned by AWS
    ///             CodePipeline when there is a job to be worked on by a partner action.</p>
    public struct ThirdPartyJob: Swift.Equatable {
        /// <p>The <code>clientToken</code> portion of the <code>clientId</code> and
        ///                 <code>clientToken</code> pair used to verify that the calling entity is allowed
        ///             access to the job and its details.</p>
        public let clientId: Swift.String?
        /// <p>The identifier used to identify the job in AWS CodePipeline.</p>
        public let jobId: Swift.String?

        public init (
            clientId: Swift.String? = nil,
            jobId: Swift.String? = nil
        )
        {
            self.clientId = clientId
            self.jobId = jobId
        }
    }

}

extension CodePipelineClientTypes.ThirdPartyJobData: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionConfiguration
        case actionTypeId
        case artifactCredentials
        case continuationToken
        case encryptionKey
        case inputArtifacts
        case outputArtifacts
        case pipelineContext
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionConfiguration = actionConfiguration {
            try encodeContainer.encode(actionConfiguration, forKey: .actionConfiguration)
        }
        if let actionTypeId = actionTypeId {
            try encodeContainer.encode(actionTypeId, forKey: .actionTypeId)
        }
        if let artifactCredentials = artifactCredentials {
            try encodeContainer.encode(artifactCredentials, forKey: .artifactCredentials)
        }
        if let continuationToken = continuationToken {
            try encodeContainer.encode(continuationToken, forKey: .continuationToken)
        }
        if let encryptionKey = encryptionKey {
            try encodeContainer.encode(encryptionKey, forKey: .encryptionKey)
        }
        if let inputArtifacts = inputArtifacts {
            var inputArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputArtifacts)
            for artifactlist0 in inputArtifacts {
                try inputArtifactsContainer.encode(artifactlist0)
            }
        }
        if let outputArtifacts = outputArtifacts {
            var outputArtifactsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputArtifacts)
            for artifactlist0 in outputArtifacts {
                try outputArtifactsContainer.encode(artifactlist0)
            }
        }
        if let pipelineContext = pipelineContext {
            try encodeContainer.encode(pipelineContext, forKey: .pipelineContext)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeIdDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionTypeId.self, forKey: .actionTypeId)
        actionTypeId = actionTypeIdDecoded
        let actionConfigurationDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionConfiguration.self, forKey: .actionConfiguration)
        actionConfiguration = actionConfigurationDecoded
        let pipelineContextDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.PipelineContext.self, forKey: .pipelineContext)
        pipelineContext = pipelineContextDecoded
        let inputArtifactsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.Artifact?].self, forKey: .inputArtifacts)
        var inputArtifactsDecoded0:[CodePipelineClientTypes.Artifact]? = nil
        if let inputArtifactsContainer = inputArtifactsContainer {
            inputArtifactsDecoded0 = [CodePipelineClientTypes.Artifact]()
            for structure0 in inputArtifactsContainer {
                if let structure0 = structure0 {
                    inputArtifactsDecoded0?.append(structure0)
                }
            }
        }
        inputArtifacts = inputArtifactsDecoded0
        let outputArtifactsContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.Artifact?].self, forKey: .outputArtifacts)
        var outputArtifactsDecoded0:[CodePipelineClientTypes.Artifact]? = nil
        if let outputArtifactsContainer = outputArtifactsContainer {
            outputArtifactsDecoded0 = [CodePipelineClientTypes.Artifact]()
            for structure0 in outputArtifactsContainer {
                if let structure0 = structure0 {
                    outputArtifactsDecoded0?.append(structure0)
                }
            }
        }
        outputArtifacts = outputArtifactsDecoded0
        let artifactCredentialsDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.AWSSessionCredentials.self, forKey: .artifactCredentials)
        artifactCredentials = artifactCredentialsDecoded
        let continuationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .continuationToken)
        continuationToken = continuationTokenDecoded
        let encryptionKeyDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.EncryptionKey.self, forKey: .encryptionKey)
        encryptionKey = encryptionKeyDecoded
    }
}

extension CodePipelineClientTypes.ThirdPartyJobData: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThirdPartyJobData(actionConfiguration: \(Swift.String(describing: actionConfiguration)), actionTypeId: \(Swift.String(describing: actionTypeId)), artifactCredentials: \(Swift.String(describing: artifactCredentials)), continuationToken: \(Swift.String(describing: continuationToken)), encryptionKey: \(Swift.String(describing: encryptionKey)), inputArtifacts: \(Swift.String(describing: inputArtifacts)), outputArtifacts: \(Swift.String(describing: outputArtifacts)), pipelineContext: \(Swift.String(describing: pipelineContext)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about the job data for a partner action.</p>
    public struct ThirdPartyJobData: Swift.Equatable {
        /// <p>Represents information about an action configuration.</p>
        public let actionConfiguration: CodePipelineClientTypes.ActionConfiguration?
        /// <p>Represents information about an action type.</p>
        public let actionTypeId: CodePipelineClientTypes.ActionTypeId?
        /// <p>Represents an AWS session credentials object. These credentials are temporary
        ///             credentials that are issued by AWS Secure Token Service (STS). They can be used to
        ///             access input and output artifacts in the S3 bucket used to store artifact for the
        ///             pipeline in AWS CodePipeline. </p>
        public let artifactCredentials: CodePipelineClientTypes.AWSSessionCredentials?
        /// <p>A system-generated token, such as a AWS CodeDeploy deployment ID, that a job
        ///             requires to continue the job asynchronously.</p>
        public let continuationToken: Swift.String?
        /// <p>The encryption key used to encrypt and decrypt data in the artifact store for the
        ///             pipeline, such as an AWS Key Management Service (AWS KMS) key. This is optional and
        ///             might not be present.</p>
        public let encryptionKey: CodePipelineClientTypes.EncryptionKey?
        /// <p>The name of the artifact that is worked on by the action, if any. This name might
        ///             be system-generated, such as "MyApp", or it might be defined by the user when the action
        ///             is created. The input artifact name must match the name of an output artifact generated
        ///             by an action in an earlier action or stage of the pipeline.</p>
        public let inputArtifacts: [CodePipelineClientTypes.Artifact]?
        /// <p>The name of the artifact that is the result of the action, if any. This name might
        ///             be system-generated, such as "MyBuiltApp", or it might be defined by the user when the
        ///             action is created.</p>
        public let outputArtifacts: [CodePipelineClientTypes.Artifact]?
        /// <p>Represents information about a pipeline to a job worker.</p>
        ///         <note>
        ///             <p>Does not include <code>pipelineArn</code> and <code>pipelineExecutionId</code>
        ///                 for ThirdParty jobs.</p>
        ///         </note>
        public let pipelineContext: CodePipelineClientTypes.PipelineContext?

        public init (
            actionConfiguration: CodePipelineClientTypes.ActionConfiguration? = nil,
            actionTypeId: CodePipelineClientTypes.ActionTypeId? = nil,
            artifactCredentials: CodePipelineClientTypes.AWSSessionCredentials? = nil,
            continuationToken: Swift.String? = nil,
            encryptionKey: CodePipelineClientTypes.EncryptionKey? = nil,
            inputArtifacts: [CodePipelineClientTypes.Artifact]? = nil,
            outputArtifacts: [CodePipelineClientTypes.Artifact]? = nil,
            pipelineContext: CodePipelineClientTypes.PipelineContext? = nil
        )
        {
            self.actionConfiguration = actionConfiguration
            self.actionTypeId = actionTypeId
            self.artifactCredentials = artifactCredentials
            self.continuationToken = continuationToken
            self.encryptionKey = encryptionKey
            self.inputArtifacts = inputArtifacts
            self.outputArtifacts = outputArtifacts
            self.pipelineContext = pipelineContext
        }
    }

}

extension CodePipelineClientTypes.ThirdPartyJobDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data
        case id
        case nonce
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let nonce = nonce {
            try encodeContainer.encode(nonce, forKey: .nonce)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let dataDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ThirdPartyJobData.self, forKey: .data)
        data = dataDecoded
        let nonceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nonce)
        nonce = nonceDecoded
    }
}

extension CodePipelineClientTypes.ThirdPartyJobDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThirdPartyJobDetails(data: \(Swift.String(describing: data)), id: \(Swift.String(describing: id)), nonce: \(Swift.String(describing: nonce)))"}
}

extension CodePipelineClientTypes {
    /// <p>The details of a job sent in response to a <code>GetThirdPartyJobDetails</code>
    ///             request.</p>
    public struct ThirdPartyJobDetails: Swift.Equatable {
        /// <p>The data to be returned by the third party job worker.</p>
        public let data: CodePipelineClientTypes.ThirdPartyJobData?
        /// <p>The identifier used to identify the job details in AWS CodePipeline.</p>
        public let id: Swift.String?
        /// <p>A system-generated random number that AWS CodePipeline uses to ensure that the job
        ///             is being worked on by only one job worker. Use this number in an <a>AcknowledgeThirdPartyJob</a> request.</p>
        public let nonce: Swift.String?

        public init (
            data: CodePipelineClientTypes.ThirdPartyJobData? = nil,
            id: Swift.String? = nil,
            nonce: Swift.String? = nil
        )
        {
            self.data = data
            self.id = id
            self.nonce = nonce
        }
    }

}

extension TooManyTagsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyTagsException(message: \(Swift.String(describing: message)))"}
}

extension TooManyTagsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The tags limit for a resource has been exceeded.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodePipelineClientTypes.TransitionState: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disabledReason
        case enabled
        case lastChangedAt
        case lastChangedBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disabledReason = disabledReason {
            try encodeContainer.encode(disabledReason, forKey: .disabledReason)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let lastChangedAt = lastChangedAt {
            try encodeContainer.encode(lastChangedAt.timeIntervalSince1970, forKey: .lastChangedAt)
        }
        if let lastChangedBy = lastChangedBy {
            try encodeContainer.encode(lastChangedBy, forKey: .lastChangedBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let lastChangedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastChangedBy)
        lastChangedBy = lastChangedByDecoded
        let lastChangedAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastChangedAt)
        lastChangedAt = lastChangedAtDecoded
        let disabledReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .disabledReason)
        disabledReason = disabledReasonDecoded
    }
}

extension CodePipelineClientTypes.TransitionState: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TransitionState(disabledReason: \(Swift.String(describing: disabledReason)), enabled: \(Swift.String(describing: enabled)), lastChangedAt: \(Swift.String(describing: lastChangedAt)), lastChangedBy: \(Swift.String(describing: lastChangedBy)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about the state of transitions between one stage and another
    ///             stage.</p>
    public struct TransitionState: Swift.Equatable {
        /// <p>The user-specified reason why the transition between two stages of a pipeline was
        ///             disabled.</p>
        public let disabledReason: Swift.String?
        /// <p>Whether the transition between stages is enabled (true) or disabled
        ///             (false).</p>
        public let enabled: Swift.Bool
        /// <p>The timestamp when the transition state was last changed.</p>
        public let lastChangedAt: ClientRuntime.Date?
        /// <p>The ID of the user who last changed the transition state.</p>
        public let lastChangedBy: Swift.String?

        public init (
            disabledReason: Swift.String? = nil,
            enabled: Swift.Bool = false,
            lastChangedAt: ClientRuntime.Date? = nil,
            lastChangedBy: Swift.String? = nil
        )
        {
            self.disabledReason = disabledReason
            self.enabled = enabled
            self.lastChangedAt = lastChangedAt
            self.lastChangedBy = lastChangedBy
        }
    }

}

extension CodePipelineClientTypes {
    public enum TriggerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudwatchevent
        case createpipeline
        case pollforsourcechanges
        case putactionrevision
        case startpipelineexecution
        case webhook
        case sdkUnknown(Swift.String)

        public static var allCases: [TriggerType] {
            return [
                .cloudwatchevent,
                .createpipeline,
                .pollforsourcechanges,
                .putactionrevision,
                .startpipelineexecution,
                .webhook,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudwatchevent: return "CloudWatchEvent"
            case .createpipeline: return "CreatePipeline"
            case .pollforsourcechanges: return "PollForSourceChanges"
            case .putactionrevision: return "PutActionRevision"
            case .startpipelineexecution: return "StartPipelineExecution"
            case .webhook: return "Webhook"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TriggerType(rawValue: rawValue) ?? TriggerType.sdkUnknown(rawValue)
        }
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// <p> The Amazon Resource Name (ARN) of the resource to remove tags from.</p>
    public let resourceArn: Swift.String?
    /// <p>The list of keys for the tags to be removed from the resource.</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArnException" : self = .invalidArnException(try InvalidArnException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidTagsException" : self = .invalidTagsException(try InvalidTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidArnException(InvalidArnException)
    case invalidTagsException(InvalidTagsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateActionTypeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateActionTypeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateActionTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateActionTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateActionTypeOutputError>
}

extension UpdateActionTypeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateActionTypeInput(actionType: \(Swift.String(describing: actionType)))"}
}

extension UpdateActionTypeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionType = actionType {
            try encodeContainer.encode(actionType, forKey: .actionType)
        }
    }
}

public struct UpdateActionTypeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateActionTypeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateActionTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateActionTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateActionTypeOutputError>
}

public struct UpdateActionTypeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateActionTypeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateActionTypeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateActionTypeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateActionTypeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateActionTypeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateActionTypeOutputError>
}

public struct UpdateActionTypeInput: Swift.Equatable {
    /// <p>The action type definition for the action type to be updated.</p>
    public let actionType: CodePipelineClientTypes.ActionTypeDeclaration?

    public init (
        actionType: CodePipelineClientTypes.ActionTypeDeclaration? = nil
    )
    {
        self.actionType = actionType
    }
}

struct UpdateActionTypeInputBody: Swift.Equatable {
    public let actionType: CodePipelineClientTypes.ActionTypeDeclaration?
}

extension UpdateActionTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.ActionTypeDeclaration.self, forKey: .actionType)
        actionType = actionTypeDecoded
    }
}

extension UpdateActionTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateActionTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ActionTypeNotFoundException" : self = .actionTypeNotFoundException(try ActionTypeNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestFailedException" : self = .requestFailedException(try RequestFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateActionTypeOutputError: Swift.Error, Swift.Equatable {
    case actionTypeNotFoundException(ActionTypeNotFoundException)
    case requestFailedException(RequestFailedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateActionTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateActionTypeOutputResponse()"}
}

extension UpdateActionTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateActionTypeOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateActionTypeOutputResponseBody: Swift.Equatable {
}

extension UpdateActionTypeOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdatePipelineInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePipelineInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePipelineOutputError>
}

extension UpdatePipelineInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePipelineInput(pipeline: \(Swift.String(describing: pipeline)))"}
}

extension UpdatePipelineInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipeline
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipeline = pipeline {
            try encodeContainer.encode(pipeline, forKey: .pipeline)
        }
    }
}

public struct UpdatePipelineInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePipelineInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePipelineOutputError>
}

public struct UpdatePipelineInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePipelineInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePipelineInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePipelineOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePipelineInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePipelineOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePipelineOutputError>
}

/// <p>Represents the input of an <code>UpdatePipeline</code> action.</p>
public struct UpdatePipelineInput: Swift.Equatable {
    /// <p>The name of the pipeline to be updated.</p>
    public let pipeline: CodePipelineClientTypes.PipelineDeclaration?

    public init (
        pipeline: CodePipelineClientTypes.PipelineDeclaration? = nil
    )
    {
        self.pipeline = pipeline
    }
}

struct UpdatePipelineInputBody: Swift.Equatable {
    public let pipeline: CodePipelineClientTypes.PipelineDeclaration?
}

extension UpdatePipelineInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipeline
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.PipelineDeclaration.self, forKey: .pipeline)
        pipeline = pipelineDecoded
    }
}

extension UpdatePipelineOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePipelineOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidActionDeclarationException" : self = .invalidActionDeclarationException(try InvalidActionDeclarationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidBlockerDeclarationException" : self = .invalidBlockerDeclarationException(try InvalidBlockerDeclarationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStageDeclarationException" : self = .invalidStageDeclarationException(try InvalidStageDeclarationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStructureException" : self = .invalidStructureException(try InvalidStructureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePipelineOutputError: Swift.Error, Swift.Equatable {
    case invalidActionDeclarationException(InvalidActionDeclarationException)
    case invalidBlockerDeclarationException(InvalidBlockerDeclarationException)
    case invalidStageDeclarationException(InvalidStageDeclarationException)
    case invalidStructureException(InvalidStructureException)
    case limitExceededException(LimitExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePipelineOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePipelineOutputResponse(pipeline: \(Swift.String(describing: pipeline)))"}
}

extension UpdatePipelineOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePipelineOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pipeline = output.pipeline
        } else {
            self.pipeline = nil
        }
    }
}

/// <p>Represents the output of an <code>UpdatePipeline</code> action.</p>
public struct UpdatePipelineOutputResponse: Swift.Equatable {
    /// <p>The structure of the updated pipeline.</p>
    public let pipeline: CodePipelineClientTypes.PipelineDeclaration?

    public init (
        pipeline: CodePipelineClientTypes.PipelineDeclaration? = nil
    )
    {
        self.pipeline = pipeline
    }
}

struct UpdatePipelineOutputResponseBody: Swift.Equatable {
    public let pipeline: CodePipelineClientTypes.PipelineDeclaration?
}

extension UpdatePipelineOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipeline
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.PipelineDeclaration.self, forKey: .pipeline)
        pipeline = pipelineDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The validation was specified in an invalid format.</p>
public struct ValidationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>The message provided to the user in the event of an exception.</p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodePipelineClientTypes.WebhookAuthConfiguration: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedIPRange = "AllowedIPRange"
        case secretToken = "SecretToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedIPRange = allowedIPRange {
            try encodeContainer.encode(allowedIPRange, forKey: .allowedIPRange)
        }
        if let secretToken = secretToken {
            try encodeContainer.encode(secretToken, forKey: .secretToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedIPRangeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedIPRange)
        allowedIPRange = allowedIPRangeDecoded
        let secretTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretToken)
        secretToken = secretTokenDecoded
    }
}

extension CodePipelineClientTypes.WebhookAuthConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WebhookAuthConfiguration(allowedIPRange: \(Swift.String(describing: allowedIPRange)), secretToken: \(Swift.String(describing: secretToken)))"}
}

extension CodePipelineClientTypes {
    /// <p>The authentication applied to incoming webhook trigger requests.</p>
    public struct WebhookAuthConfiguration: Swift.Equatable {
        /// <p>The property used to configure acceptance of webhooks in an IP address range. For
        ///             IP, only the <code>AllowedIPRange</code> property must be set. This property must be set
        ///             to a valid CIDR range.</p>
        public let allowedIPRange: Swift.String?
        /// <p>The property used to configure GitHub authentication. For GITHUB_HMAC, only the
        ///                 <code>SecretToken</code> property must be set.</p>
        public let secretToken: Swift.String?

        public init (
            allowedIPRange: Swift.String? = nil,
            secretToken: Swift.String? = nil
        )
        {
            self.allowedIPRange = allowedIPRange
            self.secretToken = secretToken
        }
    }

}

extension CodePipelineClientTypes {
    public enum WebhookAuthenticationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case githubHmac
        case ip
        case unauthenticated
        case sdkUnknown(Swift.String)

        public static var allCases: [WebhookAuthenticationType] {
            return [
                .githubHmac,
                .ip,
                .unauthenticated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .githubHmac: return "GITHUB_HMAC"
            case .ip: return "IP"
            case .unauthenticated: return "UNAUTHENTICATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WebhookAuthenticationType(rawValue: rawValue) ?? WebhookAuthenticationType.sdkUnknown(rawValue)
        }
    }
}

extension CodePipelineClientTypes.WebhookDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authentication
        case authenticationConfiguration
        case filters
        case name
        case targetAction
        case targetPipeline
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authentication = authentication {
            try encodeContainer.encode(authentication.rawValue, forKey: .authentication)
        }
        if let authenticationConfiguration = authenticationConfiguration {
            try encodeContainer.encode(authenticationConfiguration, forKey: .authenticationConfiguration)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for webhookfilters0 in filters {
                try filtersContainer.encode(webhookfilters0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let targetAction = targetAction {
            try encodeContainer.encode(targetAction, forKey: .targetAction)
        }
        if let targetPipeline = targetPipeline {
            try encodeContainer.encode(targetPipeline, forKey: .targetPipeline)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let targetPipelineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetPipeline)
        targetPipeline = targetPipelineDecoded
        let targetActionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetAction)
        targetAction = targetActionDecoded
        let filtersContainer = try containerValues.decodeIfPresent([CodePipelineClientTypes.WebhookFilterRule?].self, forKey: .filters)
        var filtersDecoded0:[CodePipelineClientTypes.WebhookFilterRule]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [CodePipelineClientTypes.WebhookFilterRule]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let authenticationDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.WebhookAuthenticationType.self, forKey: .authentication)
        authentication = authenticationDecoded
        let authenticationConfigurationDecoded = try containerValues.decodeIfPresent(CodePipelineClientTypes.WebhookAuthConfiguration.self, forKey: .authenticationConfiguration)
        authenticationConfiguration = authenticationConfigurationDecoded
    }
}

extension CodePipelineClientTypes.WebhookDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WebhookDefinition(authentication: \(Swift.String(describing: authentication)), authenticationConfiguration: \(Swift.String(describing: authenticationConfiguration)), filters: \(Swift.String(describing: filters)), name: \(Swift.String(describing: name)), targetAction: \(Swift.String(describing: targetAction)), targetPipeline: \(Swift.String(describing: targetPipeline)))"}
}

extension CodePipelineClientTypes {
    /// <p>Represents information about a webhook and its definition.</p>
    public struct WebhookDefinition: Swift.Equatable {
        /// <p>Supported options are GITHUB_HMAC, IP, and UNAUTHENTICATED.</p>
        ///         <ul>
        ///             <li>
        ///                 <p>For information about the authentication scheme implemented by GITHUB_HMAC,
        ///                     see <a href="https://developer.github.com/webhooks/securing/">Securing your
        ///                         webhooks</a> on the GitHub Developer website.</p>
        ///             </li>
        ///             <li>
        ///                 <p> IP rejects webhooks trigger requests unless they originate from an IP
        ///                     address in the IP range whitelisted in the authentication
        ///                     configuration.</p>
        ///             </li>
        ///             <li>
        ///                 <p> UNAUTHENTICATED accepts all webhook trigger requests regardless of
        ///                     origin.</p>
        ///             </li>
        ///          </ul>
        public let authentication: CodePipelineClientTypes.WebhookAuthenticationType?
        /// <p>Properties that configure the authentication applied to incoming webhook trigger
        ///             requests. The required properties depend on the authentication type. For GITHUB_HMAC,
        ///             only the <code>SecretToken </code>property must be set. For IP, only the
        ///                 <code>AllowedIPRange </code>property must be set to a valid CIDR range. For
        ///             UNAUTHENTICATED, no properties can be set.</p>
        public let authenticationConfiguration: CodePipelineClientTypes.WebhookAuthConfiguration?
        /// <p>A list of rules applied to the body/payload sent in the POST request to a webhook
        ///             URL. All defined rules must pass for the request to be accepted and the pipeline
        ///             started.</p>
        public let filters: [CodePipelineClientTypes.WebhookFilterRule]?
        /// <p>The name of the webhook.</p>
        public let name: Swift.String?
        /// <p>The name of the action in a pipeline you want to connect to the webhook. The action
        ///             must be from the source (first) stage of the pipeline.</p>
        public let targetAction: Swift.String?
        /// <p>The name of the pipeline you want to connect to the webhook.</p>
        public let targetPipeline: Swift.String?

        public init (
            authentication: CodePipelineClientTypes.WebhookAuthenticationType? = nil,
            authenticationConfiguration: CodePipelineClientTypes.WebhookAuthConfiguration? = nil,
            filters: [CodePipelineClientTypes.WebhookFilterRule]? = nil,
            name: Swift.String? = nil,
            targetAction: Swift.String? = nil,
            targetPipeline: Swift.String? = nil
        )
        {
            self.authentication = authentication
            self.authenticationConfiguration = authenticationConfiguration
            self.filters = filters
            self.name = name
            self.targetAction = targetAction
            self.targetPipeline = targetPipeline
        }
    }

}

extension CodePipelineClientTypes.WebhookFilterRule: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jsonPath
        case matchEquals
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jsonPath = jsonPath {
            try encodeContainer.encode(jsonPath, forKey: .jsonPath)
        }
        if let matchEquals = matchEquals {
            try encodeContainer.encode(matchEquals, forKey: .matchEquals)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jsonPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jsonPath)
        jsonPath = jsonPathDecoded
        let matchEqualsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .matchEquals)
        matchEquals = matchEqualsDecoded
    }
}

extension CodePipelineClientTypes.WebhookFilterRule: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WebhookFilterRule(jsonPath: \(Swift.String(describing: jsonPath)), matchEquals: \(Swift.String(describing: matchEquals)))"}
}

extension CodePipelineClientTypes {
    /// <p>The event criteria that specify when a webhook notification is sent to your
    ///             URL.</p>
    public struct WebhookFilterRule: Swift.Equatable {
        /// <p>A JsonPath expression that is applied to the body/payload of the webhook. The value
        ///             selected by the JsonPath expression must match the value specified in the
        ///                 <code>MatchEquals</code> field. Otherwise, the request is ignored. For more
        ///             information, see <a href="https://github.com/json-path/JsonPath">Java JsonPath
        ///                 implementation</a> in GitHub.</p>
        public let jsonPath: Swift.String?
        /// <p>The value selected by the <code>JsonPath</code> expression must match what is
        ///             supplied in the <code>MatchEquals</code> field. Otherwise, the request is ignored.
        ///             Properties from the target action configuration can be included as placeholders in this
        ///             value by surrounding the action configuration key with curly brackets. For example, if
        ///             the value supplied here is "refs/heads/{Branch}" and the target action has an action
        ///             configuration property called "Branch" with a value of "master", the
        ///                 <code>MatchEquals</code> value is evaluated as "refs/heads/master". For a list of
        ///             action configuration properties for built-in action types, see <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/reference-pipeline-structure.html#action-requirements">Pipeline Structure Reference Action Requirements</a>.</p>
        public let matchEquals: Swift.String?

        public init (
            jsonPath: Swift.String? = nil,
            matchEquals: Swift.String? = nil
        )
        {
            self.jsonPath = jsonPath
            self.matchEquals = matchEquals
        }
    }

}

extension WebhookNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "WebhookNotFoundException()"}
}

extension WebhookNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified webhook was entered in an invalid format or cannot be
///             found.</p>
public struct WebhookNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init() {}
}
