// Code generated by smithy-swift-codegen. DO NOT EDIT!



/// <p>Rules are processed in order. If there are multiple rules that match the line item, then the first rule to match is used to determine that Cost Category value.</p>
public struct CostCategoryRule: Equatable {
    /// <p>The value the line item will be categorized as, if the line item contains the matched dimension.</p>
    public let inheritedValue: CostCategoryInheritedValueDimension?
    /// <p>An <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a>
    ///             object used to categorize costs. This supports dimensions, tags, and nested expressions.
    ///             Currently the only dimensions supported are <code>LINKED_ACCOUNT</code>,
    ///                 <code>SERVICE_CODE</code>, <code>RECORD_TYPE</code>, and
    ///                 <code>LINKED_ACCOUNT_NAME</code>.</p>
    ///         <p>Root level <code>OR</code> is not supported. We recommend that you create a separate
    ///             rule instead.</p>
    ///
    ///         <p>
    ///             <code>RECORD_TYPE</code> is a dimension used for Cost Explorer APIs, and is also
    ///             supported for Cost Category expressions. This dimension uses different terms, depending
    ///             on whether you're using the console or API/JSON editor. For a detailed comparison, see
    ///             <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/manage-cost-categories.html#cost-categories-terms">Term Comparisons</a> in the <i>AWS Billing and Cost Management User
    ///                 Guide</i>.</p>
    public let rule: Expression?
    /// <p>You can define the <code>CostCategoryRule</code> rule type as either <code>REGULAR</code> or <code>INHERITED_VALUE</code>. The <code>INHERITED_VALUE</code> rule type adds the flexibility of defining a rule that dynamically inherits the cost category value from the dimension value defined by <code>CostCategoryInheritedValueDimension</code>. For example, if you wanted to dynamically group costs based on the value of a specific tag key, you would first choose an inherited value rule type, then choose the tag dimension and specify the tag key to use.</p>
    public let type: CostCategoryRuleType?
    /// <p>The default value for the cost category.</p>
    public let value: String?

    public init (
        inheritedValue: CostCategoryInheritedValueDimension? = nil,
        rule: Expression? = nil,
        type: CostCategoryRuleType? = nil,
        value: String? = nil
    )
    {
        self.inheritedValue = inheritedValue
        self.rule = rule
        self.type = type
        self.value = value
    }
}
