// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public enum AccountScope {
    case linked
    case payer
    case sdkUnknown(String)
}

extension AccountScope : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AccountScope] {
        return [
            .linked,
            .payer,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .linked: return "LINKED"
        case .payer: return "PAYER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AccountScope(rawValue: rawValue) ?? AccountScope.sdkUnknown(rawValue)
    }
}

extension Anomaly: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyEndDate = "AnomalyEndDate"
        case anomalyId = "AnomalyId"
        case anomalyScore = "AnomalyScore"
        case anomalyStartDate = "AnomalyStartDate"
        case dimensionValue = "DimensionValue"
        case feedback = "Feedback"
        case impact = "Impact"
        case monitorArn = "MonitorArn"
        case rootCauses = "RootCauses"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyEndDate = anomalyEndDate {
            try encodeContainer.encode(anomalyEndDate, forKey: .anomalyEndDate)
        }
        if let anomalyId = anomalyId {
            try encodeContainer.encode(anomalyId, forKey: .anomalyId)
        }
        if let anomalyScore = anomalyScore {
            try encodeContainer.encode(anomalyScore, forKey: .anomalyScore)
        }
        if let anomalyStartDate = anomalyStartDate {
            try encodeContainer.encode(anomalyStartDate, forKey: .anomalyStartDate)
        }
        if let dimensionValue = dimensionValue {
            try encodeContainer.encode(dimensionValue, forKey: .dimensionValue)
        }
        if let feedback = feedback {
            try encodeContainer.encode(feedback.rawValue, forKey: .feedback)
        }
        if let impact = impact {
            try encodeContainer.encode(impact, forKey: .impact)
        }
        if let monitorArn = monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let rootCauses = rootCauses {
            var rootCausesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rootCauses)
            for rootcauses0 in rootCauses {
                try rootCausesContainer.encode(rootcauses0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyId)
        anomalyId = anomalyIdDecoded
        let anomalyStartDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyStartDate)
        anomalyStartDate = anomalyStartDateDecoded
        let anomalyEndDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyEndDate)
        anomalyEndDate = anomalyEndDateDecoded
        let dimensionValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dimensionValue)
        dimensionValue = dimensionValueDecoded
        let rootCausesContainer = try containerValues.decodeIfPresent([RootCause?].self, forKey: .rootCauses)
        var rootCausesDecoded0:[RootCause]? = nil
        if let rootCausesContainer = rootCausesContainer {
            rootCausesDecoded0 = [RootCause]()
            for structure0 in rootCausesContainer {
                if let structure0 = structure0 {
                    rootCausesDecoded0?.append(structure0)
                }
            }
        }
        rootCauses = rootCausesDecoded0
        let anomalyScoreDecoded = try containerValues.decodeIfPresent(AnomalyScore.self, forKey: .anomalyScore)
        anomalyScore = anomalyScoreDecoded
        let impactDecoded = try containerValues.decodeIfPresent(Impact.self, forKey: .impact)
        impact = impactDecoded
        let monitorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let feedbackDecoded = try containerValues.decodeIfPresent(AnomalyFeedbackType.self, forKey: .feedback)
        feedback = feedbackDecoded
    }
}

extension Anomaly: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Anomaly(anomalyEndDate: \(String(describing: anomalyEndDate)), anomalyId: \(String(describing: anomalyId)), anomalyScore: \(String(describing: anomalyScore)), anomalyStartDate: \(String(describing: anomalyStartDate)), dimensionValue: \(String(describing: dimensionValue)), feedback: \(String(describing: feedback)), impact: \(String(describing: impact)), monitorArn: \(String(describing: monitorArn)), rootCauses: \(String(describing: rootCauses)))"}
}

/// <p>
///         An unusual cost pattern. This consists of the detailed metadata and the current status of the anomaly object.
///     </p>
public struct Anomaly: Equatable {
    /// <p>
    ///         The last day the anomaly is detected.
    ///     </p>
    public let anomalyEndDate: String?
    /// <p>
    ///         The unique identifier for the anomaly.
    ///     </p>
    public let anomalyId: String?
    /// <p>
    ///         The latest and maximum score for the anomaly.
    ///     </p>
    public let anomalyScore: AnomalyScore?
    /// <p>
    ///         The first day the anomaly is detected.
    ///     </p>
    public let anomalyStartDate: String?
    /// <p>
    ///         The dimension for the anomaly. For example, an AWS service in a service monitor.
    ///     </p>
    public let dimensionValue: String?
    /// <p>
    ///         The feedback value.
    ///     </p>
    public let feedback: AnomalyFeedbackType?
    /// <p>
    ///         The dollar impact for the anomaly.
    ///     </p>
    public let impact: Impact?
    /// <p> The Amazon Resource Name (ARN) for the cost monitor that generated this anomaly. </p>
    public let monitorArn: String?
    /// <p>
    ///         The list of identified root causes for the anomaly.
    ///     </p>
    public let rootCauses: [RootCause]?

    public init (
        anomalyEndDate: String? = nil,
        anomalyId: String? = nil,
        anomalyScore: AnomalyScore? = nil,
        anomalyStartDate: String? = nil,
        dimensionValue: String? = nil,
        feedback: AnomalyFeedbackType? = nil,
        impact: Impact? = nil,
        monitorArn: String? = nil,
        rootCauses: [RootCause]? = nil
    )
    {
        self.anomalyEndDate = anomalyEndDate
        self.anomalyId = anomalyId
        self.anomalyScore = anomalyScore
        self.anomalyStartDate = anomalyStartDate
        self.dimensionValue = dimensionValue
        self.feedback = feedback
        self.impact = impact
        self.monitorArn = monitorArn
        self.rootCauses = rootCauses
    }
}

extension AnomalyDateInterval: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endDate = "EndDate"
        case startDate = "StartDate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endDate = endDate {
            try encodeContainer.encode(endDate, forKey: .endDate)
        }
        if let startDate = startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endDate)
        endDate = endDateDecoded
    }
}

extension AnomalyDateInterval: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnomalyDateInterval(endDate: \(String(describing: endDate)), startDate: \(String(describing: startDate)))"}
}

/// <p>
///         The time period for an anomaly.
///     </p>
public struct AnomalyDateInterval: Equatable {
    /// <p>
    ///         The last date an anomaly was observed.
    ///     </p>
    public let endDate: String?
    /// <p>
    ///         The first date an anomaly was observed.
    ///     </p>
    public let startDate: String?

    public init (
        endDate: String? = nil,
        startDate: String? = nil
    )
    {
        self.endDate = endDate
        self.startDate = startDate
    }
}

public enum AnomalyFeedbackType {
    case no
    case plannedActivity
    case yes
    case sdkUnknown(String)
}

extension AnomalyFeedbackType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AnomalyFeedbackType] {
        return [
            .no,
            .plannedActivity,
            .yes,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .no: return "NO"
        case .plannedActivity: return "PLANNED_ACTIVITY"
        case .yes: return "YES"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AnomalyFeedbackType(rawValue: rawValue) ?? AnomalyFeedbackType.sdkUnknown(rawValue)
    }
}

extension AnomalyMonitor: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate = "CreationDate"
        case dimensionalValueCount = "DimensionalValueCount"
        case lastEvaluatedDate = "LastEvaluatedDate"
        case lastUpdatedDate = "LastUpdatedDate"
        case monitorArn = "MonitorArn"
        case monitorDimension = "MonitorDimension"
        case monitorName = "MonitorName"
        case monitorSpecification = "MonitorSpecification"
        case monitorType = "MonitorType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if dimensionalValueCount != 0 {
            try encodeContainer.encode(dimensionalValueCount, forKey: .dimensionalValueCount)
        }
        if let lastEvaluatedDate = lastEvaluatedDate {
            try encodeContainer.encode(lastEvaluatedDate, forKey: .lastEvaluatedDate)
        }
        if let lastUpdatedDate = lastUpdatedDate {
            try encodeContainer.encode(lastUpdatedDate, forKey: .lastUpdatedDate)
        }
        if let monitorArn = monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let monitorDimension = monitorDimension {
            try encodeContainer.encode(monitorDimension.rawValue, forKey: .monitorDimension)
        }
        if let monitorName = monitorName {
            try encodeContainer.encode(monitorName, forKey: .monitorName)
        }
        if let monitorSpecification = monitorSpecification {
            try encodeContainer.encode(monitorSpecification, forKey: .monitorSpecification)
        }
        if let monitorType = monitorType {
            try encodeContainer.encode(monitorType.rawValue, forKey: .monitorType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let monitorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdatedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedDate)
        lastUpdatedDate = lastUpdatedDateDecoded
        let lastEvaluatedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastEvaluatedDate)
        lastEvaluatedDate = lastEvaluatedDateDecoded
        let monitorTypeDecoded = try containerValues.decodeIfPresent(MonitorType.self, forKey: .monitorType)
        monitorType = monitorTypeDecoded
        let monitorDimensionDecoded = try containerValues.decodeIfPresent(MonitorDimension.self, forKey: .monitorDimension)
        monitorDimension = monitorDimensionDecoded
        let monitorSpecificationDecoded = try containerValues.decodeIfPresent(Expression.self, forKey: .monitorSpecification)
        monitorSpecification = monitorSpecificationDecoded
        let dimensionalValueCountDecoded = try containerValues.decode(Int.self, forKey: .dimensionalValueCount)
        dimensionalValueCount = dimensionalValueCountDecoded
    }
}

extension AnomalyMonitor: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnomalyMonitor(creationDate: \(String(describing: creationDate)), dimensionalValueCount: \(String(describing: dimensionalValueCount)), lastEvaluatedDate: \(String(describing: lastEvaluatedDate)), lastUpdatedDate: \(String(describing: lastUpdatedDate)), monitorArn: \(String(describing: monitorArn)), monitorDimension: \(String(describing: monitorDimension)), monitorName: \(String(describing: monitorName)), monitorSpecification: \(String(describing: monitorSpecification)), monitorType: \(String(describing: monitorType)))"}
}

/// <p> This object continuously inspects your account's cost data for anomalies, based on
///                 <code>MonitorType</code> and <code>MonitorSpecification</code>. The content consists
///             of detailed metadata and the current status of the monitor object. </p>
public struct AnomalyMonitor: Equatable {
    /// <p>
    ///         The date when the monitor was created.
    ///     </p>
    public let creationDate: String?
    /// <p>
    ///         The value for evaluated dimensions.
    ///     </p>
    public let dimensionalValueCount: Int
    /// <p>
    ///         The date when the monitor last evaluated for anomalies.
    ///     </p>
    public let lastEvaluatedDate: String?
    /// <p>
    ///         The date when the monitor was last updated.
    ///     </p>
    public let lastUpdatedDate: String?
    /// <p> The Amazon Resource Name (ARN) value. </p>
    public let monitorArn: String?
    /// <p>
    ///         The dimensions to evaluate.
    ///     </p>
    public let monitorDimension: MonitorDimension?
    /// <p>
    ///         The name of the monitor.
    ///     </p>
    public let monitorName: String?
    /// <p>Use <code>Expression</code> to filter by cost or by usage. There are two patterns: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>Simple dimension values - You can set the dimension name and values for the
    ///                     filters that you plan to use. For example, you can filter for
    ///                     <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>. The
    ///                         <code>Expression</code> example looks like:</p>
    ///                 <p>
    ///                   <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1",
    ///                         “us-west-1” ] } }</code>
    ///                 </p>
    ///                 <p>The list of dimension values are OR'd together to retrieve cost or usage
    ///                     data. You can create <code>Expression</code> and <code>DimensionValues</code>
    ///                     objects using either <code>with*</code> methods or <code>set*</code> methods in
    ///                     multiple lines. </p>
    ///             </li>
    ///             <li>
    ///                 <p>Compound dimension values with logical operations - You can use multiple
    ///                         <code>Expression</code> types and the logical operators
    ///                         <code>AND/OR/NOT</code> to create a list of one or more
    ///                         <code>Expression</code> objects. This allows you to filter on more advanced
    ///                     options. For example, you can filter on <code>((REGION == us-east-1 OR
    ///                         REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE !=
    ///                         DataTransfer)</code>. The <code>Expression</code> for that looks like
    ///                     this:</p>
    ///                 <p>
    ///                   <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION",
    ///                         "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName",
    ///                         "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE",
    ///                         "Values": ["DataTransfer"] }}} ] } </code>
    ///                </p>
    ///                 <note>
    ///                     <p>Because each <code>Expression</code> can have only one operator, the
    ///                         service returns an error if more than one is specified. The following
    ///                         example shows an <code>Expression</code> object that creates an
    ///                         error.</p>
    ///                 </note>
    ///                 <p>
    ///                     <code> { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE",
    ///                         "Values": [ "DataTransfer" ] } } </code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///         <note>
    ///             <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT is not
    ///                 supported. OR is not supported between different dimensions, or dimensions and tags.
    ///                 NOT operators aren't supported.
    ///                 Dimensions
    ///                 are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or
    ///                     <code>RIGHTSIZING_TYPE</code>.</p>
    /// 					
    /// 					       <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR are not supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
    /// 					
    /// 					
    /// 					
    ///          </note>
    public let monitorSpecification: Expression?
    /// <p>
    ///         The possible type values.
    ///     </p>
    public let monitorType: MonitorType?

    public init (
        creationDate: String? = nil,
        dimensionalValueCount: Int = 0,
        lastEvaluatedDate: String? = nil,
        lastUpdatedDate: String? = nil,
        monitorArn: String? = nil,
        monitorDimension: MonitorDimension? = nil,
        monitorName: String? = nil,
        monitorSpecification: Expression? = nil,
        monitorType: MonitorType? = nil
    )
    {
        self.creationDate = creationDate
        self.dimensionalValueCount = dimensionalValueCount
        self.lastEvaluatedDate = lastEvaluatedDate
        self.lastUpdatedDate = lastUpdatedDate
        self.monitorArn = monitorArn
        self.monitorDimension = monitorDimension
        self.monitorName = monitorName
        self.monitorSpecification = monitorSpecification
        self.monitorType = monitorType
    }
}

extension AnomalyScore: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentScore = "CurrentScore"
        case maxScore = "MaxScore"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if currentScore != 0.0 {
            try encodeContainer.encode(currentScore, forKey: .currentScore)
        }
        if maxScore != 0.0 {
            try encodeContainer.encode(maxScore, forKey: .maxScore)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxScoreDecoded = try containerValues.decode(Double.self, forKey: .maxScore)
        maxScore = maxScoreDecoded
        let currentScoreDecoded = try containerValues.decode(Double.self, forKey: .currentScore)
        currentScore = currentScoreDecoded
    }
}

extension AnomalyScore: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnomalyScore(currentScore: \(String(describing: currentScore)), maxScore: \(String(describing: maxScore)))"}
}

/// <p> Quantifies the anomaly. The higher score means that it is more anomalous. </p>
public struct AnomalyScore: Equatable {
    /// <p>
    ///        The last observed score.
    ///     </p>
    public let currentScore: Double
    /// <p>
    ///         The maximum score observed during the <code>AnomalyDateInterval</code>.
    ///     </p>
    public let maxScore: Double

    public init (
        currentScore: Double = 0.0,
        maxScore: Double = 0.0
    )
    {
        self.currentScore = currentScore
        self.maxScore = maxScore
    }
}

extension AnomalySubscription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case frequency = "Frequency"
        case monitorArnList = "MonitorArnList"
        case subscribers = "Subscribers"
        case subscriptionArn = "SubscriptionArn"
        case subscriptionName = "SubscriptionName"
        case threshold = "Threshold"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let frequency = frequency {
            try encodeContainer.encode(frequency.rawValue, forKey: .frequency)
        }
        if let monitorArnList = monitorArnList {
            var monitorArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monitorArnList)
            for monitorarnlist0 in monitorArnList {
                try monitorArnListContainer.encode(monitorarnlist0)
            }
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscribers0 in subscribers {
                try subscribersContainer.encode(subscribers0)
            }
        }
        if let subscriptionArn = subscriptionArn {
            try encodeContainer.encode(subscriptionArn, forKey: .subscriptionArn)
        }
        if let subscriptionName = subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
        if let threshold = threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let monitorArnListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .monitorArnList)
        var monitorArnListDecoded0:[String]? = nil
        if let monitorArnListContainer = monitorArnListContainer {
            monitorArnListDecoded0 = [String]()
            for string0 in monitorArnListContainer {
                if let string0 = string0 {
                    monitorArnListDecoded0?.append(string0)
                }
            }
        }
        monitorArnList = monitorArnListDecoded0
        let subscribersContainer = try containerValues.decodeIfPresent([Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
        let thresholdDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .threshold)
        threshold = thresholdDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(AnomalySubscriptionFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
    }
}

extension AnomalySubscription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnomalySubscription(accountId: \(String(describing: accountId)), frequency: \(String(describing: frequency)), monitorArnList: \(String(describing: monitorArnList)), subscribers: \(String(describing: subscribers)), subscriptionArn: \(String(describing: subscriptionArn)), subscriptionName: \(String(describing: subscriptionName)), threshold: \(String(describing: threshold)))"}
}

/// <p>
///         The association between a monitor, threshold, and list of subscribers used to deliver notifications about anomalies detected by a monitor that exceeds a threshold. The content consists of the detailed metadata and the current status of the <code>AnomalySubscription</code> object.
///     </p>
public struct AnomalySubscription: Equatable {
    /// <p>
    ///         Your unique account identifier.
    ///     </p>
    public let accountId: String?
    /// <p>
    ///         The frequency at which anomaly reports are sent over email.
    ///     </p>
    public let frequency: AnomalySubscriptionFrequency?
    /// <p>
    ///         A list of cost anomaly monitors.
    ///     </p>
    public let monitorArnList: [String]?
    /// <p>
    ///         A list of subscribers to notify.
    ///     </p>
    public let subscribers: [Subscriber]?
    /// <p> The <code>AnomalySubscription</code> Amazon Resource Name (ARN). </p>
    public let subscriptionArn: String?
    /// <p>
    ///         The name for the subscription.
    ///     </p>
    public let subscriptionName: String?
    /// <p>
    ///         The dollar value that triggers a notification if the threshold is exceeded.
    ///     </p>
    public let threshold: Double?

    public init (
        accountId: String? = nil,
        frequency: AnomalySubscriptionFrequency? = nil,
        monitorArnList: [String]? = nil,
        subscribers: [Subscriber]? = nil,
        subscriptionArn: String? = nil,
        subscriptionName: String? = nil,
        threshold: Double? = nil
    )
    {
        self.accountId = accountId
        self.frequency = frequency
        self.monitorArnList = monitorArnList
        self.subscribers = subscribers
        self.subscriptionArn = subscriptionArn
        self.subscriptionName = subscriptionName
        self.threshold = threshold
    }
}

public enum AnomalySubscriptionFrequency {
    case daily
    case immediate
    case weekly
    case sdkUnknown(String)
}

extension AnomalySubscriptionFrequency : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AnomalySubscriptionFrequency] {
        return [
            .daily,
            .immediate,
            .weekly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .daily: return "DAILY"
        case .immediate: return "IMMEDIATE"
        case .weekly: return "WEEKLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AnomalySubscriptionFrequency(rawValue: rawValue) ?? AnomalySubscriptionFrequency.sdkUnknown(rawValue)
    }
}

extension BillExpirationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BillExpirationException(message: \(String(describing: message)))"}
}

extension BillExpirationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BillExpirationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested report expired. Update the date interval and try again.</p>
public struct BillExpirationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BillExpirationExceptionBody: Equatable {
    public let message: String?
}

extension BillExpirationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum Context {
    case costAndUsage
    case reservations
    case savingsPlans
    case sdkUnknown(String)
}

extension Context : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Context] {
        return [
            .costAndUsage,
            .reservations,
            .savingsPlans,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .costAndUsage: return "COST_AND_USAGE"
        case .reservations: return "RESERVATIONS"
        case .savingsPlans: return "SAVINGS_PLANS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Context(rawValue: rawValue) ?? Context.sdkUnknown(rawValue)
    }
}

extension CostCategory: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case defaultValue = "DefaultValue"
        case effectiveEnd = "EffectiveEnd"
        case effectiveStart = "EffectiveStart"
        case name = "Name"
        case processingStatus = "ProcessingStatus"
        case ruleVersion = "RuleVersion"
        case rules = "Rules"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costCategoryArn = costCategoryArn {
            try encodeContainer.encode(costCategoryArn, forKey: .costCategoryArn)
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let effectiveEnd = effectiveEnd {
            try encodeContainer.encode(effectiveEnd, forKey: .effectiveEnd)
        }
        if let effectiveStart = effectiveStart {
            try encodeContainer.encode(effectiveStart, forKey: .effectiveStart)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let processingStatus = processingStatus {
            var processingStatusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processingStatus)
            for costcategoryprocessingstatuslist0 in processingStatus {
                try processingStatusContainer.encode(costcategoryprocessingstatuslist0)
            }
        }
        if let ruleVersion = ruleVersion {
            try encodeContainer.encode(ruleVersion.rawValue, forKey: .ruleVersion)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for costcategoryruleslist0 in rules {
                try rulesContainer.encode(costcategoryruleslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
        let effectiveStartDecoded = try containerValues.decodeIfPresent(String.self, forKey: .effectiveStart)
        effectiveStart = effectiveStartDecoded
        let effectiveEndDecoded = try containerValues.decodeIfPresent(String.self, forKey: .effectiveEnd)
        effectiveEnd = effectiveEndDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ruleVersionDecoded = try containerValues.decodeIfPresent(CostCategoryRuleVersion.self, forKey: .ruleVersion)
        ruleVersion = ruleVersionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([CostCategoryRule?].self, forKey: .rules)
        var rulesDecoded0:[CostCategoryRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [CostCategoryRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let processingStatusContainer = try containerValues.decodeIfPresent([CostCategoryProcessingStatus?].self, forKey: .processingStatus)
        var processingStatusDecoded0:[CostCategoryProcessingStatus]? = nil
        if let processingStatusContainer = processingStatusContainer {
            processingStatusDecoded0 = [CostCategoryProcessingStatus]()
            for structure0 in processingStatusContainer {
                if let structure0 = structure0 {
                    processingStatusDecoded0?.append(structure0)
                }
            }
        }
        processingStatus = processingStatusDecoded0
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension CostCategory: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CostCategory(costCategoryArn: \(String(describing: costCategoryArn)), defaultValue: \(String(describing: defaultValue)), effectiveEnd: \(String(describing: effectiveEnd)), effectiveStart: \(String(describing: effectiveStart)), name: \(String(describing: name)), processingStatus: \(String(describing: processingStatus)), ruleVersion: \(String(describing: ruleVersion)), rules: \(String(describing: rules)))"}
}

/// <p>The structure of Cost Categories. This includes detailed metadata and the set of rules for the <code>CostCategory</code> object.</p>
public struct CostCategory: Equatable {
    /// <p>
    ///             The unique identifier for your Cost Category.
    ///         </p>
    public let costCategoryArn: String?
    /// <p>The default value for the cost category.</p>
    public let defaultValue: String?
    /// <p>
    ///             The Cost Category's effective end date.</p>
    public let effectiveEnd: String?
    /// <p>
    ///             The Cost Category's effective start date.</p>
    public let effectiveStart: String?
    /// <p>The unique name of the Cost Category.</p>
    public let name: String?
    /// <p>
    ///             The list of processing statuses for Cost Management products for a specific cost category.
    ///         </p>
    public let processingStatus: [CostCategoryProcessingStatus]?
    /// <p>The rule schema version in this particular Cost Category.</p>
    public let ruleVersion: CostCategoryRuleVersion?
    /// <p>
    ///             Rules are processed in order. If there are multiple rules that match the line item, then the first rule to match is used to determine that Cost Category value.
    ///         </p>
    public let rules: [CostCategoryRule]?

    public init (
        costCategoryArn: String? = nil,
        defaultValue: String? = nil,
        effectiveEnd: String? = nil,
        effectiveStart: String? = nil,
        name: String? = nil,
        processingStatus: [CostCategoryProcessingStatus]? = nil,
        ruleVersion: CostCategoryRuleVersion? = nil,
        rules: [CostCategoryRule]? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.defaultValue = defaultValue
        self.effectiveEnd = effectiveEnd
        self.effectiveStart = effectiveStart
        self.name = name
        self.processingStatus = processingStatus
        self.ruleVersion = ruleVersion
        self.rules = rules
    }
}

extension CostCategoryInheritedValueDimension: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensionKey = "DimensionKey"
        case dimensionName = "DimensionName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionKey = dimensionKey {
            try encodeContainer.encode(dimensionKey, forKey: .dimensionKey)
        }
        if let dimensionName = dimensionName {
            try encodeContainer.encode(dimensionName.rawValue, forKey: .dimensionName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionNameDecoded = try containerValues.decodeIfPresent(CostCategoryInheritedValueDimensionName.self, forKey: .dimensionName)
        dimensionName = dimensionNameDecoded
        let dimensionKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dimensionKey)
        dimensionKey = dimensionKeyDecoded
    }
}

extension CostCategoryInheritedValueDimension: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CostCategoryInheritedValueDimension(dimensionKey: \(String(describing: dimensionKey)), dimensionName: \(String(describing: dimensionName)))"}
}

/// <p>When creating or updating a cost category, you can define the <code>CostCategoryRule</code> rule type as <code>INHERITED_VALUE</code>. This rule type adds the flexibility of defining a rule that dynamically inherits the cost category value from the dimension value defined by <code>CostCategoryInheritedValueDimension</code>. For example, if you wanted to dynamically group costs based on the value of a specific tag key, you would first choose an inherited value rule type, then choose the tag dimension and specify the tag key to use.</p>
public struct CostCategoryInheritedValueDimension: Equatable {
    /// <p>The key to extract cost category values.</p>
    public let dimensionKey: String?
    /// <p>The name of dimension for which to group costs.</p>
    /// 	        <p>If you specify <code>LINKED_ACCOUNT_NAME</code>, the cost category value will be based on account name. If you specify <code>TAG</code>, the cost category value will be based on the value of the specified tag key.</p>
    public let dimensionName: CostCategoryInheritedValueDimensionName?

    public init (
        dimensionKey: String? = nil,
        dimensionName: CostCategoryInheritedValueDimensionName? = nil
    )
    {
        self.dimensionKey = dimensionKey
        self.dimensionName = dimensionName
    }
}

public enum CostCategoryInheritedValueDimensionName {
    case linkedAccountName
    case tag
    case sdkUnknown(String)
}

extension CostCategoryInheritedValueDimensionName : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CostCategoryInheritedValueDimensionName] {
        return [
            .linkedAccountName,
            .tag,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .linkedAccountName: return "LINKED_ACCOUNT_NAME"
        case .tag: return "TAG"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CostCategoryInheritedValueDimensionName(rawValue: rawValue) ?? CostCategoryInheritedValueDimensionName.sdkUnknown(rawValue)
    }
}

extension CostCategoryProcessingStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case component = "Component"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let component = component {
            try encodeContainer.encode(component.rawValue, forKey: .component)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentDecoded = try containerValues.decodeIfPresent(CostCategoryStatusComponent.self, forKey: .component)
        component = componentDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CostCategoryStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CostCategoryProcessingStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CostCategoryProcessingStatus(component: \(String(describing: component)), status: \(String(describing: status)))"}
}

/// <p>
///             The list of processing statuses for Cost Management products for a specific cost category.
///         </p>
public struct CostCategoryProcessingStatus: Equatable {
    /// <p>
    ///             The Cost Management product name of the applied status.
    ///         </p>
    public let component: CostCategoryStatusComponent?
    /// <p>
    ///             The process status for a specific cost category.
    ///         </p>
    public let status: CostCategoryStatus?

    public init (
        component: CostCategoryStatusComponent? = nil,
        status: CostCategoryStatus? = nil
    )
    {
        self.component = component
        self.status = status
    }
}

extension CostCategoryReference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case defaultValue = "DefaultValue"
        case effectiveEnd = "EffectiveEnd"
        case effectiveStart = "EffectiveStart"
        case name = "Name"
        case numberOfRules = "NumberOfRules"
        case processingStatus = "ProcessingStatus"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costCategoryArn = costCategoryArn {
            try encodeContainer.encode(costCategoryArn, forKey: .costCategoryArn)
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let effectiveEnd = effectiveEnd {
            try encodeContainer.encode(effectiveEnd, forKey: .effectiveEnd)
        }
        if let effectiveStart = effectiveStart {
            try encodeContainer.encode(effectiveStart, forKey: .effectiveStart)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if numberOfRules != 0 {
            try encodeContainer.encode(numberOfRules, forKey: .numberOfRules)
        }
        if let processingStatus = processingStatus {
            var processingStatusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .processingStatus)
            for costcategoryprocessingstatuslist0 in processingStatus {
                try processingStatusContainer.encode(costcategoryprocessingstatuslist0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for costcategoryvalueslist0 in values {
                try valuesContainer.encode(costcategoryvalueslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let effectiveStartDecoded = try containerValues.decodeIfPresent(String.self, forKey: .effectiveStart)
        effectiveStart = effectiveStartDecoded
        let effectiveEndDecoded = try containerValues.decodeIfPresent(String.self, forKey: .effectiveEnd)
        effectiveEnd = effectiveEndDecoded
        let numberOfRulesDecoded = try containerValues.decode(Int.self, forKey: .numberOfRules)
        numberOfRules = numberOfRulesDecoded
        let processingStatusContainer = try containerValues.decodeIfPresent([CostCategoryProcessingStatus?].self, forKey: .processingStatus)
        var processingStatusDecoded0:[CostCategoryProcessingStatus]? = nil
        if let processingStatusContainer = processingStatusContainer {
            processingStatusDecoded0 = [CostCategoryProcessingStatus]()
            for structure0 in processingStatusContainer {
                if let structure0 = structure0 {
                    processingStatusDecoded0?.append(structure0)
                }
            }
        }
        processingStatus = processingStatusDecoded0
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension CostCategoryReference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CostCategoryReference(costCategoryArn: \(String(describing: costCategoryArn)), defaultValue: \(String(describing: defaultValue)), effectiveEnd: \(String(describing: effectiveEnd)), effectiveStart: \(String(describing: effectiveStart)), name: \(String(describing: name)), numberOfRules: \(String(describing: numberOfRules)), processingStatus: \(String(describing: processingStatus)), values: \(String(describing: values)))"}
}

/// <p>A reference to a Cost Category containing only enough information to identify the Cost Category.</p>
///         <p>You can use this information to retrieve the full Cost Category information using <code>DescribeCostCategory</code>.</p>
public struct CostCategoryReference: Equatable {
    /// <p>
    ///             The unique identifier for your Cost Category.
    ///         </p>
    public let costCategoryArn: String?
    /// <p>The default value for the cost category.</p>
    public let defaultValue: String?
    /// <p>
    ///             The Cost Category's effective end date.</p>
    public let effectiveEnd: String?
    /// <p>
    ///             The Cost Category's effective start date.</p>
    public let effectiveStart: String?
    /// <p>The unique name of the Cost Category.</p>
    public let name: String?
    /// <p>
    ///             The number of rules associated with a specific Cost Category.
    ///         </p>
    public let numberOfRules: Int
    /// <p>
    ///             The list of processing statuses for Cost Management products for a specific cost category.
    ///         </p>
    public let processingStatus: [CostCategoryProcessingStatus]?
    /// <p>
    ///             A list of unique cost category values in a specific cost category.
    ///         </p>
    public let values: [String]?

    public init (
        costCategoryArn: String? = nil,
        defaultValue: String? = nil,
        effectiveEnd: String? = nil,
        effectiveStart: String? = nil,
        name: String? = nil,
        numberOfRules: Int = 0,
        processingStatus: [CostCategoryProcessingStatus]? = nil,
        values: [String]? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.defaultValue = defaultValue
        self.effectiveEnd = effectiveEnd
        self.effectiveStart = effectiveStart
        self.name = name
        self.numberOfRules = numberOfRules
        self.processingStatus = processingStatus
        self.values = values
    }
}

extension CostCategoryRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inheritedValue = "InheritedValue"
        case rule = "Rule"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inheritedValue = inheritedValue {
            try encodeContainer.encode(inheritedValue, forKey: .inheritedValue)
        }
        if let rule = rule {
            try encodeContainer.encode(rule, forKey: .rule)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let ruleDecoded = try containerValues.decodeIfPresent(Expression.self, forKey: .rule)
        rule = ruleDecoded
        let inheritedValueDecoded = try containerValues.decodeIfPresent(CostCategoryInheritedValueDimension.self, forKey: .inheritedValue)
        inheritedValue = inheritedValueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CostCategoryRuleType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CostCategoryRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CostCategoryRule(inheritedValue: \(String(describing: inheritedValue)), rule: \(String(describing: rule)), type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <p>Rules are processed in order. If there are multiple rules that match the line item, then the first rule to match is used to determine that Cost Category value.</p>
public struct CostCategoryRule: Equatable {
    /// <p>The value the line item will be categorized as, if the line item contains the matched dimension.</p>
    public let inheritedValue: CostCategoryInheritedValueDimension?
    /// <p>An <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a>
    ///             object used to categorize costs. This supports dimensions, tags, and nested expressions.
    ///             Currently the only dimensions supported are <code>LINKED_ACCOUNT</code>,
    ///                 <code>SERVICE_CODE</code>, <code>RECORD_TYPE</code>, and
    ///                 <code>LINKED_ACCOUNT_NAME</code>.</p>
    ///         <p>Root level <code>OR</code> is not supported. We recommend that you create a separate
    ///             rule instead.</p>
    ///
    ///         <p>
    ///             <code>RECORD_TYPE</code> is a dimension used for Cost Explorer APIs, and is also
    ///             supported for Cost Category expressions. This dimension uses different terms, depending
    ///             on whether you're using the console or API/JSON editor. For a detailed comparison, see
    ///             <a href="https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/manage-cost-categories.html#cost-categories-terms">Term Comparisons</a> in the <i>AWS Billing and Cost Management User
    ///                 Guide</i>.</p>
    public let rule: Expression?
    /// <p>You can define the <code>CostCategoryRule</code> rule type as either <code>REGULAR</code> or <code>INHERITED_VALUE</code>. The <code>INHERITED_VALUE</code> rule type adds the flexibility of defining a rule that dynamically inherits the cost category value from the dimension value defined by <code>CostCategoryInheritedValueDimension</code>. For example, if you wanted to dynamically group costs based on the value of a specific tag key, you would first choose an inherited value rule type, then choose the tag dimension and specify the tag key to use.</p>
    public let type: CostCategoryRuleType?
    /// <p>The default value for the cost category.</p>
    public let value: String?

    public init (
        inheritedValue: CostCategoryInheritedValueDimension? = nil,
        rule: Expression? = nil,
        type: CostCategoryRuleType? = nil,
        value: String? = nil
    )
    {
        self.inheritedValue = inheritedValue
        self.rule = rule
        self.type = type
        self.value = value
    }
}

public enum CostCategoryRuleType {
    case inheritedValue
    case regular
    case sdkUnknown(String)
}

extension CostCategoryRuleType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CostCategoryRuleType] {
        return [
            .inheritedValue,
            .regular,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .inheritedValue: return "INHERITED_VALUE"
        case .regular: return "REGULAR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CostCategoryRuleType(rawValue: rawValue) ?? CostCategoryRuleType.sdkUnknown(rawValue)
    }
}

/// <p>The rule schema version in this particular Cost Category.</p>
public enum CostCategoryRuleVersion {
    case costcategoryexpressionv1
    case sdkUnknown(String)
}

extension CostCategoryRuleVersion : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CostCategoryRuleVersion] {
        return [
            .costcategoryexpressionv1,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .costcategoryexpressionv1: return "CostCategoryExpression.v1"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CostCategoryRuleVersion(rawValue: rawValue) ?? CostCategoryRuleVersion.sdkUnknown(rawValue)
    }
}

public enum CostCategoryStatus {
    case applied
    case processing
    case sdkUnknown(String)
}

extension CostCategoryStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CostCategoryStatus] {
        return [
            .applied,
            .processing,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .applied: return "APPLIED"
        case .processing: return "PROCESSING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CostCategoryStatus(rawValue: rawValue) ?? CostCategoryStatus.sdkUnknown(rawValue)
    }
}

public enum CostCategoryStatusComponent {
    case costExplorer
    case sdkUnknown(String)
}

extension CostCategoryStatusComponent : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CostCategoryStatusComponent] {
        return [
            .costExplorer,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .costExplorer: return "COST_EXPLORER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CostCategoryStatusComponent(rawValue: rawValue) ?? CostCategoryStatusComponent.sdkUnknown(rawValue)
    }
}

extension CostCategoryValues: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case matchOptions = "MatchOptions"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let matchOptions = matchOptions {
            var matchOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchOptions)
            for matchoptions0 in matchOptions {
                try matchOptionsContainer.encode(matchoptions0.rawValue)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for values0 in values {
                try valuesContainer.encode(values0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let matchOptionsContainer = try containerValues.decodeIfPresent([MatchOption?].self, forKey: .matchOptions)
        var matchOptionsDecoded0:[MatchOption]? = nil
        if let matchOptionsContainer = matchOptionsContainer {
            matchOptionsDecoded0 = [MatchOption]()
            for string0 in matchOptionsContainer {
                if let string0 = string0 {
                    matchOptionsDecoded0?.append(string0)
                }
            }
        }
        matchOptions = matchOptionsDecoded0
    }
}

extension CostCategoryValues: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CostCategoryValues(key: \(String(describing: key)), matchOptions: \(String(describing: matchOptions)), values: \(String(describing: values)))"}
}

/// <p>The Cost Categories values used for filtering the costs.</p>
/// 		       <p>If <code>Values</code> and <code>Key</code> are not specified, the <code>ABSENT</code>
///             <code>MatchOption</code> is applied to all Cost Categories. That is, filtering on resources that are not mapped to any Cost Categories.</p>
///          <p>If <code>Values</code> is provided and <code>Key</code> is not specified, the <code>ABSENT</code>
///             <code>MatchOption</code> is applied to the Cost Categories <code>Key</code> only. That is, filtering on resources without the given Cost Categories key.</p>
public struct CostCategoryValues: Equatable {
    /// <p>The unique name of the Cost Category.</p>
    public let key: String?
    /// <p>
    ///             The match options that you can use to filter your results. MatchOptions is only applicable for actions related to cost category. The default values for <code>MatchOptions</code> is <code>EQUALS</code> and <code>CASE_SENSITIVE</code>.
    ///         </p>
    public let matchOptions: [MatchOption]?
    /// <p>The specific value of the Cost Category.</p>
    public let values: [String]?

    public init (
        key: String? = nil,
        matchOptions: [MatchOption]? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.matchOptions = matchOptions
        self.values = values
    }
}

extension Coverage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case coverageCost = "CoverageCost"
        case coverageHours = "CoverageHours"
        case coverageNormalizedUnits = "CoverageNormalizedUnits"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coverageCost = coverageCost {
            try encodeContainer.encode(coverageCost, forKey: .coverageCost)
        }
        if let coverageHours = coverageHours {
            try encodeContainer.encode(coverageHours, forKey: .coverageHours)
        }
        if let coverageNormalizedUnits = coverageNormalizedUnits {
            try encodeContainer.encode(coverageNormalizedUnits, forKey: .coverageNormalizedUnits)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coverageHoursDecoded = try containerValues.decodeIfPresent(CoverageHours.self, forKey: .coverageHours)
        coverageHours = coverageHoursDecoded
        let coverageNormalizedUnitsDecoded = try containerValues.decodeIfPresent(CoverageNormalizedUnits.self, forKey: .coverageNormalizedUnits)
        coverageNormalizedUnits = coverageNormalizedUnitsDecoded
        let coverageCostDecoded = try containerValues.decodeIfPresent(CoverageCost.self, forKey: .coverageCost)
        coverageCost = coverageCostDecoded
    }
}

extension Coverage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Coverage(coverageCost: \(String(describing: coverageCost)), coverageHours: \(String(describing: coverageHours)), coverageNormalizedUnits: \(String(describing: coverageNormalizedUnits)))"}
}

/// <p>The amount of instance usage that a reservation covered.</p>
public struct Coverage: Equatable {
    /// <p>The amount of cost that the reservation covered.</p>
    public let coverageCost: CoverageCost?
    /// <p>The amount of instance usage that the reservation covered, in hours.</p>
    public let coverageHours: CoverageHours?
    /// <p>The amount of instance usage that the reservation covered, in normalized
    ///             units.</p>
    public let coverageNormalizedUnits: CoverageNormalizedUnits?

    public init (
        coverageCost: CoverageCost? = nil,
        coverageHours: CoverageHours? = nil,
        coverageNormalizedUnits: CoverageNormalizedUnits? = nil
    )
    {
        self.coverageCost = coverageCost
        self.coverageHours = coverageHours
        self.coverageNormalizedUnits = coverageNormalizedUnits
    }
}

extension CoverageByTime: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groups = "Groups"
        case timePeriod = "TimePeriod"
        case total = "Total"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for reservationcoveragegroups0 in groups {
                try groupsContainer.encode(reservationcoveragegroups0)
            }
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let groupsContainer = try containerValues.decodeIfPresent([ReservationCoverageGroup?].self, forKey: .groups)
        var groupsDecoded0:[ReservationCoverageGroup]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [ReservationCoverageGroup]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(Coverage.self, forKey: .total)
        total = totalDecoded
    }
}

extension CoverageByTime: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CoverageByTime(groups: \(String(describing: groups)), timePeriod: \(String(describing: timePeriod)), total: \(String(describing: total)))"}
}

/// <p>Reservation
///             coverage for a specified period, in
///             hours.</p>
public struct CoverageByTime: Equatable {
    /// <p>The groups of instances that the reservation covered.</p>
    public let groups: [ReservationCoverageGroup]?
    /// <p>The period that this coverage was used over.</p>
    public let timePeriod: DateInterval?
    /// <p>The total reservation coverage, in hours.</p>
    public let total: Coverage?

    public init (
        groups: [ReservationCoverageGroup]? = nil,
        timePeriod: DateInterval? = nil,
        total: Coverage? = nil
    )
    {
        self.groups = groups
        self.timePeriod = timePeriod
        self.total = total
    }
}

extension CoverageCost: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case onDemandCost = "OnDemandCost"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let onDemandCost = onDemandCost {
            try encodeContainer.encode(onDemandCost, forKey: .onDemandCost)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let onDemandCostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .onDemandCost)
        onDemandCost = onDemandCostDecoded
    }
}

extension CoverageCost: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CoverageCost(onDemandCost: \(String(describing: onDemandCost)))"}
}

/// <p>How much it costs to run an instance.</p>
public struct CoverageCost: Equatable {
    /// <p>How much an On-Demand Instance costs.</p>
    public let onDemandCost: String?

    public init (
        onDemandCost: String? = nil
    )
    {
        self.onDemandCost = onDemandCost
    }
}

extension CoverageHours: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case coverageHoursPercentage = "CoverageHoursPercentage"
        case onDemandHours = "OnDemandHours"
        case reservedHours = "ReservedHours"
        case totalRunningHours = "TotalRunningHours"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coverageHoursPercentage = coverageHoursPercentage {
            try encodeContainer.encode(coverageHoursPercentage, forKey: .coverageHoursPercentage)
        }
        if let onDemandHours = onDemandHours {
            try encodeContainer.encode(onDemandHours, forKey: .onDemandHours)
        }
        if let reservedHours = reservedHours {
            try encodeContainer.encode(reservedHours, forKey: .reservedHours)
        }
        if let totalRunningHours = totalRunningHours {
            try encodeContainer.encode(totalRunningHours, forKey: .totalRunningHours)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let onDemandHoursDecoded = try containerValues.decodeIfPresent(String.self, forKey: .onDemandHours)
        onDemandHours = onDemandHoursDecoded
        let reservedHoursDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reservedHours)
        reservedHours = reservedHoursDecoded
        let totalRunningHoursDecoded = try containerValues.decodeIfPresent(String.self, forKey: .totalRunningHours)
        totalRunningHours = totalRunningHoursDecoded
        let coverageHoursPercentageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .coverageHoursPercentage)
        coverageHoursPercentage = coverageHoursPercentageDecoded
    }
}

extension CoverageHours: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CoverageHours(coverageHoursPercentage: \(String(describing: coverageHoursPercentage)), onDemandHours: \(String(describing: onDemandHours)), reservedHours: \(String(describing: reservedHours)), totalRunningHours: \(String(describing: totalRunningHours)))"}
}

/// <p>How long a running instance either used a reservation or was On-Demand.</p>
public struct CoverageHours: Equatable {
    /// <p>The percentage of instance hours that a reservation covered.</p>
    public let coverageHoursPercentage: String?
    /// <p>The number of instance running hours that On-Demand Instances covered.</p>
    public let onDemandHours: String?
    /// <p>The number of instance running hours that reservations covered.</p>
    public let reservedHours: String?
    /// <p>The total instance usage, in hours.</p>
    public let totalRunningHours: String?

    public init (
        coverageHoursPercentage: String? = nil,
        onDemandHours: String? = nil,
        reservedHours: String? = nil,
        totalRunningHours: String? = nil
    )
    {
        self.coverageHoursPercentage = coverageHoursPercentage
        self.onDemandHours = onDemandHours
        self.reservedHours = reservedHours
        self.totalRunningHours = totalRunningHours
    }
}

extension CoverageNormalizedUnits: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case coverageNormalizedUnitsPercentage = "CoverageNormalizedUnitsPercentage"
        case onDemandNormalizedUnits = "OnDemandNormalizedUnits"
        case reservedNormalizedUnits = "ReservedNormalizedUnits"
        case totalRunningNormalizedUnits = "TotalRunningNormalizedUnits"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coverageNormalizedUnitsPercentage = coverageNormalizedUnitsPercentage {
            try encodeContainer.encode(coverageNormalizedUnitsPercentage, forKey: .coverageNormalizedUnitsPercentage)
        }
        if let onDemandNormalizedUnits = onDemandNormalizedUnits {
            try encodeContainer.encode(onDemandNormalizedUnits, forKey: .onDemandNormalizedUnits)
        }
        if let reservedNormalizedUnits = reservedNormalizedUnits {
            try encodeContainer.encode(reservedNormalizedUnits, forKey: .reservedNormalizedUnits)
        }
        if let totalRunningNormalizedUnits = totalRunningNormalizedUnits {
            try encodeContainer.encode(totalRunningNormalizedUnits, forKey: .totalRunningNormalizedUnits)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let onDemandNormalizedUnitsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .onDemandNormalizedUnits)
        onDemandNormalizedUnits = onDemandNormalizedUnitsDecoded
        let reservedNormalizedUnitsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reservedNormalizedUnits)
        reservedNormalizedUnits = reservedNormalizedUnitsDecoded
        let totalRunningNormalizedUnitsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .totalRunningNormalizedUnits)
        totalRunningNormalizedUnits = totalRunningNormalizedUnitsDecoded
        let coverageNormalizedUnitsPercentageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .coverageNormalizedUnitsPercentage)
        coverageNormalizedUnitsPercentage = coverageNormalizedUnitsPercentageDecoded
    }
}

extension CoverageNormalizedUnits: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CoverageNormalizedUnits(coverageNormalizedUnitsPercentage: \(String(describing: coverageNormalizedUnitsPercentage)), onDemandNormalizedUnits: \(String(describing: onDemandNormalizedUnits)), reservedNormalizedUnits: \(String(describing: reservedNormalizedUnits)), totalRunningNormalizedUnits: \(String(describing: totalRunningNormalizedUnits)))"}
}

/// <p>The amount of instance usage, in normalized units. Normalized units enable you to
///             see your EC2 usage for multiple sizes of instances in a uniform way. For example,
///             suppose you run an xlarge instance and a 2xlarge instance. If you run both instances for
///             the same amount of time, the 2xlarge instance uses twice as much of your reservation as
///             the xlarge instance, even though both instances show only one instance-hour. Using
///             normalized units instead of instance-hours, the xlarge instance used 8 normalized units,
///             and the 2xlarge instance used 16 normalized units.</p>
///         <p>For more information, see <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ri-modifying.html">Modifying Reserved Instances</a> in the <i>Amazon Elastic Compute Cloud User Guide for
///                 Linux Instances</i>.</p>
public struct CoverageNormalizedUnits: Equatable {
    /// <p>The percentage of your used instance normalized units that a reservation
    ///             covers.</p>
    public let coverageNormalizedUnitsPercentage: String?
    /// <p>The number of normalized units that are covered by On-Demand Instances instead of a
    ///             reservation.</p>
    public let onDemandNormalizedUnits: String?
    /// <p>The number of normalized units that a reservation covers.</p>
    public let reservedNormalizedUnits: String?
    /// <p>The total number of normalized units that you used.</p>
    public let totalRunningNormalizedUnits: String?

    public init (
        coverageNormalizedUnitsPercentage: String? = nil,
        onDemandNormalizedUnits: String? = nil,
        reservedNormalizedUnits: String? = nil,
        totalRunningNormalizedUnits: String? = nil
    )
    {
        self.coverageNormalizedUnitsPercentage = coverageNormalizedUnitsPercentage
        self.onDemandNormalizedUnits = onDemandNormalizedUnits
        self.reservedNormalizedUnits = reservedNormalizedUnits
        self.totalRunningNormalizedUnits = totalRunningNormalizedUnits
    }
}

public struct CreateAnomalyMonitorInputBodyMiddleware: Middleware {
    public let id: String = "CreateAnomalyMonitorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAnomalyMonitorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAnomalyMonitorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAnomalyMonitorInput>
    public typealias MOutput = OperationOutput<CreateAnomalyMonitorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAnomalyMonitorOutputError>
}

extension CreateAnomalyMonitorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAnomalyMonitorInput(anomalyMonitor: \(String(describing: anomalyMonitor)))"}
}

extension CreateAnomalyMonitorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyMonitor = "AnomalyMonitor"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyMonitor = anomalyMonitor {
            try encodeContainer.encode(anomalyMonitor, forKey: .anomalyMonitor)
        }
    }
}

public struct CreateAnomalyMonitorInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAnomalyMonitorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAnomalyMonitorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAnomalyMonitorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAnomalyMonitorInput>
    public typealias MOutput = OperationOutput<CreateAnomalyMonitorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAnomalyMonitorOutputError>
}

public struct CreateAnomalyMonitorInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAnomalyMonitorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAnomalyMonitorInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAnomalyMonitorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAnomalyMonitorInput>
    public typealias MOutput = OperationOutput<CreateAnomalyMonitorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAnomalyMonitorOutputError>
}

public struct CreateAnomalyMonitorInput: Equatable {
    /// <p> The cost anomaly detection monitor object that you want to create.</p>
    public let anomalyMonitor: AnomalyMonitor?

    public init (
        anomalyMonitor: AnomalyMonitor? = nil
    )
    {
        self.anomalyMonitor = anomalyMonitor
    }
}

struct CreateAnomalyMonitorInputBody: Equatable {
    public let anomalyMonitor: AnomalyMonitor?
}

extension CreateAnomalyMonitorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyMonitor = "AnomalyMonitor"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyMonitorDecoded = try containerValues.decodeIfPresent(AnomalyMonitor.self, forKey: .anomalyMonitor)
        anomalyMonitor = anomalyMonitorDecoded
    }
}

extension CreateAnomalyMonitorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAnomalyMonitorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAnomalyMonitorOutputError: Swift.Error, Equatable {
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAnomalyMonitorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAnomalyMonitorOutputResponse(monitorArn: \(String(describing: monitorArn)))"}
}

extension CreateAnomalyMonitorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAnomalyMonitorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.monitorArn = output.monitorArn
        } else {
            self.monitorArn = nil
        }
    }
}

public struct CreateAnomalyMonitorOutputResponse: Equatable {
    /// <p> The unique identifier of your newly created cost anomaly detection monitor.</p>
    public let monitorArn: String?

    public init (
        monitorArn: String? = nil
    )
    {
        self.monitorArn = monitorArn
    }
}

struct CreateAnomalyMonitorOutputResponseBody: Equatable {
    public let monitorArn: String?
}

extension CreateAnomalyMonitorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case monitorArn = "MonitorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
    }
}

public struct CreateAnomalySubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "CreateAnomalySubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAnomalySubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAnomalySubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAnomalySubscriptionInput>
    public typealias MOutput = OperationOutput<CreateAnomalySubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAnomalySubscriptionOutputError>
}

extension CreateAnomalySubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAnomalySubscriptionInput(anomalySubscription: \(String(describing: anomalySubscription)))"}
}

extension CreateAnomalySubscriptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalySubscription = "AnomalySubscription"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalySubscription = anomalySubscription {
            try encodeContainer.encode(anomalySubscription, forKey: .anomalySubscription)
        }
    }
}

public struct CreateAnomalySubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAnomalySubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAnomalySubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAnomalySubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAnomalySubscriptionInput>
    public typealias MOutput = OperationOutput<CreateAnomalySubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAnomalySubscriptionOutputError>
}

public struct CreateAnomalySubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAnomalySubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAnomalySubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAnomalySubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAnomalySubscriptionInput>
    public typealias MOutput = OperationOutput<CreateAnomalySubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAnomalySubscriptionOutputError>
}

public struct CreateAnomalySubscriptionInput: Equatable {
    /// <p>
    ///       The cost anomaly subscription object that you want to create.
    ///     </p>
    public let anomalySubscription: AnomalySubscription?

    public init (
        anomalySubscription: AnomalySubscription? = nil
    )
    {
        self.anomalySubscription = anomalySubscription
    }
}

struct CreateAnomalySubscriptionInputBody: Equatable {
    public let anomalySubscription: AnomalySubscription?
}

extension CreateAnomalySubscriptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalySubscription = "AnomalySubscription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalySubscriptionDecoded = try containerValues.decodeIfPresent(AnomalySubscription.self, forKey: .anomalySubscription)
        anomalySubscription = anomalySubscriptionDecoded
    }
}

extension CreateAnomalySubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAnomalySubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownMonitorException" : self = .unknownMonitorException(try UnknownMonitorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAnomalySubscriptionOutputError: Swift.Error, Equatable {
    case limitExceededException(LimitExceededException)
    case unknownMonitorException(UnknownMonitorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAnomalySubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAnomalySubscriptionOutputResponse(subscriptionArn: \(String(describing: subscriptionArn)))"}
}

extension CreateAnomalySubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAnomalySubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.subscriptionArn = output.subscriptionArn
        } else {
            self.subscriptionArn = nil
        }
    }
}

public struct CreateAnomalySubscriptionOutputResponse: Equatable {
    /// <p>
    ///       The unique identifier of your newly created cost anomaly subscription.
    ///     </p>
    public let subscriptionArn: String?

    public init (
        subscriptionArn: String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

struct CreateAnomalySubscriptionOutputResponseBody: Equatable {
    public let subscriptionArn: String?
}

extension CreateAnomalySubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
    }
}

public struct CreateCostCategoryDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "CreateCostCategoryDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCostCategoryDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCostCategoryDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCostCategoryDefinitionInput>
    public typealias MOutput = OperationOutput<CreateCostCategoryDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCostCategoryDefinitionOutputError>
}

extension CreateCostCategoryDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCostCategoryDefinitionInput(defaultValue: \(String(describing: defaultValue)), name: \(String(describing: name)), ruleVersion: \(String(describing: ruleVersion)), rules: \(String(describing: rules)))"}
}

extension CreateCostCategoryDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultValue = "DefaultValue"
        case name = "Name"
        case ruleVersion = "RuleVersion"
        case rules = "Rules"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ruleVersion = ruleVersion {
            try encodeContainer.encode(ruleVersion.rawValue, forKey: .ruleVersion)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for costcategoryruleslist0 in rules {
                try rulesContainer.encode(costcategoryruleslist0)
            }
        }
    }
}

public struct CreateCostCategoryDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCostCategoryDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCostCategoryDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCostCategoryDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCostCategoryDefinitionInput>
    public typealias MOutput = OperationOutput<CreateCostCategoryDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCostCategoryDefinitionOutputError>
}

public struct CreateCostCategoryDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCostCategoryDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCostCategoryDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCostCategoryDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCostCategoryDefinitionInput>
    public typealias MOutput = OperationOutput<CreateCostCategoryDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCostCategoryDefinitionOutputError>
}

public struct CreateCostCategoryDefinitionInput: Equatable {
    /// <p>The default value for the cost category.</p>
    public let defaultValue: String?
    /// <p>The unique name of the Cost Category.</p>
    public let name: String?
    /// <p>The rule schema version in this particular Cost Category.</p>
    public let ruleVersion: CostCategoryRuleVersion?
    /// <p>The Cost Category rules used to categorize costs. For more information, see
    ///         <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategoryRule.html">CostCategoryRule</a>.</p>
    public let rules: [CostCategoryRule]?

    public init (
        defaultValue: String? = nil,
        name: String? = nil,
        ruleVersion: CostCategoryRuleVersion? = nil,
        rules: [CostCategoryRule]? = nil
    )
    {
        self.defaultValue = defaultValue
        self.name = name
        self.ruleVersion = ruleVersion
        self.rules = rules
    }
}

struct CreateCostCategoryDefinitionInputBody: Equatable {
    public let name: String?
    public let ruleVersion: CostCategoryRuleVersion?
    public let rules: [CostCategoryRule]?
    public let defaultValue: String?
}

extension CreateCostCategoryDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultValue = "DefaultValue"
        case name = "Name"
        case ruleVersion = "RuleVersion"
        case rules = "Rules"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let ruleVersionDecoded = try containerValues.decodeIfPresent(CostCategoryRuleVersion.self, forKey: .ruleVersion)
        ruleVersion = ruleVersionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([CostCategoryRule?].self, forKey: .rules)
        var rulesDecoded0:[CostCategoryRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [CostCategoryRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension CreateCostCategoryDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCostCategoryDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCostCategoryDefinitionOutputError: Swift.Error, Equatable {
    case limitExceededException(LimitExceededException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCostCategoryDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCostCategoryDefinitionOutputResponse(costCategoryArn: \(String(describing: costCategoryArn)), effectiveStart: \(String(describing: effectiveStart)))"}
}

extension CreateCostCategoryDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCostCategoryDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.costCategoryArn = output.costCategoryArn
            self.effectiveStart = output.effectiveStart
        } else {
            self.costCategoryArn = nil
            self.effectiveStart = nil
        }
    }
}

public struct CreateCostCategoryDefinitionOutputResponse: Equatable {
    /// <p>
    ///       The unique identifier for your newly created Cost Category.
    ///     </p>
    public let costCategoryArn: String?
    /// <p>
    ///       The Cost Category's effective start date.
    ///     </p>
    public let effectiveStart: String?

    public init (
        costCategoryArn: String? = nil,
        effectiveStart: String? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.effectiveStart = effectiveStart
    }
}

struct CreateCostCategoryDefinitionOutputResponseBody: Equatable {
    public let costCategoryArn: String?
    public let effectiveStart: String?
}

extension CreateCostCategoryDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case effectiveStart = "EffectiveStart"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
        let effectiveStartDecoded = try containerValues.decodeIfPresent(String.self, forKey: .effectiveStart)
        effectiveStart = effectiveStartDecoded
    }
}

extension CurrentInstance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currencyCode = "CurrencyCode"
        case instanceName = "InstanceName"
        case monthlyCost = "MonthlyCost"
        case onDemandHoursInLookbackPeriod = "OnDemandHoursInLookbackPeriod"
        case reservationCoveredHoursInLookbackPeriod = "ReservationCoveredHoursInLookbackPeriod"
        case resourceDetails = "ResourceDetails"
        case resourceId = "ResourceId"
        case resourceUtilization = "ResourceUtilization"
        case savingsPlansCoveredHoursInLookbackPeriod = "SavingsPlansCoveredHoursInLookbackPeriod"
        case tags = "Tags"
        case totalRunningHoursInLookbackPeriod = "TotalRunningHoursInLookbackPeriod"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let instanceName = instanceName {
            try encodeContainer.encode(instanceName, forKey: .instanceName)
        }
        if let monthlyCost = monthlyCost {
            try encodeContainer.encode(monthlyCost, forKey: .monthlyCost)
        }
        if let onDemandHoursInLookbackPeriod = onDemandHoursInLookbackPeriod {
            try encodeContainer.encode(onDemandHoursInLookbackPeriod, forKey: .onDemandHoursInLookbackPeriod)
        }
        if let reservationCoveredHoursInLookbackPeriod = reservationCoveredHoursInLookbackPeriod {
            try encodeContainer.encode(reservationCoveredHoursInLookbackPeriod, forKey: .reservationCoveredHoursInLookbackPeriod)
        }
        if let resourceDetails = resourceDetails {
            try encodeContainer.encode(resourceDetails, forKey: .resourceDetails)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceUtilization = resourceUtilization {
            try encodeContainer.encode(resourceUtilization, forKey: .resourceUtilization)
        }
        if let savingsPlansCoveredHoursInLookbackPeriod = savingsPlansCoveredHoursInLookbackPeriod {
            try encodeContainer.encode(savingsPlansCoveredHoursInLookbackPeriod, forKey: .savingsPlansCoveredHoursInLookbackPeriod)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagvalueslist0 in tags {
                try tagsContainer.encode(tagvalueslist0)
            }
        }
        if let totalRunningHoursInLookbackPeriod = totalRunningHoursInLookbackPeriod {
            try encodeContainer.encode(totalRunningHoursInLookbackPeriod, forKey: .totalRunningHoursInLookbackPeriod)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let instanceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceName)
        instanceName = instanceNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TagValues?].self, forKey: .tags)
        var tagsDecoded0:[TagValues]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TagValues]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let resourceDetailsDecoded = try containerValues.decodeIfPresent(ResourceDetails.self, forKey: .resourceDetails)
        resourceDetails = resourceDetailsDecoded
        let resourceUtilizationDecoded = try containerValues.decodeIfPresent(ResourceUtilization.self, forKey: .resourceUtilization)
        resourceUtilization = resourceUtilizationDecoded
        let reservationCoveredHoursInLookbackPeriodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .reservationCoveredHoursInLookbackPeriod)
        reservationCoveredHoursInLookbackPeriod = reservationCoveredHoursInLookbackPeriodDecoded
        let savingsPlansCoveredHoursInLookbackPeriodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .savingsPlansCoveredHoursInLookbackPeriod)
        savingsPlansCoveredHoursInLookbackPeriod = savingsPlansCoveredHoursInLookbackPeriodDecoded
        let onDemandHoursInLookbackPeriodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .onDemandHoursInLookbackPeriod)
        onDemandHoursInLookbackPeriod = onDemandHoursInLookbackPeriodDecoded
        let totalRunningHoursInLookbackPeriodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .totalRunningHoursInLookbackPeriod)
        totalRunningHoursInLookbackPeriod = totalRunningHoursInLookbackPeriodDecoded
        let monthlyCostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .monthlyCost)
        monthlyCost = monthlyCostDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
    }
}

extension CurrentInstance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CurrentInstance(currencyCode: \(String(describing: currencyCode)), instanceName: \(String(describing: instanceName)), monthlyCost: \(String(describing: monthlyCost)), onDemandHoursInLookbackPeriod: \(String(describing: onDemandHoursInLookbackPeriod)), reservationCoveredHoursInLookbackPeriod: \(String(describing: reservationCoveredHoursInLookbackPeriod)), resourceDetails: \(String(describing: resourceDetails)), resourceId: \(String(describing: resourceId)), resourceUtilization: \(String(describing: resourceUtilization)), savingsPlansCoveredHoursInLookbackPeriod: \(String(describing: savingsPlansCoveredHoursInLookbackPeriod)), tags: \(String(describing: tags)), totalRunningHoursInLookbackPeriod: \(String(describing: totalRunningHoursInLookbackPeriod)))"}
}

/// <p>Context about the current instance.</p>
public struct CurrentInstance: Equatable {
    /// <p> The currency code that AWS used to calculate the costs for this instance.</p>
    public let currencyCode: String?
    /// <p>The name you've given an instance. This field will show as blank if you haven't given the instance a name.</p>
    public let instanceName: String?
    /// <p> Current On-Demand cost of operating this instance on a monthly basis.</p>
    public let monthlyCost: String?
    /// <p> Number of hours during the lookback period billed at On-Demand rates.</p>
    public let onDemandHoursInLookbackPeriod: String?
    /// <p> Number of hours during the lookback period covered by reservations.</p>
    public let reservationCoveredHoursInLookbackPeriod: String?
    /// <p> Details about the resource and utilization.</p>
    public let resourceDetails: ResourceDetails?
    /// <p>Resource ID of the current instance.</p>
    public let resourceId: String?
    /// <p> Utilization information of the current instance during the lookback period.</p>
    public let resourceUtilization: ResourceUtilization?
    /// <p>Number of hours during the lookback period covered by Savings Plans.</p>
    public let savingsPlansCoveredHoursInLookbackPeriod: String?
    /// <p>Cost allocation resource tags applied to the instance.</p>
    public let tags: [TagValues]?
    /// <p> The total number of hours the instance ran during the lookback period.</p>
    public let totalRunningHoursInLookbackPeriod: String?

    public init (
        currencyCode: String? = nil,
        instanceName: String? = nil,
        monthlyCost: String? = nil,
        onDemandHoursInLookbackPeriod: String? = nil,
        reservationCoveredHoursInLookbackPeriod: String? = nil,
        resourceDetails: ResourceDetails? = nil,
        resourceId: String? = nil,
        resourceUtilization: ResourceUtilization? = nil,
        savingsPlansCoveredHoursInLookbackPeriod: String? = nil,
        tags: [TagValues]? = nil,
        totalRunningHoursInLookbackPeriod: String? = nil
    )
    {
        self.currencyCode = currencyCode
        self.instanceName = instanceName
        self.monthlyCost = monthlyCost
        self.onDemandHoursInLookbackPeriod = onDemandHoursInLookbackPeriod
        self.reservationCoveredHoursInLookbackPeriod = reservationCoveredHoursInLookbackPeriod
        self.resourceDetails = resourceDetails
        self.resourceId = resourceId
        self.resourceUtilization = resourceUtilization
        self.savingsPlansCoveredHoursInLookbackPeriod = savingsPlansCoveredHoursInLookbackPeriod
        self.tags = tags
        self.totalRunningHoursInLookbackPeriod = totalRunningHoursInLookbackPeriod
    }
}

extension DataUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DataUnavailableException(message: \(String(describing: message)))"}
}

extension DataUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DataUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested data is unavailable.</p>
public struct DataUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DataUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension DataUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DateInterval: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case end = "End"
        case start = "Start"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let end = end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let start = start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(String.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeIfPresent(String.self, forKey: .end)
        end = endDecoded
    }
}

extension DateInterval: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DateInterval(end: \(String(describing: end)), start: \(String(describing: start)))"}
}

/// <p>The time period of the request.
///         </p>
public struct DateInterval: Equatable {
    /// <p>The end of the time period. The end date is
    ///             exclusive. For example, if <code>end</code> is <code>2017-05-01</code>, AWS retrieves
    ///             cost and usage data from the start date up to, but not including,
    ///                 <code>2017-05-01</code>.</p>
    public let end: String?
    /// <p>The beginning of the time period. The start
    ///             date is inclusive. For example, if <code>start</code> is <code>2017-01-01</code>, AWS
    ///             retrieves cost and usage data starting at <code>2017-01-01</code> up to the end
    ///             date. The start date must be equal to or no later than the current date to avoid a validation error.</p>
    public let start: String?

    public init (
        end: String? = nil,
        start: String? = nil
    )
    {
        self.end = end
        self.start = start
    }
}

public struct DeleteAnomalyMonitorInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAnomalyMonitorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAnomalyMonitorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAnomalyMonitorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAnomalyMonitorInput>
    public typealias MOutput = OperationOutput<DeleteAnomalyMonitorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAnomalyMonitorOutputError>
}

extension DeleteAnomalyMonitorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAnomalyMonitorInput(monitorArn: \(String(describing: monitorArn)))"}
}

extension DeleteAnomalyMonitorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case monitorArn = "MonitorArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monitorArn = monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
    }
}

public struct DeleteAnomalyMonitorInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAnomalyMonitorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAnomalyMonitorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAnomalyMonitorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAnomalyMonitorInput>
    public typealias MOutput = OperationOutput<DeleteAnomalyMonitorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAnomalyMonitorOutputError>
}

public struct DeleteAnomalyMonitorInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAnomalyMonitorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAnomalyMonitorInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAnomalyMonitorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAnomalyMonitorInput>
    public typealias MOutput = OperationOutput<DeleteAnomalyMonitorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAnomalyMonitorOutputError>
}

public struct DeleteAnomalyMonitorInput: Equatable {
    /// <p> The unique identifier of the cost anomaly monitor that you want to delete. </p>
    public let monitorArn: String?

    public init (
        monitorArn: String? = nil
    )
    {
        self.monitorArn = monitorArn
    }
}

struct DeleteAnomalyMonitorInputBody: Equatable {
    public let monitorArn: String?
}

extension DeleteAnomalyMonitorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case monitorArn = "MonitorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
    }
}

extension DeleteAnomalyMonitorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAnomalyMonitorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownMonitorException" : self = .unknownMonitorException(try UnknownMonitorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAnomalyMonitorOutputError: Swift.Error, Equatable {
    case limitExceededException(LimitExceededException)
    case unknownMonitorException(UnknownMonitorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAnomalyMonitorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAnomalyMonitorOutputResponse()"}
}

extension DeleteAnomalyMonitorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAnomalyMonitorOutputResponse: Equatable {

    public init() {}
}

struct DeleteAnomalyMonitorOutputResponseBody: Equatable {
}

extension DeleteAnomalyMonitorOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteAnomalySubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAnomalySubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAnomalySubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAnomalySubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAnomalySubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteAnomalySubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAnomalySubscriptionOutputError>
}

extension DeleteAnomalySubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAnomalySubscriptionInput(subscriptionArn: \(String(describing: subscriptionArn)))"}
}

extension DeleteAnomalySubscriptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subscriptionArn = subscriptionArn {
            try encodeContainer.encode(subscriptionArn, forKey: .subscriptionArn)
        }
    }
}

public struct DeleteAnomalySubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAnomalySubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAnomalySubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAnomalySubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAnomalySubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteAnomalySubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAnomalySubscriptionOutputError>
}

public struct DeleteAnomalySubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAnomalySubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAnomalySubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAnomalySubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAnomalySubscriptionInput>
    public typealias MOutput = OperationOutput<DeleteAnomalySubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAnomalySubscriptionOutputError>
}

public struct DeleteAnomalySubscriptionInput: Equatable {
    /// <p> The unique identifier of the cost anomaly subscription that you want to delete. </p>
    public let subscriptionArn: String?

    public init (
        subscriptionArn: String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

struct DeleteAnomalySubscriptionInputBody: Equatable {
    public let subscriptionArn: String?
}

extension DeleteAnomalySubscriptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
    }
}

extension DeleteAnomalySubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAnomalySubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownSubscriptionException" : self = .unknownSubscriptionException(try UnknownSubscriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAnomalySubscriptionOutputError: Swift.Error, Equatable {
    case limitExceededException(LimitExceededException)
    case unknownSubscriptionException(UnknownSubscriptionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAnomalySubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAnomalySubscriptionOutputResponse()"}
}

extension DeleteAnomalySubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAnomalySubscriptionOutputResponse: Equatable {

    public init() {}
}

struct DeleteAnomalySubscriptionOutputResponseBody: Equatable {
}

extension DeleteAnomalySubscriptionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteCostCategoryDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteCostCategoryDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCostCategoryDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCostCategoryDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCostCategoryDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteCostCategoryDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCostCategoryDefinitionOutputError>
}

extension DeleteCostCategoryDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCostCategoryDefinitionInput(costCategoryArn: \(String(describing: costCategoryArn)))"}
}

extension DeleteCostCategoryDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case costCategoryArn = "CostCategoryArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costCategoryArn = costCategoryArn {
            try encodeContainer.encode(costCategoryArn, forKey: .costCategoryArn)
        }
    }
}

public struct DeleteCostCategoryDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCostCategoryDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCostCategoryDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCostCategoryDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCostCategoryDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteCostCategoryDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCostCategoryDefinitionOutputError>
}

public struct DeleteCostCategoryDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCostCategoryDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCostCategoryDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCostCategoryDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCostCategoryDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteCostCategoryDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCostCategoryDefinitionOutputError>
}

public struct DeleteCostCategoryDefinitionInput: Equatable {
    /// <p>
    ///       The unique identifier for your Cost Category.
    ///     </p>
    public let costCategoryArn: String?

    public init (
        costCategoryArn: String? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
    }
}

struct DeleteCostCategoryDefinitionInputBody: Equatable {
    public let costCategoryArn: String?
}

extension DeleteCostCategoryDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case costCategoryArn = "CostCategoryArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
    }
}

extension DeleteCostCategoryDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCostCategoryDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCostCategoryDefinitionOutputError: Swift.Error, Equatable {
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCostCategoryDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCostCategoryDefinitionOutputResponse(costCategoryArn: \(String(describing: costCategoryArn)), effectiveEnd: \(String(describing: effectiveEnd)))"}
}

extension DeleteCostCategoryDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteCostCategoryDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.costCategoryArn = output.costCategoryArn
            self.effectiveEnd = output.effectiveEnd
        } else {
            self.costCategoryArn = nil
            self.effectiveEnd = nil
        }
    }
}

public struct DeleteCostCategoryDefinitionOutputResponse: Equatable {
    /// <p>
    ///       The unique identifier for your Cost Category.
    ///     </p>
    public let costCategoryArn: String?
    /// <p>
    ///       The effective end date of the Cost Category as a result of deleting it. No costs after this date will be categorized by the deleted Cost Category.
    ///     </p>
    public let effectiveEnd: String?

    public init (
        costCategoryArn: String? = nil,
        effectiveEnd: String? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.effectiveEnd = effectiveEnd
    }
}

struct DeleteCostCategoryDefinitionOutputResponseBody: Equatable {
    public let costCategoryArn: String?
    public let effectiveEnd: String?
}

extension DeleteCostCategoryDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case effectiveEnd = "EffectiveEnd"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
        let effectiveEndDecoded = try containerValues.decodeIfPresent(String.self, forKey: .effectiveEnd)
        effectiveEnd = effectiveEndDecoded
    }
}

public struct DescribeCostCategoryDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "DescribeCostCategoryDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCostCategoryDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCostCategoryDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCostCategoryDefinitionInput>
    public typealias MOutput = OperationOutput<DescribeCostCategoryDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCostCategoryDefinitionOutputError>
}

extension DescribeCostCategoryDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCostCategoryDefinitionInput(costCategoryArn: \(String(describing: costCategoryArn)), effectiveOn: \(String(describing: effectiveOn)))"}
}

extension DescribeCostCategoryDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case effectiveOn = "EffectiveOn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costCategoryArn = costCategoryArn {
            try encodeContainer.encode(costCategoryArn, forKey: .costCategoryArn)
        }
        if let effectiveOn = effectiveOn {
            try encodeContainer.encode(effectiveOn, forKey: .effectiveOn)
        }
    }
}

public struct DescribeCostCategoryDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCostCategoryDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCostCategoryDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCostCategoryDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCostCategoryDefinitionInput>
    public typealias MOutput = OperationOutput<DescribeCostCategoryDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCostCategoryDefinitionOutputError>
}

public struct DescribeCostCategoryDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCostCategoryDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCostCategoryDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCostCategoryDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCostCategoryDefinitionInput>
    public typealias MOutput = OperationOutput<DescribeCostCategoryDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCostCategoryDefinitionOutputError>
}

public struct DescribeCostCategoryDefinitionInput: Equatable {
    /// <p>
    ///       The unique identifier for your Cost Category.
    ///     </p>
    public let costCategoryArn: String?
    /// <p>
    ///       The date when the Cost Category was effective.
    ///     </p>
    public let effectiveOn: String?

    public init (
        costCategoryArn: String? = nil,
        effectiveOn: String? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.effectiveOn = effectiveOn
    }
}

struct DescribeCostCategoryDefinitionInputBody: Equatable {
    public let costCategoryArn: String?
    public let effectiveOn: String?
}

extension DescribeCostCategoryDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case effectiveOn = "EffectiveOn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
        let effectiveOnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .effectiveOn)
        effectiveOn = effectiveOnDecoded
    }
}

extension DescribeCostCategoryDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCostCategoryDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCostCategoryDefinitionOutputError: Swift.Error, Equatable {
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCostCategoryDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCostCategoryDefinitionOutputResponse(costCategory: \(String(describing: costCategory)))"}
}

extension DescribeCostCategoryDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCostCategoryDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.costCategory = output.costCategory
        } else {
            self.costCategory = nil
        }
    }
}

public struct DescribeCostCategoryDefinitionOutputResponse: Equatable {
    /// <p>The structure of Cost Categories. This includes detailed metadata and the set of rules for the <code>CostCategory</code> object.</p>
    public let costCategory: CostCategory?

    public init (
        costCategory: CostCategory? = nil
    )
    {
        self.costCategory = costCategory
    }
}

struct DescribeCostCategoryDefinitionOutputResponseBody: Equatable {
    public let costCategory: CostCategory?
}

extension DescribeCostCategoryDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case costCategory = "CostCategory"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryDecoded = try containerValues.decodeIfPresent(CostCategory.self, forKey: .costCategory)
        costCategory = costCategoryDecoded
    }
}

public enum Dimension {
    case agreementEndDateTimeAfter
    case agreementEndDateTimeBefore
    case az
    case billingEntity
    case cacheEngine
    case databaseEngine
    case deploymentOption
    case instanceType
    case instanceTypeFamily
    case legalEntityName
    case linkedAccount
    case linkedAccountName
    case operatingSystem
    case operation
    case paymentOption
    case platform
    case purchaseType
    case recordType
    case region
    case reservationId
    case resourceId
    case rightsizingType
    case savingsPlansType
    case savingsPlanArn
    case scope
    case service
    case serviceCode
    case subscriptionId
    case tenancy
    case usageType
    case usageTypeGroup
    case sdkUnknown(String)
}

extension Dimension : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Dimension] {
        return [
            .agreementEndDateTimeAfter,
            .agreementEndDateTimeBefore,
            .az,
            .billingEntity,
            .cacheEngine,
            .databaseEngine,
            .deploymentOption,
            .instanceType,
            .instanceTypeFamily,
            .legalEntityName,
            .linkedAccount,
            .linkedAccountName,
            .operatingSystem,
            .operation,
            .paymentOption,
            .platform,
            .purchaseType,
            .recordType,
            .region,
            .reservationId,
            .resourceId,
            .rightsizingType,
            .savingsPlansType,
            .savingsPlanArn,
            .scope,
            .service,
            .serviceCode,
            .subscriptionId,
            .tenancy,
            .usageType,
            .usageTypeGroup,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .agreementEndDateTimeAfter: return "AGREEMENT_END_DATE_TIME_AFTER"
        case .agreementEndDateTimeBefore: return "AGREEMENT_END_DATE_TIME_BEFORE"
        case .az: return "AZ"
        case .billingEntity: return "BILLING_ENTITY"
        case .cacheEngine: return "CACHE_ENGINE"
        case .databaseEngine: return "DATABASE_ENGINE"
        case .deploymentOption: return "DEPLOYMENT_OPTION"
        case .instanceType: return "INSTANCE_TYPE"
        case .instanceTypeFamily: return "INSTANCE_TYPE_FAMILY"
        case .legalEntityName: return "LEGAL_ENTITY_NAME"
        case .linkedAccount: return "LINKED_ACCOUNT"
        case .linkedAccountName: return "LINKED_ACCOUNT_NAME"
        case .operatingSystem: return "OPERATING_SYSTEM"
        case .operation: return "OPERATION"
        case .paymentOption: return "PAYMENT_OPTION"
        case .platform: return "PLATFORM"
        case .purchaseType: return "PURCHASE_TYPE"
        case .recordType: return "RECORD_TYPE"
        case .region: return "REGION"
        case .reservationId: return "RESERVATION_ID"
        case .resourceId: return "RESOURCE_ID"
        case .rightsizingType: return "RIGHTSIZING_TYPE"
        case .savingsPlansType: return "SAVINGS_PLANS_TYPE"
        case .savingsPlanArn: return "SAVINGS_PLAN_ARN"
        case .scope: return "SCOPE"
        case .service: return "SERVICE"
        case .serviceCode: return "SERVICE_CODE"
        case .subscriptionId: return "SUBSCRIPTION_ID"
        case .tenancy: return "TENANCY"
        case .usageType: return "USAGE_TYPE"
        case .usageTypeGroup: return "USAGE_TYPE_GROUP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Dimension(rawValue: rawValue) ?? Dimension.sdkUnknown(rawValue)
    }
}

extension DimensionValues: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case matchOptions = "MatchOptions"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let matchOptions = matchOptions {
            var matchOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchOptions)
            for matchoptions0 in matchOptions {
                try matchOptionsContainer.encode(matchoptions0.rawValue)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for values0 in values {
                try valuesContainer.encode(values0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Dimension.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let matchOptionsContainer = try containerValues.decodeIfPresent([MatchOption?].self, forKey: .matchOptions)
        var matchOptionsDecoded0:[MatchOption]? = nil
        if let matchOptionsContainer = matchOptionsContainer {
            matchOptionsDecoded0 = [MatchOption]()
            for string0 in matchOptionsContainer {
                if let string0 = string0 {
                    matchOptionsDecoded0?.append(string0)
                }
            }
        }
        matchOptions = matchOptionsDecoded0
    }
}

extension DimensionValues: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DimensionValues(key: \(String(describing: key)), matchOptions: \(String(describing: matchOptions)), values: \(String(describing: values)))"}
}

/// <p>The metadata that you can use to filter and group your results. You can use
///                 <code>GetDimensionValues</code> to find specific values.</p>
public struct DimensionValues: Equatable {
    /// <p>The names of the metadata types that you can use to filter and group your results.
    ///             For example, <code>AZ</code> returns a list of Availability Zones.</p>
    public let key: Dimension?
    /// <p>The match options that you can use to filter your results.
    ///                 <code>MatchOptions</code> is only applicable for actions related to Cost Category.
    ///             The default values for <code>MatchOptions</code> are <code>EQUALS</code> and
    ///                 <code>CASE_SENSITIVE</code>.</p>
    public let matchOptions: [MatchOption]?
    /// <p>The metadata values that you can use to filter and group your results. You can use
    ///                 <code>GetDimensionValues</code> to find specific values.</p>
    public let values: [String]?

    public init (
        key: Dimension? = nil,
        matchOptions: [MatchOption]? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.matchOptions = matchOptions
        self.values = values
    }
}

extension DimensionValuesWithAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension DimensionValuesWithAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DimensionValuesWithAttributes(attributes: \(String(describing: attributes)), value: \(String(describing: value)))"}
}

/// <p>The metadata of a specific type that you can use to filter and group your results.
///             You can use <code>GetDimensionValues</code> to find specific values.</p>
public struct DimensionValuesWithAttributes: Equatable {
    /// <p>The attribute that applies to a specific <code>Dimension</code>.</p>
    public let attributes: [String:String]?
    /// <p>The value of a dimension with a specific attribute.</p>
    public let value: String?

    public init (
        attributes: [String:String]? = nil,
        value: String? = nil
    )
    {
        self.attributes = attributes
        self.value = value
    }
}

extension DiskResourceUtilization: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case diskReadBytesPerSecond = "DiskReadBytesPerSecond"
        case diskReadOpsPerSecond = "DiskReadOpsPerSecond"
        case diskWriteBytesPerSecond = "DiskWriteBytesPerSecond"
        case diskWriteOpsPerSecond = "DiskWriteOpsPerSecond"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskReadBytesPerSecond = diskReadBytesPerSecond {
            try encodeContainer.encode(diskReadBytesPerSecond, forKey: .diskReadBytesPerSecond)
        }
        if let diskReadOpsPerSecond = diskReadOpsPerSecond {
            try encodeContainer.encode(diskReadOpsPerSecond, forKey: .diskReadOpsPerSecond)
        }
        if let diskWriteBytesPerSecond = diskWriteBytesPerSecond {
            try encodeContainer.encode(diskWriteBytesPerSecond, forKey: .diskWriteBytesPerSecond)
        }
        if let diskWriteOpsPerSecond = diskWriteOpsPerSecond {
            try encodeContainer.encode(diskWriteOpsPerSecond, forKey: .diskWriteOpsPerSecond)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let diskReadOpsPerSecondDecoded = try containerValues.decodeIfPresent(String.self, forKey: .diskReadOpsPerSecond)
        diskReadOpsPerSecond = diskReadOpsPerSecondDecoded
        let diskWriteOpsPerSecondDecoded = try containerValues.decodeIfPresent(String.self, forKey: .diskWriteOpsPerSecond)
        diskWriteOpsPerSecond = diskWriteOpsPerSecondDecoded
        let diskReadBytesPerSecondDecoded = try containerValues.decodeIfPresent(String.self, forKey: .diskReadBytesPerSecond)
        diskReadBytesPerSecond = diskReadBytesPerSecondDecoded
        let diskWriteBytesPerSecondDecoded = try containerValues.decodeIfPresent(String.self, forKey: .diskWriteBytesPerSecond)
        diskWriteBytesPerSecond = diskWriteBytesPerSecondDecoded
    }
}

extension DiskResourceUtilization: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DiskResourceUtilization(diskReadBytesPerSecond: \(String(describing: diskReadBytesPerSecond)), diskReadOpsPerSecond: \(String(describing: diskReadOpsPerSecond)), diskWriteBytesPerSecond: \(String(describing: diskWriteBytesPerSecond)), diskWriteOpsPerSecond: \(String(describing: diskWriteOpsPerSecond)))"}
}

/// <p>
///             The field that contains a list of disk (local storage) metrics associated with the current instance.
///         </p>
public struct DiskResourceUtilization: Equatable {
    /// <p>
    ///             The maximum read throughput operations per second.
    ///         </p>
    public let diskReadBytesPerSecond: String?
    /// <p>
    ///             The maximum number of read operations per second.
    ///         </p>
    public let diskReadOpsPerSecond: String?
    /// <p>
    ///             The maximum write throughput operations per second.
    ///         </p>
    public let diskWriteBytesPerSecond: String?
    /// <p>
    ///             The maximum number of write operations per second.
    ///         </p>
    public let diskWriteOpsPerSecond: String?

    public init (
        diskReadBytesPerSecond: String? = nil,
        diskReadOpsPerSecond: String? = nil,
        diskWriteBytesPerSecond: String? = nil,
        diskWriteOpsPerSecond: String? = nil
    )
    {
        self.diskReadBytesPerSecond = diskReadBytesPerSecond
        self.diskReadOpsPerSecond = diskReadOpsPerSecond
        self.diskWriteBytesPerSecond = diskWriteBytesPerSecond
        self.diskWriteOpsPerSecond = diskWriteOpsPerSecond
    }
}

extension EBSResourceUtilization: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ebsReadBytesPerSecond = "EbsReadBytesPerSecond"
        case ebsReadOpsPerSecond = "EbsReadOpsPerSecond"
        case ebsWriteBytesPerSecond = "EbsWriteBytesPerSecond"
        case ebsWriteOpsPerSecond = "EbsWriteOpsPerSecond"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ebsReadBytesPerSecond = ebsReadBytesPerSecond {
            try encodeContainer.encode(ebsReadBytesPerSecond, forKey: .ebsReadBytesPerSecond)
        }
        if let ebsReadOpsPerSecond = ebsReadOpsPerSecond {
            try encodeContainer.encode(ebsReadOpsPerSecond, forKey: .ebsReadOpsPerSecond)
        }
        if let ebsWriteBytesPerSecond = ebsWriteBytesPerSecond {
            try encodeContainer.encode(ebsWriteBytesPerSecond, forKey: .ebsWriteBytesPerSecond)
        }
        if let ebsWriteOpsPerSecond = ebsWriteOpsPerSecond {
            try encodeContainer.encode(ebsWriteOpsPerSecond, forKey: .ebsWriteOpsPerSecond)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ebsReadOpsPerSecondDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ebsReadOpsPerSecond)
        ebsReadOpsPerSecond = ebsReadOpsPerSecondDecoded
        let ebsWriteOpsPerSecondDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ebsWriteOpsPerSecond)
        ebsWriteOpsPerSecond = ebsWriteOpsPerSecondDecoded
        let ebsReadBytesPerSecondDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ebsReadBytesPerSecond)
        ebsReadBytesPerSecond = ebsReadBytesPerSecondDecoded
        let ebsWriteBytesPerSecondDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ebsWriteBytesPerSecond)
        ebsWriteBytesPerSecond = ebsWriteBytesPerSecondDecoded
    }
}

extension EBSResourceUtilization: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EBSResourceUtilization(ebsReadBytesPerSecond: \(String(describing: ebsReadBytesPerSecond)), ebsReadOpsPerSecond: \(String(describing: ebsReadOpsPerSecond)), ebsWriteBytesPerSecond: \(String(describing: ebsWriteBytesPerSecond)), ebsWriteOpsPerSecond: \(String(describing: ebsWriteOpsPerSecond)))"}
}

/// <p>
///             The EBS field that contains a list of EBS metrics associated with the current instance.
///         </p>
public struct EBSResourceUtilization: Equatable {
    /// <p>
    ///             The maximum size of read operations per second
    ///         </p>
    public let ebsReadBytesPerSecond: String?
    /// <p>
    ///             The maximum number of read operations per second.
    ///         </p>
    public let ebsReadOpsPerSecond: String?
    /// <p>
    ///             The maximum size of write operations per second.
    ///         </p>
    public let ebsWriteBytesPerSecond: String?
    /// <p>
    ///             The maximum number of write operations per second.
    ///         </p>
    public let ebsWriteOpsPerSecond: String?

    public init (
        ebsReadBytesPerSecond: String? = nil,
        ebsReadOpsPerSecond: String? = nil,
        ebsWriteBytesPerSecond: String? = nil,
        ebsWriteOpsPerSecond: String? = nil
    )
    {
        self.ebsReadBytesPerSecond = ebsReadBytesPerSecond
        self.ebsReadOpsPerSecond = ebsReadOpsPerSecond
        self.ebsWriteBytesPerSecond = ebsWriteBytesPerSecond
        self.ebsWriteOpsPerSecond = ebsWriteOpsPerSecond
    }
}

extension EC2InstanceDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case availabilityZone = "AvailabilityZone"
        case currentGeneration = "CurrentGeneration"
        case family = "Family"
        case instanceType = "InstanceType"
        case platform = "Platform"
        case region = "Region"
        case sizeFlexEligible = "SizeFlexEligible"
        case tenancy = "Tenancy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if currentGeneration != false {
            try encodeContainer.encode(currentGeneration, forKey: .currentGeneration)
        }
        if let family = family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if sizeFlexEligible != false {
            try encodeContainer.encode(sizeFlexEligible, forKey: .sizeFlexEligible)
        }
        if let tenancy = tenancy {
            try encodeContainer.encode(tenancy, forKey: .tenancy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let familyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .family)
        family = familyDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let platformDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platform)
        platform = platformDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tenancy)
        tenancy = tenancyDecoded
        let currentGenerationDecoded = try containerValues.decode(Bool.self, forKey: .currentGeneration)
        currentGeneration = currentGenerationDecoded
        let sizeFlexEligibleDecoded = try containerValues.decode(Bool.self, forKey: .sizeFlexEligible)
        sizeFlexEligible = sizeFlexEligibleDecoded
    }
}

extension EC2InstanceDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EC2InstanceDetails(availabilityZone: \(String(describing: availabilityZone)), currentGeneration: \(String(describing: currentGeneration)), family: \(String(describing: family)), instanceType: \(String(describing: instanceType)), platform: \(String(describing: platform)), region: \(String(describing: region)), sizeFlexEligible: \(String(describing: sizeFlexEligible)), tenancy: \(String(describing: tenancy)))"}
}

/// <p>Details about the Amazon EC2 instances that AWS recommends that you purchase.</p>
public struct EC2InstanceDetails: Equatable {
    /// <p>The Availability Zone of the recommended reservation.</p>
    public let availabilityZone: String?
    /// <p>Whether the recommendation is for a current-generation instance. </p>
    public let currentGeneration: Bool
    /// <p>The instance family of the recommended reservation.</p>
    public let family: String?
    /// <p>The type of instance that AWS recommends.</p>
    public let instanceType: String?
    /// <p>The platform of the recommended reservation. The platform is the specific
    ///             combination of operating system, license model, and software on an instance.</p>
    public let platform: String?
    /// <p>The AWS Region of the recommended reservation.</p>
    public let region: String?
    /// <p>Whether the recommended reservation is size flexible.</p>
    public let sizeFlexEligible: Bool
    /// <p>Whether the recommended reservation is dedicated or shared.</p>
    public let tenancy: String?

    public init (
        availabilityZone: String? = nil,
        currentGeneration: Bool = false,
        family: String? = nil,
        instanceType: String? = nil,
        platform: String? = nil,
        region: String? = nil,
        sizeFlexEligible: Bool = false,
        tenancy: String? = nil
    )
    {
        self.availabilityZone = availabilityZone
        self.currentGeneration = currentGeneration
        self.family = family
        self.instanceType = instanceType
        self.platform = platform
        self.region = region
        self.sizeFlexEligible = sizeFlexEligible
        self.tenancy = tenancy
    }
}

extension EC2ResourceDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hourlyOnDemandRate = "HourlyOnDemandRate"
        case instanceType = "InstanceType"
        case memory = "Memory"
        case networkPerformance = "NetworkPerformance"
        case platform = "Platform"
        case region = "Region"
        case sku = "Sku"
        case storage = "Storage"
        case vcpu = "Vcpu"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hourlyOnDemandRate = hourlyOnDemandRate {
            try encodeContainer.encode(hourlyOnDemandRate, forKey: .hourlyOnDemandRate)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let memory = memory {
            try encodeContainer.encode(memory, forKey: .memory)
        }
        if let networkPerformance = networkPerformance {
            try encodeContainer.encode(networkPerformance, forKey: .networkPerformance)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let sku = sku {
            try encodeContainer.encode(sku, forKey: .sku)
        }
        if let storage = storage {
            try encodeContainer.encode(storage, forKey: .storage)
        }
        if let vcpu = vcpu {
            try encodeContainer.encode(vcpu, forKey: .vcpu)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hourlyOnDemandRateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hourlyOnDemandRate)
        hourlyOnDemandRate = hourlyOnDemandRateDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let platformDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platform)
        platform = platformDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let skuDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sku)
        sku = skuDecoded
        let memoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .memory)
        memory = memoryDecoded
        let networkPerformanceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkPerformance)
        networkPerformance = networkPerformanceDecoded
        let storageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .storage)
        storage = storageDecoded
        let vcpuDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vcpu)
        vcpu = vcpuDecoded
    }
}

extension EC2ResourceDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EC2ResourceDetails(hourlyOnDemandRate: \(String(describing: hourlyOnDemandRate)), instanceType: \(String(describing: instanceType)), memory: \(String(describing: memory)), networkPerformance: \(String(describing: networkPerformance)), platform: \(String(describing: platform)), region: \(String(describing: region)), sku: \(String(describing: sku)), storage: \(String(describing: storage)), vcpu: \(String(describing: vcpu)))"}
}

/// <p> Details on the Amazon EC2 Resource.</p>
public struct EC2ResourceDetails: Equatable {
    /// <p> Hourly public On-Demand rate for the instance type.</p>
    public let hourlyOnDemandRate: String?
    /// <p> The type of AWS instance.</p>
    public let instanceType: String?
    /// <p> Memory capacity of the AWS instance.</p>
    public let memory: String?
    /// <p> Network performance capacity of the AWS instance.</p>
    public let networkPerformance: String?
    /// <p> The platform of the AWS instance. The platform is the specific combination of
    ///             operating system, license model, and software on an instance.</p>
    public let platform: String?
    /// <p> The AWS Region of the instance.</p>
    public let region: String?
    /// <p> The SKU of the product.</p>
    public let sku: String?
    /// <p> The disk storage of the AWS instance (not EBS storage).</p>
    public let storage: String?
    /// <p> Number of VCPU cores in the AWS instance type.</p>
    public let vcpu: String?

    public init (
        hourlyOnDemandRate: String? = nil,
        instanceType: String? = nil,
        memory: String? = nil,
        networkPerformance: String? = nil,
        platform: String? = nil,
        region: String? = nil,
        sku: String? = nil,
        storage: String? = nil,
        vcpu: String? = nil
    )
    {
        self.hourlyOnDemandRate = hourlyOnDemandRate
        self.instanceType = instanceType
        self.memory = memory
        self.networkPerformance = networkPerformance
        self.platform = platform
        self.region = region
        self.sku = sku
        self.storage = storage
        self.vcpu = vcpu
    }
}

extension EC2ResourceUtilization: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case diskResourceUtilization = "DiskResourceUtilization"
        case eBSResourceUtilization = "EBSResourceUtilization"
        case maxCpuUtilizationPercentage = "MaxCpuUtilizationPercentage"
        case maxMemoryUtilizationPercentage = "MaxMemoryUtilizationPercentage"
        case maxStorageUtilizationPercentage = "MaxStorageUtilizationPercentage"
        case networkResourceUtilization = "NetworkResourceUtilization"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let diskResourceUtilization = diskResourceUtilization {
            try encodeContainer.encode(diskResourceUtilization, forKey: .diskResourceUtilization)
        }
        if let eBSResourceUtilization = eBSResourceUtilization {
            try encodeContainer.encode(eBSResourceUtilization, forKey: .eBSResourceUtilization)
        }
        if let maxCpuUtilizationPercentage = maxCpuUtilizationPercentage {
            try encodeContainer.encode(maxCpuUtilizationPercentage, forKey: .maxCpuUtilizationPercentage)
        }
        if let maxMemoryUtilizationPercentage = maxMemoryUtilizationPercentage {
            try encodeContainer.encode(maxMemoryUtilizationPercentage, forKey: .maxMemoryUtilizationPercentage)
        }
        if let maxStorageUtilizationPercentage = maxStorageUtilizationPercentage {
            try encodeContainer.encode(maxStorageUtilizationPercentage, forKey: .maxStorageUtilizationPercentage)
        }
        if let networkResourceUtilization = networkResourceUtilization {
            try encodeContainer.encode(networkResourceUtilization, forKey: .networkResourceUtilization)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxCpuUtilizationPercentageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxCpuUtilizationPercentage)
        maxCpuUtilizationPercentage = maxCpuUtilizationPercentageDecoded
        let maxMemoryUtilizationPercentageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxMemoryUtilizationPercentage)
        maxMemoryUtilizationPercentage = maxMemoryUtilizationPercentageDecoded
        let maxStorageUtilizationPercentageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maxStorageUtilizationPercentage)
        maxStorageUtilizationPercentage = maxStorageUtilizationPercentageDecoded
        let eBSResourceUtilizationDecoded = try containerValues.decodeIfPresent(EBSResourceUtilization.self, forKey: .eBSResourceUtilization)
        eBSResourceUtilization = eBSResourceUtilizationDecoded
        let diskResourceUtilizationDecoded = try containerValues.decodeIfPresent(DiskResourceUtilization.self, forKey: .diskResourceUtilization)
        diskResourceUtilization = diskResourceUtilizationDecoded
        let networkResourceUtilizationDecoded = try containerValues.decodeIfPresent(NetworkResourceUtilization.self, forKey: .networkResourceUtilization)
        networkResourceUtilization = networkResourceUtilizationDecoded
    }
}

extension EC2ResourceUtilization: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EC2ResourceUtilization(diskResourceUtilization: \(String(describing: diskResourceUtilization)), eBSResourceUtilization: \(String(describing: eBSResourceUtilization)), maxCpuUtilizationPercentage: \(String(describing: maxCpuUtilizationPercentage)), maxMemoryUtilizationPercentage: \(String(describing: maxMemoryUtilizationPercentage)), maxStorageUtilizationPercentage: \(String(describing: maxStorageUtilizationPercentage)), networkResourceUtilization: \(String(describing: networkResourceUtilization)))"}
}

/// <p> Utilization metrics of the instance.  </p>
public struct EC2ResourceUtilization: Equatable {
    /// <p>
    ///             The field that contains a list of disk (local storage) metrics associated with the current instance.
    ///         </p>
    public let diskResourceUtilization: DiskResourceUtilization?
    /// <p>
    ///             The EBS field that contains a list of EBS metrics associated with the current instance.
    ///         </p>
    public let eBSResourceUtilization: EBSResourceUtilization?
    /// <p> Maximum observed or expected CPU utilization of the instance.</p>
    public let maxCpuUtilizationPercentage: String?
    /// <p> Maximum observed or expected memory utilization of the instance.</p>
    public let maxMemoryUtilizationPercentage: String?
    /// <p> Maximum observed or expected storage utilization of the instance (does not measure EBS storage).</p>
    public let maxStorageUtilizationPercentage: String?
    /// <p>
    ///             The network field that contains a list of network metrics associated with the current instance.
    ///         </p>
    public let networkResourceUtilization: NetworkResourceUtilization?

    public init (
        diskResourceUtilization: DiskResourceUtilization? = nil,
        eBSResourceUtilization: EBSResourceUtilization? = nil,
        maxCpuUtilizationPercentage: String? = nil,
        maxMemoryUtilizationPercentage: String? = nil,
        maxStorageUtilizationPercentage: String? = nil,
        networkResourceUtilization: NetworkResourceUtilization? = nil
    )
    {
        self.diskResourceUtilization = diskResourceUtilization
        self.eBSResourceUtilization = eBSResourceUtilization
        self.maxCpuUtilizationPercentage = maxCpuUtilizationPercentage
        self.maxMemoryUtilizationPercentage = maxMemoryUtilizationPercentage
        self.maxStorageUtilizationPercentage = maxStorageUtilizationPercentage
        self.networkResourceUtilization = networkResourceUtilization
    }
}

extension EC2Specification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case offeringClass = "OfferingClass"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offeringClass = offeringClass {
            try encodeContainer.encode(offeringClass.rawValue, forKey: .offeringClass)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringClassDecoded = try containerValues.decodeIfPresent(OfferingClass.self, forKey: .offeringClass)
        offeringClass = offeringClassDecoded
    }
}

extension EC2Specification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EC2Specification(offeringClass: \(String(describing: offeringClass)))"}
}

/// <p>The Amazon EC2 hardware specifications that you want AWS to provide recommendations
///             for.</p>
public struct EC2Specification: Equatable {
    /// <p>Whether you want a recommendation for standard or convertible
    ///             reservations.</p>
    public let offeringClass: OfferingClass?

    public init (
        offeringClass: OfferingClass? = nil
    )
    {
        self.offeringClass = offeringClass
    }
}

extension ESInstanceDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentGeneration = "CurrentGeneration"
        case instanceClass = "InstanceClass"
        case instanceSize = "InstanceSize"
        case region = "Region"
        case sizeFlexEligible = "SizeFlexEligible"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if currentGeneration != false {
            try encodeContainer.encode(currentGeneration, forKey: .currentGeneration)
        }
        if let instanceClass = instanceClass {
            try encodeContainer.encode(instanceClass, forKey: .instanceClass)
        }
        if let instanceSize = instanceSize {
            try encodeContainer.encode(instanceSize, forKey: .instanceSize)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if sizeFlexEligible != false {
            try encodeContainer.encode(sizeFlexEligible, forKey: .sizeFlexEligible)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceClass)
        instanceClass = instanceClassDecoded
        let instanceSizeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceSize)
        instanceSize = instanceSizeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let currentGenerationDecoded = try containerValues.decode(Bool.self, forKey: .currentGeneration)
        currentGeneration = currentGenerationDecoded
        let sizeFlexEligibleDecoded = try containerValues.decode(Bool.self, forKey: .sizeFlexEligible)
        sizeFlexEligible = sizeFlexEligibleDecoded
    }
}

extension ESInstanceDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ESInstanceDetails(currentGeneration: \(String(describing: currentGeneration)), instanceClass: \(String(describing: instanceClass)), instanceSize: \(String(describing: instanceSize)), region: \(String(describing: region)), sizeFlexEligible: \(String(describing: sizeFlexEligible)))"}
}

/// <p>Details about the Amazon ES instances that AWS recommends that you
///             purchase.</p>
public struct ESInstanceDetails: Equatable {
    /// <p>Whether the recommendation is for a current-generation instance.</p>
    public let currentGeneration: Bool
    /// <p>The class of instance that AWS recommends.</p>
    public let instanceClass: String?
    /// <p>The size of instance that AWS recommends.</p>
    public let instanceSize: String?
    /// <p>The AWS Region of the recommended reservation.</p>
    public let region: String?
    /// <p>Whether the recommended reservation is size flexible.</p>
    public let sizeFlexEligible: Bool

    public init (
        currentGeneration: Bool = false,
        instanceClass: String? = nil,
        instanceSize: String? = nil,
        region: String? = nil,
        sizeFlexEligible: Bool = false
    )
    {
        self.currentGeneration = currentGeneration
        self.instanceClass = instanceClass
        self.instanceSize = instanceSize
        self.region = region
        self.sizeFlexEligible = sizeFlexEligible
    }
}

extension ElastiCacheInstanceDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentGeneration = "CurrentGeneration"
        case family = "Family"
        case nodeType = "NodeType"
        case productDescription = "ProductDescription"
        case region = "Region"
        case sizeFlexEligible = "SizeFlexEligible"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if currentGeneration != false {
            try encodeContainer.encode(currentGeneration, forKey: .currentGeneration)
        }
        if let family = family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let nodeType = nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let productDescription = productDescription {
            try encodeContainer.encode(productDescription, forKey: .productDescription)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if sizeFlexEligible != false {
            try encodeContainer.encode(sizeFlexEligible, forKey: .sizeFlexEligible)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let familyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .family)
        family = familyDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let productDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .productDescription)
        productDescription = productDescriptionDecoded
        let currentGenerationDecoded = try containerValues.decode(Bool.self, forKey: .currentGeneration)
        currentGeneration = currentGenerationDecoded
        let sizeFlexEligibleDecoded = try containerValues.decode(Bool.self, forKey: .sizeFlexEligible)
        sizeFlexEligible = sizeFlexEligibleDecoded
    }
}

extension ElastiCacheInstanceDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ElastiCacheInstanceDetails(currentGeneration: \(String(describing: currentGeneration)), family: \(String(describing: family)), nodeType: \(String(describing: nodeType)), productDescription: \(String(describing: productDescription)), region: \(String(describing: region)), sizeFlexEligible: \(String(describing: sizeFlexEligible)))"}
}

/// <p>Details about the Amazon ElastiCache instances that AWS recommends that you
///             purchase.</p>
public struct ElastiCacheInstanceDetails: Equatable {
    /// <p>Whether the recommendation is for a current generation instance.</p>
    public let currentGeneration: Bool
    /// <p>The instance family of the recommended reservation.</p>
    public let family: String?
    /// <p>The type of node that AWS recommends.</p>
    public let nodeType: String?
    /// <p>The description of the recommended reservation.</p>
    public let productDescription: String?
    /// <p>The AWS Region of the recommended reservation.</p>
    public let region: String?
    /// <p>Whether the recommended reservation is size flexible.</p>
    public let sizeFlexEligible: Bool

    public init (
        currentGeneration: Bool = false,
        family: String? = nil,
        nodeType: String? = nil,
        productDescription: String? = nil,
        region: String? = nil,
        sizeFlexEligible: Bool = false
    )
    {
        self.currentGeneration = currentGeneration
        self.family = family
        self.nodeType = nodeType
        self.productDescription = productDescription
        self.region = region
        self.sizeFlexEligible = sizeFlexEligible
    }
}

extension Expression: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case and = "And"
        case costCategories = "CostCategories"
        case dimensions = "Dimensions"
        case not = "Not"
        case or = "Or"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let and = and {
            var andContainer = encodeContainer.nestedUnkeyedContainer(forKey: .and)
            for expressions0 in and {
                try andContainer.encode(expressions0)
            }
        }
        if let costCategories = costCategories {
            try encodeContainer.encode(costCategories, forKey: .costCategories)
        }
        if let dimensions = dimensions {
            try encodeContainer.encode(dimensions, forKey: .dimensions)
        }
        if let not = not {
            try encodeContainer.encode(not.value, forKey: .not)
        }
        if let or = or {
            var orContainer = encodeContainer.nestedUnkeyedContainer(forKey: .or)
            for expressions0 in or {
                try orContainer.encode(expressions0)
            }
        }
        if let tags = tags {
            try encodeContainer.encode(tags, forKey: .tags)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let orContainer = try containerValues.decodeIfPresent([Expression?].self, forKey: .or)
        var orDecoded0:[Expression]? = nil
        if let orContainer = orContainer {
            orDecoded0 = [Expression]()
            for structure0 in orContainer {
                if let structure0 = structure0 {
                    orDecoded0?.append(structure0)
                }
            }
        }
        or = orDecoded0
        let andContainer = try containerValues.decodeIfPresent([Expression?].self, forKey: .and)
        var andDecoded0:[Expression]? = nil
        if let andContainer = andContainer {
            andDecoded0 = [Expression]()
            for structure0 in andContainer {
                if let structure0 = structure0 {
                    andDecoded0?.append(structure0)
                }
            }
        }
        and = andDecoded0
        let notDecoded = try containerValues.decodeIfPresent(Box<Expression>.self, forKey: .not)
        not = notDecoded
        let dimensionsDecoded = try containerValues.decodeIfPresent(DimensionValues.self, forKey: .dimensions)
        dimensions = dimensionsDecoded
        let tagsDecoded = try containerValues.decodeIfPresent(TagValues.self, forKey: .tags)
        tags = tagsDecoded
        let costCategoriesDecoded = try containerValues.decodeIfPresent(CostCategoryValues.self, forKey: .costCategories)
        costCategories = costCategoriesDecoded
    }
}

extension Expression: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Expression(and: \(String(describing: and)), costCategories: \(String(describing: costCategories)), dimensions: \(String(describing: dimensions)), not: \(String(describing: not)), or: \(String(describing: or)), tags: \(String(describing: tags)))"}
}

/// <p>Use <code>Expression</code> to filter by cost or by usage. There are two patterns: </p>
///         <ul>
///             <li>
///                 <p>Simple dimension values - You can set the dimension name and values for the
///                     filters that you plan to use. For example, you can filter for
///                     <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>. The
///                         <code>Expression</code> example looks like:</p>
///                 <p>
///                   <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1",
///                         “us-west-1” ] } }</code>
///                 </p>
///                 <p>The list of dimension values are OR'd together to retrieve cost or usage
///                     data. You can create <code>Expression</code> and <code>DimensionValues</code>
///                     objects using either <code>with*</code> methods or <code>set*</code> methods in
///                     multiple lines. </p>
///             </li>
///             <li>
///                 <p>Compound dimension values with logical operations - You can use multiple
///                         <code>Expression</code> types and the logical operators
///                         <code>AND/OR/NOT</code> to create a list of one or more
///                         <code>Expression</code> objects. This allows you to filter on more advanced
///                     options. For example, you can filter on <code>((REGION == us-east-1 OR
///                         REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE !=
///                         DataTransfer)</code>. The <code>Expression</code> for that looks like
///                     this:</p>
///                 <p>
///                   <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION",
///                         "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName",
///                         "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE",
///                         "Values": ["DataTransfer"] }}} ] } </code>
///                </p>
///                 <note>
///                     <p>Because each <code>Expression</code> can have only one operator, the
///                         service returns an error if more than one is specified. The following
///                         example shows an <code>Expression</code> object that creates an
///                         error.</p>
///                 </note>
///                 <p>
///                     <code> { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE",
///                         "Values": [ "DataTransfer" ] } } </code>
///                </p>
///             </li>
///          </ul>
///         <note>
///             <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT is not
///                 supported. OR is not supported between different dimensions, or dimensions and tags.
///                 NOT operators aren't supported.
///                 Dimensions
///                 are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or
///                     <code>RIGHTSIZING_TYPE</code>.</p>
/// 					
/// 					       <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR are not supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
/// 					
/// 					
/// 					
///          </note>
public struct Expression: Equatable {
    /// <p>Return results that match both <code>Dimension</code> objects.</p>
    public let and: [Expression]?
    /// <p>The filter based on <code>CostCategory</code> values.</p>
    public let costCategories: CostCategoryValues?
    /// <p>The specific <code>Dimension</code> to use for <code>Expression</code>.</p>
    public let dimensions: DimensionValues?
    /// <p>Return results that don't match a <code>Dimension</code> object.</p>
    public let not: Box<Expression>?
    /// <p>Return results that match either <code>Dimension</code> object.</p>
    public let or: [Expression]?
    /// <p>The specific <code>Tag</code> to use for <code>Expression</code>.</p>
    public let tags: TagValues?

    public init (
        and: [Expression]? = nil,
        costCategories: CostCategoryValues? = nil,
        dimensions: DimensionValues? = nil,
        not: Box<Expression>? = nil,
        or: [Expression]? = nil,
        tags: TagValues? = nil
    )
    {
        self.and = and
        self.costCategories = costCategories
        self.dimensions = dimensions
        self.not = not
        self.or = or
        self.tags = tags
    }
}

public enum FindingReasonCode {
    case cpuOverProvisioned
    case cpuUnderProvisioned
    case diskIopsOverProvisioned
    case diskIopsUnderProvisioned
    case diskThroughputOverProvisioned
    case diskThroughputUnderProvisioned
    case ebsIopsOverProvisioned
    case ebsIopsUnderProvisioned
    case ebsThroughputOverProvisioned
    case ebsThroughputUnderProvisioned
    case memoryOverProvisioned
    case memoryUnderProvisioned
    case networkBandwidthOverProvisioned
    case networkBandwidthUnderProvisioned
    case networkPpsOverProvisioned
    case networkPpsUnderProvisioned
    case sdkUnknown(String)
}

extension FindingReasonCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FindingReasonCode] {
        return [
            .cpuOverProvisioned,
            .cpuUnderProvisioned,
            .diskIopsOverProvisioned,
            .diskIopsUnderProvisioned,
            .diskThroughputOverProvisioned,
            .diskThroughputUnderProvisioned,
            .ebsIopsOverProvisioned,
            .ebsIopsUnderProvisioned,
            .ebsThroughputOverProvisioned,
            .ebsThroughputUnderProvisioned,
            .memoryOverProvisioned,
            .memoryUnderProvisioned,
            .networkBandwidthOverProvisioned,
            .networkBandwidthUnderProvisioned,
            .networkPpsOverProvisioned,
            .networkPpsUnderProvisioned,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cpuOverProvisioned: return "CPU_OVER_PROVISIONED"
        case .cpuUnderProvisioned: return "CPU_UNDER_PROVISIONED"
        case .diskIopsOverProvisioned: return "DISK_IOPS_OVER_PROVISIONED"
        case .diskIopsUnderProvisioned: return "DISK_IOPS_UNDER_PROVISIONED"
        case .diskThroughputOverProvisioned: return "DISK_THROUGHPUT_OVER_PROVISIONED"
        case .diskThroughputUnderProvisioned: return "DISK_THROUGHPUT_UNDER_PROVISIONED"
        case .ebsIopsOverProvisioned: return "EBS_IOPS_OVER_PROVISIONED"
        case .ebsIopsUnderProvisioned: return "EBS_IOPS_UNDER_PROVISIONED"
        case .ebsThroughputOverProvisioned: return "EBS_THROUGHPUT_OVER_PROVISIONED"
        case .ebsThroughputUnderProvisioned: return "EBS_THROUGHPUT_UNDER_PROVISIONED"
        case .memoryOverProvisioned: return "MEMORY_OVER_PROVISIONED"
        case .memoryUnderProvisioned: return "MEMORY_UNDER_PROVISIONED"
        case .networkBandwidthOverProvisioned: return "NETWORK_BANDWIDTH_OVER_PROVISIONED"
        case .networkBandwidthUnderProvisioned: return "NETWORK_BANDWIDTH_UNDER_PROVISIONED"
        case .networkPpsOverProvisioned: return "NETWORK_PPS_OVER_PROVISIONED"
        case .networkPpsUnderProvisioned: return "NETWORK_PPS_UNDER_PROVISIONED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FindingReasonCode(rawValue: rawValue) ?? FindingReasonCode.sdkUnknown(rawValue)
    }
}

extension ForecastResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case meanValue = "MeanValue"
        case predictionIntervalLowerBound = "PredictionIntervalLowerBound"
        case predictionIntervalUpperBound = "PredictionIntervalUpperBound"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let meanValue = meanValue {
            try encodeContainer.encode(meanValue, forKey: .meanValue)
        }
        if let predictionIntervalLowerBound = predictionIntervalLowerBound {
            try encodeContainer.encode(predictionIntervalLowerBound, forKey: .predictionIntervalLowerBound)
        }
        if let predictionIntervalUpperBound = predictionIntervalUpperBound {
            try encodeContainer.encode(predictionIntervalUpperBound, forKey: .predictionIntervalUpperBound)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let meanValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meanValue)
        meanValue = meanValueDecoded
        let predictionIntervalLowerBoundDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictionIntervalLowerBound)
        predictionIntervalLowerBound = predictionIntervalLowerBoundDecoded
        let predictionIntervalUpperBoundDecoded = try containerValues.decodeIfPresent(String.self, forKey: .predictionIntervalUpperBound)
        predictionIntervalUpperBound = predictionIntervalUpperBoundDecoded
    }
}

extension ForecastResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForecastResult(meanValue: \(String(describing: meanValue)), predictionIntervalLowerBound: \(String(describing: predictionIntervalLowerBound)), predictionIntervalUpperBound: \(String(describing: predictionIntervalUpperBound)), timePeriod: \(String(describing: timePeriod)))"}
}

/// <p>The forecast created for your query.</p>
public struct ForecastResult: Equatable {
    /// <p>The mean value of the forecast.</p>
    public let meanValue: String?
    /// <p>The lower limit for the prediction interval. </p>
    public let predictionIntervalLowerBound: String?
    /// <p>The upper limit for the prediction interval. </p>
    public let predictionIntervalUpperBound: String?
    /// <p>The period of time that the forecast covers.</p>
    public let timePeriod: DateInterval?

    public init (
        meanValue: String? = nil,
        predictionIntervalLowerBound: String? = nil,
        predictionIntervalUpperBound: String? = nil,
        timePeriod: DateInterval? = nil
    )
    {
        self.meanValue = meanValue
        self.predictionIntervalLowerBound = predictionIntervalLowerBound
        self.predictionIntervalUpperBound = predictionIntervalUpperBound
        self.timePeriod = timePeriod
    }
}

public struct GetAnomaliesInputBodyMiddleware: Middleware {
    public let id: String = "GetAnomaliesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAnomaliesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAnomaliesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAnomaliesInput>
    public typealias MOutput = OperationOutput<GetAnomaliesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAnomaliesOutputError>
}

extension GetAnomaliesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAnomaliesInput(dateInterval: \(String(describing: dateInterval)), feedback: \(String(describing: feedback)), maxResults: \(String(describing: maxResults)), monitorArn: \(String(describing: monitorArn)), nextPageToken: \(String(describing: nextPageToken)), totalImpact: \(String(describing: totalImpact)))"}
}

extension GetAnomaliesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dateInterval = "DateInterval"
        case feedback = "Feedback"
        case maxResults = "MaxResults"
        case monitorArn = "MonitorArn"
        case nextPageToken = "NextPageToken"
        case totalImpact = "TotalImpact"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dateInterval = dateInterval {
            try encodeContainer.encode(dateInterval, forKey: .dateInterval)
        }
        if let feedback = feedback {
            try encodeContainer.encode(feedback.rawValue, forKey: .feedback)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let monitorArn = monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let totalImpact = totalImpact {
            try encodeContainer.encode(totalImpact, forKey: .totalImpact)
        }
    }
}

public struct GetAnomaliesInputHeadersMiddleware: Middleware {
    public let id: String = "GetAnomaliesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAnomaliesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAnomaliesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAnomaliesInput>
    public typealias MOutput = OperationOutput<GetAnomaliesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAnomaliesOutputError>
}

public struct GetAnomaliesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAnomaliesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAnomaliesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAnomaliesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAnomaliesInput>
    public typealias MOutput = OperationOutput<GetAnomaliesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAnomaliesOutputError>
}

public struct GetAnomaliesInput: Equatable {
    /// <p>Assigns the start and end dates for retrieving cost anomalies. The returned anomaly object
    ///       will have an <code>AnomalyEndDate</code> in the specified time range. </p>
    public let dateInterval: AnomalyDateInterval?
    /// <p>Filters anomaly results by the feedback field on the anomaly object. </p>
    public let feedback: AnomalyFeedbackType?
    /// <p>
    ///       The number of entries a paginated response contains.
    ///     </p>
    public let maxResults: Int?
    /// <p>Retrieves all of the cost anomalies detected for a specific cost anomaly monitor Amazon
    ///       Resource Name (ARN). </p>
    public let monitorArn: String?
    /// <p>
    ///       The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.
    ///     </p>
    public let nextPageToken: String?
    /// <p>Filters anomaly results by the total impact field on the anomaly object. For example, you
    ///       can filter anomalies <code>GREATER_THAN 200.00</code> to retrieve anomalies, with an estimated
    ///       dollar impact greater than 200. </p>
    public let totalImpact: TotalImpactFilter?

    public init (
        dateInterval: AnomalyDateInterval? = nil,
        feedback: AnomalyFeedbackType? = nil,
        maxResults: Int? = nil,
        monitorArn: String? = nil,
        nextPageToken: String? = nil,
        totalImpact: TotalImpactFilter? = nil
    )
    {
        self.dateInterval = dateInterval
        self.feedback = feedback
        self.maxResults = maxResults
        self.monitorArn = monitorArn
        self.nextPageToken = nextPageToken
        self.totalImpact = totalImpact
    }
}

struct GetAnomaliesInputBody: Equatable {
    public let monitorArn: String?
    public let dateInterval: AnomalyDateInterval?
    public let feedback: AnomalyFeedbackType?
    public let totalImpact: TotalImpactFilter?
    public let nextPageToken: String?
    public let maxResults: Int?
}

extension GetAnomaliesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dateInterval = "DateInterval"
        case feedback = "Feedback"
        case maxResults = "MaxResults"
        case monitorArn = "MonitorArn"
        case nextPageToken = "NextPageToken"
        case totalImpact = "TotalImpact"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let dateIntervalDecoded = try containerValues.decodeIfPresent(AnomalyDateInterval.self, forKey: .dateInterval)
        dateInterval = dateIntervalDecoded
        let feedbackDecoded = try containerValues.decodeIfPresent(AnomalyFeedbackType.self, forKey: .feedback)
        feedback = feedbackDecoded
        let totalImpactDecoded = try containerValues.decodeIfPresent(TotalImpactFilter.self, forKey: .totalImpact)
        totalImpact = totalImpactDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetAnomaliesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAnomaliesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAnomaliesOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAnomaliesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAnomaliesOutputResponse(anomalies: \(String(describing: anomalies)), nextPageToken: \(String(describing: nextPageToken)))"}
}

extension GetAnomaliesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAnomaliesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.anomalies = output.anomalies
            self.nextPageToken = output.nextPageToken
        } else {
            self.anomalies = nil
            self.nextPageToken = nil
        }
    }
}

public struct GetAnomaliesOutputResponse: Equatable {
    /// <p>
    ///       A list of cost anomalies.
    ///     </p>
    public let anomalies: [Anomaly]?
    /// <p>
    ///       The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.
    ///     </p>
    public let nextPageToken: String?

    public init (
        anomalies: [Anomaly]? = nil,
        nextPageToken: String? = nil
    )
    {
        self.anomalies = anomalies
        self.nextPageToken = nextPageToken
    }
}

struct GetAnomaliesOutputResponseBody: Equatable {
    public let anomalies: [Anomaly]?
    public let nextPageToken: String?
}

extension GetAnomaliesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalies = "Anomalies"
        case nextPageToken = "NextPageToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomaliesContainer = try containerValues.decodeIfPresent([Anomaly?].self, forKey: .anomalies)
        var anomaliesDecoded0:[Anomaly]? = nil
        if let anomaliesContainer = anomaliesContainer {
            anomaliesDecoded0 = [Anomaly]()
            for structure0 in anomaliesContainer {
                if let structure0 = structure0 {
                    anomaliesDecoded0?.append(structure0)
                }
            }
        }
        anomalies = anomaliesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct GetAnomalyMonitorsInputBodyMiddleware: Middleware {
    public let id: String = "GetAnomalyMonitorsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAnomalyMonitorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAnomalyMonitorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAnomalyMonitorsInput>
    public typealias MOutput = OperationOutput<GetAnomalyMonitorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAnomalyMonitorsOutputError>
}

extension GetAnomalyMonitorsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAnomalyMonitorsInput(maxResults: \(String(describing: maxResults)), monitorArnList: \(String(describing: monitorArnList)), nextPageToken: \(String(describing: nextPageToken)))"}
}

extension GetAnomalyMonitorsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case monitorArnList = "MonitorArnList"
        case nextPageToken = "NextPageToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let monitorArnList = monitorArnList {
            var monitorArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monitorArnList)
            for values0 in monitorArnList {
                try monitorArnListContainer.encode(values0)
            }
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
    }
}

public struct GetAnomalyMonitorsInputHeadersMiddleware: Middleware {
    public let id: String = "GetAnomalyMonitorsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAnomalyMonitorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAnomalyMonitorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAnomalyMonitorsInput>
    public typealias MOutput = OperationOutput<GetAnomalyMonitorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAnomalyMonitorsOutputError>
}

public struct GetAnomalyMonitorsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAnomalyMonitorsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAnomalyMonitorsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAnomalyMonitorsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAnomalyMonitorsInput>
    public typealias MOutput = OperationOutput<GetAnomalyMonitorsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAnomalyMonitorsOutputError>
}

public struct GetAnomalyMonitorsInput: Equatable {
    /// <p>
    ///       The number of entries a paginated response contains.
    ///     </p>
    public let maxResults: Int?
    /// <p>
    ///       A list of cost anomaly monitor ARNs.
    ///     </p>
    public let monitorArnList: [String]?
    /// <p>
    ///       The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.
    ///     </p>
    public let nextPageToken: String?

    public init (
        maxResults: Int? = nil,
        monitorArnList: [String]? = nil,
        nextPageToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.monitorArnList = monitorArnList
        self.nextPageToken = nextPageToken
    }
}

struct GetAnomalyMonitorsInputBody: Equatable {
    public let monitorArnList: [String]?
    public let nextPageToken: String?
    public let maxResults: Int?
}

extension GetAnomalyMonitorsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case monitorArnList = "MonitorArnList"
        case nextPageToken = "NextPageToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .monitorArnList)
        var monitorArnListDecoded0:[String]? = nil
        if let monitorArnListContainer = monitorArnListContainer {
            monitorArnListDecoded0 = [String]()
            for string0 in monitorArnListContainer {
                if let string0 = string0 {
                    monitorArnListDecoded0?.append(string0)
                }
            }
        }
        monitorArnList = monitorArnListDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetAnomalyMonitorsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAnomalyMonitorsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownMonitorException" : self = .unknownMonitorException(try UnknownMonitorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAnomalyMonitorsOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case unknownMonitorException(UnknownMonitorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAnomalyMonitorsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAnomalyMonitorsOutputResponse(anomalyMonitors: \(String(describing: anomalyMonitors)), nextPageToken: \(String(describing: nextPageToken)))"}
}

extension GetAnomalyMonitorsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAnomalyMonitorsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.anomalyMonitors = output.anomalyMonitors
            self.nextPageToken = output.nextPageToken
        } else {
            self.anomalyMonitors = nil
            self.nextPageToken = nil
        }
    }
}

public struct GetAnomalyMonitorsOutputResponse: Equatable {
    /// <p>
    ///       A list of cost anomaly monitors that includes the detailed metadata for each monitor.
    ///     </p>
    public let anomalyMonitors: [AnomalyMonitor]?
    /// <p>
    ///       The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.
    ///     </p>
    public let nextPageToken: String?

    public init (
        anomalyMonitors: [AnomalyMonitor]? = nil,
        nextPageToken: String? = nil
    )
    {
        self.anomalyMonitors = anomalyMonitors
        self.nextPageToken = nextPageToken
    }
}

struct GetAnomalyMonitorsOutputResponseBody: Equatable {
    public let anomalyMonitors: [AnomalyMonitor]?
    public let nextPageToken: String?
}

extension GetAnomalyMonitorsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyMonitors = "AnomalyMonitors"
        case nextPageToken = "NextPageToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyMonitorsContainer = try containerValues.decodeIfPresent([AnomalyMonitor?].self, forKey: .anomalyMonitors)
        var anomalyMonitorsDecoded0:[AnomalyMonitor]? = nil
        if let anomalyMonitorsContainer = anomalyMonitorsContainer {
            anomalyMonitorsDecoded0 = [AnomalyMonitor]()
            for structure0 in anomalyMonitorsContainer {
                if let structure0 = structure0 {
                    anomalyMonitorsDecoded0?.append(structure0)
                }
            }
        }
        anomalyMonitors = anomalyMonitorsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct GetAnomalySubscriptionsInputBodyMiddleware: Middleware {
    public let id: String = "GetAnomalySubscriptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAnomalySubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAnomalySubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAnomalySubscriptionsInput>
    public typealias MOutput = OperationOutput<GetAnomalySubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAnomalySubscriptionsOutputError>
}

extension GetAnomalySubscriptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAnomalySubscriptionsInput(maxResults: \(String(describing: maxResults)), monitorArn: \(String(describing: monitorArn)), nextPageToken: \(String(describing: nextPageToken)), subscriptionArnList: \(String(describing: subscriptionArnList)))"}
}

extension GetAnomalySubscriptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case monitorArn = "MonitorArn"
        case nextPageToken = "NextPageToken"
        case subscriptionArnList = "SubscriptionArnList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let monitorArn = monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let subscriptionArnList = subscriptionArnList {
            var subscriptionArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscriptionArnList)
            for values0 in subscriptionArnList {
                try subscriptionArnListContainer.encode(values0)
            }
        }
    }
}

public struct GetAnomalySubscriptionsInputHeadersMiddleware: Middleware {
    public let id: String = "GetAnomalySubscriptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAnomalySubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAnomalySubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAnomalySubscriptionsInput>
    public typealias MOutput = OperationOutput<GetAnomalySubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAnomalySubscriptionsOutputError>
}

public struct GetAnomalySubscriptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAnomalySubscriptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAnomalySubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAnomalySubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAnomalySubscriptionsInput>
    public typealias MOutput = OperationOutput<GetAnomalySubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAnomalySubscriptionsOutputError>
}

public struct GetAnomalySubscriptionsInput: Equatable {
    /// <p>
    ///       The number of entries a paginated response contains.
    ///     </p>
    public let maxResults: Int?
    /// <p>
    ///       Cost anomaly monitor ARNs.
    ///     </p>
    public let monitorArn: String?
    /// <p>
    ///       The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.
    ///     </p>
    public let nextPageToken: String?
    /// <p>
    ///       A list of cost anomaly subscription ARNs.
    ///     </p>
    public let subscriptionArnList: [String]?

    public init (
        maxResults: Int? = nil,
        monitorArn: String? = nil,
        nextPageToken: String? = nil,
        subscriptionArnList: [String]? = nil
    )
    {
        self.maxResults = maxResults
        self.monitorArn = monitorArn
        self.nextPageToken = nextPageToken
        self.subscriptionArnList = subscriptionArnList
    }
}

struct GetAnomalySubscriptionsInputBody: Equatable {
    public let subscriptionArnList: [String]?
    public let monitorArn: String?
    public let nextPageToken: String?
    public let maxResults: Int?
}

extension GetAnomalySubscriptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case monitorArn = "MonitorArn"
        case nextPageToken = "NextPageToken"
        case subscriptionArnList = "SubscriptionArnList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subscriptionArnList)
        var subscriptionArnListDecoded0:[String]? = nil
        if let subscriptionArnListContainer = subscriptionArnListContainer {
            subscriptionArnListDecoded0 = [String]()
            for string0 in subscriptionArnListContainer {
                if let string0 = string0 {
                    subscriptionArnListDecoded0?.append(string0)
                }
            }
        }
        subscriptionArnList = subscriptionArnListDecoded0
        let monitorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetAnomalySubscriptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAnomalySubscriptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownSubscriptionException" : self = .unknownSubscriptionException(try UnknownSubscriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAnomalySubscriptionsOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case unknownSubscriptionException(UnknownSubscriptionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAnomalySubscriptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAnomalySubscriptionsOutputResponse(anomalySubscriptions: \(String(describing: anomalySubscriptions)), nextPageToken: \(String(describing: nextPageToken)))"}
}

extension GetAnomalySubscriptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAnomalySubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.anomalySubscriptions = output.anomalySubscriptions
            self.nextPageToken = output.nextPageToken
        } else {
            self.anomalySubscriptions = nil
            self.nextPageToken = nil
        }
    }
}

public struct GetAnomalySubscriptionsOutputResponse: Equatable {
    /// <p>
    ///       A list of cost anomaly subscriptions that includes the detailed metadata for each one.
    ///     </p>
    public let anomalySubscriptions: [AnomalySubscription]?
    /// <p>
    ///       The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.
    ///     </p>
    public let nextPageToken: String?

    public init (
        anomalySubscriptions: [AnomalySubscription]? = nil,
        nextPageToken: String? = nil
    )
    {
        self.anomalySubscriptions = anomalySubscriptions
        self.nextPageToken = nextPageToken
    }
}

struct GetAnomalySubscriptionsOutputResponseBody: Equatable {
    public let anomalySubscriptions: [AnomalySubscription]?
    public let nextPageToken: String?
}

extension GetAnomalySubscriptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalySubscriptions = "AnomalySubscriptions"
        case nextPageToken = "NextPageToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalySubscriptionsContainer = try containerValues.decodeIfPresent([AnomalySubscription?].self, forKey: .anomalySubscriptions)
        var anomalySubscriptionsDecoded0:[AnomalySubscription]? = nil
        if let anomalySubscriptionsContainer = anomalySubscriptionsContainer {
            anomalySubscriptionsDecoded0 = [AnomalySubscription]()
            for structure0 in anomalySubscriptionsContainer {
                if let structure0 = structure0 {
                    anomalySubscriptionsDecoded0?.append(structure0)
                }
            }
        }
        anomalySubscriptions = anomalySubscriptionsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct GetCostAndUsageInputBodyMiddleware: Middleware {
    public let id: String = "GetCostAndUsageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCostAndUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCostAndUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCostAndUsageInput>
    public typealias MOutput = OperationOutput<GetCostAndUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCostAndUsageOutputError>
}

extension GetCostAndUsageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCostAndUsageInput(filter: \(String(describing: filter)), granularity: \(String(describing: granularity)), groupBy: \(String(describing: groupBy)), metrics: \(String(describing: metrics)), nextPageToken: \(String(describing: nextPageToken)), timePeriod: \(String(describing: timePeriod)))"}
}

extension GetCostAndUsageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case metrics = "Metrics"
        case nextPageToken = "NextPageToken"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for groupdefinitions0 in groupBy {
                try groupByContainer.encode(groupdefinitions0)
            }
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metrics)
            for metricnames0 in metrics {
                try metricsContainer.encode(metricnames0)
            }
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

public struct GetCostAndUsageInputHeadersMiddleware: Middleware {
    public let id: String = "GetCostAndUsageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCostAndUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCostAndUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCostAndUsageInput>
    public typealias MOutput = OperationOutput<GetCostAndUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCostAndUsageOutputError>
}

public struct GetCostAndUsageInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCostAndUsageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCostAndUsageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCostAndUsageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCostAndUsageInput>
    public typealias MOutput = OperationOutput<GetCostAndUsageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCostAndUsageOutputError>
}

public struct GetCostAndUsageInput: Equatable {
    /// <p>Filters AWS costs by different dimensions. For example, you can specify <code>SERVICE</code> and <code>LINKED_ACCOUNT</code>
    /// 			and get the costs that are associated with that account's usage of that service. You can nest <code>Expression</code> objects
    /// 			to define any combination of dimension filters. For more information, see
    /// 			<a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a>. </p>
    public let filter: Expression?
    /// <p>Sets the AWS cost granularity to <code>MONTHLY</code> or <code>DAILY</code>, or <code>HOURLY</code>. If <code>Granularity</code> isn't set,
    /// 	    the response object doesn't include the <code>Granularity</code>, either <code>MONTHLY</code> or <code>DAILY</code>, or <code>HOURLY</code>. </p>
    public let granularity: Granularity?
    /// <p>You can group AWS costs using up to two different groups, either dimensions, tag keys,
    ///       cost categories, or any two group by types.</p>
    /// 		       <p>When you group by tag key, you get all tag values, including empty strings.</p>
    /// 		       <p>Valid values are <code>AZ</code>, <code>INSTANCE_TYPE</code>, <code>LEGAL_ENTITY_NAME</code>, <code>LINKED_ACCOUNT</code>,
    /// 			<code>OPERATION</code>, <code>PLATFORM</code>, <code>PURCHASE_TYPE</code>, <code>SERVICE</code>, <code>TAGS</code>,
    /// 		  <code>TENANCY</code>, <code>RECORD_TYPE</code>, and <code>USAGE_TYPE</code>.</p>
    public let groupBy: [GroupDefinition]?
    /// <p>Which metrics are returned in the query. For more information about blended and unblended rates, see
    /// 			<a href="http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/">Why does the "blended" annotation
    /// 				appear on some line items in my bill?</a>. </p>
    /// 		       <p>Valid values are <code>AmortizedCost</code>, <code>BlendedCost</code>, <code>NetAmortizedCost</code>,
    /// 			<code>NetUnblendedCost</code>, <code>NormalizedUsageAmount</code>, <code>UnblendedCost</code>, and <code>UsageQuantity</code>. </p>
    /// 		       <note>
    /// 			         <p>If you return the <code>UsageQuantity</code> metric, the service aggregates all usage numbers without
    /// 				taking into account the units. For example, if you aggregate <code>usageQuantity</code> across all of Amazon EC2,
    /// 				the results aren't meaningful because Amazon EC2 compute hours and data transfer are measured in different units
    /// 				(for example, hours vs. GB). To get more meaningful <code>UsageQuantity</code> metrics, filter by <code>UsageType</code> or
    /// 				<code>UsageTypeGroups</code>. </p>
    /// 		       </note>
    /// 		       <p>
    ///             <code>Metrics</code> is required for <code>GetCostAndUsage</code> requests.</p>
    public let metrics: [String]?
    /// <p>The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.</p>
    public let nextPageToken: String?
    /// <p>Sets the start and end dates for retrieving AWS costs. The start date is inclusive,  but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is
    ///             retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
    public let timePeriod: DateInterval?

    public init (
        filter: Expression? = nil,
        granularity: Granularity? = nil,
        groupBy: [GroupDefinition]? = nil,
        metrics: [String]? = nil,
        nextPageToken: String? = nil,
        timePeriod: DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.groupBy = groupBy
        self.metrics = metrics
        self.nextPageToken = nextPageToken
        self.timePeriod = timePeriod
    }
}

struct GetCostAndUsageInputBody: Equatable {
    public let timePeriod: DateInterval?
    public let granularity: Granularity?
    public let filter: Expression?
    public let metrics: [String]?
    public let groupBy: [GroupDefinition]?
    public let nextPageToken: String?
}

extension GetCostAndUsageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case metrics = "Metrics"
        case nextPageToken = "NextPageToken"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let granularityDecoded = try containerValues.decodeIfPresent(Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(Expression.self, forKey: .filter)
        filter = filterDecoded
        let metricsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .metrics)
        var metricsDecoded0:[String]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [String]()
            for string0 in metricsContainer {
                if let string0 = string0 {
                    metricsDecoded0?.append(string0)
                }
            }
        }
        metrics = metricsDecoded0
        let groupByContainer = try containerValues.decodeIfPresent([GroupDefinition?].self, forKey: .groupBy)
        var groupByDecoded0:[GroupDefinition]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [GroupDefinition]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetCostAndUsageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCostAndUsageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BillExpirationException" : self = .billExpirationException(try BillExpirationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestChangedException" : self = .requestChangedException(try RequestChangedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCostAndUsageOutputError: Swift.Error, Equatable {
    case billExpirationException(BillExpirationException)
    case dataUnavailableException(DataUnavailableException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case requestChangedException(RequestChangedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCostAndUsageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCostAndUsageOutputResponse(dimensionValueAttributes: \(String(describing: dimensionValueAttributes)), groupDefinitions: \(String(describing: groupDefinitions)), nextPageToken: \(String(describing: nextPageToken)), resultsByTime: \(String(describing: resultsByTime)))"}
}

extension GetCostAndUsageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCostAndUsageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dimensionValueAttributes = output.dimensionValueAttributes
            self.groupDefinitions = output.groupDefinitions
            self.nextPageToken = output.nextPageToken
            self.resultsByTime = output.resultsByTime
        } else {
            self.dimensionValueAttributes = nil
            self.groupDefinitions = nil
            self.nextPageToken = nil
            self.resultsByTime = nil
        }
    }
}

public struct GetCostAndUsageOutputResponse: Equatable {
    /// <p>The attributes that apply to a specific dimension value. For example, if the value is a linked account, the attribute is that account name.</p>
    public let dimensionValueAttributes: [DimensionValuesWithAttributes]?
    /// <p>The groups that are specified by the <code>Filter</code> or <code>GroupBy</code> parameters in the request.</p>
    public let groupDefinitions: [GroupDefinition]?
    /// <p>The token for the next set of retrievable results. AWS provides the token when the response from a previous call has more results than the maximum page size.</p>
    public let nextPageToken: String?
    /// <p>The time period that is covered by the results in the response.</p>
    public let resultsByTime: [ResultByTime]?

    public init (
        dimensionValueAttributes: [DimensionValuesWithAttributes]? = nil,
        groupDefinitions: [GroupDefinition]? = nil,
        nextPageToken: String? = nil,
        resultsByTime: [ResultByTime]? = nil
    )
    {
        self.dimensionValueAttributes = dimensionValueAttributes
        self.groupDefinitions = groupDefinitions
        self.nextPageToken = nextPageToken
        self.resultsByTime = resultsByTime
    }
}

struct GetCostAndUsageOutputResponseBody: Equatable {
    public let nextPageToken: String?
    public let groupDefinitions: [GroupDefinition]?
    public let resultsByTime: [ResultByTime]?
    public let dimensionValueAttributes: [DimensionValuesWithAttributes]?
}

extension GetCostAndUsageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dimensionValueAttributes = "DimensionValueAttributes"
        case groupDefinitions = "GroupDefinitions"
        case nextPageToken = "NextPageToken"
        case resultsByTime = "ResultsByTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let groupDefinitionsContainer = try containerValues.decodeIfPresent([GroupDefinition?].self, forKey: .groupDefinitions)
        var groupDefinitionsDecoded0:[GroupDefinition]? = nil
        if let groupDefinitionsContainer = groupDefinitionsContainer {
            groupDefinitionsDecoded0 = [GroupDefinition]()
            for structure0 in groupDefinitionsContainer {
                if let structure0 = structure0 {
                    groupDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        groupDefinitions = groupDefinitionsDecoded0
        let resultsByTimeContainer = try containerValues.decodeIfPresent([ResultByTime?].self, forKey: .resultsByTime)
        var resultsByTimeDecoded0:[ResultByTime]? = nil
        if let resultsByTimeContainer = resultsByTimeContainer {
            resultsByTimeDecoded0 = [ResultByTime]()
            for structure0 in resultsByTimeContainer {
                if let structure0 = structure0 {
                    resultsByTimeDecoded0?.append(structure0)
                }
            }
        }
        resultsByTime = resultsByTimeDecoded0
        let dimensionValueAttributesContainer = try containerValues.decodeIfPresent([DimensionValuesWithAttributes?].self, forKey: .dimensionValueAttributes)
        var dimensionValueAttributesDecoded0:[DimensionValuesWithAttributes]? = nil
        if let dimensionValueAttributesContainer = dimensionValueAttributesContainer {
            dimensionValueAttributesDecoded0 = [DimensionValuesWithAttributes]()
            for structure0 in dimensionValueAttributesContainer {
                if let structure0 = structure0 {
                    dimensionValueAttributesDecoded0?.append(structure0)
                }
            }
        }
        dimensionValueAttributes = dimensionValueAttributesDecoded0
    }
}

public struct GetCostAndUsageWithResourcesInputBodyMiddleware: Middleware {
    public let id: String = "GetCostAndUsageWithResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCostAndUsageWithResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCostAndUsageWithResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCostAndUsageWithResourcesInput>
    public typealias MOutput = OperationOutput<GetCostAndUsageWithResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCostAndUsageWithResourcesOutputError>
}

extension GetCostAndUsageWithResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCostAndUsageWithResourcesInput(filter: \(String(describing: filter)), granularity: \(String(describing: granularity)), groupBy: \(String(describing: groupBy)), metrics: \(String(describing: metrics)), nextPageToken: \(String(describing: nextPageToken)), timePeriod: \(String(describing: timePeriod)))"}
}

extension GetCostAndUsageWithResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case metrics = "Metrics"
        case nextPageToken = "NextPageToken"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for groupdefinitions0 in groupBy {
                try groupByContainer.encode(groupdefinitions0)
            }
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metrics)
            for metricnames0 in metrics {
                try metricsContainer.encode(metricnames0)
            }
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

public struct GetCostAndUsageWithResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "GetCostAndUsageWithResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCostAndUsageWithResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCostAndUsageWithResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCostAndUsageWithResourcesInput>
    public typealias MOutput = OperationOutput<GetCostAndUsageWithResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCostAndUsageWithResourcesOutputError>
}

public struct GetCostAndUsageWithResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCostAndUsageWithResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCostAndUsageWithResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCostAndUsageWithResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCostAndUsageWithResourcesInput>
    public typealias MOutput = OperationOutput<GetCostAndUsageWithResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCostAndUsageWithResourcesOutputError>
}

public struct GetCostAndUsageWithResourcesInput: Equatable {
    /// <p>Filters Amazon Web Services costs by different dimensions. For example, you can specify
    ///       <code>SERVICE</code> and <code>LINKED_ACCOUNT</code> and get the costs that are associated
    ///       with that account's usage of that service. You can nest <code>Expression</code> objects to
    ///       define any combination of dimension filters. For more information, see <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a>. </p>
    ///          <p>The <code>GetCostAndUsageWithResources</code> operation requires that you either group by or filter by a
    ///       <code>ResourceId</code>. It requires the <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a>
    ///             <code>"SERVICE = Amazon Elastic Compute Cloud - Compute"</code> in the filter.</p>
    public let filter: Expression?
    /// <p>Sets the AWS cost granularity to <code>MONTHLY</code>, <code>DAILY</code>, or <code>HOURLY</code>. If
    /// 	    <code>Granularity</code> isn't set, the response object doesn't include the
    /// 	    <code>Granularity</code>, <code>MONTHLY</code>, <code>DAILY</code>, or <code>HOURLY</code>. </p>
    public let granularity: Granularity?
    /// <p>You can group Amazon Web Services costs using up to two different groups: <code>DIMENSION</code>, <code>TAG</code>, <code>COST_CATEGORY</code>.</p>
    public let groupBy: [GroupDefinition]?
    /// <p>Which metrics are returned in the query. For more information about blended and
    ///       unblended rates, see <a href="http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/">Why does
    ///         the "blended" annotation appear on some line items in my bill?</a>. </p>
    ///          <p>Valid values are <code>AmortizedCost</code>, <code>BlendedCost</code>,
    ///       <code>NetAmortizedCost</code>, <code>NetUnblendedCost</code>,
    ///       <code>NormalizedUsageAmount</code>, <code>UnblendedCost</code>, and
    ///       <code>UsageQuantity</code>. </p>
    ///          <note>
    ///             <p>If you return the <code>UsageQuantity</code> metric, the service aggregates all usage
    ///         numbers without taking the units into account. For example, if you aggregate
    ///         <code>usageQuantity</code> across all of Amazon EC2, the results aren't meaningful because
    ///         Amazon EC2 compute hours and data transfer are measured in different units (for example, hours
    ///         vs. GB). To get more meaningful <code>UsageQuantity</code> metrics, filter by
    ///         <code>UsageType</code> or <code>UsageTypeGroups</code>. </p>
    ///          </note>
    ///          <p>
    ///             <code>Metrics</code> is required for <code>GetCostAndUsageWithResources</code> requests.</p>
    public let metrics: [String]?
    /// <p>The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.</p>
    public let nextPageToken: String?
    /// <p>Sets the start and end dates for retrieving Amazon Web Services costs. The range must be within the last 14 days (the start date cannot be earlier than 14 days ago). The start date is inclusive,  but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is
    ///             retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
    public let timePeriod: DateInterval?

    public init (
        filter: Expression? = nil,
        granularity: Granularity? = nil,
        groupBy: [GroupDefinition]? = nil,
        metrics: [String]? = nil,
        nextPageToken: String? = nil,
        timePeriod: DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.groupBy = groupBy
        self.metrics = metrics
        self.nextPageToken = nextPageToken
        self.timePeriod = timePeriod
    }
}

struct GetCostAndUsageWithResourcesInputBody: Equatable {
    public let timePeriod: DateInterval?
    public let granularity: Granularity?
    public let filter: Expression?
    public let metrics: [String]?
    public let groupBy: [GroupDefinition]?
    public let nextPageToken: String?
}

extension GetCostAndUsageWithResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case metrics = "Metrics"
        case nextPageToken = "NextPageToken"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let granularityDecoded = try containerValues.decodeIfPresent(Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(Expression.self, forKey: .filter)
        filter = filterDecoded
        let metricsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .metrics)
        var metricsDecoded0:[String]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [String]()
            for string0 in metricsContainer {
                if let string0 = string0 {
                    metricsDecoded0?.append(string0)
                }
            }
        }
        metrics = metricsDecoded0
        let groupByContainer = try containerValues.decodeIfPresent([GroupDefinition?].self, forKey: .groupBy)
        var groupByDecoded0:[GroupDefinition]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [GroupDefinition]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetCostAndUsageWithResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCostAndUsageWithResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BillExpirationException" : self = .billExpirationException(try BillExpirationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestChangedException" : self = .requestChangedException(try RequestChangedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCostAndUsageWithResourcesOutputError: Swift.Error, Equatable {
    case billExpirationException(BillExpirationException)
    case dataUnavailableException(DataUnavailableException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case requestChangedException(RequestChangedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCostAndUsageWithResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCostAndUsageWithResourcesOutputResponse(dimensionValueAttributes: \(String(describing: dimensionValueAttributes)), groupDefinitions: \(String(describing: groupDefinitions)), nextPageToken: \(String(describing: nextPageToken)), resultsByTime: \(String(describing: resultsByTime)))"}
}

extension GetCostAndUsageWithResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCostAndUsageWithResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dimensionValueAttributes = output.dimensionValueAttributes
            self.groupDefinitions = output.groupDefinitions
            self.nextPageToken = output.nextPageToken
            self.resultsByTime = output.resultsByTime
        } else {
            self.dimensionValueAttributes = nil
            self.groupDefinitions = nil
            self.nextPageToken = nil
            self.resultsByTime = nil
        }
    }
}

public struct GetCostAndUsageWithResourcesOutputResponse: Equatable {
    /// <p>The attributes that apply to a specific dimension value. For example, if the value is a linked account, the attribute is that account name.</p>
    public let dimensionValueAttributes: [DimensionValuesWithAttributes]?
    /// <p>The groups that are specified by the <code>Filter</code> or <code>GroupBy</code>
    ///       parameters in the request.</p>
    public let groupDefinitions: [GroupDefinition]?
    /// <p>The token for the next set of retrievable results. AWS provides the token when the response from a previous call has more results than the maximum page size.</p>
    public let nextPageToken: String?
    /// <p>The time period that is covered by the results in the response.</p>
    public let resultsByTime: [ResultByTime]?

    public init (
        dimensionValueAttributes: [DimensionValuesWithAttributes]? = nil,
        groupDefinitions: [GroupDefinition]? = nil,
        nextPageToken: String? = nil,
        resultsByTime: [ResultByTime]? = nil
    )
    {
        self.dimensionValueAttributes = dimensionValueAttributes
        self.groupDefinitions = groupDefinitions
        self.nextPageToken = nextPageToken
        self.resultsByTime = resultsByTime
    }
}

struct GetCostAndUsageWithResourcesOutputResponseBody: Equatable {
    public let nextPageToken: String?
    public let groupDefinitions: [GroupDefinition]?
    public let resultsByTime: [ResultByTime]?
    public let dimensionValueAttributes: [DimensionValuesWithAttributes]?
}

extension GetCostAndUsageWithResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dimensionValueAttributes = "DimensionValueAttributes"
        case groupDefinitions = "GroupDefinitions"
        case nextPageToken = "NextPageToken"
        case resultsByTime = "ResultsByTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let groupDefinitionsContainer = try containerValues.decodeIfPresent([GroupDefinition?].self, forKey: .groupDefinitions)
        var groupDefinitionsDecoded0:[GroupDefinition]? = nil
        if let groupDefinitionsContainer = groupDefinitionsContainer {
            groupDefinitionsDecoded0 = [GroupDefinition]()
            for structure0 in groupDefinitionsContainer {
                if let structure0 = structure0 {
                    groupDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        groupDefinitions = groupDefinitionsDecoded0
        let resultsByTimeContainer = try containerValues.decodeIfPresent([ResultByTime?].self, forKey: .resultsByTime)
        var resultsByTimeDecoded0:[ResultByTime]? = nil
        if let resultsByTimeContainer = resultsByTimeContainer {
            resultsByTimeDecoded0 = [ResultByTime]()
            for structure0 in resultsByTimeContainer {
                if let structure0 = structure0 {
                    resultsByTimeDecoded0?.append(structure0)
                }
            }
        }
        resultsByTime = resultsByTimeDecoded0
        let dimensionValueAttributesContainer = try containerValues.decodeIfPresent([DimensionValuesWithAttributes?].self, forKey: .dimensionValueAttributes)
        var dimensionValueAttributesDecoded0:[DimensionValuesWithAttributes]? = nil
        if let dimensionValueAttributesContainer = dimensionValueAttributesContainer {
            dimensionValueAttributesDecoded0 = [DimensionValuesWithAttributes]()
            for structure0 in dimensionValueAttributesContainer {
                if let structure0 = structure0 {
                    dimensionValueAttributesDecoded0?.append(structure0)
                }
            }
        }
        dimensionValueAttributes = dimensionValueAttributesDecoded0
    }
}

public struct GetCostCategoriesInputBodyMiddleware: Middleware {
    public let id: String = "GetCostCategoriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCostCategoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCostCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCostCategoriesInput>
    public typealias MOutput = OperationOutput<GetCostCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCostCategoriesOutputError>
}

extension GetCostCategoriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCostCategoriesInput(costCategoryName: \(String(describing: costCategoryName)), filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextPageToken: \(String(describing: nextPageToken)), searchString: \(String(describing: searchString)), sortBy: \(String(describing: sortBy)), timePeriod: \(String(describing: timePeriod)))"}
}

extension GetCostCategoriesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case costCategoryName = "CostCategoryName"
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case searchString = "SearchString"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costCategoryName = costCategoryName {
            try encodeContainer.encode(costCategoryName, forKey: .costCategoryName)
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let searchString = searchString {
            try encodeContainer.encode(searchString, forKey: .searchString)
        }
        if let sortBy = sortBy {
            var sortByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortBy)
            for sortdefinitions0 in sortBy {
                try sortByContainer.encode(sortdefinitions0)
            }
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

public struct GetCostCategoriesInputHeadersMiddleware: Middleware {
    public let id: String = "GetCostCategoriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCostCategoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCostCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCostCategoriesInput>
    public typealias MOutput = OperationOutput<GetCostCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCostCategoriesOutputError>
}

public struct GetCostCategoriesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCostCategoriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCostCategoriesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCostCategoriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCostCategoriesInput>
    public typealias MOutput = OperationOutput<GetCostCategoriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCostCategoriesOutputError>
}

public struct GetCostCategoriesInput: Equatable {
    /// <p>The unique name of the Cost Category.</p>
    public let costCategoryName: String?
    /// <p>Use <code>Expression</code> to filter by cost or by usage. There are two patterns: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>Simple dimension values - You can set the dimension name and values for the
    ///                     filters that you plan to use. For example, you can filter for
    ///                     <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>. The
    ///                         <code>Expression</code> example looks like:</p>
    ///                 <p>
    ///                   <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1",
    ///                         “us-west-1” ] } }</code>
    ///                 </p>
    ///                 <p>The list of dimension values are OR'd together to retrieve cost or usage
    ///                     data. You can create <code>Expression</code> and <code>DimensionValues</code>
    ///                     objects using either <code>with*</code> methods or <code>set*</code> methods in
    ///                     multiple lines. </p>
    ///             </li>
    ///             <li>
    ///                 <p>Compound dimension values with logical operations - You can use multiple
    ///                         <code>Expression</code> types and the logical operators
    ///                         <code>AND/OR/NOT</code> to create a list of one or more
    ///                         <code>Expression</code> objects. This allows you to filter on more advanced
    ///                     options. For example, you can filter on <code>((REGION == us-east-1 OR
    ///                         REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE !=
    ///                         DataTransfer)</code>. The <code>Expression</code> for that looks like
    ///                     this:</p>
    ///                 <p>
    ///                   <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION",
    ///                         "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName",
    ///                         "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE",
    ///                         "Values": ["DataTransfer"] }}} ] } </code>
    ///                </p>
    ///                 <note>
    ///                     <p>Because each <code>Expression</code> can have only one operator, the
    ///                         service returns an error if more than one is specified. The following
    ///                         example shows an <code>Expression</code> object that creates an
    ///                         error.</p>
    ///                 </note>
    ///                 <p>
    ///                     <code> { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE",
    ///                         "Values": [ "DataTransfer" ] } } </code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///         <note>
    ///             <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT is not
    ///                 supported. OR is not supported between different dimensions, or dimensions and tags.
    ///                 NOT operators aren't supported.
    ///                 Dimensions
    ///                 are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or
    ///                     <code>RIGHTSIZING_TYPE</code>.</p>
    /// 					
    /// 					       <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR are not supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
    /// 					
    /// 					
    /// 					
    ///          </note>
    public let filter: Expression?
    /// <p>This field is only used when <code>SortBy</code> is provided in the request.</p>
    /// 	        <p>The maximum number of objects that to be returned for this request.  If <code>MaxResults</code> is not specified with <code>SortBy</code>, the request will return 1000 results as the default value for this parameter.</p>
    /// 	        <p>For <code>GetCostCategories</code>, MaxResults has an upper limit of 1000.</p>
    public let maxResults: Int
    /// <p>If the number of objects that are still available for retrieval exceeds the limit, AWS returns a NextPageToken value in the response. To retrieve the next batch of objects, provide the NextPageToken from the prior call in your next request.</p>
    public let nextPageToken: String?
    /// <p>The value that you want to search the filter values for.</p>
    /// 	        <p>If you do not specify a <code>CostCategoryName</code>, <code>SearchString</code> will be used to filter Cost Category names that match the <code>SearchString</code> pattern. If you do specifiy a <code>CostCategoryName</code>, <code>SearchString</code> will be used to filter Cost Category values that match the <code>SearchString</code> pattern.</p>
    public let searchString: String?
    /// <p>The value by which you want to sort the data.</p>
    /// 	        <p>The key represents cost and usage metrics. The following values are supported:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>BlendedCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UnblendedCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AmortizedCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NetAmortizedCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NetUnblendedCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UsageQuantity</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NormalizedUsageAmount</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>Supported values for <code>SortOrder</code> are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
    ///          <p>When using <code>SortBy</code>, <code>NextPageToken</code> and <code>SearchString</code> are not supported.</p>
    public let sortBy: [SortDefinition]?
    /// <p>The time period of the request.
    ///         </p>
    public let timePeriod: DateInterval?

    public init (
        costCategoryName: String? = nil,
        filter: Expression? = nil,
        maxResults: Int = 0,
        nextPageToken: String? = nil,
        searchString: String? = nil,
        sortBy: [SortDefinition]? = nil,
        timePeriod: DateInterval? = nil
    )
    {
        self.costCategoryName = costCategoryName
        self.filter = filter
        self.maxResults = maxResults
        self.nextPageToken = nextPageToken
        self.searchString = searchString
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

struct GetCostCategoriesInputBody: Equatable {
    public let searchString: String?
    public let timePeriod: DateInterval?
    public let costCategoryName: String?
    public let filter: Expression?
    public let sortBy: [SortDefinition]?
    public let maxResults: Int
    public let nextPageToken: String?
}

extension GetCostCategoriesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case costCategoryName = "CostCategoryName"
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case searchString = "SearchString"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .searchString)
        searchString = searchStringDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let costCategoryNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .costCategoryName)
        costCategoryName = costCategoryNameDecoded
        let filterDecoded = try containerValues.decodeIfPresent(Expression.self, forKey: .filter)
        filter = filterDecoded
        let sortByContainer = try containerValues.decodeIfPresent([SortDefinition?].self, forKey: .sortBy)
        var sortByDecoded0:[SortDefinition]? = nil
        if let sortByContainer = sortByContainer {
            sortByDecoded0 = [SortDefinition]()
            for structure0 in sortByContainer {
                if let structure0 = structure0 {
                    sortByDecoded0?.append(structure0)
                }
            }
        }
        sortBy = sortByDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetCostCategoriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCostCategoriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BillExpirationException" : self = .billExpirationException(try BillExpirationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestChangedException" : self = .requestChangedException(try RequestChangedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCostCategoriesOutputError: Swift.Error, Equatable {
    case billExpirationException(BillExpirationException)
    case dataUnavailableException(DataUnavailableException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case requestChangedException(RequestChangedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCostCategoriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCostCategoriesOutputResponse(costCategoryNames: \(String(describing: costCategoryNames)), costCategoryValues: \(String(describing: costCategoryValues)), nextPageToken: \(String(describing: nextPageToken)), returnSize: \(String(describing: returnSize)), totalSize: \(String(describing: totalSize)))"}
}

extension GetCostCategoriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCostCategoriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.costCategoryNames = output.costCategoryNames
            self.costCategoryValues = output.costCategoryValues
            self.nextPageToken = output.nextPageToken
            self.returnSize = output.returnSize
            self.totalSize = output.totalSize
        } else {
            self.costCategoryNames = nil
            self.costCategoryValues = nil
            self.nextPageToken = nil
            self.returnSize = nil
            self.totalSize = nil
        }
    }
}

public struct GetCostCategoriesOutputResponse: Equatable {
    /// <p>The names of the Cost Categories.</p>
    public let costCategoryNames: [String]?
    /// <p>The Cost Category values.</p>
    /// 	        <p>
    ///             <code>CostCategoryValues</code> are not returned if <code>CostCategoryName</code> is not specified in the request. </p>
    public let costCategoryValues: [String]?
    /// <p>If the number of objects that are still available for retrieval exceeds the limit, AWS returns a NextPageToken value in the response. To retrieve the next batch of objects, provide the marker from the prior call in your next request.</p>
    public let nextPageToken: String?
    /// <p>The number of objects returned.</p>
    public let returnSize: Int?
    /// <p>The total number of objects.</p>
    public let totalSize: Int?

    public init (
        costCategoryNames: [String]? = nil,
        costCategoryValues: [String]? = nil,
        nextPageToken: String? = nil,
        returnSize: Int? = nil,
        totalSize: Int? = nil
    )
    {
        self.costCategoryNames = costCategoryNames
        self.costCategoryValues = costCategoryValues
        self.nextPageToken = nextPageToken
        self.returnSize = returnSize
        self.totalSize = totalSize
    }
}

struct GetCostCategoriesOutputResponseBody: Equatable {
    public let nextPageToken: String?
    public let costCategoryNames: [String]?
    public let costCategoryValues: [String]?
    public let returnSize: Int?
    public let totalSize: Int?
}

extension GetCostCategoriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case costCategoryNames = "CostCategoryNames"
        case costCategoryValues = "CostCategoryValues"
        case nextPageToken = "NextPageToken"
        case returnSize = "ReturnSize"
        case totalSize = "TotalSize"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let costCategoryNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .costCategoryNames)
        var costCategoryNamesDecoded0:[String]? = nil
        if let costCategoryNamesContainer = costCategoryNamesContainer {
            costCategoryNamesDecoded0 = [String]()
            for string0 in costCategoryNamesContainer {
                if let string0 = string0 {
                    costCategoryNamesDecoded0?.append(string0)
                }
            }
        }
        costCategoryNames = costCategoryNamesDecoded0
        let costCategoryValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .costCategoryValues)
        var costCategoryValuesDecoded0:[String]? = nil
        if let costCategoryValuesContainer = costCategoryValuesContainer {
            costCategoryValuesDecoded0 = [String]()
            for string0 in costCategoryValuesContainer {
                if let string0 = string0 {
                    costCategoryValuesDecoded0?.append(string0)
                }
            }
        }
        costCategoryValues = costCategoryValuesDecoded0
        let returnSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .returnSize)
        returnSize = returnSizeDecoded
        let totalSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalSize)
        totalSize = totalSizeDecoded
    }
}

public struct GetCostForecastInputBodyMiddleware: Middleware {
    public let id: String = "GetCostForecastInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCostForecastInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCostForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCostForecastInput>
    public typealias MOutput = OperationOutput<GetCostForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCostForecastOutputError>
}

extension GetCostForecastInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCostForecastInput(filter: \(String(describing: filter)), granularity: \(String(describing: granularity)), metric: \(String(describing: metric)), predictionIntervalLevel: \(String(describing: predictionIntervalLevel)), timePeriod: \(String(describing: timePeriod)))"}
}

extension GetCostForecastInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case metric = "Metric"
        case predictionIntervalLevel = "PredictionIntervalLevel"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let metric = metric {
            try encodeContainer.encode(metric.rawValue, forKey: .metric)
        }
        if let predictionIntervalLevel = predictionIntervalLevel {
            try encodeContainer.encode(predictionIntervalLevel, forKey: .predictionIntervalLevel)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

public struct GetCostForecastInputHeadersMiddleware: Middleware {
    public let id: String = "GetCostForecastInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCostForecastInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCostForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCostForecastInput>
    public typealias MOutput = OperationOutput<GetCostForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCostForecastOutputError>
}

public struct GetCostForecastInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCostForecastInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCostForecastInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCostForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCostForecastInput>
    public typealias MOutput = OperationOutput<GetCostForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCostForecastOutputError>
}

public struct GetCostForecastInput: Equatable {
    /// <p>The filters that you want to use to filter your forecast. The <code>GetCostForecast</code> API supports filtering by the following dimensions:</p>
    /// 		
    /// 	        <ul>
    ///             <li>
    ///                <p>
    ///                   <code>AZ</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INSTANCE_TYPE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LINKED_ACCOUNT</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LINKED_ACCOUNT_NAME</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OPERATION</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PURCHASE_TYPE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>REGION</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SERVICE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>USAGE_TYPE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>USAGE_TYPE_GROUP</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RECORD_TYPE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OPERATING_SYSTEM</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TENANCY</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SCOPE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PLATFORM</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SUBSCRIPTION_ID</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LEGAL_ENTITY_NAME</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DEPLOYMENT_OPTION</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DATABASE_ENGINE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INSTANCE_TYPE_FAMILY</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>BILLING_ENTITY</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RESERVATION_ID</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SAVINGS_PLAN_ARN</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let filter: Expression?
    /// <p>How granular you want the forecast to be. You can get 3 months of <code>DAILY</code> forecasts or 12 months of <code>MONTHLY</code> forecasts.</p>
    /// 		       <p>The <code>GetCostForecast</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
    public let granularity: Granularity?
    /// <p>Which metric Cost Explorer uses to create your forecast. For more information about blended and unblended rates, see
    /// 			<a href="http://aws.amazon.com/premiumsupport/knowledge-center/blended-rates-intro/">Why does the "blended" annotation
    /// 				appear on some line items in my bill?</a>. </p>
    /// 		       <p>Valid values for a <code>GetCostForecast</code> call are the following:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>AMORTIZED_COST</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>BLENDED_COST</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>NET_AMORTIZED_COST</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>NET_UNBLENDED_COST</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>UNBLENDED_COST</p>
    /// 			         </li>
    ///          </ul>
    public let metric: Metric?
    /// <p>Cost Explorer always returns the mean forecast as a single point. You can request a prediction interval around the mean
    /// 			by specifying a confidence level. The higher the confidence level, the more confident Cost Explorer is about the actual value
    /// 			falling in the prediction interval. Higher confidence levels result in wider prediction intervals.</p>
    public let predictionIntervalLevel: Int?
    /// <p>The period of time that you want the forecast to cover. The start date must be equal to or no later than the current date to avoid a validation error.</p>
    public let timePeriod: DateInterval?

    public init (
        filter: Expression? = nil,
        granularity: Granularity? = nil,
        metric: Metric? = nil,
        predictionIntervalLevel: Int? = nil,
        timePeriod: DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.metric = metric
        self.predictionIntervalLevel = predictionIntervalLevel
        self.timePeriod = timePeriod
    }
}

struct GetCostForecastInputBody: Equatable {
    public let timePeriod: DateInterval?
    public let metric: Metric?
    public let granularity: Granularity?
    public let filter: Expression?
    public let predictionIntervalLevel: Int?
}

extension GetCostForecastInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case metric = "Metric"
        case predictionIntervalLevel = "PredictionIntervalLevel"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let metricDecoded = try containerValues.decodeIfPresent(Metric.self, forKey: .metric)
        metric = metricDecoded
        let granularityDecoded = try containerValues.decodeIfPresent(Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(Expression.self, forKey: .filter)
        filter = filterDecoded
        let predictionIntervalLevelDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .predictionIntervalLevel)
        predictionIntervalLevel = predictionIntervalLevelDecoded
    }
}

extension GetCostForecastOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCostForecastOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCostForecastOutputError: Swift.Error, Equatable {
    case dataUnavailableException(DataUnavailableException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCostForecastOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCostForecastOutputResponse(forecastResultsByTime: \(String(describing: forecastResultsByTime)), total: \(String(describing: total)))"}
}

extension GetCostForecastOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCostForecastOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.forecastResultsByTime = output.forecastResultsByTime
            self.total = output.total
        } else {
            self.forecastResultsByTime = nil
            self.total = nil
        }
    }
}

public struct GetCostForecastOutputResponse: Equatable {
    /// <p>The forecasts for your query, in order. For <code>DAILY</code> forecasts, this is a list of days. For <code>MONTHLY</code> forecasts,
    /// 			this is a list of months.</p>
    public let forecastResultsByTime: [ForecastResult]?
    /// <p>How much you are forecasted to spend over the forecast period, in <code>USD</code>.</p>
    public let total: MetricValue?

    public init (
        forecastResultsByTime: [ForecastResult]? = nil,
        total: MetricValue? = nil
    )
    {
        self.forecastResultsByTime = forecastResultsByTime
        self.total = total
    }
}

struct GetCostForecastOutputResponseBody: Equatable {
    public let total: MetricValue?
    public let forecastResultsByTime: [ForecastResult]?
}

extension GetCostForecastOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case forecastResultsByTime = "ForecastResultsByTime"
        case total = "Total"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(MetricValue.self, forKey: .total)
        total = totalDecoded
        let forecastResultsByTimeContainer = try containerValues.decodeIfPresent([ForecastResult?].self, forKey: .forecastResultsByTime)
        var forecastResultsByTimeDecoded0:[ForecastResult]? = nil
        if let forecastResultsByTimeContainer = forecastResultsByTimeContainer {
            forecastResultsByTimeDecoded0 = [ForecastResult]()
            for structure0 in forecastResultsByTimeContainer {
                if let structure0 = structure0 {
                    forecastResultsByTimeDecoded0?.append(structure0)
                }
            }
        }
        forecastResultsByTime = forecastResultsByTimeDecoded0
    }
}

public struct GetDimensionValuesInputBodyMiddleware: Middleware {
    public let id: String = "GetDimensionValuesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDimensionValuesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDimensionValuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDimensionValuesInput>
    public typealias MOutput = OperationOutput<GetDimensionValuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDimensionValuesOutputError>
}

extension GetDimensionValuesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDimensionValuesInput(context: \(String(describing: context)), dimension: \(String(describing: dimension)), filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextPageToken: \(String(describing: nextPageToken)), searchString: \(String(describing: searchString)), sortBy: \(String(describing: sortBy)), timePeriod: \(String(describing: timePeriod)))"}
}

extension GetDimensionValuesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case context = "Context"
        case dimension = "Dimension"
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case searchString = "SearchString"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let context = context {
            try encodeContainer.encode(context.rawValue, forKey: .context)
        }
        if let dimension = dimension {
            try encodeContainer.encode(dimension.rawValue, forKey: .dimension)
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let searchString = searchString {
            try encodeContainer.encode(searchString, forKey: .searchString)
        }
        if let sortBy = sortBy {
            var sortByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortBy)
            for sortdefinitions0 in sortBy {
                try sortByContainer.encode(sortdefinitions0)
            }
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

public struct GetDimensionValuesInputHeadersMiddleware: Middleware {
    public let id: String = "GetDimensionValuesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDimensionValuesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDimensionValuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDimensionValuesInput>
    public typealias MOutput = OperationOutput<GetDimensionValuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDimensionValuesOutputError>
}

public struct GetDimensionValuesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDimensionValuesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDimensionValuesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDimensionValuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDimensionValuesInput>
    public typealias MOutput = OperationOutput<GetDimensionValuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDimensionValuesOutputError>
}

public struct GetDimensionValuesInput: Equatable {
    /// <p>The context for the call to <code>GetDimensionValues</code>. This can be <code>RESERVATIONS</code> or <code>COST_AND_USAGE</code>.
    /// 			The default value is <code>COST_AND_USAGE</code>. If the context is set to <code>RESERVATIONS</code>, the resulting dimension values
    /// 			can be used in the <code>GetReservationUtilization</code> operation. If the context is set to <code>COST_AND_USAGE</code>,
    /// 			the resulting dimension values can be used in the <code>GetCostAndUsage</code> operation.</p>
    /// 		       <p>If you set the context to <code>COST_AND_USAGE</code>, you can use the following
    ///            dimensions for searching:</p>
    ///            <ul>
    ///             <li>
    ///                <p>AZ - The Availability Zone. An example is <code>us-east-1a</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>DATABASE_ENGINE - The Amazon Relational Database Service database. Examples are Aurora or MySQL.</p>
    ///             </li>
    ///             <li>
    ///                <p>INSTANCE_TYPE - The type of Amazon EC2 instance. An example is <code>m4.xlarge</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>LEGAL_ENTITY_NAME - The name of the organization that sells you AWS services, such as Amazon Web Services.</p>
    ///             </li>
    ///             <li>
    ///                <p>LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value
    ///                field contains the AWS ID of the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>OPERATING_SYSTEM - The operating system. Examples are Windows or Linux.</p>
    ///             </li>
    ///             <li>
    ///                <p>OPERATION - The action performed. Examples include <code>RunInstance</code> and <code>CreateBucket</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.</p>
    ///             </li>
    ///             <li>
    ///                <p>PURCHASE_TYPE - The reservation type of the purchase to which this usage is related. Examples include On-Demand
    ///                Instances and Standard Reserved Instances.</p>
    ///             </li>
    ///             <li>
    ///                <p>SERVICE - The AWS service such as Amazon DynamoDB.</p>
    ///             </li>
    ///             <li>
    ///                <p>USAGE_TYPE - The type of usage. An example is DataTransfer-In-Bytes. The response for the <code>GetDimensionValues</code> operation
    ///            includes a unit attribute. Examples include GB and Hrs.</p>
    ///             </li>
    ///             <li>
    ///                <p>USAGE_TYPE_GROUP - The grouping of common usage types. An example is Amazon EC2: CloudWatch – Alarms. The response for this
    ///                operation includes a unit attribute.</p>
    ///             </li>
    ///             <li>
    ///                <p>REGION - The AWS Region.</p>
    ///             </li>
    ///             <li>
    ///                <p>RECORD_TYPE - The different types of charges such as RI fees, usage costs, tax refunds, and credits.</p>
    ///             </li>
    ///             <li>
    ///                <p>RESOURCE_ID - The unique identifier of the resource. ResourceId is an opt-in feature only available for last 14 days for EC2-Compute Service.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you set the context to <code>RESERVATIONS</code>, you can use the following
    ///            dimensions for searching:</p>
    ///          <ul>
    ///             <li>
    ///                <p>AZ - The Availability Zone. An example is <code>us-east-1a</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.</p>
    ///             </li>
    ///             <li>
    ///                <p>DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are <code>SingleAZ</code> and <code>MultiAZ</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>INSTANCE_TYPE - The type of Amazon EC2 instance. An example is <code>m4.xlarge</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value
    ///                field contains the AWS ID of the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.</p>
    ///             </li>
    ///             <li>
    ///                <p>REGION - The AWS Region.</p>
    ///             </li>
    ///             <li>
    ///                <p>SCOPE (Utilization only) - The scope of a Reserved Instance (RI). Values are regional or a single Availability Zone.</p>
    ///             </li>
    ///             <li>
    ///                <p>TAG (Coverage only) - The tags that are associated with a Reserved Instance (RI).</p>
    ///             </li>
    ///             <li>
    ///                <p>TENANCY - The tenancy of a resource. Examples are shared or dedicated.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you set the context to <code>SAVINGS_PLANS</code>, you can use the following dimensions for searching:</p>
    ///          <ul>
    ///             <li>
    ///                <p>SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute)</p>
    ///             </li>
    ///             <li>
    ///                <p>PAYMENT_OPTION - Payment option for the given Savings Plans (for example, All Upfront)</p>
    ///             </li>
    ///             <li>
    ///                <p>REGION - The AWS Region.</p>
    ///             </li>
    ///             <li>
    ///                <p>INSTANCE_TYPE_FAMILY - The family of instances (For example, <code>m5</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value
    ///                field contains the AWS ID of the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>SAVINGS_PLAN_ARN - The unique identifier for your Savings Plan</p>
    ///             </li>
    ///          </ul>
    public let context: Context?
    /// <p>The name of the dimension. Each <code>Dimension</code> is available for a different <code>Context</code>.
    /// 			For more information, see <code>Context</code>.
    /// 			
    /// 		</p>
    public let dimension: Dimension?
    /// <p>Use <code>Expression</code> to filter by cost or by usage. There are two patterns: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>Simple dimension values - You can set the dimension name and values for the
    ///                     filters that you plan to use. For example, you can filter for
    ///                     <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>. The
    ///                         <code>Expression</code> example looks like:</p>
    ///                 <p>
    ///                   <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1",
    ///                         “us-west-1” ] } }</code>
    ///                 </p>
    ///                 <p>The list of dimension values are OR'd together to retrieve cost or usage
    ///                     data. You can create <code>Expression</code> and <code>DimensionValues</code>
    ///                     objects using either <code>with*</code> methods or <code>set*</code> methods in
    ///                     multiple lines. </p>
    ///             </li>
    ///             <li>
    ///                 <p>Compound dimension values with logical operations - You can use multiple
    ///                         <code>Expression</code> types and the logical operators
    ///                         <code>AND/OR/NOT</code> to create a list of one or more
    ///                         <code>Expression</code> objects. This allows you to filter on more advanced
    ///                     options. For example, you can filter on <code>((REGION == us-east-1 OR
    ///                         REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE !=
    ///                         DataTransfer)</code>. The <code>Expression</code> for that looks like
    ///                     this:</p>
    ///                 <p>
    ///                   <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION",
    ///                         "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName",
    ///                         "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE",
    ///                         "Values": ["DataTransfer"] }}} ] } </code>
    ///                </p>
    ///                 <note>
    ///                     <p>Because each <code>Expression</code> can have only one operator, the
    ///                         service returns an error if more than one is specified. The following
    ///                         example shows an <code>Expression</code> object that creates an
    ///                         error.</p>
    ///                 </note>
    ///                 <p>
    ///                     <code> { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE",
    ///                         "Values": [ "DataTransfer" ] } } </code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///         <note>
    ///             <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT is not
    ///                 supported. OR is not supported between different dimensions, or dimensions and tags.
    ///                 NOT operators aren't supported.
    ///                 Dimensions
    ///                 are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or
    ///                     <code>RIGHTSIZING_TYPE</code>.</p>
    /// 					
    /// 					       <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR are not supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
    /// 					
    /// 					
    /// 					
    ///          </note>
    public let filter: Expression?
    /// <p>This field is only used when SortBy is provided in the request. The maximum number of objects that to be returned for this request. If MaxResults is not specified with SortBy, the request will return 1000 results as the default value for this parameter.</p>
    /// 	        <p>For <code>GetDimensionValues</code>, MaxResults has an upper limit of 1000.</p>
    public let maxResults: Int
    /// <p>The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.</p>
    public let nextPageToken: String?
    /// <p>The value that you want to search the filter values for.</p>
    public let searchString: String?
    /// <p>The value by which you want to sort the data.</p>
    /// 	        <p>The key represents cost and usage metrics. The following values are supported:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>BlendedCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UnblendedCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AmortizedCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NetAmortizedCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NetUnblendedCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UsageQuantity</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NormalizedUsageAmount</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>Supported values for <code>SortOrder</code> are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
    ///          <p>When you specify a <code>SortBy</code> paramater, the context must be <code>COST_AND_USAGE</code>. Further, when using <code>SortBy</code>, <code>NextPageToken</code> and <code>SearchString</code> are not supported.</p>
    public let sortBy: [SortDefinition]?
    /// <p>The start and end dates for retrieving the dimension values. The start date is inclusive,  but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is
    ///             retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
    public let timePeriod: DateInterval?

    public init (
        context: Context? = nil,
        dimension: Dimension? = nil,
        filter: Expression? = nil,
        maxResults: Int = 0,
        nextPageToken: String? = nil,
        searchString: String? = nil,
        sortBy: [SortDefinition]? = nil,
        timePeriod: DateInterval? = nil
    )
    {
        self.context = context
        self.dimension = dimension
        self.filter = filter
        self.maxResults = maxResults
        self.nextPageToken = nextPageToken
        self.searchString = searchString
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

struct GetDimensionValuesInputBody: Equatable {
    public let searchString: String?
    public let timePeriod: DateInterval?
    public let dimension: Dimension?
    public let context: Context?
    public let filter: Expression?
    public let sortBy: [SortDefinition]?
    public let maxResults: Int
    public let nextPageToken: String?
}

extension GetDimensionValuesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case context = "Context"
        case dimension = "Dimension"
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case searchString = "SearchString"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .searchString)
        searchString = searchStringDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let dimensionDecoded = try containerValues.decodeIfPresent(Dimension.self, forKey: .dimension)
        dimension = dimensionDecoded
        let contextDecoded = try containerValues.decodeIfPresent(Context.self, forKey: .context)
        context = contextDecoded
        let filterDecoded = try containerValues.decodeIfPresent(Expression.self, forKey: .filter)
        filter = filterDecoded
        let sortByContainer = try containerValues.decodeIfPresent([SortDefinition?].self, forKey: .sortBy)
        var sortByDecoded0:[SortDefinition]? = nil
        if let sortByContainer = sortByContainer {
            sortByDecoded0 = [SortDefinition]()
            for structure0 in sortByContainer {
                if let structure0 = structure0 {
                    sortByDecoded0?.append(structure0)
                }
            }
        }
        sortBy = sortByDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetDimensionValuesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDimensionValuesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BillExpirationException" : self = .billExpirationException(try BillExpirationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestChangedException" : self = .requestChangedException(try RequestChangedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDimensionValuesOutputError: Swift.Error, Equatable {
    case billExpirationException(BillExpirationException)
    case dataUnavailableException(DataUnavailableException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case requestChangedException(RequestChangedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDimensionValuesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDimensionValuesOutputResponse(dimensionValues: \(String(describing: dimensionValues)), nextPageToken: \(String(describing: nextPageToken)), returnSize: \(String(describing: returnSize)), totalSize: \(String(describing: totalSize)))"}
}

extension GetDimensionValuesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDimensionValuesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.dimensionValues = output.dimensionValues
            self.nextPageToken = output.nextPageToken
            self.returnSize = output.returnSize
            self.totalSize = output.totalSize
        } else {
            self.dimensionValues = nil
            self.nextPageToken = nil
            self.returnSize = nil
            self.totalSize = nil
        }
    }
}

public struct GetDimensionValuesOutputResponse: Equatable {
    /// <p>The filters that you used to filter your request. Some dimensions are available only for a specific context.</p>
    /// 		       <p>If you set the context to <code>COST_AND_USAGE</code>, you can use the following
    ///            dimensions for searching:</p>
    ///            <ul>
    ///             <li>
    ///                <p>AZ - The Availability Zone. An example is <code>us-east-1a</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>DATABASE_ENGINE - The Amazon Relational Database Service database. Examples are Aurora or MySQL.</p>
    ///             </li>
    ///             <li>
    ///                <p>INSTANCE_TYPE - The type of Amazon EC2 instance. An example is <code>m4.xlarge</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>LEGAL_ENTITY_NAME - The name of the organization that sells you AWS services, such as Amazon Web Services.</p>
    ///             </li>
    ///             <li>
    ///                <p>LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value
    ///                field contains the AWS ID of the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>OPERATING_SYSTEM - The operating system. Examples are Windows or Linux.</p>
    ///             </li>
    ///             <li>
    ///                <p>OPERATION - The action performed. Examples include <code>RunInstance</code> and <code>CreateBucket</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.</p>
    ///             </li>
    ///             <li>
    ///                <p>PURCHASE_TYPE - The reservation type of the purchase to which this usage is related. Examples include On-Demand
    ///                Instances and Standard Reserved Instances.</p>
    ///             </li>
    ///             <li>
    ///                <p>SERVICE - The AWS service such as Amazon DynamoDB.</p>
    ///             </li>
    ///             <li>
    ///                <p>USAGE_TYPE - The type of usage. An example is DataTransfer-In-Bytes. The response for the <code>GetDimensionValues</code> operation
    ///            includes a unit attribute. Examples include GB and Hrs.</p>
    ///             </li>
    ///             <li>
    ///                <p>USAGE_TYPE_GROUP - The grouping of common usage types. An example is Amazon EC2: CloudWatch – Alarms. The response for this
    ///                operation includes a unit attribute.</p>
    ///             </li>
    ///             <li>
    ///                <p>RECORD_TYPE - The different types of charges such as RI fees, usage costs, tax refunds, and credits.</p>
    ///             </li>
    ///             <li>
    ///                <p>RESOURCE_ID - The unique identifier of the resource. ResourceId is an opt-in feature only available for last 14 days for EC2-Compute Service.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you set the context to <code>RESERVATIONS</code>, you can use the following
    ///            dimensions for searching:</p>
    ///          <ul>
    ///             <li>
    ///                <p>AZ - The Availability Zone. An example is <code>us-east-1a</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>CACHE_ENGINE - The Amazon ElastiCache operating system. Examples are Windows or Linux.</p>
    ///             </li>
    ///             <li>
    ///                <p>DEPLOYMENT_OPTION - The scope of Amazon Relational Database Service deployments. Valid values are <code>SingleAZ</code> and <code>MultiAZ</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>INSTANCE_TYPE - The type of Amazon EC2 instance. An example is <code>m4.xlarge</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value
    ///                field contains the AWS ID of the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>PLATFORM - The Amazon EC2 operating system. Examples are Windows or Linux.</p>
    ///             </li>
    ///             <li>
    ///                <p>REGION - The AWS Region.</p>
    ///             </li>
    ///             <li>
    ///                <p>SCOPE (Utilization only) - The scope of a Reserved Instance (RI). Values are regional or a single Availability Zone.</p>
    ///             </li>
    ///             <li>
    ///                <p>TAG (Coverage only) - The tags that are associated with a Reserved Instance (RI).</p>
    ///             </li>
    ///             <li>
    ///                <p>TENANCY - The tenancy of a resource. Examples are shared or dedicated.</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you set the context to <code>SAVINGS_PLANS</code>, you can use the following dimensions for searching:</p>
    ///          <ul>
    ///             <li>
    ///                <p>SAVINGS_PLANS_TYPE - Type of Savings Plans (EC2 Instance or Compute)</p>
    ///             </li>
    ///             <li>
    ///                <p>PAYMENT_OPTION - Payment option for the given Savings Plans (for example, All Upfront)</p>
    ///             </li>
    ///             <li>
    ///                <p>REGION - The AWS Region.</p>
    ///             </li>
    ///             <li>
    ///                <p>INSTANCE_TYPE_FAMILY - The family of instances (For example, <code>m5</code>)</p>
    ///             </li>
    ///             <li>
    ///                <p>LINKED_ACCOUNT - The description in the attribute map that includes the full name of the member account. The value
    ///                field contains the AWS ID of the member account.</p>
    ///             </li>
    ///             <li>
    ///                <p>SAVINGS_PLAN_ARN - The unique identifier for your Savings Plan</p>
    ///             </li>
    ///          </ul>
    public let dimensionValues: [DimensionValuesWithAttributes]?
    /// <p>The token for the next set of retrievable results. AWS provides the token when the response from a previous call has more results than the maximum page size.</p>
    public let nextPageToken: String?
    /// <p>The number of results that AWS returned at one time.</p>
    public let returnSize: Int?
    /// <p>The total number of search results.</p>
    public let totalSize: Int?

    public init (
        dimensionValues: [DimensionValuesWithAttributes]? = nil,
        nextPageToken: String? = nil,
        returnSize: Int? = nil,
        totalSize: Int? = nil
    )
    {
        self.dimensionValues = dimensionValues
        self.nextPageToken = nextPageToken
        self.returnSize = returnSize
        self.totalSize = totalSize
    }
}

struct GetDimensionValuesOutputResponseBody: Equatable {
    public let dimensionValues: [DimensionValuesWithAttributes]?
    public let returnSize: Int?
    public let totalSize: Int?
    public let nextPageToken: String?
}

extension GetDimensionValuesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dimensionValues = "DimensionValues"
        case nextPageToken = "NextPageToken"
        case returnSize = "ReturnSize"
        case totalSize = "TotalSize"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionValuesContainer = try containerValues.decodeIfPresent([DimensionValuesWithAttributes?].self, forKey: .dimensionValues)
        var dimensionValuesDecoded0:[DimensionValuesWithAttributes]? = nil
        if let dimensionValuesContainer = dimensionValuesContainer {
            dimensionValuesDecoded0 = [DimensionValuesWithAttributes]()
            for structure0 in dimensionValuesContainer {
                if let structure0 = structure0 {
                    dimensionValuesDecoded0?.append(structure0)
                }
            }
        }
        dimensionValues = dimensionValuesDecoded0
        let returnSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .returnSize)
        returnSize = returnSizeDecoded
        let totalSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalSize)
        totalSize = totalSizeDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct GetReservationCoverageInputBodyMiddleware: Middleware {
    public let id: String = "GetReservationCoverageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReservationCoverageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReservationCoverageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReservationCoverageInput>
    public typealias MOutput = OperationOutput<GetReservationCoverageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReservationCoverageOutputError>
}

extension GetReservationCoverageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetReservationCoverageInput(filter: \(String(describing: filter)), granularity: \(String(describing: granularity)), groupBy: \(String(describing: groupBy)), maxResults: \(String(describing: maxResults)), metrics: \(String(describing: metrics)), nextPageToken: \(String(describing: nextPageToken)), sortBy: \(String(describing: sortBy)), timePeriod: \(String(describing: timePeriod)))"}
}

extension GetReservationCoverageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case maxResults = "MaxResults"
        case metrics = "Metrics"
        case nextPageToken = "NextPageToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for groupdefinitions0 in groupBy {
                try groupByContainer.encode(groupdefinitions0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metrics)
            for metricnames0 in metrics {
                try metricsContainer.encode(metricnames0)
            }
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

public struct GetReservationCoverageInputHeadersMiddleware: Middleware {
    public let id: String = "GetReservationCoverageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReservationCoverageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReservationCoverageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReservationCoverageInput>
    public typealias MOutput = OperationOutput<GetReservationCoverageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReservationCoverageOutputError>
}

public struct GetReservationCoverageInputQueryItemMiddleware: Middleware {
    public let id: String = "GetReservationCoverageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReservationCoverageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReservationCoverageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReservationCoverageInput>
    public typealias MOutput = OperationOutput<GetReservationCoverageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReservationCoverageOutputError>
}

/// <p>You can use the following request parameters to query for how much of your instance usage a reservation covered.</p>
public struct GetReservationCoverageInput: Equatable {
    /// <p>Filters utilization data by dimensions. You can filter by the following dimensions:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>AZ</p>
    ///             </li>
    ///             <li>
    ///                <p>CACHE_ENGINE</p>
    ///             </li>
    ///             <li>
    ///                <p>DATABASE_ENGINE</p>
    ///             </li>
    ///             <li>
    ///                <p>DEPLOYMENT_OPTION</p>
    ///             </li>
    ///             <li>
    ///                <p>INSTANCE_TYPE</p>
    ///             </li>
    ///             <li>
    ///                <p>LINKED_ACCOUNT</p>
    ///             </li>
    ///             <li>
    ///                <p>OPERATING_SYSTEM</p>
    ///             </li>
    ///             <li>
    ///                <p>PLATFORM</p>
    ///             </li>
    ///             <li>
    ///                <p>REGION</p>
    ///             </li>
    ///             <li>
    ///                <p>SERVICE</p>
    ///             </li>
    ///             <li>
    ///                <p>TAG</p>
    ///             </li>
    ///             <li>
    ///                <p>TENANCY</p>
    ///             </li>
    ///          </ul>
    /// 		       <p>
    ///             <code>GetReservationCoverage</code> uses the same
    /// 			<a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object
    /// 			as the other operations, but only <code>AND</code> is supported among each dimension. You can nest only one level deep.
    /// 			If there are multiple values for a dimension, they are OR'd together.</p>
    /// 		       <p>If you don't provide a <code>SERVICE</code> filter, Cost Explorer defaults to EC2.</p>
    /// 	        <p>Cost category is also supported.</p>
    public let filter: Expression?
    /// <p>The granularity of the AWS cost data for the reservation. Valid values are <code>MONTHLY</code> and <code>DAILY</code>.</p>
    /// 		       <p>If <code>GroupBy</code> is set, <code>Granularity</code> can't be set. If <code>Granularity</code> isn't set,
    /// 			the response object doesn't include <code>Granularity</code>, either <code>MONTHLY</code> or <code>DAILY</code>.</p>
    /// 		       <p>The <code>GetReservationCoverage</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
    public let granularity: Granularity?
    /// <p>You can group the data by the following attributes:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>AZ</p>
    ///             </li>
    ///             <li>
    ///                <p>CACHE_ENGINE</p>
    ///             </li>
    ///             <li>
    ///                <p>DATABASE_ENGINE</p>
    ///             </li>
    ///             <li>
    ///                <p>DEPLOYMENT_OPTION</p>
    ///             </li>
    ///             <li>
    ///                <p>INSTANCE_TYPE</p>
    ///             </li>
    ///             <li>
    ///                <p>LINKED_ACCOUNT</p>
    ///             </li>
    ///             <li>
    ///                <p>OPERATING_SYSTEM</p>
    ///             </li>
    ///             <li>
    ///                <p>PLATFORM</p>
    ///             </li>
    ///             <li>
    ///                <p>REGION</p>
    ///             </li>
    ///             <li>
    ///                <p>TENANCY</p>
    ///             </li>
    ///          </ul>
    public let groupBy: [GroupDefinition]?
    /// <p>The maximum number of objects that you returned for this request. If more objects are available, in the response, AWS provides a NextPageToken value that you can use in a subsequent call to get the next batch of objects.</p>
    public let maxResults: Int
    /// <p>The measurement that you want your reservation coverage reported in.</p>
    /// 		       <p>Valid values are <code>Hour</code>, <code>Unit</code>, and <code>Cost</code>. You can use multiple values in a request.</p>
    public let metrics: [String]?
    /// <p>The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.</p>
    public let nextPageToken: String?
    /// <p>The value by which you want to sort the data.</p>
    /// 	        <p>The following values are supported for <code>Key</code>:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>OnDemandCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CoverageHoursPercentage</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OnDemandHours</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ReservedHours</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TotalRunningHours</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CoverageNormalizedUnitsPercentage</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OnDemandNormalizedUnits</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ReservedNormalizedUnits</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TotalRunningNormalizedUnits</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Time</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>Supported values for <code>SortOrder</code> are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
    public let sortBy: SortDefinition?
    /// <p>The start and end dates of the period that you want to retrieve data about reservation coverage for. You can retrieve data
    /// 			for a maximum of 13 months: the last 12 months and the current month. The start date is inclusive,  but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is
    ///             retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>. </p>
    public let timePeriod: DateInterval?

    public init (
        filter: Expression? = nil,
        granularity: Granularity? = nil,
        groupBy: [GroupDefinition]? = nil,
        maxResults: Int = 0,
        metrics: [String]? = nil,
        nextPageToken: String? = nil,
        sortBy: SortDefinition? = nil,
        timePeriod: DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.groupBy = groupBy
        self.maxResults = maxResults
        self.metrics = metrics
        self.nextPageToken = nextPageToken
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

struct GetReservationCoverageInputBody: Equatable {
    public let timePeriod: DateInterval?
    public let groupBy: [GroupDefinition]?
    public let granularity: Granularity?
    public let filter: Expression?
    public let metrics: [String]?
    public let nextPageToken: String?
    public let sortBy: SortDefinition?
    public let maxResults: Int
}

extension GetReservationCoverageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case maxResults = "MaxResults"
        case metrics = "Metrics"
        case nextPageToken = "NextPageToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let groupByContainer = try containerValues.decodeIfPresent([GroupDefinition?].self, forKey: .groupBy)
        var groupByDecoded0:[GroupDefinition]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [GroupDefinition]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let granularityDecoded = try containerValues.decodeIfPresent(Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(Expression.self, forKey: .filter)
        filter = filterDecoded
        let metricsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .metrics)
        var metricsDecoded0:[String]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [String]()
            for string0 in metricsContainer {
                if let string0 = string0 {
                    metricsDecoded0?.append(string0)
                }
            }
        }
        metrics = metricsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(SortDefinition.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetReservationCoverageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReservationCoverageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetReservationCoverageOutputError: Swift.Error, Equatable {
    case dataUnavailableException(DataUnavailableException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReservationCoverageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetReservationCoverageOutputResponse(coveragesByTime: \(String(describing: coveragesByTime)), nextPageToken: \(String(describing: nextPageToken)), total: \(String(describing: total)))"}
}

extension GetReservationCoverageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetReservationCoverageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.coveragesByTime = output.coveragesByTime
            self.nextPageToken = output.nextPageToken
            self.total = output.total
        } else {
            self.coveragesByTime = nil
            self.nextPageToken = nil
            self.total = nil
        }
    }
}

public struct GetReservationCoverageOutputResponse: Equatable {
    /// <p>The amount of time that your reservations covered.</p>
    public let coveragesByTime: [CoverageByTime]?
    /// <p>The token for the next set of retrievable results. AWS provides the token when the response from a previous call has more results than the maximum page size.</p>
    public let nextPageToken: String?
    /// <p>The total amount of instance usage that a reservation covered.</p>
    public let total: Coverage?

    public init (
        coveragesByTime: [CoverageByTime]? = nil,
        nextPageToken: String? = nil,
        total: Coverage? = nil
    )
    {
        self.coveragesByTime = coveragesByTime
        self.nextPageToken = nextPageToken
        self.total = total
    }
}

struct GetReservationCoverageOutputResponseBody: Equatable {
    public let coveragesByTime: [CoverageByTime]?
    public let total: Coverage?
    public let nextPageToken: String?
}

extension GetReservationCoverageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case coveragesByTime = "CoveragesByTime"
        case nextPageToken = "NextPageToken"
        case total = "Total"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coveragesByTimeContainer = try containerValues.decodeIfPresent([CoverageByTime?].self, forKey: .coveragesByTime)
        var coveragesByTimeDecoded0:[CoverageByTime]? = nil
        if let coveragesByTimeContainer = coveragesByTimeContainer {
            coveragesByTimeDecoded0 = [CoverageByTime]()
            for structure0 in coveragesByTimeContainer {
                if let structure0 = structure0 {
                    coveragesByTimeDecoded0?.append(structure0)
                }
            }
        }
        coveragesByTime = coveragesByTimeDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(Coverage.self, forKey: .total)
        total = totalDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct GetReservationPurchaseRecommendationInputBodyMiddleware: Middleware {
    public let id: String = "GetReservationPurchaseRecommendationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReservationPurchaseRecommendationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReservationPurchaseRecommendationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReservationPurchaseRecommendationInput>
    public typealias MOutput = OperationOutput<GetReservationPurchaseRecommendationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReservationPurchaseRecommendationOutputError>
}

extension GetReservationPurchaseRecommendationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetReservationPurchaseRecommendationInput(accountId: \(String(describing: accountId)), accountScope: \(String(describing: accountScope)), filter: \(String(describing: filter)), lookbackPeriodInDays: \(String(describing: lookbackPeriodInDays)), nextPageToken: \(String(describing: nextPageToken)), pageSize: \(String(describing: pageSize)), paymentOption: \(String(describing: paymentOption)), service: \(String(describing: service)), serviceSpecification: \(String(describing: serviceSpecification)), termInYears: \(String(describing: termInYears)))"}
}

extension GetReservationPurchaseRecommendationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case accountScope = "AccountScope"
        case filter = "Filter"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case nextPageToken = "NextPageToken"
        case pageSize = "PageSize"
        case paymentOption = "PaymentOption"
        case service = "Service"
        case serviceSpecification = "ServiceSpecification"
        case termInYears = "TermInYears"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let accountScope = accountScope {
            try encodeContainer.encode(accountScope.rawValue, forKey: .accountScope)
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let lookbackPeriodInDays = lookbackPeriodInDays {
            try encodeContainer.encode(lookbackPeriodInDays.rawValue, forKey: .lookbackPeriodInDays)
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let paymentOption = paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let service = service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let serviceSpecification = serviceSpecification {
            try encodeContainer.encode(serviceSpecification, forKey: .serviceSpecification)
        }
        if let termInYears = termInYears {
            try encodeContainer.encode(termInYears.rawValue, forKey: .termInYears)
        }
    }
}

public struct GetReservationPurchaseRecommendationInputHeadersMiddleware: Middleware {
    public let id: String = "GetReservationPurchaseRecommendationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReservationPurchaseRecommendationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReservationPurchaseRecommendationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReservationPurchaseRecommendationInput>
    public typealias MOutput = OperationOutput<GetReservationPurchaseRecommendationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReservationPurchaseRecommendationOutputError>
}

public struct GetReservationPurchaseRecommendationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetReservationPurchaseRecommendationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReservationPurchaseRecommendationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReservationPurchaseRecommendationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReservationPurchaseRecommendationInput>
    public typealias MOutput = OperationOutput<GetReservationPurchaseRecommendationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReservationPurchaseRecommendationOutputError>
}

public struct GetReservationPurchaseRecommendationInput: Equatable {
    /// <p>The account ID that is associated with the recommendation. </p>
    public let accountId: String?
    /// <p>The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to <code>PAYER</code>. If the value is <code>LINKED</code>, recommendations are calculated for individual member accounts only.</p>
    public let accountScope: AccountScope?
    /// <p>Use <code>Expression</code> to filter by cost or by usage. There are two patterns: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>Simple dimension values - You can set the dimension name and values for the
    ///                     filters that you plan to use. For example, you can filter for
    ///                     <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>. The
    ///                         <code>Expression</code> example looks like:</p>
    ///                 <p>
    ///                   <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1",
    ///                         “us-west-1” ] } }</code>
    ///                 </p>
    ///                 <p>The list of dimension values are OR'd together to retrieve cost or usage
    ///                     data. You can create <code>Expression</code> and <code>DimensionValues</code>
    ///                     objects using either <code>with*</code> methods or <code>set*</code> methods in
    ///                     multiple lines. </p>
    ///             </li>
    ///             <li>
    ///                 <p>Compound dimension values with logical operations - You can use multiple
    ///                         <code>Expression</code> types and the logical operators
    ///                         <code>AND/OR/NOT</code> to create a list of one or more
    ///                         <code>Expression</code> objects. This allows you to filter on more advanced
    ///                     options. For example, you can filter on <code>((REGION == us-east-1 OR
    ///                         REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE !=
    ///                         DataTransfer)</code>. The <code>Expression</code> for that looks like
    ///                     this:</p>
    ///                 <p>
    ///                   <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION",
    ///                         "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName",
    ///                         "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE",
    ///                         "Values": ["DataTransfer"] }}} ] } </code>
    ///                </p>
    ///                 <note>
    ///                     <p>Because each <code>Expression</code> can have only one operator, the
    ///                         service returns an error if more than one is specified. The following
    ///                         example shows an <code>Expression</code> object that creates an
    ///                         error.</p>
    ///                 </note>
    ///                 <p>
    ///                     <code> { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE",
    ///                         "Values": [ "DataTransfer" ] } } </code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///         <note>
    ///             <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT is not
    ///                 supported. OR is not supported between different dimensions, or dimensions and tags.
    ///                 NOT operators aren't supported.
    ///                 Dimensions
    ///                 are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or
    ///                     <code>RIGHTSIZING_TYPE</code>.</p>
    /// 					
    /// 					       <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR are not supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
    /// 					
    /// 					
    /// 					
    ///          </note>
    public let filter: Expression?
    /// <p>The number of previous days that you want AWS to consider when it calculates your recommendations.</p>
    public let lookbackPeriodInDays: LookbackPeriodInDays?
    /// <p>The pagination token that indicates the next set of results that you want to retrieve.</p>
    public let nextPageToken: String?
    /// <p>The number of recommendations that you want returned in a single response object.</p>
    public let pageSize: Int
    /// <p>The reservation purchase option that you want recommendations for.</p>
    public let paymentOption: PaymentOption?
    /// <p>The specific service that you want recommendations for.</p>
    public let service: String?
    /// <p>The hardware specifications for the service instances that you want recommendations for, such as standard or convertible Amazon EC2 instances.</p>
    public let serviceSpecification: ServiceSpecification?
    /// <p>The reservation term that you want recommendations for.</p>
    public let termInYears: TermInYears?

    public init (
        accountId: String? = nil,
        accountScope: AccountScope? = nil,
        filter: Expression? = nil,
        lookbackPeriodInDays: LookbackPeriodInDays? = nil,
        nextPageToken: String? = nil,
        pageSize: Int = 0,
        paymentOption: PaymentOption? = nil,
        service: String? = nil,
        serviceSpecification: ServiceSpecification? = nil,
        termInYears: TermInYears? = nil
    )
    {
        self.accountId = accountId
        self.accountScope = accountScope
        self.filter = filter
        self.lookbackPeriodInDays = lookbackPeriodInDays
        self.nextPageToken = nextPageToken
        self.pageSize = pageSize
        self.paymentOption = paymentOption
        self.service = service
        self.serviceSpecification = serviceSpecification
        self.termInYears = termInYears
    }
}

struct GetReservationPurchaseRecommendationInputBody: Equatable {
    public let accountId: String?
    public let service: String?
    public let filter: Expression?
    public let accountScope: AccountScope?
    public let lookbackPeriodInDays: LookbackPeriodInDays?
    public let termInYears: TermInYears?
    public let paymentOption: PaymentOption?
    public let serviceSpecification: ServiceSpecification?
    public let pageSize: Int
    public let nextPageToken: String?
}

extension GetReservationPurchaseRecommendationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case accountScope = "AccountScope"
        case filter = "Filter"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case nextPageToken = "NextPageToken"
        case pageSize = "PageSize"
        case paymentOption = "PaymentOption"
        case service = "Service"
        case serviceSpecification = "ServiceSpecification"
        case termInYears = "TermInYears"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .service)
        service = serviceDecoded
        let filterDecoded = try containerValues.decodeIfPresent(Expression.self, forKey: .filter)
        filter = filterDecoded
        let accountScopeDecoded = try containerValues.decodeIfPresent(AccountScope.self, forKey: .accountScope)
        accountScope = accountScopeDecoded
        let lookbackPeriodInDaysDecoded = try containerValues.decodeIfPresent(LookbackPeriodInDays.self, forKey: .lookbackPeriodInDays)
        lookbackPeriodInDays = lookbackPeriodInDaysDecoded
        let termInYearsDecoded = try containerValues.decodeIfPresent(TermInYears.self, forKey: .termInYears)
        termInYears = termInYearsDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(PaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let serviceSpecificationDecoded = try containerValues.decodeIfPresent(ServiceSpecification.self, forKey: .serviceSpecification)
        serviceSpecification = serviceSpecificationDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetReservationPurchaseRecommendationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReservationPurchaseRecommendationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetReservationPurchaseRecommendationOutputError: Swift.Error, Equatable {
    case dataUnavailableException(DataUnavailableException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReservationPurchaseRecommendationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetReservationPurchaseRecommendationOutputResponse(metadata: \(String(describing: metadata)), nextPageToken: \(String(describing: nextPageToken)), recommendations: \(String(describing: recommendations)))"}
}

extension GetReservationPurchaseRecommendationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetReservationPurchaseRecommendationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.metadata = output.metadata
            self.nextPageToken = output.nextPageToken
            self.recommendations = output.recommendations
        } else {
            self.metadata = nil
            self.nextPageToken = nil
            self.recommendations = nil
        }
    }
}

public struct GetReservationPurchaseRecommendationOutputResponse: Equatable {
    /// <p>Information about this specific recommendation call, such as the time stamp for when Cost Explorer generated this recommendation.</p>
    public let metadata: ReservationPurchaseRecommendationMetadata?
    /// <p>The pagination token for the next set of retrievable results.</p>
    public let nextPageToken: String?
    /// <p>Recommendations for reservations to purchase.</p>
    public let recommendations: [ReservationPurchaseRecommendation]?

    public init (
        metadata: ReservationPurchaseRecommendationMetadata? = nil,
        nextPageToken: String? = nil,
        recommendations: [ReservationPurchaseRecommendation]? = nil
    )
    {
        self.metadata = metadata
        self.nextPageToken = nextPageToken
        self.recommendations = recommendations
    }
}

struct GetReservationPurchaseRecommendationOutputResponseBody: Equatable {
    public let metadata: ReservationPurchaseRecommendationMetadata?
    public let recommendations: [ReservationPurchaseRecommendation]?
    public let nextPageToken: String?
}

extension GetReservationPurchaseRecommendationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metadata = "Metadata"
        case nextPageToken = "NextPageToken"
        case recommendations = "Recommendations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(ReservationPurchaseRecommendationMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let recommendationsContainer = try containerValues.decodeIfPresent([ReservationPurchaseRecommendation?].self, forKey: .recommendations)
        var recommendationsDecoded0:[ReservationPurchaseRecommendation]? = nil
        if let recommendationsContainer = recommendationsContainer {
            recommendationsDecoded0 = [ReservationPurchaseRecommendation]()
            for structure0 in recommendationsContainer {
                if let structure0 = structure0 {
                    recommendationsDecoded0?.append(structure0)
                }
            }
        }
        recommendations = recommendationsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct GetReservationUtilizationInputBodyMiddleware: Middleware {
    public let id: String = "GetReservationUtilizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReservationUtilizationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReservationUtilizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReservationUtilizationInput>
    public typealias MOutput = OperationOutput<GetReservationUtilizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReservationUtilizationOutputError>
}

extension GetReservationUtilizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetReservationUtilizationInput(filter: \(String(describing: filter)), granularity: \(String(describing: granularity)), groupBy: \(String(describing: groupBy)), maxResults: \(String(describing: maxResults)), nextPageToken: \(String(describing: nextPageToken)), sortBy: \(String(describing: sortBy)), timePeriod: \(String(describing: timePeriod)))"}
}

extension GetReservationUtilizationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for groupdefinitions0 in groupBy {
                try groupByContainer.encode(groupdefinitions0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

public struct GetReservationUtilizationInputHeadersMiddleware: Middleware {
    public let id: String = "GetReservationUtilizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReservationUtilizationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReservationUtilizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReservationUtilizationInput>
    public typealias MOutput = OperationOutput<GetReservationUtilizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReservationUtilizationOutputError>
}

public struct GetReservationUtilizationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetReservationUtilizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReservationUtilizationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReservationUtilizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReservationUtilizationInput>
    public typealias MOutput = OperationOutput<GetReservationUtilizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReservationUtilizationOutputError>
}

public struct GetReservationUtilizationInput: Equatable {
    /// <p>Filters utilization data by dimensions. You can filter by the following dimensions:</p>
    /// 		       <ul>
    ///             <li>
    ///                <p>AZ</p>
    ///             </li>
    ///             <li>
    ///                <p>CACHE_ENGINE</p>
    ///             </li>
    ///             <li>
    ///                <p>DEPLOYMENT_OPTION</p>
    ///             </li>
    ///             <li>
    ///                <p>INSTANCE_TYPE</p>
    ///             </li>
    ///             <li>
    ///                <p>LINKED_ACCOUNT</p>
    ///             </li>
    ///             <li>
    ///                <p>OPERATING_SYSTEM</p>
    ///             </li>
    ///             <li>
    ///                <p>PLATFORM</p>
    ///             </li>
    ///             <li>
    ///                <p>REGION</p>
    ///             </li>
    ///             <li>
    ///                <p>SERVICE</p>
    ///             </li>
    ///             <li>
    ///                <p>SCOPE</p>
    ///             </li>
    ///             <li>
    ///                <p>TENANCY</p>
    ///             </li>
    ///          </ul>
    /// 		       <p>
    ///             <code>GetReservationUtilization</code> uses the same
    /// 			<a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object
    /// 			as the other operations, but only <code>AND</code> is supported among each dimension, and nesting is supported up to
    /// 			only one level deep. If there are multiple values for a dimension, they are OR'd together.</p>
    public let filter: Expression?
    /// <p>If <code>GroupBy</code> is set, <code>Granularity</code> can't be set. If <code>Granularity</code> isn't set,
    /// 			the response object doesn't include <code>Granularity</code>, either <code>MONTHLY</code> or <code>DAILY</code>.
    /// 			If both <code>GroupBy</code> and <code>Granularity</code> aren't set, <code>GetReservationUtilization</code> defaults to <code>DAILY</code>.</p>
    /// 		       <p>The <code>GetReservationUtilization</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
    public let granularity: Granularity?
    /// <p>Groups only by <code>SUBSCRIPTION_ID</code>. Metadata is included.</p>
    public let groupBy: [GroupDefinition]?
    /// <p>The maximum number of objects that you returned for this request. If more objects are available, in the response, AWS provides a NextPageToken value that you can use in a subsequent call to get the next batch of objects.</p>
    public let maxResults: Int
    /// <p>The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.</p>
    public let nextPageToken: String?
    /// <p>The value by which you want to sort the data.</p>
    /// 	
    /// 	        <p>The following values are supported for <code>Key</code>:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>UtilizationPercentage</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UtilizationPercentageInUnits</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PurchasedHours</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PurchasedUnits</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TotalActualHours</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TotalActualUnits</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UnusedHours</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UnusedUnits</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OnDemandCostOfRIHoursUsed</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NetRISavings</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TotalPotentialRISavings</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AmortizedUpfrontFee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AmortizedRecurringFee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TotalAmortizedFee</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RICostForUnusedHours</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RealizedSavings</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UnrealizedSavings</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>Supported values for <code>SortOrder</code> are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
    public let sortBy: SortDefinition?
    /// <p>Sets the start and end dates for retrieving RI utilization. The start date is inclusive,  but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is
    ///             retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>. </p>
    public let timePeriod: DateInterval?

    public init (
        filter: Expression? = nil,
        granularity: Granularity? = nil,
        groupBy: [GroupDefinition]? = nil,
        maxResults: Int = 0,
        nextPageToken: String? = nil,
        sortBy: SortDefinition? = nil,
        timePeriod: DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.groupBy = groupBy
        self.maxResults = maxResults
        self.nextPageToken = nextPageToken
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

struct GetReservationUtilizationInputBody: Equatable {
    public let timePeriod: DateInterval?
    public let groupBy: [GroupDefinition]?
    public let granularity: Granularity?
    public let filter: Expression?
    public let sortBy: SortDefinition?
    public let nextPageToken: String?
    public let maxResults: Int
}

extension GetReservationUtilizationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let groupByContainer = try containerValues.decodeIfPresent([GroupDefinition?].self, forKey: .groupBy)
        var groupByDecoded0:[GroupDefinition]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [GroupDefinition]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let granularityDecoded = try containerValues.decodeIfPresent(Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(Expression.self, forKey: .filter)
        filter = filterDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(SortDefinition.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetReservationUtilizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReservationUtilizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetReservationUtilizationOutputError: Swift.Error, Equatable {
    case dataUnavailableException(DataUnavailableException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReservationUtilizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetReservationUtilizationOutputResponse(nextPageToken: \(String(describing: nextPageToken)), total: \(String(describing: total)), utilizationsByTime: \(String(describing: utilizationsByTime)))"}
}

extension GetReservationUtilizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetReservationUtilizationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.total = output.total
            self.utilizationsByTime = output.utilizationsByTime
        } else {
            self.nextPageToken = nil
            self.total = nil
            self.utilizationsByTime = nil
        }
    }
}

public struct GetReservationUtilizationOutputResponse: Equatable {
    /// <p>The token for the next set of retrievable results. AWS provides the token when the response from a previous call has more results than the maximum page size.</p>
    public let nextPageToken: String?
    /// <p>The total amount of time that you used your RIs.</p>
    public let total: ReservationAggregates?
    /// <p>The amount of time that you used your RIs.</p>
    public let utilizationsByTime: [UtilizationByTime]?

    public init (
        nextPageToken: String? = nil,
        total: ReservationAggregates? = nil,
        utilizationsByTime: [UtilizationByTime]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.total = total
        self.utilizationsByTime = utilizationsByTime
    }
}

struct GetReservationUtilizationOutputResponseBody: Equatable {
    public let utilizationsByTime: [UtilizationByTime]?
    public let total: ReservationAggregates?
    public let nextPageToken: String?
}

extension GetReservationUtilizationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case total = "Total"
        case utilizationsByTime = "UtilizationsByTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let utilizationsByTimeContainer = try containerValues.decodeIfPresent([UtilizationByTime?].self, forKey: .utilizationsByTime)
        var utilizationsByTimeDecoded0:[UtilizationByTime]? = nil
        if let utilizationsByTimeContainer = utilizationsByTimeContainer {
            utilizationsByTimeDecoded0 = [UtilizationByTime]()
            for structure0 in utilizationsByTimeContainer {
                if let structure0 = structure0 {
                    utilizationsByTimeDecoded0?.append(structure0)
                }
            }
        }
        utilizationsByTime = utilizationsByTimeDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(ReservationAggregates.self, forKey: .total)
        total = totalDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct GetRightsizingRecommendationInputBodyMiddleware: Middleware {
    public let id: String = "GetRightsizingRecommendationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRightsizingRecommendationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRightsizingRecommendationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRightsizingRecommendationInput>
    public typealias MOutput = OperationOutput<GetRightsizingRecommendationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRightsizingRecommendationOutputError>
}

extension GetRightsizingRecommendationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRightsizingRecommendationInput(configuration: \(String(describing: configuration)), filter: \(String(describing: filter)), nextPageToken: \(String(describing: nextPageToken)), pageSize: \(String(describing: pageSize)), service: \(String(describing: service)))"}
}

extension GetRightsizingRecommendationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
        case filter = "Filter"
        case nextPageToken = "NextPageToken"
        case pageSize = "PageSize"
        case service = "Service"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let service = service {
            try encodeContainer.encode(service, forKey: .service)
        }
    }
}

public struct GetRightsizingRecommendationInputHeadersMiddleware: Middleware {
    public let id: String = "GetRightsizingRecommendationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRightsizingRecommendationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRightsizingRecommendationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRightsizingRecommendationInput>
    public typealias MOutput = OperationOutput<GetRightsizingRecommendationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRightsizingRecommendationOutputError>
}

public struct GetRightsizingRecommendationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRightsizingRecommendationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRightsizingRecommendationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRightsizingRecommendationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRightsizingRecommendationInput>
    public typealias MOutput = OperationOutput<GetRightsizingRecommendationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRightsizingRecommendationOutputError>
}

public struct GetRightsizingRecommendationInput: Equatable {
    /// <p> Enables you to customize recommendations across two attributes. You can choose to view
    ///       recommendations for instances within the same instance families or across different instance
    ///       families. You can also choose to view your estimated savings associated with recommendations
    ///       with consideration of existing Savings Plans or RI benefits, or
    ///       neither. </p>
    public let configuration: RightsizingRecommendationConfiguration?
    /// <p>Use <code>Expression</code> to filter by cost or by usage. There are two patterns: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>Simple dimension values - You can set the dimension name and values for the
    ///                     filters that you plan to use. For example, you can filter for
    ///                     <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>. The
    ///                         <code>Expression</code> example looks like:</p>
    ///                 <p>
    ///                   <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1",
    ///                         “us-west-1” ] } }</code>
    ///                 </p>
    ///                 <p>The list of dimension values are OR'd together to retrieve cost or usage
    ///                     data. You can create <code>Expression</code> and <code>DimensionValues</code>
    ///                     objects using either <code>with*</code> methods or <code>set*</code> methods in
    ///                     multiple lines. </p>
    ///             </li>
    ///             <li>
    ///                 <p>Compound dimension values with logical operations - You can use multiple
    ///                         <code>Expression</code> types and the logical operators
    ///                         <code>AND/OR/NOT</code> to create a list of one or more
    ///                         <code>Expression</code> objects. This allows you to filter on more advanced
    ///                     options. For example, you can filter on <code>((REGION == us-east-1 OR
    ///                         REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE !=
    ///                         DataTransfer)</code>. The <code>Expression</code> for that looks like
    ///                     this:</p>
    ///                 <p>
    ///                   <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION",
    ///                         "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName",
    ///                         "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE",
    ///                         "Values": ["DataTransfer"] }}} ] } </code>
    ///                </p>
    ///                 <note>
    ///                     <p>Because each <code>Expression</code> can have only one operator, the
    ///                         service returns an error if more than one is specified. The following
    ///                         example shows an <code>Expression</code> object that creates an
    ///                         error.</p>
    ///                 </note>
    ///                 <p>
    ///                     <code> { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE",
    ///                         "Values": [ "DataTransfer" ] } } </code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///         <note>
    ///             <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT is not
    ///                 supported. OR is not supported between different dimensions, or dimensions and tags.
    ///                 NOT operators aren't supported.
    ///                 Dimensions
    ///                 are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or
    ///                     <code>RIGHTSIZING_TYPE</code>.</p>
    /// 					
    /// 					       <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR are not supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
    /// 					
    /// 					
    /// 					
    ///          </note>
    public let filter: Expression?
    /// <p>The pagination token that indicates the next set of results that you want to retrieve.</p>
    public let nextPageToken: String?
    /// <p>The number of recommendations that you want returned in a single response object.</p>
    public let pageSize: Int
    /// <p>The specific service that you want recommendations for. The only valid value for <code>GetRightsizingRecommendation</code> is
    ///     	"<code>AmazonEC2</code>".</p>
    public let service: String?

    public init (
        configuration: RightsizingRecommendationConfiguration? = nil,
        filter: Expression? = nil,
        nextPageToken: String? = nil,
        pageSize: Int = 0,
        service: String? = nil
    )
    {
        self.configuration = configuration
        self.filter = filter
        self.nextPageToken = nextPageToken
        self.pageSize = pageSize
        self.service = service
    }
}

struct GetRightsizingRecommendationInputBody: Equatable {
    public let filter: Expression?
    public let configuration: RightsizingRecommendationConfiguration?
    public let service: String?
    public let pageSize: Int
    public let nextPageToken: String?
}

extension GetRightsizingRecommendationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
        case filter = "Filter"
        case nextPageToken = "NextPageToken"
        case pageSize = "PageSize"
        case service = "Service"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(Expression.self, forKey: .filter)
        filter = filterDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(RightsizingRecommendationConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .service)
        service = serviceDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetRightsizingRecommendationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRightsizingRecommendationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRightsizingRecommendationOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRightsizingRecommendationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRightsizingRecommendationOutputResponse(configuration: \(String(describing: configuration)), metadata: \(String(describing: metadata)), nextPageToken: \(String(describing: nextPageToken)), rightsizingRecommendations: \(String(describing: rightsizingRecommendations)), summary: \(String(describing: summary)))"}
}

extension GetRightsizingRecommendationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetRightsizingRecommendationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configuration = output.configuration
            self.metadata = output.metadata
            self.nextPageToken = output.nextPageToken
            self.rightsizingRecommendations = output.rightsizingRecommendations
            self.summary = output.summary
        } else {
            self.configuration = nil
            self.metadata = nil
            self.nextPageToken = nil
            self.rightsizingRecommendations = nil
            self.summary = nil
        }
    }
}

public struct GetRightsizingRecommendationOutputResponse: Equatable {
    /// <p> Enables you to customize recommendations across two attributes. You can choose to view
    ///       recommendations for instances within the same instance families or across different instance
    ///       families. You can also choose to view your estimated savings associated with recommendations
    ///       with consideration of existing Savings Plans or RI benefits, or
    ///       neither. </p>
    public let configuration: RightsizingRecommendationConfiguration?
    /// <p>Information regarding this specific recommendation set.</p>
    public let metadata: RightsizingRecommendationMetadata?
    /// <p>The token to retrieve the next set of results.</p>
    public let nextPageToken: String?
    /// <p>Recommendations to rightsize resources.</p>
    public let rightsizingRecommendations: [RightsizingRecommendation]?
    /// <p>Summary of this recommendation set.</p>
    public let summary: RightsizingRecommendationSummary?

    public init (
        configuration: RightsizingRecommendationConfiguration? = nil,
        metadata: RightsizingRecommendationMetadata? = nil,
        nextPageToken: String? = nil,
        rightsizingRecommendations: [RightsizingRecommendation]? = nil,
        summary: RightsizingRecommendationSummary? = nil
    )
    {
        self.configuration = configuration
        self.metadata = metadata
        self.nextPageToken = nextPageToken
        self.rightsizingRecommendations = rightsizingRecommendations
        self.summary = summary
    }
}

struct GetRightsizingRecommendationOutputResponseBody: Equatable {
    public let metadata: RightsizingRecommendationMetadata?
    public let summary: RightsizingRecommendationSummary?
    public let rightsizingRecommendations: [RightsizingRecommendation]?
    public let nextPageToken: String?
    public let configuration: RightsizingRecommendationConfiguration?
}

extension GetRightsizingRecommendationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configuration = "Configuration"
        case metadata = "Metadata"
        case nextPageToken = "NextPageToken"
        case rightsizingRecommendations = "RightsizingRecommendations"
        case summary = "Summary"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(RightsizingRecommendationMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(RightsizingRecommendationSummary.self, forKey: .summary)
        summary = summaryDecoded
        let rightsizingRecommendationsContainer = try containerValues.decodeIfPresent([RightsizingRecommendation?].self, forKey: .rightsizingRecommendations)
        var rightsizingRecommendationsDecoded0:[RightsizingRecommendation]? = nil
        if let rightsizingRecommendationsContainer = rightsizingRecommendationsContainer {
            rightsizingRecommendationsDecoded0 = [RightsizingRecommendation]()
            for structure0 in rightsizingRecommendationsContainer {
                if let structure0 = structure0 {
                    rightsizingRecommendationsDecoded0?.append(structure0)
                }
            }
        }
        rightsizingRecommendations = rightsizingRecommendationsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(RightsizingRecommendationConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

public struct GetSavingsPlansCoverageInputBodyMiddleware: Middleware {
    public let id: String = "GetSavingsPlansCoverageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSavingsPlansCoverageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSavingsPlansCoverageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSavingsPlansCoverageInput>
    public typealias MOutput = OperationOutput<GetSavingsPlansCoverageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSavingsPlansCoverageOutputError>
}

extension GetSavingsPlansCoverageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSavingsPlansCoverageInput(filter: \(String(describing: filter)), granularity: \(String(describing: granularity)), groupBy: \(String(describing: groupBy)), maxResults: \(String(describing: maxResults)), metrics: \(String(describing: metrics)), nextToken: \(String(describing: nextToken)), sortBy: \(String(describing: sortBy)), timePeriod: \(String(describing: timePeriod)))"}
}

extension GetSavingsPlansCoverageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case maxResults = "MaxResults"
        case metrics = "Metrics"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let groupBy = groupBy {
            var groupByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupBy)
            for groupdefinitions0 in groupBy {
                try groupByContainer.encode(groupdefinitions0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metrics)
            for metricnames0 in metrics {
                try metricsContainer.encode(metricnames0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

public struct GetSavingsPlansCoverageInputHeadersMiddleware: Middleware {
    public let id: String = "GetSavingsPlansCoverageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSavingsPlansCoverageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSavingsPlansCoverageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSavingsPlansCoverageInput>
    public typealias MOutput = OperationOutput<GetSavingsPlansCoverageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSavingsPlansCoverageOutputError>
}

public struct GetSavingsPlansCoverageInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSavingsPlansCoverageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSavingsPlansCoverageInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSavingsPlansCoverageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSavingsPlansCoverageInput>
    public typealias MOutput = OperationOutput<GetSavingsPlansCoverageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSavingsPlansCoverageOutputError>
}

public struct GetSavingsPlansCoverageInput: Equatable {
    /// <p>Filters Savings Plans coverage data by dimensions. You can filter data for Savings Plans usage with the following dimensions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>LINKED_ACCOUNT</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>REGION</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SERVICE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INSTANCE_FAMILY</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <code>GetSavingsPlansCoverage</code> uses the same
    ///       <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object
    ///       as the other operations, but only <code>AND</code> is supported among each dimension. If there are multiple values for a dimension, they are OR'd together.</p>
    ///          <p>Cost category is also supported.</p>
    public let filter: Expression?
    /// <p>The granularity of the Amazon Web Services cost data for your Savings Plans. <code>Granularity</code> can't be set if <code>GroupBy</code> is set.</p>
    /// 	        <p>The <code>GetSavingsPlansCoverage</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
    public let granularity: Granularity?
    /// <p>You can group the data using the attributes <code>INSTANCE_FAMILY</code>, <code>REGION</code>, or <code>SERVICE</code>.</p>
    public let groupBy: [GroupDefinition]?
    /// <p>The number of items to be returned in a response. The default is <code>20</code>, with a minimum value of <code>1</code>.</p>
    public let maxResults: Int
    /// <p>The measurement that you want your Savings Plans coverage reported in. The only valid value is <code>SpendCoveredBySavingsPlans</code>.</p>
    public let metrics: [String]?
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    public let nextToken: String?
    /// <p>The value by which you want to sort the data.</p>
    /// 	  	     <p>The following values are supported for <code>Key</code>:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SpendCoveredBySavingsPlan</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OnDemandCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CoveragePercentage</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TotalCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>InstanceFamily</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Region</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Service</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>Supported values for <code>SortOrder</code> are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
    public let sortBy: SortDefinition?
    /// <p>The time period that you want the usage and costs for. The <code>Start</code> date must be within 13 months. The <code>End</code> date must be after the <code>Start</code> date, and before the current date. Future dates can't be used as an <code>End</code> date.</p>
    public let timePeriod: DateInterval?

    public init (
        filter: Expression? = nil,
        granularity: Granularity? = nil,
        groupBy: [GroupDefinition]? = nil,
        maxResults: Int = 0,
        metrics: [String]? = nil,
        nextToken: String? = nil,
        sortBy: SortDefinition? = nil,
        timePeriod: DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.groupBy = groupBy
        self.maxResults = maxResults
        self.metrics = metrics
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

struct GetSavingsPlansCoverageInputBody: Equatable {
    public let timePeriod: DateInterval?
    public let groupBy: [GroupDefinition]?
    public let granularity: Granularity?
    public let filter: Expression?
    public let metrics: [String]?
    public let nextToken: String?
    public let maxResults: Int
    public let sortBy: SortDefinition?
}

extension GetSavingsPlansCoverageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case groupBy = "GroupBy"
        case maxResults = "MaxResults"
        case metrics = "Metrics"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let groupByContainer = try containerValues.decodeIfPresent([GroupDefinition?].self, forKey: .groupBy)
        var groupByDecoded0:[GroupDefinition]? = nil
        if let groupByContainer = groupByContainer {
            groupByDecoded0 = [GroupDefinition]()
            for structure0 in groupByContainer {
                if let structure0 = structure0 {
                    groupByDecoded0?.append(structure0)
                }
            }
        }
        groupBy = groupByDecoded0
        let granularityDecoded = try containerValues.decodeIfPresent(Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(Expression.self, forKey: .filter)
        filter = filterDecoded
        let metricsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .metrics)
        var metricsDecoded0:[String]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [String]()
            for string0 in metricsContainer {
                if let string0 = string0 {
                    metricsDecoded0?.append(string0)
                }
            }
        }
        metrics = metricsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(SortDefinition.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension GetSavingsPlansCoverageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSavingsPlansCoverageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSavingsPlansCoverageOutputError: Swift.Error, Equatable {
    case dataUnavailableException(DataUnavailableException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSavingsPlansCoverageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSavingsPlansCoverageOutputResponse(nextToken: \(String(describing: nextToken)), savingsPlansCoverages: \(String(describing: savingsPlansCoverages)))"}
}

extension GetSavingsPlansCoverageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSavingsPlansCoverageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.savingsPlansCoverages = output.savingsPlansCoverages
        } else {
            self.nextToken = nil
            self.savingsPlansCoverages = nil
        }
    }
}

public struct GetSavingsPlansCoverageOutputResponse: Equatable {
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    public let nextToken: String?
    /// <p>The amount of spend that your Savings Plans covered.</p>
    public let savingsPlansCoverages: [SavingsPlansCoverage]?

    public init (
        nextToken: String? = nil,
        savingsPlansCoverages: [SavingsPlansCoverage]? = nil
    )
    {
        self.nextToken = nextToken
        self.savingsPlansCoverages = savingsPlansCoverages
    }
}

struct GetSavingsPlansCoverageOutputResponseBody: Equatable {
    public let savingsPlansCoverages: [SavingsPlansCoverage]?
    public let nextToken: String?
}

extension GetSavingsPlansCoverageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case savingsPlansCoverages = "SavingsPlansCoverages"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlansCoveragesContainer = try containerValues.decodeIfPresent([SavingsPlansCoverage?].self, forKey: .savingsPlansCoverages)
        var savingsPlansCoveragesDecoded0:[SavingsPlansCoverage]? = nil
        if let savingsPlansCoveragesContainer = savingsPlansCoveragesContainer {
            savingsPlansCoveragesDecoded0 = [SavingsPlansCoverage]()
            for structure0 in savingsPlansCoveragesContainer {
                if let structure0 = structure0 {
                    savingsPlansCoveragesDecoded0?.append(structure0)
                }
            }
        }
        savingsPlansCoverages = savingsPlansCoveragesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetSavingsPlansPurchaseRecommendationInputBodyMiddleware: Middleware {
    public let id: String = "GetSavingsPlansPurchaseRecommendationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSavingsPlansPurchaseRecommendationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSavingsPlansPurchaseRecommendationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSavingsPlansPurchaseRecommendationInput>
    public typealias MOutput = OperationOutput<GetSavingsPlansPurchaseRecommendationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSavingsPlansPurchaseRecommendationOutputError>
}

extension GetSavingsPlansPurchaseRecommendationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSavingsPlansPurchaseRecommendationInput(accountScope: \(String(describing: accountScope)), filter: \(String(describing: filter)), lookbackPeriodInDays: \(String(describing: lookbackPeriodInDays)), nextPageToken: \(String(describing: nextPageToken)), pageSize: \(String(describing: pageSize)), paymentOption: \(String(describing: paymentOption)), savingsPlansType: \(String(describing: savingsPlansType)), termInYears: \(String(describing: termInYears)))"}
}

extension GetSavingsPlansPurchaseRecommendationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountScope = "AccountScope"
        case filter = "Filter"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case nextPageToken = "NextPageToken"
        case pageSize = "PageSize"
        case paymentOption = "PaymentOption"
        case savingsPlansType = "SavingsPlansType"
        case termInYears = "TermInYears"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountScope = accountScope {
            try encodeContainer.encode(accountScope.rawValue, forKey: .accountScope)
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let lookbackPeriodInDays = lookbackPeriodInDays {
            try encodeContainer.encode(lookbackPeriodInDays.rawValue, forKey: .lookbackPeriodInDays)
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let paymentOption = paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let savingsPlansType = savingsPlansType {
            try encodeContainer.encode(savingsPlansType.rawValue, forKey: .savingsPlansType)
        }
        if let termInYears = termInYears {
            try encodeContainer.encode(termInYears.rawValue, forKey: .termInYears)
        }
    }
}

public struct GetSavingsPlansPurchaseRecommendationInputHeadersMiddleware: Middleware {
    public let id: String = "GetSavingsPlansPurchaseRecommendationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSavingsPlansPurchaseRecommendationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSavingsPlansPurchaseRecommendationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSavingsPlansPurchaseRecommendationInput>
    public typealias MOutput = OperationOutput<GetSavingsPlansPurchaseRecommendationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSavingsPlansPurchaseRecommendationOutputError>
}

public struct GetSavingsPlansPurchaseRecommendationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSavingsPlansPurchaseRecommendationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSavingsPlansPurchaseRecommendationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSavingsPlansPurchaseRecommendationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSavingsPlansPurchaseRecommendationInput>
    public typealias MOutput = OperationOutput<GetSavingsPlansPurchaseRecommendationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSavingsPlansPurchaseRecommendationOutputError>
}

public struct GetSavingsPlansPurchaseRecommendationInput: Equatable {
    /// <p>The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to <code>PAYER</code>. If the value is <code>LINKED</code>, recommendations are calculated for individual member accounts only.</p>
    public let accountScope: AccountScope?
    /// <p>You can filter your recommendations by Account ID with the <code>LINKED_ACCOUNT</code>
    ///       dimension. To filter your recommendations by Account ID, specify <code>Key</code> as
    ///         <code>LINKED_ACCOUNT</code> and <code>Value</code> as the comma-separated Acount ID(s) for
    ///       which you want to see Savings Plans purchase recommendations.</p>
    ///          <p>For GetSavingsPlansPurchaseRecommendation, the <code>Filter</code> does not include
    ///         <code>CostCategories</code> or <code>Tags</code>. It only includes <code>Dimensions</code>.
    ///       With <code>Dimensions</code>, <code>Key</code> must be <code>LINKED_ACCOUNT</code> and
    ///         <code>Value</code> can be a single Account ID or multiple comma-separated Account IDs for
    ///       which you want to see Savings Plans Purchase Recommendations. <code>AND</code> and
    ///         <code>OR</code> operators are not supported.</p>
    public let filter: Expression?
    /// <p>The lookback period used to generate the recommendation.</p>
    public let lookbackPeriodInDays: LookbackPeriodInDays?
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    public let nextPageToken: String?
    /// <p>The number of recommendations that you want returned in a single response object.</p>
    public let pageSize: Int
    /// <p>The payment option used to generate these recommendations.</p>
    public let paymentOption: PaymentOption?
    /// <p>The Savings Plans recommendation type requested.</p>
    public let savingsPlansType: SupportedSavingsPlansType?
    /// <p>The savings plan recommendation term used to
    ///       generate these
    ///       recommendations.</p>
    public let termInYears: TermInYears?

    public init (
        accountScope: AccountScope? = nil,
        filter: Expression? = nil,
        lookbackPeriodInDays: LookbackPeriodInDays? = nil,
        nextPageToken: String? = nil,
        pageSize: Int = 0,
        paymentOption: PaymentOption? = nil,
        savingsPlansType: SupportedSavingsPlansType? = nil,
        termInYears: TermInYears? = nil
    )
    {
        self.accountScope = accountScope
        self.filter = filter
        self.lookbackPeriodInDays = lookbackPeriodInDays
        self.nextPageToken = nextPageToken
        self.pageSize = pageSize
        self.paymentOption = paymentOption
        self.savingsPlansType = savingsPlansType
        self.termInYears = termInYears
    }
}

struct GetSavingsPlansPurchaseRecommendationInputBody: Equatable {
    public let savingsPlansType: SupportedSavingsPlansType?
    public let termInYears: TermInYears?
    public let paymentOption: PaymentOption?
    public let accountScope: AccountScope?
    public let nextPageToken: String?
    public let pageSize: Int
    public let lookbackPeriodInDays: LookbackPeriodInDays?
    public let filter: Expression?
}

extension GetSavingsPlansPurchaseRecommendationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountScope = "AccountScope"
        case filter = "Filter"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case nextPageToken = "NextPageToken"
        case pageSize = "PageSize"
        case paymentOption = "PaymentOption"
        case savingsPlansType = "SavingsPlansType"
        case termInYears = "TermInYears"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlansTypeDecoded = try containerValues.decodeIfPresent(SupportedSavingsPlansType.self, forKey: .savingsPlansType)
        savingsPlansType = savingsPlansTypeDecoded
        let termInYearsDecoded = try containerValues.decodeIfPresent(TermInYears.self, forKey: .termInYears)
        termInYears = termInYearsDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(PaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let accountScopeDecoded = try containerValues.decodeIfPresent(AccountScope.self, forKey: .accountScope)
        accountScope = accountScopeDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let pageSizeDecoded = try containerValues.decode(Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let lookbackPeriodInDaysDecoded = try containerValues.decodeIfPresent(LookbackPeriodInDays.self, forKey: .lookbackPeriodInDays)
        lookbackPeriodInDays = lookbackPeriodInDaysDecoded
        let filterDecoded = try containerValues.decodeIfPresent(Expression.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension GetSavingsPlansPurchaseRecommendationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSavingsPlansPurchaseRecommendationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSavingsPlansPurchaseRecommendationOutputError: Swift.Error, Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSavingsPlansPurchaseRecommendationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSavingsPlansPurchaseRecommendationOutputResponse(metadata: \(String(describing: metadata)), nextPageToken: \(String(describing: nextPageToken)), savingsPlansPurchaseRecommendation: \(String(describing: savingsPlansPurchaseRecommendation)))"}
}

extension GetSavingsPlansPurchaseRecommendationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSavingsPlansPurchaseRecommendationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.metadata = output.metadata
            self.nextPageToken = output.nextPageToken
            self.savingsPlansPurchaseRecommendation = output.savingsPlansPurchaseRecommendation
        } else {
            self.metadata = nil
            self.nextPageToken = nil
            self.savingsPlansPurchaseRecommendation = nil
        }
    }
}

public struct GetSavingsPlansPurchaseRecommendationOutputResponse: Equatable {
    /// <p>Information regarding this specific recommendation set.</p>
    public let metadata: SavingsPlansPurchaseRecommendationMetadata?
    /// <p>The token for the next set of retrievable results. AWS provides the token when the response from a previous call has more results than the maximum page size.</p>
    public let nextPageToken: String?
    /// <p>Contains your request parameters, Savings Plan Recommendations Summary, and Details.</p>
    public let savingsPlansPurchaseRecommendation: SavingsPlansPurchaseRecommendation?

    public init (
        metadata: SavingsPlansPurchaseRecommendationMetadata? = nil,
        nextPageToken: String? = nil,
        savingsPlansPurchaseRecommendation: SavingsPlansPurchaseRecommendation? = nil
    )
    {
        self.metadata = metadata
        self.nextPageToken = nextPageToken
        self.savingsPlansPurchaseRecommendation = savingsPlansPurchaseRecommendation
    }
}

struct GetSavingsPlansPurchaseRecommendationOutputResponseBody: Equatable {
    public let metadata: SavingsPlansPurchaseRecommendationMetadata?
    public let savingsPlansPurchaseRecommendation: SavingsPlansPurchaseRecommendation?
    public let nextPageToken: String?
}

extension GetSavingsPlansPurchaseRecommendationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metadata = "Metadata"
        case nextPageToken = "NextPageToken"
        case savingsPlansPurchaseRecommendation = "SavingsPlansPurchaseRecommendation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metadataDecoded = try containerValues.decodeIfPresent(SavingsPlansPurchaseRecommendationMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let savingsPlansPurchaseRecommendationDecoded = try containerValues.decodeIfPresent(SavingsPlansPurchaseRecommendation.self, forKey: .savingsPlansPurchaseRecommendation)
        savingsPlansPurchaseRecommendation = savingsPlansPurchaseRecommendationDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct GetSavingsPlansUtilizationDetailsInputBodyMiddleware: Middleware {
    public let id: String = "GetSavingsPlansUtilizationDetailsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSavingsPlansUtilizationDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSavingsPlansUtilizationDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSavingsPlansUtilizationDetailsInput>
    public typealias MOutput = OperationOutput<GetSavingsPlansUtilizationDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSavingsPlansUtilizationDetailsOutputError>
}

extension GetSavingsPlansUtilizationDetailsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSavingsPlansUtilizationDetailsInput(dataType: \(String(describing: dataType)), filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortBy: \(String(describing: sortBy)), timePeriod: \(String(describing: timePeriod)))"}
}

extension GetSavingsPlansUtilizationDetailsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataType = "DataType"
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = dataType {
            var dataTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataType)
            for savingsplansdatatypes0 in dataType {
                try dataTypeContainer.encode(savingsplansdatatypes0.rawValue)
            }
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

public struct GetSavingsPlansUtilizationDetailsInputHeadersMiddleware: Middleware {
    public let id: String = "GetSavingsPlansUtilizationDetailsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSavingsPlansUtilizationDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSavingsPlansUtilizationDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSavingsPlansUtilizationDetailsInput>
    public typealias MOutput = OperationOutput<GetSavingsPlansUtilizationDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSavingsPlansUtilizationDetailsOutputError>
}

public struct GetSavingsPlansUtilizationDetailsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSavingsPlansUtilizationDetailsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSavingsPlansUtilizationDetailsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSavingsPlansUtilizationDetailsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSavingsPlansUtilizationDetailsInput>
    public typealias MOutput = OperationOutput<GetSavingsPlansUtilizationDetailsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSavingsPlansUtilizationDetailsOutputError>
}

public struct GetSavingsPlansUtilizationDetailsInput: Equatable {
    /// <p>The data type.</p>
    public let dataType: [SavingsPlansDataType]?
    /// <p>Filters Savings Plans utilization coverage data for active Savings Plans dimensions.  You can filter data with the following dimensions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>LINKED_ACCOUNT</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SAVINGS_PLAN_ARN</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>REGION</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PAYMENT_OPTION</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INSTANCE_TYPE_FAMILY</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <code>GetSavingsPlansUtilizationDetails</code> uses the same
    ///       <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object
    ///       as the other operations, but only <code>AND</code> is supported among each dimension.</p>
    public let filter: Expression?
    /// <p>The number of items to be returned in a response. The default is <code>20</code>, with a minimum value of <code>1</code>.</p>
    public let maxResults: Int
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    public let nextToken: String?
    /// <p>The value by which you want to sort the data.</p>
    /// 	
    /// 	        <p>The following values are supported for <code>Key</code>:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>UtilizationPercentage</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TotalCommitment</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UsedCommitment</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UnusedCommitment</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NetSavings</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AmortizedRecurringCommitment</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AmortizedUpfrontCommitment</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>Supported values for <code>SortOrder</code> are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
    public let sortBy: SortDefinition?
    /// <p>The time period that you want the usage and costs for. The <code>Start</code> date must be within 13 months. The <code>End</code> date must be after the <code>Start</code> date, and before the current date. Future dates can't be used as an <code>End</code> date.</p>
    public let timePeriod: DateInterval?

    public init (
        dataType: [SavingsPlansDataType]? = nil,
        filter: Expression? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        sortBy: SortDefinition? = nil,
        timePeriod: DateInterval? = nil
    )
    {
        self.dataType = dataType
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

struct GetSavingsPlansUtilizationDetailsInputBody: Equatable {
    public let timePeriod: DateInterval?
    public let filter: Expression?
    public let dataType: [SavingsPlansDataType]?
    public let nextToken: String?
    public let maxResults: Int
    public let sortBy: SortDefinition?
}

extension GetSavingsPlansUtilizationDetailsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dataType = "DataType"
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let filterDecoded = try containerValues.decodeIfPresent(Expression.self, forKey: .filter)
        filter = filterDecoded
        let dataTypeContainer = try containerValues.decodeIfPresent([SavingsPlansDataType?].self, forKey: .dataType)
        var dataTypeDecoded0:[SavingsPlansDataType]? = nil
        if let dataTypeContainer = dataTypeContainer {
            dataTypeDecoded0 = [SavingsPlansDataType]()
            for string0 in dataTypeContainer {
                if let string0 = string0 {
                    dataTypeDecoded0?.append(string0)
                }
            }
        }
        dataType = dataTypeDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(SortDefinition.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension GetSavingsPlansUtilizationDetailsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSavingsPlansUtilizationDetailsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSavingsPlansUtilizationDetailsOutputError: Swift.Error, Equatable {
    case dataUnavailableException(DataUnavailableException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSavingsPlansUtilizationDetailsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSavingsPlansUtilizationDetailsOutputResponse(nextToken: \(String(describing: nextToken)), savingsPlansUtilizationDetails: \(String(describing: savingsPlansUtilizationDetails)), timePeriod: \(String(describing: timePeriod)), total: \(String(describing: total)))"}
}

extension GetSavingsPlansUtilizationDetailsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSavingsPlansUtilizationDetailsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.savingsPlansUtilizationDetails = output.savingsPlansUtilizationDetails
            self.timePeriod = output.timePeriod
            self.total = output.total
        } else {
            self.nextToken = nil
            self.savingsPlansUtilizationDetails = nil
            self.timePeriod = nil
            self.total = nil
        }
    }
}

public struct GetSavingsPlansUtilizationDetailsOutputResponse: Equatable {
    /// <p>The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.</p>
    public let nextToken: String?
    /// <p>Retrieves a single daily or monthly Savings Plans utilization rate and details for your account.</p>
    public let savingsPlansUtilizationDetails: [SavingsPlansUtilizationDetail]?
    /// <p>The time period of the request.
    ///         </p>
    public let timePeriod: DateInterval?
    /// <p>The total Savings Plans utilization, regardless of time period.</p>
    public let total: SavingsPlansUtilizationAggregates?

    public init (
        nextToken: String? = nil,
        savingsPlansUtilizationDetails: [SavingsPlansUtilizationDetail]? = nil,
        timePeriod: DateInterval? = nil,
        total: SavingsPlansUtilizationAggregates? = nil
    )
    {
        self.nextToken = nextToken
        self.savingsPlansUtilizationDetails = savingsPlansUtilizationDetails
        self.timePeriod = timePeriod
        self.total = total
    }
}

struct GetSavingsPlansUtilizationDetailsOutputResponseBody: Equatable {
    public let savingsPlansUtilizationDetails: [SavingsPlansUtilizationDetail]?
    public let total: SavingsPlansUtilizationAggregates?
    public let timePeriod: DateInterval?
    public let nextToken: String?
}

extension GetSavingsPlansUtilizationDetailsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case savingsPlansUtilizationDetails = "SavingsPlansUtilizationDetails"
        case timePeriod = "TimePeriod"
        case total = "Total"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlansUtilizationDetailsContainer = try containerValues.decodeIfPresent([SavingsPlansUtilizationDetail?].self, forKey: .savingsPlansUtilizationDetails)
        var savingsPlansUtilizationDetailsDecoded0:[SavingsPlansUtilizationDetail]? = nil
        if let savingsPlansUtilizationDetailsContainer = savingsPlansUtilizationDetailsContainer {
            savingsPlansUtilizationDetailsDecoded0 = [SavingsPlansUtilizationDetail]()
            for structure0 in savingsPlansUtilizationDetailsContainer {
                if let structure0 = structure0 {
                    savingsPlansUtilizationDetailsDecoded0?.append(structure0)
                }
            }
        }
        savingsPlansUtilizationDetails = savingsPlansUtilizationDetailsDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(SavingsPlansUtilizationAggregates.self, forKey: .total)
        total = totalDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetSavingsPlansUtilizationInputBodyMiddleware: Middleware {
    public let id: String = "GetSavingsPlansUtilizationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSavingsPlansUtilizationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSavingsPlansUtilizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSavingsPlansUtilizationInput>
    public typealias MOutput = OperationOutput<GetSavingsPlansUtilizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSavingsPlansUtilizationOutputError>
}

extension GetSavingsPlansUtilizationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSavingsPlansUtilizationInput(filter: \(String(describing: filter)), granularity: \(String(describing: granularity)), sortBy: \(String(describing: sortBy)), timePeriod: \(String(describing: timePeriod)))"}
}

extension GetSavingsPlansUtilizationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

public struct GetSavingsPlansUtilizationInputHeadersMiddleware: Middleware {
    public let id: String = "GetSavingsPlansUtilizationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSavingsPlansUtilizationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSavingsPlansUtilizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSavingsPlansUtilizationInput>
    public typealias MOutput = OperationOutput<GetSavingsPlansUtilizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSavingsPlansUtilizationOutputError>
}

public struct GetSavingsPlansUtilizationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSavingsPlansUtilizationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSavingsPlansUtilizationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSavingsPlansUtilizationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSavingsPlansUtilizationInput>
    public typealias MOutput = OperationOutput<GetSavingsPlansUtilizationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSavingsPlansUtilizationOutputError>
}

public struct GetSavingsPlansUtilizationInput: Equatable {
    /// <p>Filters Savings Plans utilization coverage data for active Savings Plans dimensions.  You can filter data with the following dimensions:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>LINKED_ACCOUNT</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SAVINGS_PLAN_ARN</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SAVINGS_PLANS_TYPE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>REGION</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PAYMENT_OPTION</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INSTANCE_TYPE_FAMILY</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <code>GetSavingsPlansUtilization</code> uses the same
    ///       <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_Expression.html">Expression</a> object
    ///       as the other operations, but only <code>AND</code> is supported among each dimension.</p>
    public let filter: Expression?
    /// <p>The granularity of the Amazon Web Services utillization data for your Savings Plans.</p>
    /// 	        <p>The <code>GetSavingsPlansUtilization</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
    public let granularity: Granularity?
    /// <p>The value by which you want to sort the data.</p>
    /// 	        <p>The following values are supported for <code>Key</code>:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>UtilizationPercentage</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TotalCommitment</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UsedCommitment</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UnusedCommitment</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NetSavings</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///
    ///          <p>Supported values for <code>SortOrder</code> are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
    public let sortBy: SortDefinition?
    /// <p>The time period that you want the usage and costs for. The <code>Start</code> date must be within 13 months. The <code>End</code> date must be after the <code>Start</code> date, and before the current date. Future dates can't be used as an <code>End</code> date.</p>
    public let timePeriod: DateInterval?

    public init (
        filter: Expression? = nil,
        granularity: Granularity? = nil,
        sortBy: SortDefinition? = nil,
        timePeriod: DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

struct GetSavingsPlansUtilizationInputBody: Equatable {
    public let timePeriod: DateInterval?
    public let granularity: Granularity?
    public let filter: Expression?
    public let sortBy: SortDefinition?
}

extension GetSavingsPlansUtilizationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case sortBy = "SortBy"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let granularityDecoded = try containerValues.decodeIfPresent(Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(Expression.self, forKey: .filter)
        filter = filterDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(SortDefinition.self, forKey: .sortBy)
        sortBy = sortByDecoded
    }
}

extension GetSavingsPlansUtilizationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSavingsPlansUtilizationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSavingsPlansUtilizationOutputError: Swift.Error, Equatable {
    case dataUnavailableException(DataUnavailableException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSavingsPlansUtilizationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSavingsPlansUtilizationOutputResponse(savingsPlansUtilizationsByTime: \(String(describing: savingsPlansUtilizationsByTime)), total: \(String(describing: total)))"}
}

extension GetSavingsPlansUtilizationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSavingsPlansUtilizationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.savingsPlansUtilizationsByTime = output.savingsPlansUtilizationsByTime
            self.total = output.total
        } else {
            self.savingsPlansUtilizationsByTime = nil
            self.total = nil
        }
    }
}

public struct GetSavingsPlansUtilizationOutputResponse: Equatable {
    /// <p>The amount of cost/commitment you used your Savings Plans. This allows you to specify date ranges.</p>
    public let savingsPlansUtilizationsByTime: [SavingsPlansUtilizationByTime]?
    /// <p>The total amount of cost/commitment that you used your Savings Plans, regardless of date ranges.</p>
    public let total: SavingsPlansUtilizationAggregates?

    public init (
        savingsPlansUtilizationsByTime: [SavingsPlansUtilizationByTime]? = nil,
        total: SavingsPlansUtilizationAggregates? = nil
    )
    {
        self.savingsPlansUtilizationsByTime = savingsPlansUtilizationsByTime
        self.total = total
    }
}

struct GetSavingsPlansUtilizationOutputResponseBody: Equatable {
    public let savingsPlansUtilizationsByTime: [SavingsPlansUtilizationByTime]?
    public let total: SavingsPlansUtilizationAggregates?
}

extension GetSavingsPlansUtilizationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case savingsPlansUtilizationsByTime = "SavingsPlansUtilizationsByTime"
        case total = "Total"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlansUtilizationsByTimeContainer = try containerValues.decodeIfPresent([SavingsPlansUtilizationByTime?].self, forKey: .savingsPlansUtilizationsByTime)
        var savingsPlansUtilizationsByTimeDecoded0:[SavingsPlansUtilizationByTime]? = nil
        if let savingsPlansUtilizationsByTimeContainer = savingsPlansUtilizationsByTimeContainer {
            savingsPlansUtilizationsByTimeDecoded0 = [SavingsPlansUtilizationByTime]()
            for structure0 in savingsPlansUtilizationsByTimeContainer {
                if let structure0 = structure0 {
                    savingsPlansUtilizationsByTimeDecoded0?.append(structure0)
                }
            }
        }
        savingsPlansUtilizationsByTime = savingsPlansUtilizationsByTimeDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(SavingsPlansUtilizationAggregates.self, forKey: .total)
        total = totalDecoded
    }
}

public struct GetTagsInputBodyMiddleware: Middleware {
    public let id: String = "GetTagsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTagsInput>
    public typealias MOutput = OperationOutput<GetTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTagsOutputError>
}

extension GetTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTagsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextPageToken: \(String(describing: nextPageToken)), searchString: \(String(describing: searchString)), sortBy: \(String(describing: sortBy)), tagKey: \(String(describing: tagKey)), timePeriod: \(String(describing: timePeriod)))"}
}

extension GetTagsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case searchString = "SearchString"
        case sortBy = "SortBy"
        case tagKey = "TagKey"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextPageToken = nextPageToken {
            try encodeContainer.encode(nextPageToken, forKey: .nextPageToken)
        }
        if let searchString = searchString {
            try encodeContainer.encode(searchString, forKey: .searchString)
        }
        if let sortBy = sortBy {
            var sortByContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortBy)
            for sortdefinitions0 in sortBy {
                try sortByContainer.encode(sortdefinitions0)
            }
        }
        if let tagKey = tagKey {
            try encodeContainer.encode(tagKey, forKey: .tagKey)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

public struct GetTagsInputHeadersMiddleware: Middleware {
    public let id: String = "GetTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTagsInput>
    public typealias MOutput = OperationOutput<GetTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTagsOutputError>
}

public struct GetTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTagsInput>
    public typealias MOutput = OperationOutput<GetTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTagsOutputError>
}

public struct GetTagsInput: Equatable {
    /// <p>Use <code>Expression</code> to filter by cost or by usage. There are two patterns: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>Simple dimension values - You can set the dimension name and values for the
    ///                     filters that you plan to use. For example, you can filter for
    ///                     <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>. The
    ///                         <code>Expression</code> example looks like:</p>
    ///                 <p>
    ///                   <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1",
    ///                         “us-west-1” ] } }</code>
    ///                 </p>
    ///                 <p>The list of dimension values are OR'd together to retrieve cost or usage
    ///                     data. You can create <code>Expression</code> and <code>DimensionValues</code>
    ///                     objects using either <code>with*</code> methods or <code>set*</code> methods in
    ///                     multiple lines. </p>
    ///             </li>
    ///             <li>
    ///                 <p>Compound dimension values with logical operations - You can use multiple
    ///                         <code>Expression</code> types and the logical operators
    ///                         <code>AND/OR/NOT</code> to create a list of one or more
    ///                         <code>Expression</code> objects. This allows you to filter on more advanced
    ///                     options. For example, you can filter on <code>((REGION == us-east-1 OR
    ///                         REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE !=
    ///                         DataTransfer)</code>. The <code>Expression</code> for that looks like
    ///                     this:</p>
    ///                 <p>
    ///                   <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION",
    ///                         "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName",
    ///                         "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE",
    ///                         "Values": ["DataTransfer"] }}} ] } </code>
    ///                </p>
    ///                 <note>
    ///                     <p>Because each <code>Expression</code> can have only one operator, the
    ///                         service returns an error if more than one is specified. The following
    ///                         example shows an <code>Expression</code> object that creates an
    ///                         error.</p>
    ///                 </note>
    ///                 <p>
    ///                     <code> { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE",
    ///                         "Values": [ "DataTransfer" ] } } </code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///         <note>
    ///             <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT is not
    ///                 supported. OR is not supported between different dimensions, or dimensions and tags.
    ///                 NOT operators aren't supported.
    ///                 Dimensions
    ///                 are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or
    ///                     <code>RIGHTSIZING_TYPE</code>.</p>
    /// 					
    /// 					       <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR are not supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
    /// 					
    /// 					
    /// 					
    ///          </note>
    public let filter: Expression?
    /// <p>This field is only used when SortBy is provided in the request. The maximum number of objects that to be returned for this request. If MaxResults is not specified with SortBy, the request will return 1000 results as the default value for this parameter.</p>
    /// 	        <p>For <code>GetTags</code>, MaxResults has an upper limit of 1000.</p>
    public let maxResults: Int
    /// <p>The token to retrieve the next set of results. AWS provides the token when the response from a previous call has more results than the maximum page size.</p>
    public let nextPageToken: String?
    /// <p>The value that you want to search for.</p>
    public let searchString: String?
    /// <p>The value by which you want to sort the data.</p>
    /// 	        <p>The key represents cost and usage metrics. The following values are supported:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>BlendedCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UnblendedCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AmortizedCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NetAmortizedCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NetUnblendedCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UsageQuantity</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NormalizedUsageAmount</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>Supported values for <code>SortOrder</code> are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
    ///          <p>When using <code>SortBy</code>, <code>NextPageToken</code> and <code>SearchString</code> are not supported.</p>
    public let sortBy: [SortDefinition]?
    /// <p>The key of the tag that you want to return values for.</p>
    public let tagKey: String?
    /// <p>The start and end dates for retrieving the dimension values. The start date is inclusive,  but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is
    ///             retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>.</p>
    public let timePeriod: DateInterval?

    public init (
        filter: Expression? = nil,
        maxResults: Int = 0,
        nextPageToken: String? = nil,
        searchString: String? = nil,
        sortBy: [SortDefinition]? = nil,
        tagKey: String? = nil,
        timePeriod: DateInterval? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextPageToken = nextPageToken
        self.searchString = searchString
        self.sortBy = sortBy
        self.tagKey = tagKey
        self.timePeriod = timePeriod
    }
}

struct GetTagsInputBody: Equatable {
    public let searchString: String?
    public let timePeriod: DateInterval?
    public let tagKey: String?
    public let filter: Expression?
    public let sortBy: [SortDefinition]?
    public let maxResults: Int
    public let nextPageToken: String?
}

extension GetTagsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case maxResults = "MaxResults"
        case nextPageToken = "NextPageToken"
        case searchString = "SearchString"
        case sortBy = "SortBy"
        case tagKey = "TagKey"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .searchString)
        searchString = searchStringDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let tagKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tagKey)
        tagKey = tagKeyDecoded
        let filterDecoded = try containerValues.decodeIfPresent(Expression.self, forKey: .filter)
        filter = filterDecoded
        let sortByContainer = try containerValues.decodeIfPresent([SortDefinition?].self, forKey: .sortBy)
        var sortByDecoded0:[SortDefinition]? = nil
        if let sortByContainer = sortByContainer {
            sortByDecoded0 = [SortDefinition]()
            for structure0 in sortByContainer {
                if let structure0 = structure0 {
                    sortByDecoded0?.append(structure0)
                }
            }
        }
        sortBy = sortByDecoded0
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension GetTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BillExpirationException" : self = .billExpirationException(try BillExpirationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestChangedException" : self = .requestChangedException(try RequestChangedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTagsOutputError: Swift.Error, Equatable {
    case billExpirationException(BillExpirationException)
    case dataUnavailableException(DataUnavailableException)
    case invalidNextTokenException(InvalidNextTokenException)
    case limitExceededException(LimitExceededException)
    case requestChangedException(RequestChangedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTagsOutputResponse(nextPageToken: \(String(describing: nextPageToken)), returnSize: \(String(describing: returnSize)), tags: \(String(describing: tags)), totalSize: \(String(describing: totalSize)))"}
}

extension GetTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextPageToken = output.nextPageToken
            self.returnSize = output.returnSize
            self.tags = output.tags
            self.totalSize = output.totalSize
        } else {
            self.nextPageToken = nil
            self.returnSize = nil
            self.tags = nil
            self.totalSize = nil
        }
    }
}

public struct GetTagsOutputResponse: Equatable {
    /// <p>The token for the next set of retrievable results. AWS provides the token when the response from a previous call has more results than the maximum page size.</p>
    public let nextPageToken: String?
    /// <p>The number of query results that AWS returns at a time.</p>
    public let returnSize: Int?
    /// <p>The tags that match your request.</p>
    public let tags: [String]?
    /// <p>The total number of query results.</p>
    public let totalSize: Int?

    public init (
        nextPageToken: String? = nil,
        returnSize: Int? = nil,
        tags: [String]? = nil,
        totalSize: Int? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.returnSize = returnSize
        self.tags = tags
        self.totalSize = totalSize
    }
}

struct GetTagsOutputResponseBody: Equatable {
    public let nextPageToken: String?
    public let tags: [String]?
    public let returnSize: Int?
    public let totalSize: Int?
}

extension GetTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextPageToken = "NextPageToken"
        case returnSize = "ReturnSize"
        case tags = "Tags"
        case totalSize = "TotalSize"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tags)
        var tagsDecoded0:[String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String]()
            for string0 in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?.append(string0)
                }
            }
        }
        tags = tagsDecoded0
        let returnSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .returnSize)
        returnSize = returnSizeDecoded
        let totalSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .totalSize)
        totalSize = totalSizeDecoded
    }
}

public struct GetUsageForecastInputBodyMiddleware: Middleware {
    public let id: String = "GetUsageForecastInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUsageForecastInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUsageForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUsageForecastInput>
    public typealias MOutput = OperationOutput<GetUsageForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUsageForecastOutputError>
}

extension GetUsageForecastInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUsageForecastInput(filter: \(String(describing: filter)), granularity: \(String(describing: granularity)), metric: \(String(describing: metric)), predictionIntervalLevel: \(String(describing: predictionIntervalLevel)), timePeriod: \(String(describing: timePeriod)))"}
}

extension GetUsageForecastInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case metric = "Metric"
        case predictionIntervalLevel = "PredictionIntervalLevel"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let granularity = granularity {
            try encodeContainer.encode(granularity.rawValue, forKey: .granularity)
        }
        if let metric = metric {
            try encodeContainer.encode(metric.rawValue, forKey: .metric)
        }
        if let predictionIntervalLevel = predictionIntervalLevel {
            try encodeContainer.encode(predictionIntervalLevel, forKey: .predictionIntervalLevel)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

public struct GetUsageForecastInputHeadersMiddleware: Middleware {
    public let id: String = "GetUsageForecastInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUsageForecastInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUsageForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUsageForecastInput>
    public typealias MOutput = OperationOutput<GetUsageForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUsageForecastOutputError>
}

public struct GetUsageForecastInputQueryItemMiddleware: Middleware {
    public let id: String = "GetUsageForecastInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUsageForecastInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUsageForecastOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUsageForecastInput>
    public typealias MOutput = OperationOutput<GetUsageForecastOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUsageForecastOutputError>
}

public struct GetUsageForecastInput: Equatable {
    /// <p>The filters that you want to use to filter your forecast. The <code>GetUsageForecast</code> API supports filtering by the following dimensions:</p>
    /// 		
    /// 	        <ul>
    ///             <li>
    ///                <p>
    ///                   <code>AZ</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INSTANCE_TYPE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LINKED_ACCOUNT</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LINKED_ACCOUNT_NAME</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OPERATION</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PURCHASE_TYPE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>REGION</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SERVICE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>USAGE_TYPE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>USAGE_TYPE_GROUP</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RECORD_TYPE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OPERATING_SYSTEM</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>TENANCY</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SCOPE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PLATFORM</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SUBSCRIPTION_ID</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>LEGAL_ENTITY_NAME</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DEPLOYMENT_OPTION</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DATABASE_ENGINE</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INSTANCE_TYPE_FAMILY</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>BILLING_ENTITY</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>RESERVATION_ID</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SAVINGS_PLAN_ARN</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let filter: Expression?
    /// <p>How granular you want the forecast to be. You can get 3 months of <code>DAILY</code> forecasts or 12 months of <code>MONTHLY</code> forecasts.</p>
    /// 		       <p>The <code>GetUsageForecast</code> operation supports only <code>DAILY</code> and <code>MONTHLY</code> granularities.</p>
    public let granularity: Granularity?
    /// <p>Which metric Cost Explorer uses to create your forecast.</p>
    /// 		       <p>Valid values for a <code>GetUsageForecast</code> call are the following:</p>
    /// 		       <ul>
    ///             <li>
    /// 				           <p>USAGE_QUANTITY</p>
    /// 			         </li>
    ///             <li>
    /// 				           <p>NORMALIZED_USAGE_AMOUNT</p>
    /// 			         </li>
    ///          </ul>
    public let metric: Metric?
    /// <p>Cost Explorer always returns the mean forecast as a single point. You can request a prediction interval around the mean
    /// 			by specifying a confidence level. The higher the confidence level, the more confident Cost Explorer is about the actual value
    /// 			falling in the prediction interval. Higher confidence levels result in wider prediction intervals.</p>
    public let predictionIntervalLevel: Int?
    /// <p>The start and end dates of the period that you want to retrieve usage forecast for. The start date is inclusive,  but the end date is exclusive. For example, if <code>start</code> is <code>2017-01-01</code> and <code>end</code> is <code>2017-05-01</code>, then the cost and usage data is
    /// 		  retrieved from <code>2017-01-01</code> up to and including <code>2017-04-30</code> but not including <code>2017-05-01</code>. The start date must be equal to or later than the current date to avoid a validation error.</p>
    public let timePeriod: DateInterval?

    public init (
        filter: Expression? = nil,
        granularity: Granularity? = nil,
        metric: Metric? = nil,
        predictionIntervalLevel: Int? = nil,
        timePeriod: DateInterval? = nil
    )
    {
        self.filter = filter
        self.granularity = granularity
        self.metric = metric
        self.predictionIntervalLevel = predictionIntervalLevel
        self.timePeriod = timePeriod
    }
}

struct GetUsageForecastInputBody: Equatable {
    public let timePeriod: DateInterval?
    public let metric: Metric?
    public let granularity: Granularity?
    public let filter: Expression?
    public let predictionIntervalLevel: Int?
}

extension GetUsageForecastInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter = "Filter"
        case granularity = "Granularity"
        case metric = "Metric"
        case predictionIntervalLevel = "PredictionIntervalLevel"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let metricDecoded = try containerValues.decodeIfPresent(Metric.self, forKey: .metric)
        metric = metricDecoded
        let granularityDecoded = try containerValues.decodeIfPresent(Granularity.self, forKey: .granularity)
        granularity = granularityDecoded
        let filterDecoded = try containerValues.decodeIfPresent(Expression.self, forKey: .filter)
        filter = filterDecoded
        let predictionIntervalLevelDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .predictionIntervalLevel)
        predictionIntervalLevel = predictionIntervalLevelDecoded
    }
}

extension GetUsageForecastOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUsageForecastOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DataUnavailableException" : self = .dataUnavailableException(try DataUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnresolvableUsageUnitException" : self = .unresolvableUsageUnitException(try UnresolvableUsageUnitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUsageForecastOutputError: Swift.Error, Equatable {
    case dataUnavailableException(DataUnavailableException)
    case limitExceededException(LimitExceededException)
    case unresolvableUsageUnitException(UnresolvableUsageUnitException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUsageForecastOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUsageForecastOutputResponse(forecastResultsByTime: \(String(describing: forecastResultsByTime)), total: \(String(describing: total)))"}
}

extension GetUsageForecastOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetUsageForecastOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.forecastResultsByTime = output.forecastResultsByTime
            self.total = output.total
        } else {
            self.forecastResultsByTime = nil
            self.total = nil
        }
    }
}

public struct GetUsageForecastOutputResponse: Equatable {
    /// <p>The forecasts for your query, in order. For <code>DAILY</code> forecasts, this is a list of days. For <code>MONTHLY</code> forecasts,
    /// 			this is a list of months.</p>
    public let forecastResultsByTime: [ForecastResult]?
    /// <p>How much you're forecasted to use over the forecast period.</p>
    public let total: MetricValue?

    public init (
        forecastResultsByTime: [ForecastResult]? = nil,
        total: MetricValue? = nil
    )
    {
        self.forecastResultsByTime = forecastResultsByTime
        self.total = total
    }
}

struct GetUsageForecastOutputResponseBody: Equatable {
    public let total: MetricValue?
    public let forecastResultsByTime: [ForecastResult]?
}

extension GetUsageForecastOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case forecastResultsByTime = "ForecastResultsByTime"
        case total = "Total"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(MetricValue.self, forKey: .total)
        total = totalDecoded
        let forecastResultsByTimeContainer = try containerValues.decodeIfPresent([ForecastResult?].self, forKey: .forecastResultsByTime)
        var forecastResultsByTimeDecoded0:[ForecastResult]? = nil
        if let forecastResultsByTimeContainer = forecastResultsByTimeContainer {
            forecastResultsByTimeDecoded0 = [ForecastResult]()
            for structure0 in forecastResultsByTimeContainer {
                if let structure0 = structure0 {
                    forecastResultsByTimeDecoded0?.append(structure0)
                }
            }
        }
        forecastResultsByTime = forecastResultsByTimeDecoded0
    }
}

public enum Granularity {
    case daily
    case hourly
    case monthly
    case sdkUnknown(String)
}

extension Granularity : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Granularity] {
        return [
            .daily,
            .hourly,
            .monthly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .daily: return "DAILY"
        case .hourly: return "HOURLY"
        case .monthly: return "MONTHLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Granularity(rawValue: rawValue) ?? Granularity.sdkUnknown(rawValue)
    }
}

extension Group: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keys = "Keys"
        case metrics = "Metrics"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keys = keys {
            var keysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .keys)
            for keys0 in keys {
                try keysContainer.encode(keys0)
            }
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .metrics)
            for (dictKey0, metrics0) in metrics {
                try metricsContainer.encode(metrics0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .keys)
        var keysDecoded0:[String]? = nil
        if let keysContainer = keysContainer {
            keysDecoded0 = [String]()
            for string0 in keysContainer {
                if let string0 = string0 {
                    keysDecoded0?.append(string0)
                }
            }
        }
        keys = keysDecoded0
        let metricsContainer = try containerValues.decodeIfPresent([String: MetricValue?].self, forKey: .metrics)
        var metricsDecoded0: [String:MetricValue]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [String:MetricValue]()
            for (key0, metricvalue0) in metricsContainer {
                if let metricvalue0 = metricvalue0 {
                    metricsDecoded0?[key0] = metricvalue0
                }
            }
        }
        metrics = metricsDecoded0
    }
}

extension Group: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Group(keys: \(String(describing: keys)), metrics: \(String(describing: metrics)))"}
}

/// <p>One level of grouped data in the results.</p>
public struct Group: Equatable {
    /// <p>The keys that are included in this group.</p>
    public let keys: [String]?
    /// <p>The metrics that are included in this group.</p>
    public let metrics: [String:MetricValue]?

    public init (
        keys: [String]? = nil,
        metrics: [String:MetricValue]? = nil
    )
    {
        self.keys = keys
        self.metrics = metrics
    }
}

extension GroupDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(GroupDefinitionType.self, forKey: .type)
        type = typeDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
    }
}

extension GroupDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GroupDefinition(key: \(String(describing: key)), type: \(String(describing: type)))"}
}

/// <p>Represents a group when you specify a group by criteria or in the response to a
///             query with a specific grouping.</p>
public struct GroupDefinition: Equatable {
    /// <p>The string that represents a key for a specified group.</p>
    public let key: String?
    /// <p>The string that represents the type of group.</p>
    public let type: GroupDefinitionType?

    public init (
        key: String? = nil,
        type: GroupDefinitionType? = nil
    )
    {
        self.key = key
        self.type = type
    }
}

public enum GroupDefinitionType {
    case costCategory
    case dimension
    case tag
    case sdkUnknown(String)
}

extension GroupDefinitionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GroupDefinitionType] {
        return [
            .costCategory,
            .dimension,
            .tag,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .costCategory: return "COST_CATEGORY"
        case .dimension: return "DIMENSION"
        case .tag: return "TAG"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GroupDefinitionType(rawValue: rawValue) ?? GroupDefinitionType.sdkUnknown(rawValue)
    }
}

extension Impact: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxImpact = "MaxImpact"
        case totalImpact = "TotalImpact"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxImpact != 0.0 {
            try encodeContainer.encode(maxImpact, forKey: .maxImpact)
        }
        if totalImpact != 0.0 {
            try encodeContainer.encode(totalImpact, forKey: .totalImpact)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxImpactDecoded = try containerValues.decode(Double.self, forKey: .maxImpact)
        maxImpact = maxImpactDecoded
        let totalImpactDecoded = try containerValues.decode(Double.self, forKey: .totalImpact)
        totalImpact = totalImpactDecoded
    }
}

extension Impact: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Impact(maxImpact: \(String(describing: maxImpact)), totalImpact: \(String(describing: totalImpact)))"}
}

/// <p>
///         The anomaly's dollar value.
///     </p>
public struct Impact: Equatable {
    /// <p>
    ///         The maximum dollar value observed for an anomaly.
    ///     </p>
    public let maxImpact: Double
    /// <p>
    ///         The cumulative dollar value observed for an anomaly.
    ///     </p>
    public let totalImpact: Double

    public init (
        maxImpact: Double = 0.0,
        totalImpact: Double = 0.0
    )
    {
        self.maxImpact = maxImpact
        self.totalImpact = totalImpact
    }
}

extension InstanceDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eC2InstanceDetails = "EC2InstanceDetails"
        case eSInstanceDetails = "ESInstanceDetails"
        case elastiCacheInstanceDetails = "ElastiCacheInstanceDetails"
        case rDSInstanceDetails = "RDSInstanceDetails"
        case redshiftInstanceDetails = "RedshiftInstanceDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eC2InstanceDetails = eC2InstanceDetails {
            try encodeContainer.encode(eC2InstanceDetails, forKey: .eC2InstanceDetails)
        }
        if let eSInstanceDetails = eSInstanceDetails {
            try encodeContainer.encode(eSInstanceDetails, forKey: .eSInstanceDetails)
        }
        if let elastiCacheInstanceDetails = elastiCacheInstanceDetails {
            try encodeContainer.encode(elastiCacheInstanceDetails, forKey: .elastiCacheInstanceDetails)
        }
        if let rDSInstanceDetails = rDSInstanceDetails {
            try encodeContainer.encode(rDSInstanceDetails, forKey: .rDSInstanceDetails)
        }
        if let redshiftInstanceDetails = redshiftInstanceDetails {
            try encodeContainer.encode(redshiftInstanceDetails, forKey: .redshiftInstanceDetails)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eC2InstanceDetailsDecoded = try containerValues.decodeIfPresent(EC2InstanceDetails.self, forKey: .eC2InstanceDetails)
        eC2InstanceDetails = eC2InstanceDetailsDecoded
        let rDSInstanceDetailsDecoded = try containerValues.decodeIfPresent(RDSInstanceDetails.self, forKey: .rDSInstanceDetails)
        rDSInstanceDetails = rDSInstanceDetailsDecoded
        let redshiftInstanceDetailsDecoded = try containerValues.decodeIfPresent(RedshiftInstanceDetails.self, forKey: .redshiftInstanceDetails)
        redshiftInstanceDetails = redshiftInstanceDetailsDecoded
        let elastiCacheInstanceDetailsDecoded = try containerValues.decodeIfPresent(ElastiCacheInstanceDetails.self, forKey: .elastiCacheInstanceDetails)
        elastiCacheInstanceDetails = elastiCacheInstanceDetailsDecoded
        let eSInstanceDetailsDecoded = try containerValues.decodeIfPresent(ESInstanceDetails.self, forKey: .eSInstanceDetails)
        eSInstanceDetails = eSInstanceDetailsDecoded
    }
}

extension InstanceDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InstanceDetails(eC2InstanceDetails: \(String(describing: eC2InstanceDetails)), eSInstanceDetails: \(String(describing: eSInstanceDetails)), elastiCacheInstanceDetails: \(String(describing: elastiCacheInstanceDetails)), rDSInstanceDetails: \(String(describing: rDSInstanceDetails)), redshiftInstanceDetails: \(String(describing: redshiftInstanceDetails)))"}
}

/// <p>Details about the instances that AWS recommends that you purchase.</p>
public struct InstanceDetails: Equatable {
    /// <p>The Amazon EC2 instances that AWS recommends that you purchase.</p>
    public let eC2InstanceDetails: EC2InstanceDetails?
    /// <p>The Amazon ES instances that AWS recommends that you purchase.</p>
    public let eSInstanceDetails: ESInstanceDetails?
    /// <p>The ElastiCache instances that AWS recommends that you purchase.</p>
    public let elastiCacheInstanceDetails: ElastiCacheInstanceDetails?
    /// <p>The Amazon RDS instances that AWS recommends that you purchase.</p>
    public let rDSInstanceDetails: RDSInstanceDetails?
    /// <p>The Amazon Redshift instances that AWS recommends that you purchase.</p>
    public let redshiftInstanceDetails: RedshiftInstanceDetails?

    public init (
        eC2InstanceDetails: EC2InstanceDetails? = nil,
        eSInstanceDetails: ESInstanceDetails? = nil,
        elastiCacheInstanceDetails: ElastiCacheInstanceDetails? = nil,
        rDSInstanceDetails: RDSInstanceDetails? = nil,
        redshiftInstanceDetails: RedshiftInstanceDetails? = nil
    )
    {
        self.eC2InstanceDetails = eC2InstanceDetails
        self.eSInstanceDetails = eSInstanceDetails
        self.elastiCacheInstanceDetails = elastiCacheInstanceDetails
        self.rDSInstanceDetails = rDSInstanceDetails
        self.redshiftInstanceDetails = redshiftInstanceDetails
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The pagination token is invalid. Try again without a pagination token.</p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You made too many calls in a short period of time. Try again later.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListCostCategoryDefinitionsInputBodyMiddleware: Middleware {
    public let id: String = "ListCostCategoryDefinitionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCostCategoryDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCostCategoryDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCostCategoryDefinitionsInput>
    public typealias MOutput = OperationOutput<ListCostCategoryDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCostCategoryDefinitionsOutputError>
}

extension ListCostCategoryDefinitionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCostCategoryDefinitionsInput(effectiveOn: \(String(describing: effectiveOn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCostCategoryDefinitionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case effectiveOn = "EffectiveOn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let effectiveOn = effectiveOn {
            try encodeContainer.encode(effectiveOn, forKey: .effectiveOn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListCostCategoryDefinitionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListCostCategoryDefinitionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCostCategoryDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCostCategoryDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCostCategoryDefinitionsInput>
    public typealias MOutput = OperationOutput<ListCostCategoryDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCostCategoryDefinitionsOutputError>
}

public struct ListCostCategoryDefinitionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCostCategoryDefinitionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCostCategoryDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCostCategoryDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCostCategoryDefinitionsInput>
    public typealias MOutput = OperationOutput<ListCostCategoryDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCostCategoryDefinitionsOutputError>
}

public struct ListCostCategoryDefinitionsInput: Equatable {
    /// <p>
    ///       The date when the Cost Category was effective.
    ///     </p>
    public let effectiveOn: String?
    /// <p> The number of entries a paginated response contains. </p>
    public let maxResults: Int
    /// <p>
    ///       The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    ///     </p>
    public let nextToken: String?

    public init (
        effectiveOn: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.effectiveOn = effectiveOn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCostCategoryDefinitionsInputBody: Equatable {
    public let effectiveOn: String?
    public let nextToken: String?
    public let maxResults: Int
}

extension ListCostCategoryDefinitionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case effectiveOn = "EffectiveOn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let effectiveOnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .effectiveOn)
        effectiveOn = effectiveOnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListCostCategoryDefinitionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCostCategoryDefinitionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCostCategoryDefinitionsOutputError: Swift.Error, Equatable {
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCostCategoryDefinitionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCostCategoryDefinitionsOutputResponse(costCategoryReferences: \(String(describing: costCategoryReferences)), nextToken: \(String(describing: nextToken)))"}
}

extension ListCostCategoryDefinitionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCostCategoryDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.costCategoryReferences = output.costCategoryReferences
            self.nextToken = output.nextToken
        } else {
            self.costCategoryReferences = nil
            self.nextToken = nil
        }
    }
}

public struct ListCostCategoryDefinitionsOutputResponse: Equatable {
    /// <p>
    ///       A reference to a Cost Category containing enough information to identify the Cost Category.
    ///     </p>
    public let costCategoryReferences: [CostCategoryReference]?
    /// <p>
    ///       The token to retrieve the next set of results. Amazon Web Services provides the token when the response from a previous call has more results than the maximum page size.
    ///     </p>
    public let nextToken: String?

    public init (
        costCategoryReferences: [CostCategoryReference]? = nil,
        nextToken: String? = nil
    )
    {
        self.costCategoryReferences = costCategoryReferences
        self.nextToken = nextToken
    }
}

struct ListCostCategoryDefinitionsOutputResponseBody: Equatable {
    public let costCategoryReferences: [CostCategoryReference]?
    public let nextToken: String?
}

extension ListCostCategoryDefinitionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case costCategoryReferences = "CostCategoryReferences"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryReferencesContainer = try containerValues.decodeIfPresent([CostCategoryReference?].self, forKey: .costCategoryReferences)
        var costCategoryReferencesDecoded0:[CostCategoryReference]? = nil
        if let costCategoryReferencesContainer = costCategoryReferencesContainer {
            costCategoryReferencesDecoded0 = [CostCategoryReference]()
            for structure0 in costCategoryReferencesContainer {
                if let structure0 = structure0 {
                    costCategoryReferencesDecoded0?.append(structure0)
                }
            }
        }
        costCategoryReferences = costCategoryReferencesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public enum LookbackPeriodInDays {
    case sevenDays
    case sixtyDays
    case thirtyDays
    case sdkUnknown(String)
}

extension LookbackPeriodInDays : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LookbackPeriodInDays] {
        return [
            .sevenDays,
            .sixtyDays,
            .thirtyDays,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .sevenDays: return "SEVEN_DAYS"
        case .sixtyDays: return "SIXTY_DAYS"
        case .thirtyDays: return "THIRTY_DAYS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LookbackPeriodInDays(rawValue: rawValue) ?? LookbackPeriodInDays.sdkUnknown(rawValue)
    }
}

public enum MatchOption {
    case absent
    case caseInsensitive
    case caseSensitive
    case contains
    case endsWith
    case equals
    case startsWith
    case sdkUnknown(String)
}

extension MatchOption : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MatchOption] {
        return [
            .absent,
            .caseInsensitive,
            .caseSensitive,
            .contains,
            .endsWith,
            .equals,
            .startsWith,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .absent: return "ABSENT"
        case .caseInsensitive: return "CASE_INSENSITIVE"
        case .caseSensitive: return "CASE_SENSITIVE"
        case .contains: return "CONTAINS"
        case .endsWith: return "ENDS_WITH"
        case .equals: return "EQUALS"
        case .startsWith: return "STARTS_WITH"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MatchOption(rawValue: rawValue) ?? MatchOption.sdkUnknown(rawValue)
    }
}

public enum Metric {
    case amortizedCost
    case blendedCost
    case netAmortizedCost
    case netUnblendedCost
    case normalizedUsageAmount
    case unblendedCost
    case usageQuantity
    case sdkUnknown(String)
}

extension Metric : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Metric] {
        return [
            .amortizedCost,
            .blendedCost,
            .netAmortizedCost,
            .netUnblendedCost,
            .normalizedUsageAmount,
            .unblendedCost,
            .usageQuantity,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .amortizedCost: return "AMORTIZED_COST"
        case .blendedCost: return "BLENDED_COST"
        case .netAmortizedCost: return "NET_AMORTIZED_COST"
        case .netUnblendedCost: return "NET_UNBLENDED_COST"
        case .normalizedUsageAmount: return "NORMALIZED_USAGE_AMOUNT"
        case .unblendedCost: return "UNBLENDED_COST"
        case .usageQuantity: return "USAGE_QUANTITY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Metric(rawValue: rawValue) ?? Metric.sdkUnknown(rawValue)
    }
}

extension MetricValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amount = "Amount"
        case unit = "Unit"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amount = amount {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amount)
        amount = amountDecoded
        let unitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension MetricValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricValue(amount: \(String(describing: amount)), unit: \(String(describing: unit)))"}
}

/// <p>The aggregated value for a metric.</p>
public struct MetricValue: Equatable {
    /// <p>The actual number that represents the metric.</p>
    public let amount: String?
    /// <p>The unit that the metric is given in.</p>
    public let unit: String?

    public init (
        amount: String? = nil,
        unit: String? = nil
    )
    {
        self.amount = amount
        self.unit = unit
    }
}

extension ModifyRecommendationDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case targetInstances = "TargetInstances"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetInstances = targetInstances {
            var targetInstancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetInstances)
            for targetinstanceslist0 in targetInstances {
                try targetInstancesContainer.encode(targetinstanceslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetInstancesContainer = try containerValues.decodeIfPresent([TargetInstance?].self, forKey: .targetInstances)
        var targetInstancesDecoded0:[TargetInstance]? = nil
        if let targetInstancesContainer = targetInstancesContainer {
            targetInstancesDecoded0 = [TargetInstance]()
            for structure0 in targetInstancesContainer {
                if let structure0 = structure0 {
                    targetInstancesDecoded0?.append(structure0)
                }
            }
        }
        targetInstances = targetInstancesDecoded0
    }
}

extension ModifyRecommendationDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModifyRecommendationDetail(targetInstances: \(String(describing: targetInstances)))"}
}

/// <p> Details on the modification recommendation.</p>
public struct ModifyRecommendationDetail: Equatable {
    /// <p>Identifies whether this instance type is the AWS default recommendation.</p>
    public let targetInstances: [TargetInstance]?

    public init (
        targetInstances: [TargetInstance]? = nil
    )
    {
        self.targetInstances = targetInstances
    }
}

public enum MonitorDimension {
    case service
    case sdkUnknown(String)
}

extension MonitorDimension : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MonitorDimension] {
        return [
            .service,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .service: return "SERVICE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MonitorDimension(rawValue: rawValue) ?? MonitorDimension.sdkUnknown(rawValue)
    }
}

public enum MonitorType {
    case custom
    case dimensional
    case sdkUnknown(String)
}

extension MonitorType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MonitorType] {
        return [
            .custom,
            .dimensional,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .custom: return "CUSTOM"
        case .dimensional: return "DIMENSIONAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MonitorType(rawValue: rawValue) ?? MonitorType.sdkUnknown(rawValue)
    }
}

extension NetworkResourceUtilization: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case networkInBytesPerSecond = "NetworkInBytesPerSecond"
        case networkOutBytesPerSecond = "NetworkOutBytesPerSecond"
        case networkPacketsInPerSecond = "NetworkPacketsInPerSecond"
        case networkPacketsOutPerSecond = "NetworkPacketsOutPerSecond"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkInBytesPerSecond = networkInBytesPerSecond {
            try encodeContainer.encode(networkInBytesPerSecond, forKey: .networkInBytesPerSecond)
        }
        if let networkOutBytesPerSecond = networkOutBytesPerSecond {
            try encodeContainer.encode(networkOutBytesPerSecond, forKey: .networkOutBytesPerSecond)
        }
        if let networkPacketsInPerSecond = networkPacketsInPerSecond {
            try encodeContainer.encode(networkPacketsInPerSecond, forKey: .networkPacketsInPerSecond)
        }
        if let networkPacketsOutPerSecond = networkPacketsOutPerSecond {
            try encodeContainer.encode(networkPacketsOutPerSecond, forKey: .networkPacketsOutPerSecond)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInBytesPerSecondDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkInBytesPerSecond)
        networkInBytesPerSecond = networkInBytesPerSecondDecoded
        let networkOutBytesPerSecondDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkOutBytesPerSecond)
        networkOutBytesPerSecond = networkOutBytesPerSecondDecoded
        let networkPacketsInPerSecondDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkPacketsInPerSecond)
        networkPacketsInPerSecond = networkPacketsInPerSecondDecoded
        let networkPacketsOutPerSecondDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkPacketsOutPerSecond)
        networkPacketsOutPerSecond = networkPacketsOutPerSecondDecoded
    }
}

extension NetworkResourceUtilization: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkResourceUtilization(networkInBytesPerSecond: \(String(describing: networkInBytesPerSecond)), networkOutBytesPerSecond: \(String(describing: networkOutBytesPerSecond)), networkPacketsInPerSecond: \(String(describing: networkPacketsInPerSecond)), networkPacketsOutPerSecond: \(String(describing: networkPacketsOutPerSecond)))"}
}

/// <p>
///             The network field that contains a list of network metrics associated with the current instance.
///         </p>
public struct NetworkResourceUtilization: Equatable {
    /// <p>
    ///             The network ingress throughput utilization measured in Bytes per second.
    ///         </p>
    public let networkInBytesPerSecond: String?
    /// <p>
    ///             The network outgress throughput utilization measured in Bytes per second.
    ///         </p>
    public let networkOutBytesPerSecond: String?
    /// <p>
    ///             The network ingress packets measured in packets per second.
    ///         </p>
    public let networkPacketsInPerSecond: String?
    /// <p>
    ///             The network outgress packets measured in packets per second.
    ///         </p>
    public let networkPacketsOutPerSecond: String?

    public init (
        networkInBytesPerSecond: String? = nil,
        networkOutBytesPerSecond: String? = nil,
        networkPacketsInPerSecond: String? = nil,
        networkPacketsOutPerSecond: String? = nil
    )
    {
        self.networkInBytesPerSecond = networkInBytesPerSecond
        self.networkOutBytesPerSecond = networkOutBytesPerSecond
        self.networkPacketsInPerSecond = networkPacketsInPerSecond
        self.networkPacketsOutPerSecond = networkPacketsOutPerSecond
    }
}

public enum NumericOperator {
    case between
    case equal
    case greaterThan
    case greaterThanOrEqual
    case lessThan
    case lessThanOrEqual
    case sdkUnknown(String)
}

extension NumericOperator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NumericOperator] {
        return [
            .between,
            .equal,
            .greaterThan,
            .greaterThanOrEqual,
            .lessThan,
            .lessThanOrEqual,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .between: return "BETWEEN"
        case .equal: return "EQUAL"
        case .greaterThan: return "GREATER_THAN"
        case .greaterThanOrEqual: return "GREATER_THAN_OR_EQUAL"
        case .lessThan: return "LESS_THAN"
        case .lessThanOrEqual: return "LESS_THAN_OR_EQUAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NumericOperator(rawValue: rawValue) ?? NumericOperator.sdkUnknown(rawValue)
    }
}

public enum OfferingClass {
    case convertible
    case standard
    case sdkUnknown(String)
}

extension OfferingClass : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OfferingClass] {
        return [
            .convertible,
            .standard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .convertible: return "CONVERTIBLE"
        case .standard: return "STANDARD"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OfferingClass(rawValue: rawValue) ?? OfferingClass.sdkUnknown(rawValue)
    }
}

public enum PaymentOption {
    case allUpfront
    case heavyUtilization
    case lightUtilization
    case mediumUtilization
    case noUpfront
    case partialUpfront
    case sdkUnknown(String)
}

extension PaymentOption : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PaymentOption] {
        return [
            .allUpfront,
            .heavyUtilization,
            .lightUtilization,
            .mediumUtilization,
            .noUpfront,
            .partialUpfront,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allUpfront: return "ALL_UPFRONT"
        case .heavyUtilization: return "HEAVY_UTILIZATION"
        case .lightUtilization: return "LIGHT_UTILIZATION"
        case .mediumUtilization: return "MEDIUM_UTILIZATION"
        case .noUpfront: return "NO_UPFRONT"
        case .partialUpfront: return "PARTIAL_UPFRONT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PaymentOption(rawValue: rawValue) ?? PaymentOption.sdkUnknown(rawValue)
    }
}

public enum PlatformDifference {
    case hypervisor
    case instanceStoreAvailability
    case networkInterface
    case storageInterface
    case virtualizationType
    case sdkUnknown(String)
}

extension PlatformDifference : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PlatformDifference] {
        return [
            .hypervisor,
            .instanceStoreAvailability,
            .networkInterface,
            .storageInterface,
            .virtualizationType,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .hypervisor: return "HYPERVISOR"
        case .instanceStoreAvailability: return "INSTANCE_STORE_AVAILABILITY"
        case .networkInterface: return "NETWORK_INTERFACE"
        case .storageInterface: return "STORAGE_INTERFACE"
        case .virtualizationType: return "VIRTUALIZATION_TYPE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PlatformDifference(rawValue: rawValue) ?? PlatformDifference.sdkUnknown(rawValue)
    }
}

public struct ProvideAnomalyFeedbackInputBodyMiddleware: Middleware {
    public let id: String = "ProvideAnomalyFeedbackInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ProvideAnomalyFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<ProvideAnomalyFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ProvideAnomalyFeedbackInput>
    public typealias MOutput = OperationOutput<ProvideAnomalyFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ProvideAnomalyFeedbackOutputError>
}

extension ProvideAnomalyFeedbackInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvideAnomalyFeedbackInput(anomalyId: \(String(describing: anomalyId)), feedback: \(String(describing: feedback)))"}
}

extension ProvideAnomalyFeedbackInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyId = "AnomalyId"
        case feedback = "Feedback"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyId = anomalyId {
            try encodeContainer.encode(anomalyId, forKey: .anomalyId)
        }
        if let feedback = feedback {
            try encodeContainer.encode(feedback.rawValue, forKey: .feedback)
        }
    }
}

public struct ProvideAnomalyFeedbackInputHeadersMiddleware: Middleware {
    public let id: String = "ProvideAnomalyFeedbackInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ProvideAnomalyFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<ProvideAnomalyFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ProvideAnomalyFeedbackInput>
    public typealias MOutput = OperationOutput<ProvideAnomalyFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ProvideAnomalyFeedbackOutputError>
}

public struct ProvideAnomalyFeedbackInputQueryItemMiddleware: Middleware {
    public let id: String = "ProvideAnomalyFeedbackInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ProvideAnomalyFeedbackInput>,
                  next: H) -> Swift.Result<OperationOutput<ProvideAnomalyFeedbackOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ProvideAnomalyFeedbackInput>
    public typealias MOutput = OperationOutput<ProvideAnomalyFeedbackOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ProvideAnomalyFeedbackOutputError>
}

public struct ProvideAnomalyFeedbackInput: Equatable {
    /// <p>
    ///       A cost anomaly ID.
    ///     </p>
    public let anomalyId: String?
    /// <p>Describes whether the cost anomaly was a planned activity or you considered it an anomaly. </p>
    public let feedback: AnomalyFeedbackType?

    public init (
        anomalyId: String? = nil,
        feedback: AnomalyFeedbackType? = nil
    )
    {
        self.anomalyId = anomalyId
        self.feedback = feedback
    }
}

struct ProvideAnomalyFeedbackInputBody: Equatable {
    public let anomalyId: String?
    public let feedback: AnomalyFeedbackType?
}

extension ProvideAnomalyFeedbackInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyId = "AnomalyId"
        case feedback = "Feedback"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyId)
        anomalyId = anomalyIdDecoded
        let feedbackDecoded = try containerValues.decodeIfPresent(AnomalyFeedbackType.self, forKey: .feedback)
        feedback = feedbackDecoded
    }
}

extension ProvideAnomalyFeedbackOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ProvideAnomalyFeedbackOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ProvideAnomalyFeedbackOutputError: Swift.Error, Equatable {
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ProvideAnomalyFeedbackOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvideAnomalyFeedbackOutputResponse(anomalyId: \(String(describing: anomalyId)))"}
}

extension ProvideAnomalyFeedbackOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ProvideAnomalyFeedbackOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.anomalyId = output.anomalyId
        } else {
            self.anomalyId = nil
        }
    }
}

public struct ProvideAnomalyFeedbackOutputResponse: Equatable {
    /// <p>
    ///       The ID of the modified cost anomaly.
    ///     </p>
    public let anomalyId: String?

    public init (
        anomalyId: String? = nil
    )
    {
        self.anomalyId = anomalyId
    }
}

struct ProvideAnomalyFeedbackOutputResponseBody: Equatable {
    public let anomalyId: String?
}

extension ProvideAnomalyFeedbackOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case anomalyId = "AnomalyId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyId)
        anomalyId = anomalyIdDecoded
    }
}

extension RDSInstanceDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentGeneration = "CurrentGeneration"
        case databaseEdition = "DatabaseEdition"
        case databaseEngine = "DatabaseEngine"
        case deploymentOption = "DeploymentOption"
        case family = "Family"
        case instanceType = "InstanceType"
        case licenseModel = "LicenseModel"
        case region = "Region"
        case sizeFlexEligible = "SizeFlexEligible"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if currentGeneration != false {
            try encodeContainer.encode(currentGeneration, forKey: .currentGeneration)
        }
        if let databaseEdition = databaseEdition {
            try encodeContainer.encode(databaseEdition, forKey: .databaseEdition)
        }
        if let databaseEngine = databaseEngine {
            try encodeContainer.encode(databaseEngine, forKey: .databaseEngine)
        }
        if let deploymentOption = deploymentOption {
            try encodeContainer.encode(deploymentOption, forKey: .deploymentOption)
        }
        if let family = family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let licenseModel = licenseModel {
            try encodeContainer.encode(licenseModel, forKey: .licenseModel)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if sizeFlexEligible != false {
            try encodeContainer.encode(sizeFlexEligible, forKey: .sizeFlexEligible)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let familyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .family)
        family = familyDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let databaseEngineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseEngine)
        databaseEngine = databaseEngineDecoded
        let databaseEditionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .databaseEdition)
        databaseEdition = databaseEditionDecoded
        let deploymentOptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deploymentOption)
        deploymentOption = deploymentOptionDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let currentGenerationDecoded = try containerValues.decode(Bool.self, forKey: .currentGeneration)
        currentGeneration = currentGenerationDecoded
        let sizeFlexEligibleDecoded = try containerValues.decode(Bool.self, forKey: .sizeFlexEligible)
        sizeFlexEligible = sizeFlexEligibleDecoded
    }
}

extension RDSInstanceDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RDSInstanceDetails(currentGeneration: \(String(describing: currentGeneration)), databaseEdition: \(String(describing: databaseEdition)), databaseEngine: \(String(describing: databaseEngine)), deploymentOption: \(String(describing: deploymentOption)), family: \(String(describing: family)), instanceType: \(String(describing: instanceType)), licenseModel: \(String(describing: licenseModel)), region: \(String(describing: region)), sizeFlexEligible: \(String(describing: sizeFlexEligible)))"}
}

/// <p>Details about the Amazon RDS instances that AWS recommends that you
///             purchase.</p>
public struct RDSInstanceDetails: Equatable {
    /// <p>Whether the recommendation is for a current-generation instance. </p>
    public let currentGeneration: Bool
    /// <p>The database edition that the recommended reservation supports.</p>
    public let databaseEdition: String?
    /// <p>The database engine that the recommended reservation supports.</p>
    public let databaseEngine: String?
    /// <p>Whether the recommendation is for a reservation in a single Availability Zone or a
    ///             reservation with a backup in a second Availability Zone.</p>
    public let deploymentOption: String?
    /// <p>The instance family of the recommended reservation.</p>
    public let family: String?
    /// <p>The type of instance that AWS recommends.</p>
    public let instanceType: String?
    /// <p>The license model that the recommended reservation supports.</p>
    public let licenseModel: String?
    /// <p>The AWS Region of the recommended reservation.</p>
    public let region: String?
    /// <p>Whether the recommended reservation is size flexible.</p>
    public let sizeFlexEligible: Bool

    public init (
        currentGeneration: Bool = false,
        databaseEdition: String? = nil,
        databaseEngine: String? = nil,
        deploymentOption: String? = nil,
        family: String? = nil,
        instanceType: String? = nil,
        licenseModel: String? = nil,
        region: String? = nil,
        sizeFlexEligible: Bool = false
    )
    {
        self.currentGeneration = currentGeneration
        self.databaseEdition = databaseEdition
        self.databaseEngine = databaseEngine
        self.deploymentOption = deploymentOption
        self.family = family
        self.instanceType = instanceType
        self.licenseModel = licenseModel
        self.region = region
        self.sizeFlexEligible = sizeFlexEligible
    }
}

public enum RecommendationTarget {
    case crossInstanceFamily
    case sameInstanceFamily
    case sdkUnknown(String)
}

extension RecommendationTarget : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RecommendationTarget] {
        return [
            .crossInstanceFamily,
            .sameInstanceFamily,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .crossInstanceFamily: return "CROSS_INSTANCE_FAMILY"
        case .sameInstanceFamily: return "SAME_INSTANCE_FAMILY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RecommendationTarget(rawValue: rawValue) ?? RecommendationTarget.sdkUnknown(rawValue)
    }
}

extension RedshiftInstanceDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentGeneration = "CurrentGeneration"
        case family = "Family"
        case nodeType = "NodeType"
        case region = "Region"
        case sizeFlexEligible = "SizeFlexEligible"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if currentGeneration != false {
            try encodeContainer.encode(currentGeneration, forKey: .currentGeneration)
        }
        if let family = family {
            try encodeContainer.encode(family, forKey: .family)
        }
        if let nodeType = nodeType {
            try encodeContainer.encode(nodeType, forKey: .nodeType)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if sizeFlexEligible != false {
            try encodeContainer.encode(sizeFlexEligible, forKey: .sizeFlexEligible)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let familyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .family)
        family = familyDecoded
        let nodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeType)
        nodeType = nodeTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let currentGenerationDecoded = try containerValues.decode(Bool.self, forKey: .currentGeneration)
        currentGeneration = currentGenerationDecoded
        let sizeFlexEligibleDecoded = try containerValues.decode(Bool.self, forKey: .sizeFlexEligible)
        sizeFlexEligible = sizeFlexEligibleDecoded
    }
}

extension RedshiftInstanceDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RedshiftInstanceDetails(currentGeneration: \(String(describing: currentGeneration)), family: \(String(describing: family)), nodeType: \(String(describing: nodeType)), region: \(String(describing: region)), sizeFlexEligible: \(String(describing: sizeFlexEligible)))"}
}

/// <p>Details about the Amazon Redshift instances that AWS recommends that you
///             purchase.</p>
public struct RedshiftInstanceDetails: Equatable {
    /// <p>Whether the recommendation is for a current-generation instance.</p>
    public let currentGeneration: Bool
    /// <p>The instance family of the recommended reservation.</p>
    public let family: String?
    /// <p>The type of node that AWS recommends.</p>
    public let nodeType: String?
    /// <p>The AWS Region of the recommended reservation.</p>
    public let region: String?
    /// <p>Whether the recommended reservation is size flexible.</p>
    public let sizeFlexEligible: Bool

    public init (
        currentGeneration: Bool = false,
        family: String? = nil,
        nodeType: String? = nil,
        region: String? = nil,
        sizeFlexEligible: Bool = false
    )
    {
        self.currentGeneration = currentGeneration
        self.family = family
        self.nodeType = nodeType
        self.region = region
        self.sizeFlexEligible = sizeFlexEligible
    }
}

extension RequestChangedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestChangedException(message: \(String(describing: message)))"}
}

extension RequestChangedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RequestChangedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Your request parameters changed between pages. Try again with the old parameters or
///             without a pagination token.</p>
public struct RequestChangedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RequestChangedExceptionBody: Equatable {
    public let message: String?
}

extension RequestChangedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReservationAggregates: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amortizedRecurringFee = "AmortizedRecurringFee"
        case amortizedUpfrontFee = "AmortizedUpfrontFee"
        case netRISavings = "NetRISavings"
        case onDemandCostOfRIHoursUsed = "OnDemandCostOfRIHoursUsed"
        case purchasedHours = "PurchasedHours"
        case purchasedUnits = "PurchasedUnits"
        case rICostForUnusedHours = "RICostForUnusedHours"
        case realizedSavings = "RealizedSavings"
        case totalActualHours = "TotalActualHours"
        case totalActualUnits = "TotalActualUnits"
        case totalAmortizedFee = "TotalAmortizedFee"
        case totalPotentialRISavings = "TotalPotentialRISavings"
        case unrealizedSavings = "UnrealizedSavings"
        case unusedHours = "UnusedHours"
        case unusedUnits = "UnusedUnits"
        case utilizationPercentage = "UtilizationPercentage"
        case utilizationPercentageInUnits = "UtilizationPercentageInUnits"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amortizedRecurringFee = amortizedRecurringFee {
            try encodeContainer.encode(amortizedRecurringFee, forKey: .amortizedRecurringFee)
        }
        if let amortizedUpfrontFee = amortizedUpfrontFee {
            try encodeContainer.encode(amortizedUpfrontFee, forKey: .amortizedUpfrontFee)
        }
        if let netRISavings = netRISavings {
            try encodeContainer.encode(netRISavings, forKey: .netRISavings)
        }
        if let onDemandCostOfRIHoursUsed = onDemandCostOfRIHoursUsed {
            try encodeContainer.encode(onDemandCostOfRIHoursUsed, forKey: .onDemandCostOfRIHoursUsed)
        }
        if let purchasedHours = purchasedHours {
            try encodeContainer.encode(purchasedHours, forKey: .purchasedHours)
        }
        if let purchasedUnits = purchasedUnits {
            try encodeContainer.encode(purchasedUnits, forKey: .purchasedUnits)
        }
        if let rICostForUnusedHours = rICostForUnusedHours {
            try encodeContainer.encode(rICostForUnusedHours, forKey: .rICostForUnusedHours)
        }
        if let realizedSavings = realizedSavings {
            try encodeContainer.encode(realizedSavings, forKey: .realizedSavings)
        }
        if let totalActualHours = totalActualHours {
            try encodeContainer.encode(totalActualHours, forKey: .totalActualHours)
        }
        if let totalActualUnits = totalActualUnits {
            try encodeContainer.encode(totalActualUnits, forKey: .totalActualUnits)
        }
        if let totalAmortizedFee = totalAmortizedFee {
            try encodeContainer.encode(totalAmortizedFee, forKey: .totalAmortizedFee)
        }
        if let totalPotentialRISavings = totalPotentialRISavings {
            try encodeContainer.encode(totalPotentialRISavings, forKey: .totalPotentialRISavings)
        }
        if let unrealizedSavings = unrealizedSavings {
            try encodeContainer.encode(unrealizedSavings, forKey: .unrealizedSavings)
        }
        if let unusedHours = unusedHours {
            try encodeContainer.encode(unusedHours, forKey: .unusedHours)
        }
        if let unusedUnits = unusedUnits {
            try encodeContainer.encode(unusedUnits, forKey: .unusedUnits)
        }
        if let utilizationPercentage = utilizationPercentage {
            try encodeContainer.encode(utilizationPercentage, forKey: .utilizationPercentage)
        }
        if let utilizationPercentageInUnits = utilizationPercentageInUnits {
            try encodeContainer.encode(utilizationPercentageInUnits, forKey: .utilizationPercentageInUnits)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let utilizationPercentageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .utilizationPercentage)
        utilizationPercentage = utilizationPercentageDecoded
        let utilizationPercentageInUnitsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .utilizationPercentageInUnits)
        utilizationPercentageInUnits = utilizationPercentageInUnitsDecoded
        let purchasedHoursDecoded = try containerValues.decodeIfPresent(String.self, forKey: .purchasedHours)
        purchasedHours = purchasedHoursDecoded
        let purchasedUnitsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .purchasedUnits)
        purchasedUnits = purchasedUnitsDecoded
        let totalActualHoursDecoded = try containerValues.decodeIfPresent(String.self, forKey: .totalActualHours)
        totalActualHours = totalActualHoursDecoded
        let totalActualUnitsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .totalActualUnits)
        totalActualUnits = totalActualUnitsDecoded
        let unusedHoursDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unusedHours)
        unusedHours = unusedHoursDecoded
        let unusedUnitsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unusedUnits)
        unusedUnits = unusedUnitsDecoded
        let onDemandCostOfRIHoursUsedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .onDemandCostOfRIHoursUsed)
        onDemandCostOfRIHoursUsed = onDemandCostOfRIHoursUsedDecoded
        let netRISavingsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .netRISavings)
        netRISavings = netRISavingsDecoded
        let totalPotentialRISavingsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .totalPotentialRISavings)
        totalPotentialRISavings = totalPotentialRISavingsDecoded
        let amortizedUpfrontFeeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amortizedUpfrontFee)
        amortizedUpfrontFee = amortizedUpfrontFeeDecoded
        let amortizedRecurringFeeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amortizedRecurringFee)
        amortizedRecurringFee = amortizedRecurringFeeDecoded
        let totalAmortizedFeeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .totalAmortizedFee)
        totalAmortizedFee = totalAmortizedFeeDecoded
        let rICostForUnusedHoursDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rICostForUnusedHours)
        rICostForUnusedHours = rICostForUnusedHoursDecoded
        let realizedSavingsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .realizedSavings)
        realizedSavings = realizedSavingsDecoded
        let unrealizedSavingsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unrealizedSavings)
        unrealizedSavings = unrealizedSavingsDecoded
    }
}

extension ReservationAggregates: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReservationAggregates(amortizedRecurringFee: \(String(describing: amortizedRecurringFee)), amortizedUpfrontFee: \(String(describing: amortizedUpfrontFee)), netRISavings: \(String(describing: netRISavings)), onDemandCostOfRIHoursUsed: \(String(describing: onDemandCostOfRIHoursUsed)), purchasedHours: \(String(describing: purchasedHours)), purchasedUnits: \(String(describing: purchasedUnits)), rICostForUnusedHours: \(String(describing: rICostForUnusedHours)), realizedSavings: \(String(describing: realizedSavings)), totalActualHours: \(String(describing: totalActualHours)), totalActualUnits: \(String(describing: totalActualUnits)), totalAmortizedFee: \(String(describing: totalAmortizedFee)), totalPotentialRISavings: \(String(describing: totalPotentialRISavings)), unrealizedSavings: \(String(describing: unrealizedSavings)), unusedHours: \(String(describing: unusedHours)), unusedUnits: \(String(describing: unusedUnits)), utilizationPercentage: \(String(describing: utilizationPercentage)), utilizationPercentageInUnits: \(String(describing: utilizationPercentageInUnits)))"}
}

/// <p>The aggregated numbers for your reservation usage.</p>
public struct ReservationAggregates: Equatable {
    /// <p>The monthly cost of your reservation, amortized over the reservation
    ///             period.</p>
    public let amortizedRecurringFee: String?
    /// <p>The upfront cost of your reservation, amortized over the reservation
    ///             period.</p>
    public let amortizedUpfrontFee: String?
    /// <p>How much you saved due to purchasing and utilizing reservation. AWS calculates this
    ///             by subtracting <code>TotalAmortizedFee</code> from
    ///                 <code>OnDemandCostOfRIHoursUsed</code>.</p>
    public let netRISavings: String?
    /// <p>How much your reservation would cost if charged On-Demand rates.</p>
    public let onDemandCostOfRIHoursUsed: String?
    /// <p>How many reservation hours that you purchased.</p>
    public let purchasedHours: String?
    /// <p>How many Amazon EC2 reservation hours that you purchased, converted to normalized units.
    ///             Normalized units are available only for Amazon EC2 usage after November 11, 2017.</p>
    public let purchasedUnits: String?
    /// <p>The cost of unused hours for your reservation.</p>
    public let rICostForUnusedHours: String?
    /// <p>The realized savings due to purchasing and using a reservation.</p>
    public let realizedSavings: String?
    /// <p>The total number of reservation hours that you used.</p>
    public let totalActualHours: String?
    /// <p>The total number of Amazon EC2 reservation hours that you used, converted to normalized
    ///             units. Normalized units are available only for Amazon EC2 usage after November 11,
    ///             2017.</p>
    public let totalActualUnits: String?
    /// <p>The total cost of your reservation, amortized over the reservation
    ///             period.</p>
    public let totalAmortizedFee: String?
    /// <p>How much you could save if you use your entire reservation.</p>
    public let totalPotentialRISavings: String?
    /// <p>The unrealized savings due to purchasing and using a reservation.</p>
    public let unrealizedSavings: String?
    /// <p>The number of reservation hours that you didn't use.</p>
    public let unusedHours: String?
    /// <p>The number of Amazon EC2 reservation hours that you didn't use, converted to normalized
    ///             units. Normalized units are available only for Amazon EC2 usage after November 11,
    ///             2017.</p>
    public let unusedUnits: String?
    /// <p>The percentage of reservation time that you used.</p>
    public let utilizationPercentage: String?
    /// <p>The percentage of Amazon EC2 reservation time that you used, converted to normalized
    ///             units. Normalized units are available only for Amazon EC2 usage after November 11,
    ///             2017.</p>
    public let utilizationPercentageInUnits: String?

    public init (
        amortizedRecurringFee: String? = nil,
        amortizedUpfrontFee: String? = nil,
        netRISavings: String? = nil,
        onDemandCostOfRIHoursUsed: String? = nil,
        purchasedHours: String? = nil,
        purchasedUnits: String? = nil,
        rICostForUnusedHours: String? = nil,
        realizedSavings: String? = nil,
        totalActualHours: String? = nil,
        totalActualUnits: String? = nil,
        totalAmortizedFee: String? = nil,
        totalPotentialRISavings: String? = nil,
        unrealizedSavings: String? = nil,
        unusedHours: String? = nil,
        unusedUnits: String? = nil,
        utilizationPercentage: String? = nil,
        utilizationPercentageInUnits: String? = nil
    )
    {
        self.amortizedRecurringFee = amortizedRecurringFee
        self.amortizedUpfrontFee = amortizedUpfrontFee
        self.netRISavings = netRISavings
        self.onDemandCostOfRIHoursUsed = onDemandCostOfRIHoursUsed
        self.purchasedHours = purchasedHours
        self.purchasedUnits = purchasedUnits
        self.rICostForUnusedHours = rICostForUnusedHours
        self.realizedSavings = realizedSavings
        self.totalActualHours = totalActualHours
        self.totalActualUnits = totalActualUnits
        self.totalAmortizedFee = totalAmortizedFee
        self.totalPotentialRISavings = totalPotentialRISavings
        self.unrealizedSavings = unrealizedSavings
        self.unusedHours = unusedHours
        self.unusedUnits = unusedUnits
        self.utilizationPercentage = utilizationPercentage
        self.utilizationPercentageInUnits = utilizationPercentageInUnits
    }
}

extension ReservationCoverageGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case coverage = "Coverage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let coverage = coverage {
            try encodeContainer.encode(coverage, forKey: .coverage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let coverageDecoded = try containerValues.decodeIfPresent(Coverage.self, forKey: .coverage)
        coverage = coverageDecoded
    }
}

extension ReservationCoverageGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReservationCoverageGroup(attributes: \(String(describing: attributes)), coverage: \(String(describing: coverage)))"}
}

/// <p>A
///             group of reservations that share a set of attributes.</p>
public struct ReservationCoverageGroup: Equatable {
    /// <p>The attributes for this group of reservations.</p>
    public let attributes: [String:String]?
    /// <p>How much instance usage this group of reservations covered.</p>
    public let coverage: Coverage?

    public init (
        attributes: [String:String]? = nil,
        coverage: Coverage? = nil
    )
    {
        self.attributes = attributes
        self.coverage = coverage
    }
}

extension ReservationPurchaseRecommendation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountScope = "AccountScope"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case paymentOption = "PaymentOption"
        case recommendationDetails = "RecommendationDetails"
        case recommendationSummary = "RecommendationSummary"
        case serviceSpecification = "ServiceSpecification"
        case termInYears = "TermInYears"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountScope = accountScope {
            try encodeContainer.encode(accountScope.rawValue, forKey: .accountScope)
        }
        if let lookbackPeriodInDays = lookbackPeriodInDays {
            try encodeContainer.encode(lookbackPeriodInDays.rawValue, forKey: .lookbackPeriodInDays)
        }
        if let paymentOption = paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let recommendationDetails = recommendationDetails {
            var recommendationDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationDetails)
            for reservationpurchaserecommendationdetails0 in recommendationDetails {
                try recommendationDetailsContainer.encode(reservationpurchaserecommendationdetails0)
            }
        }
        if let recommendationSummary = recommendationSummary {
            try encodeContainer.encode(recommendationSummary, forKey: .recommendationSummary)
        }
        if let serviceSpecification = serviceSpecification {
            try encodeContainer.encode(serviceSpecification, forKey: .serviceSpecification)
        }
        if let termInYears = termInYears {
            try encodeContainer.encode(termInYears.rawValue, forKey: .termInYears)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountScopeDecoded = try containerValues.decodeIfPresent(AccountScope.self, forKey: .accountScope)
        accountScope = accountScopeDecoded
        let lookbackPeriodInDaysDecoded = try containerValues.decodeIfPresent(LookbackPeriodInDays.self, forKey: .lookbackPeriodInDays)
        lookbackPeriodInDays = lookbackPeriodInDaysDecoded
        let termInYearsDecoded = try containerValues.decodeIfPresent(TermInYears.self, forKey: .termInYears)
        termInYears = termInYearsDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(PaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let serviceSpecificationDecoded = try containerValues.decodeIfPresent(ServiceSpecification.self, forKey: .serviceSpecification)
        serviceSpecification = serviceSpecificationDecoded
        let recommendationDetailsContainer = try containerValues.decodeIfPresent([ReservationPurchaseRecommendationDetail?].self, forKey: .recommendationDetails)
        var recommendationDetailsDecoded0:[ReservationPurchaseRecommendationDetail]? = nil
        if let recommendationDetailsContainer = recommendationDetailsContainer {
            recommendationDetailsDecoded0 = [ReservationPurchaseRecommendationDetail]()
            for structure0 in recommendationDetailsContainer {
                if let structure0 = structure0 {
                    recommendationDetailsDecoded0?.append(structure0)
                }
            }
        }
        recommendationDetails = recommendationDetailsDecoded0
        let recommendationSummaryDecoded = try containerValues.decodeIfPresent(ReservationPurchaseRecommendationSummary.self, forKey: .recommendationSummary)
        recommendationSummary = recommendationSummaryDecoded
    }
}

extension ReservationPurchaseRecommendation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReservationPurchaseRecommendation(accountScope: \(String(describing: accountScope)), lookbackPeriodInDays: \(String(describing: lookbackPeriodInDays)), paymentOption: \(String(describing: paymentOption)), recommendationDetails: \(String(describing: recommendationDetails)), recommendationSummary: \(String(describing: recommendationSummary)), serviceSpecification: \(String(describing: serviceSpecification)), termInYears: \(String(describing: termInYears)))"}
}

/// <p>A specific reservation that AWS recommends for purchase.</p>
public struct ReservationPurchaseRecommendation: Equatable {
    /// <p>The account scope that AWS recommends that you purchase this instance for. For
    ///             example, you can purchase this reservation for an entire organization in AWS
    ///             Organizations.</p>
    public let accountScope: AccountScope?
    /// <p>How many days of previous usage that AWS considers when making this
    ///             recommendation.</p>
    public let lookbackPeriodInDays: LookbackPeriodInDays?
    /// <p>The payment option for the reservation. For example, <code>AllUpfront</code> or
    ///                 <code>NoUpfront</code>.</p>
    public let paymentOption: PaymentOption?
    /// <p>Details about the recommended purchases.</p>
    public let recommendationDetails: [ReservationPurchaseRecommendationDetail]?
    /// <p>A summary about the recommended purchase.</p>
    public let recommendationSummary: ReservationPurchaseRecommendationSummary?
    /// <p>Hardware specifications for the service that you want recommendations
    ///             for.</p>
    public let serviceSpecification: ServiceSpecification?
    /// <p>The term of the reservation that you want recommendations for, in years.</p>
    public let termInYears: TermInYears?

    public init (
        accountScope: AccountScope? = nil,
        lookbackPeriodInDays: LookbackPeriodInDays? = nil,
        paymentOption: PaymentOption? = nil,
        recommendationDetails: [ReservationPurchaseRecommendationDetail]? = nil,
        recommendationSummary: ReservationPurchaseRecommendationSummary? = nil,
        serviceSpecification: ServiceSpecification? = nil,
        termInYears: TermInYears? = nil
    )
    {
        self.accountScope = accountScope
        self.lookbackPeriodInDays = lookbackPeriodInDays
        self.paymentOption = paymentOption
        self.recommendationDetails = recommendationDetails
        self.recommendationSummary = recommendationSummary
        self.serviceSpecification = serviceSpecification
        self.termInYears = termInYears
    }
}

extension ReservationPurchaseRecommendationDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case averageNormalizedUnitsUsedPerHour = "AverageNormalizedUnitsUsedPerHour"
        case averageNumberOfInstancesUsedPerHour = "AverageNumberOfInstancesUsedPerHour"
        case averageUtilization = "AverageUtilization"
        case currencyCode = "CurrencyCode"
        case estimatedBreakEvenInMonths = "EstimatedBreakEvenInMonths"
        case estimatedMonthlyOnDemandCost = "EstimatedMonthlyOnDemandCost"
        case estimatedMonthlySavingsAmount = "EstimatedMonthlySavingsAmount"
        case estimatedMonthlySavingsPercentage = "EstimatedMonthlySavingsPercentage"
        case estimatedReservationCostForLookbackPeriod = "EstimatedReservationCostForLookbackPeriod"
        case instanceDetails = "InstanceDetails"
        case maximumNormalizedUnitsUsedPerHour = "MaximumNormalizedUnitsUsedPerHour"
        case maximumNumberOfInstancesUsedPerHour = "MaximumNumberOfInstancesUsedPerHour"
        case minimumNormalizedUnitsUsedPerHour = "MinimumNormalizedUnitsUsedPerHour"
        case minimumNumberOfInstancesUsedPerHour = "MinimumNumberOfInstancesUsedPerHour"
        case recommendedNormalizedUnitsToPurchase = "RecommendedNormalizedUnitsToPurchase"
        case recommendedNumberOfInstancesToPurchase = "RecommendedNumberOfInstancesToPurchase"
        case recurringStandardMonthlyCost = "RecurringStandardMonthlyCost"
        case upfrontCost = "UpfrontCost"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let averageNormalizedUnitsUsedPerHour = averageNormalizedUnitsUsedPerHour {
            try encodeContainer.encode(averageNormalizedUnitsUsedPerHour, forKey: .averageNormalizedUnitsUsedPerHour)
        }
        if let averageNumberOfInstancesUsedPerHour = averageNumberOfInstancesUsedPerHour {
            try encodeContainer.encode(averageNumberOfInstancesUsedPerHour, forKey: .averageNumberOfInstancesUsedPerHour)
        }
        if let averageUtilization = averageUtilization {
            try encodeContainer.encode(averageUtilization, forKey: .averageUtilization)
        }
        if let currencyCode = currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let estimatedBreakEvenInMonths = estimatedBreakEvenInMonths {
            try encodeContainer.encode(estimatedBreakEvenInMonths, forKey: .estimatedBreakEvenInMonths)
        }
        if let estimatedMonthlyOnDemandCost = estimatedMonthlyOnDemandCost {
            try encodeContainer.encode(estimatedMonthlyOnDemandCost, forKey: .estimatedMonthlyOnDemandCost)
        }
        if let estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount {
            try encodeContainer.encode(estimatedMonthlySavingsAmount, forKey: .estimatedMonthlySavingsAmount)
        }
        if let estimatedMonthlySavingsPercentage = estimatedMonthlySavingsPercentage {
            try encodeContainer.encode(estimatedMonthlySavingsPercentage, forKey: .estimatedMonthlySavingsPercentage)
        }
        if let estimatedReservationCostForLookbackPeriod = estimatedReservationCostForLookbackPeriod {
            try encodeContainer.encode(estimatedReservationCostForLookbackPeriod, forKey: .estimatedReservationCostForLookbackPeriod)
        }
        if let instanceDetails = instanceDetails {
            try encodeContainer.encode(instanceDetails, forKey: .instanceDetails)
        }
        if let maximumNormalizedUnitsUsedPerHour = maximumNormalizedUnitsUsedPerHour {
            try encodeContainer.encode(maximumNormalizedUnitsUsedPerHour, forKey: .maximumNormalizedUnitsUsedPerHour)
        }
        if let maximumNumberOfInstancesUsedPerHour = maximumNumberOfInstancesUsedPerHour {
            try encodeContainer.encode(maximumNumberOfInstancesUsedPerHour, forKey: .maximumNumberOfInstancesUsedPerHour)
        }
        if let minimumNormalizedUnitsUsedPerHour = minimumNormalizedUnitsUsedPerHour {
            try encodeContainer.encode(minimumNormalizedUnitsUsedPerHour, forKey: .minimumNormalizedUnitsUsedPerHour)
        }
        if let minimumNumberOfInstancesUsedPerHour = minimumNumberOfInstancesUsedPerHour {
            try encodeContainer.encode(minimumNumberOfInstancesUsedPerHour, forKey: .minimumNumberOfInstancesUsedPerHour)
        }
        if let recommendedNormalizedUnitsToPurchase = recommendedNormalizedUnitsToPurchase {
            try encodeContainer.encode(recommendedNormalizedUnitsToPurchase, forKey: .recommendedNormalizedUnitsToPurchase)
        }
        if let recommendedNumberOfInstancesToPurchase = recommendedNumberOfInstancesToPurchase {
            try encodeContainer.encode(recommendedNumberOfInstancesToPurchase, forKey: .recommendedNumberOfInstancesToPurchase)
        }
        if let recurringStandardMonthlyCost = recurringStandardMonthlyCost {
            try encodeContainer.encode(recurringStandardMonthlyCost, forKey: .recurringStandardMonthlyCost)
        }
        if let upfrontCost = upfrontCost {
            try encodeContainer.encode(upfrontCost, forKey: .upfrontCost)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let instanceDetailsDecoded = try containerValues.decodeIfPresent(InstanceDetails.self, forKey: .instanceDetails)
        instanceDetails = instanceDetailsDecoded
        let recommendedNumberOfInstancesToPurchaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendedNumberOfInstancesToPurchase)
        recommendedNumberOfInstancesToPurchase = recommendedNumberOfInstancesToPurchaseDecoded
        let recommendedNormalizedUnitsToPurchaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendedNormalizedUnitsToPurchase)
        recommendedNormalizedUnitsToPurchase = recommendedNormalizedUnitsToPurchaseDecoded
        let minimumNumberOfInstancesUsedPerHourDecoded = try containerValues.decodeIfPresent(String.self, forKey: .minimumNumberOfInstancesUsedPerHour)
        minimumNumberOfInstancesUsedPerHour = minimumNumberOfInstancesUsedPerHourDecoded
        let minimumNormalizedUnitsUsedPerHourDecoded = try containerValues.decodeIfPresent(String.self, forKey: .minimumNormalizedUnitsUsedPerHour)
        minimumNormalizedUnitsUsedPerHour = minimumNormalizedUnitsUsedPerHourDecoded
        let maximumNumberOfInstancesUsedPerHourDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maximumNumberOfInstancesUsedPerHour)
        maximumNumberOfInstancesUsedPerHour = maximumNumberOfInstancesUsedPerHourDecoded
        let maximumNormalizedUnitsUsedPerHourDecoded = try containerValues.decodeIfPresent(String.self, forKey: .maximumNormalizedUnitsUsedPerHour)
        maximumNormalizedUnitsUsedPerHour = maximumNormalizedUnitsUsedPerHourDecoded
        let averageNumberOfInstancesUsedPerHourDecoded = try containerValues.decodeIfPresent(String.self, forKey: .averageNumberOfInstancesUsedPerHour)
        averageNumberOfInstancesUsedPerHour = averageNumberOfInstancesUsedPerHourDecoded
        let averageNormalizedUnitsUsedPerHourDecoded = try containerValues.decodeIfPresent(String.self, forKey: .averageNormalizedUnitsUsedPerHour)
        averageNormalizedUnitsUsedPerHour = averageNormalizedUnitsUsedPerHourDecoded
        let averageUtilizationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .averageUtilization)
        averageUtilization = averageUtilizationDecoded
        let estimatedBreakEvenInMonthsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedBreakEvenInMonths)
        estimatedBreakEvenInMonths = estimatedBreakEvenInMonthsDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let estimatedMonthlySavingsAmountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedMonthlySavingsAmount)
        estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmountDecoded
        let estimatedMonthlySavingsPercentageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedMonthlySavingsPercentage)
        estimatedMonthlySavingsPercentage = estimatedMonthlySavingsPercentageDecoded
        let estimatedMonthlyOnDemandCostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedMonthlyOnDemandCost)
        estimatedMonthlyOnDemandCost = estimatedMonthlyOnDemandCostDecoded
        let estimatedReservationCostForLookbackPeriodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedReservationCostForLookbackPeriod)
        estimatedReservationCostForLookbackPeriod = estimatedReservationCostForLookbackPeriodDecoded
        let upfrontCostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .upfrontCost)
        upfrontCost = upfrontCostDecoded
        let recurringStandardMonthlyCostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recurringStandardMonthlyCost)
        recurringStandardMonthlyCost = recurringStandardMonthlyCostDecoded
    }
}

extension ReservationPurchaseRecommendationDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReservationPurchaseRecommendationDetail(accountId: \(String(describing: accountId)), averageNormalizedUnitsUsedPerHour: \(String(describing: averageNormalizedUnitsUsedPerHour)), averageNumberOfInstancesUsedPerHour: \(String(describing: averageNumberOfInstancesUsedPerHour)), averageUtilization: \(String(describing: averageUtilization)), currencyCode: \(String(describing: currencyCode)), estimatedBreakEvenInMonths: \(String(describing: estimatedBreakEvenInMonths)), estimatedMonthlyOnDemandCost: \(String(describing: estimatedMonthlyOnDemandCost)), estimatedMonthlySavingsAmount: \(String(describing: estimatedMonthlySavingsAmount)), estimatedMonthlySavingsPercentage: \(String(describing: estimatedMonthlySavingsPercentage)), estimatedReservationCostForLookbackPeriod: \(String(describing: estimatedReservationCostForLookbackPeriod)), instanceDetails: \(String(describing: instanceDetails)), maximumNormalizedUnitsUsedPerHour: \(String(describing: maximumNormalizedUnitsUsedPerHour)), maximumNumberOfInstancesUsedPerHour: \(String(describing: maximumNumberOfInstancesUsedPerHour)), minimumNormalizedUnitsUsedPerHour: \(String(describing: minimumNormalizedUnitsUsedPerHour)), minimumNumberOfInstancesUsedPerHour: \(String(describing: minimumNumberOfInstancesUsedPerHour)), recommendedNormalizedUnitsToPurchase: \(String(describing: recommendedNormalizedUnitsToPurchase)), recommendedNumberOfInstancesToPurchase: \(String(describing: recommendedNumberOfInstancesToPurchase)), recurringStandardMonthlyCost: \(String(describing: recurringStandardMonthlyCost)), upfrontCost: \(String(describing: upfrontCost)))"}
}

/// <p>Details about your recommended reservation purchase.</p>
public struct ReservationPurchaseRecommendationDetail: Equatable {
    /// <p>The account that this RI recommendation is for.</p>
    public let accountId: String?
    /// <p>The average number of normalized units that you used in an hour during the
    ///             historical period. AWS uses this to calculate your recommended reservation
    ///             purchases.</p>
    public let averageNormalizedUnitsUsedPerHour: String?
    /// <p>The average number of instances that you used in an hour during the historical
    ///             period. AWS uses this to calculate your recommended reservation purchases.</p>
    public let averageNumberOfInstancesUsedPerHour: String?
    /// <p>The average utilization of your instances. AWS uses this to calculate your
    ///             recommended reservation purchases.</p>
    public let averageUtilization: String?
    /// <p>The currency code that AWS used to calculate the costs for this instance.</p>
    public let currencyCode: String?
    /// <p>How long AWS estimates that it takes for this instance to start saving you money,
    ///             in months.</p>
    public let estimatedBreakEvenInMonths: String?
    /// <p>How much AWS estimates that you spend on On-Demand Instances in a month.</p>
    public let estimatedMonthlyOnDemandCost: String?
    /// <p>How much AWS estimates that this specific recommendation could save you in a
    ///             month.</p>
    public let estimatedMonthlySavingsAmount: String?
    /// <p>How much AWS estimates that this specific recommendation could save you in a month,
    ///             as a percentage of your overall costs.</p>
    public let estimatedMonthlySavingsPercentage: String?
    /// <p>How much AWS estimates that you would have spent for all usage during the specified
    ///             historical period if you had
    ///             a
    ///             reservation.</p>
    public let estimatedReservationCostForLookbackPeriod: String?
    /// <p>Details about the instances that AWS recommends that you purchase.</p>
    public let instanceDetails: InstanceDetails?
    /// <p>The maximum number of normalized units that you used in an hour during the
    ///             historical period. AWS uses this to calculate your recommended reservation
    ///             purchases.</p>
    public let maximumNormalizedUnitsUsedPerHour: String?
    /// <p>The maximum number of instances that you used in an hour during the historical
    ///             period. AWS uses this to calculate your recommended reservation purchases.</p>
    public let maximumNumberOfInstancesUsedPerHour: String?
    /// <p>The minimum number of normalized units that you used in an hour during the
    ///             historical period. AWS uses this to calculate your recommended reservation
    ///             purchases.</p>
    public let minimumNormalizedUnitsUsedPerHour: String?
    /// <p>The minimum number of instances that you used in an hour during the historical
    ///             period. AWS uses this to calculate your recommended reservation purchases.</p>
    public let minimumNumberOfInstancesUsedPerHour: String?
    /// <p>The number of normalized units that AWS recommends that you purchase.</p>
    public let recommendedNormalizedUnitsToPurchase: String?
    /// <p>The number of instances that AWS recommends that you purchase.</p>
    public let recommendedNumberOfInstancesToPurchase: String?
    /// <p>How much purchasing this instance costs you on a monthly basis.</p>
    public let recurringStandardMonthlyCost: String?
    /// <p>How much purchasing this instance costs you upfront.</p>
    public let upfrontCost: String?

    public init (
        accountId: String? = nil,
        averageNormalizedUnitsUsedPerHour: String? = nil,
        averageNumberOfInstancesUsedPerHour: String? = nil,
        averageUtilization: String? = nil,
        currencyCode: String? = nil,
        estimatedBreakEvenInMonths: String? = nil,
        estimatedMonthlyOnDemandCost: String? = nil,
        estimatedMonthlySavingsAmount: String? = nil,
        estimatedMonthlySavingsPercentage: String? = nil,
        estimatedReservationCostForLookbackPeriod: String? = nil,
        instanceDetails: InstanceDetails? = nil,
        maximumNormalizedUnitsUsedPerHour: String? = nil,
        maximumNumberOfInstancesUsedPerHour: String? = nil,
        minimumNormalizedUnitsUsedPerHour: String? = nil,
        minimumNumberOfInstancesUsedPerHour: String? = nil,
        recommendedNormalizedUnitsToPurchase: String? = nil,
        recommendedNumberOfInstancesToPurchase: String? = nil,
        recurringStandardMonthlyCost: String? = nil,
        upfrontCost: String? = nil
    )
    {
        self.accountId = accountId
        self.averageNormalizedUnitsUsedPerHour = averageNormalizedUnitsUsedPerHour
        self.averageNumberOfInstancesUsedPerHour = averageNumberOfInstancesUsedPerHour
        self.averageUtilization = averageUtilization
        self.currencyCode = currencyCode
        self.estimatedBreakEvenInMonths = estimatedBreakEvenInMonths
        self.estimatedMonthlyOnDemandCost = estimatedMonthlyOnDemandCost
        self.estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount
        self.estimatedMonthlySavingsPercentage = estimatedMonthlySavingsPercentage
        self.estimatedReservationCostForLookbackPeriod = estimatedReservationCostForLookbackPeriod
        self.instanceDetails = instanceDetails
        self.maximumNormalizedUnitsUsedPerHour = maximumNormalizedUnitsUsedPerHour
        self.maximumNumberOfInstancesUsedPerHour = maximumNumberOfInstancesUsedPerHour
        self.minimumNormalizedUnitsUsedPerHour = minimumNormalizedUnitsUsedPerHour
        self.minimumNumberOfInstancesUsedPerHour = minimumNumberOfInstancesUsedPerHour
        self.recommendedNormalizedUnitsToPurchase = recommendedNormalizedUnitsToPurchase
        self.recommendedNumberOfInstancesToPurchase = recommendedNumberOfInstancesToPurchase
        self.recurringStandardMonthlyCost = recurringStandardMonthlyCost
        self.upfrontCost = upfrontCost
    }
}

extension ReservationPurchaseRecommendationMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case generationTimestamp = "GenerationTimestamp"
        case recommendationId = "RecommendationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generationTimestamp = generationTimestamp {
            try encodeContainer.encode(generationTimestamp, forKey: .generationTimestamp)
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let generationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .generationTimestamp)
        generationTimestamp = generationTimestampDecoded
    }
}

extension ReservationPurchaseRecommendationMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReservationPurchaseRecommendationMetadata(generationTimestamp: \(String(describing: generationTimestamp)), recommendationId: \(String(describing: recommendationId)))"}
}

/// <p>Information about this specific recommendation, such as the timestamp for when AWS
///             made a specific recommendation.</p>
public struct ReservationPurchaseRecommendationMetadata: Equatable {
    /// <p>The timestamp for when AWS made this recommendation.</p>
    public let generationTimestamp: String?
    /// <p>The ID for this specific recommendation.</p>
    public let recommendationId: String?

    public init (
        generationTimestamp: String? = nil,
        recommendationId: String? = nil
    )
    {
        self.generationTimestamp = generationTimestamp
        self.recommendationId = recommendationId
    }
}

extension ReservationPurchaseRecommendationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currencyCode = "CurrencyCode"
        case totalEstimatedMonthlySavingsAmount = "TotalEstimatedMonthlySavingsAmount"
        case totalEstimatedMonthlySavingsPercentage = "TotalEstimatedMonthlySavingsPercentage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let totalEstimatedMonthlySavingsAmount = totalEstimatedMonthlySavingsAmount {
            try encodeContainer.encode(totalEstimatedMonthlySavingsAmount, forKey: .totalEstimatedMonthlySavingsAmount)
        }
        if let totalEstimatedMonthlySavingsPercentage = totalEstimatedMonthlySavingsPercentage {
            try encodeContainer.encode(totalEstimatedMonthlySavingsPercentage, forKey: .totalEstimatedMonthlySavingsPercentage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalEstimatedMonthlySavingsAmountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .totalEstimatedMonthlySavingsAmount)
        totalEstimatedMonthlySavingsAmount = totalEstimatedMonthlySavingsAmountDecoded
        let totalEstimatedMonthlySavingsPercentageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .totalEstimatedMonthlySavingsPercentage)
        totalEstimatedMonthlySavingsPercentage = totalEstimatedMonthlySavingsPercentageDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
    }
}

extension ReservationPurchaseRecommendationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReservationPurchaseRecommendationSummary(currencyCode: \(String(describing: currencyCode)), totalEstimatedMonthlySavingsAmount: \(String(describing: totalEstimatedMonthlySavingsAmount)), totalEstimatedMonthlySavingsPercentage: \(String(describing: totalEstimatedMonthlySavingsPercentage)))"}
}

/// <p>A summary about this recommendation, such as the currency code, the amount that AWS
///             estimates that you could save, and the total amount of reservation to
///             purchase.</p>
public struct ReservationPurchaseRecommendationSummary: Equatable {
    /// <p>The currency code used for this recommendation.</p>
    public let currencyCode: String?
    /// <p>The total amount that AWS estimates that this recommendation could save you in a
    ///             month.</p>
    public let totalEstimatedMonthlySavingsAmount: String?
    /// <p>The total amount that AWS estimates that this recommendation could save you in a
    ///             month, as a percentage of your costs.</p>
    public let totalEstimatedMonthlySavingsPercentage: String?

    public init (
        currencyCode: String? = nil,
        totalEstimatedMonthlySavingsAmount: String? = nil,
        totalEstimatedMonthlySavingsPercentage: String? = nil
    )
    {
        self.currencyCode = currencyCode
        self.totalEstimatedMonthlySavingsAmount = totalEstimatedMonthlySavingsAmount
        self.totalEstimatedMonthlySavingsPercentage = totalEstimatedMonthlySavingsPercentage
    }
}

extension ReservationUtilizationGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case key = "Key"
        case utilization = "Utilization"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let utilization = utilization {
            try encodeContainer.encode(utilization, forKey: .utilization)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let utilizationDecoded = try containerValues.decodeIfPresent(ReservationAggregates.self, forKey: .utilization)
        utilization = utilizationDecoded
    }
}

extension ReservationUtilizationGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReservationUtilizationGroup(attributes: \(String(describing: attributes)), key: \(String(describing: key)), utilization: \(String(describing: utilization)), value: \(String(describing: value)))"}
}

/// <p>A group of reservations that share a set of attributes.</p>
public struct ReservationUtilizationGroup: Equatable {
    /// <p>The attributes for this group of reservations.</p>
    public let attributes: [String:String]?
    /// <p>The key for a specific reservation attribute.</p>
    public let key: String?
    /// <p>How much you used this group of reservations.</p>
    public let utilization: ReservationAggregates?
    /// <p>The value of a specific reservation attribute.</p>
    public let value: String?

    public init (
        attributes: [String:String]? = nil,
        key: String? = nil,
        utilization: ReservationAggregates? = nil,
        value: String? = nil
    )
    {
        self.attributes = attributes
        self.key = key
        self.utilization = utilization
        self.value = value
    }
}

extension ResourceDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eC2ResourceDetails = "EC2ResourceDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eC2ResourceDetails = eC2ResourceDetails {
            try encodeContainer.encode(eC2ResourceDetails, forKey: .eC2ResourceDetails)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eC2ResourceDetailsDecoded = try containerValues.decodeIfPresent(EC2ResourceDetails.self, forKey: .eC2ResourceDetails)
        eC2ResourceDetails = eC2ResourceDetailsDecoded
    }
}

extension ResourceDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceDetails(eC2ResourceDetails: \(String(describing: eC2ResourceDetails)))"}
}

/// <p>Details on the resource.</p>
public struct ResourceDetails: Equatable {
    /// <p>Details on the Amazon EC2 resource.</p>
    public let eC2ResourceDetails: EC2ResourceDetails?

    public init (
        eC2ResourceDetails: EC2ResourceDetails? = nil
    )
    {
        self.eC2ResourceDetails = eC2ResourceDetails
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             The specified ARN in the request doesn't exist.
///         </p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceUtilization: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eC2ResourceUtilization = "EC2ResourceUtilization"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eC2ResourceUtilization = eC2ResourceUtilization {
            try encodeContainer.encode(eC2ResourceUtilization, forKey: .eC2ResourceUtilization)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eC2ResourceUtilizationDecoded = try containerValues.decodeIfPresent(EC2ResourceUtilization.self, forKey: .eC2ResourceUtilization)
        eC2ResourceUtilization = eC2ResourceUtilizationDecoded
    }
}

extension ResourceUtilization: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceUtilization(eC2ResourceUtilization: \(String(describing: eC2ResourceUtilization)))"}
}

/// <p>Resource utilization of current resource.  </p>
public struct ResourceUtilization: Equatable {
    /// <p>Utilization of current Amazon EC2 instance. </p>
    public let eC2ResourceUtilization: EC2ResourceUtilization?

    public init (
        eC2ResourceUtilization: EC2ResourceUtilization? = nil
    )
    {
        self.eC2ResourceUtilization = eC2ResourceUtilization
    }
}

extension ResultByTime: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case estimated = "Estimated"
        case groups = "Groups"
        case timePeriod = "TimePeriod"
        case total = "Total"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if estimated != false {
            try encodeContainer.encode(estimated, forKey: .estimated)
        }
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for groups0 in groups {
                try groupsContainer.encode(groups0)
            }
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
        if let total = total {
            var totalContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .total)
            for (dictKey0, metrics0) in total {
                try totalContainer.encode(metrics0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let totalContainer = try containerValues.decodeIfPresent([String: MetricValue?].self, forKey: .total)
        var totalDecoded0: [String:MetricValue]? = nil
        if let totalContainer = totalContainer {
            totalDecoded0 = [String:MetricValue]()
            for (key0, metricvalue0) in totalContainer {
                if let metricvalue0 = metricvalue0 {
                    totalDecoded0?[key0] = metricvalue0
                }
            }
        }
        total = totalDecoded0
        let groupsContainer = try containerValues.decodeIfPresent([Group?].self, forKey: .groups)
        var groupsDecoded0:[Group]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Group]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let estimatedDecoded = try containerValues.decode(Bool.self, forKey: .estimated)
        estimated = estimatedDecoded
    }
}

extension ResultByTime: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResultByTime(estimated: \(String(describing: estimated)), groups: \(String(describing: groups)), timePeriod: \(String(describing: timePeriod)), total: \(String(describing: total)))"}
}

/// <p>The result that is associated with a time period.</p>
public struct ResultByTime: Equatable {
    /// <p>Whether
    ///             the result is estimated.</p>
    public let estimated: Bool
    /// <p>The groups that this time period includes.</p>
    public let groups: [Group]?
    /// <p>The time period that the result covers.</p>
    public let timePeriod: DateInterval?
    /// <p>The total amount of cost or usage accrued during the time period.</p>
    public let total: [String:MetricValue]?

    public init (
        estimated: Bool = false,
        groups: [Group]? = nil,
        timePeriod: DateInterval? = nil,
        total: [String:MetricValue]? = nil
    )
    {
        self.estimated = estimated
        self.groups = groups
        self.timePeriod = timePeriod
        self.total = total
    }
}

extension RightsizingRecommendation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case currentInstance = "CurrentInstance"
        case findingReasonCodes = "FindingReasonCodes"
        case modifyRecommendationDetail = "ModifyRecommendationDetail"
        case rightsizingType = "RightsizingType"
        case terminateRecommendationDetail = "TerminateRecommendationDetail"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let currentInstance = currentInstance {
            try encodeContainer.encode(currentInstance, forKey: .currentInstance)
        }
        if let findingReasonCodes = findingReasonCodes {
            var findingReasonCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingReasonCodes)
            for findingreasoncodes0 in findingReasonCodes {
                try findingReasonCodesContainer.encode(findingreasoncodes0.rawValue)
            }
        }
        if let modifyRecommendationDetail = modifyRecommendationDetail {
            try encodeContainer.encode(modifyRecommendationDetail, forKey: .modifyRecommendationDetail)
        }
        if let rightsizingType = rightsizingType {
            try encodeContainer.encode(rightsizingType.rawValue, forKey: .rightsizingType)
        }
        if let terminateRecommendationDetail = terminateRecommendationDetail {
            try encodeContainer.encode(terminateRecommendationDetail, forKey: .terminateRecommendationDetail)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let currentInstanceDecoded = try containerValues.decodeIfPresent(CurrentInstance.self, forKey: .currentInstance)
        currentInstance = currentInstanceDecoded
        let rightsizingTypeDecoded = try containerValues.decodeIfPresent(RightsizingType.self, forKey: .rightsizingType)
        rightsizingType = rightsizingTypeDecoded
        let modifyRecommendationDetailDecoded = try containerValues.decodeIfPresent(ModifyRecommendationDetail.self, forKey: .modifyRecommendationDetail)
        modifyRecommendationDetail = modifyRecommendationDetailDecoded
        let terminateRecommendationDetailDecoded = try containerValues.decodeIfPresent(TerminateRecommendationDetail.self, forKey: .terminateRecommendationDetail)
        terminateRecommendationDetail = terminateRecommendationDetailDecoded
        let findingReasonCodesContainer = try containerValues.decodeIfPresent([FindingReasonCode?].self, forKey: .findingReasonCodes)
        var findingReasonCodesDecoded0:[FindingReasonCode]? = nil
        if let findingReasonCodesContainer = findingReasonCodesContainer {
            findingReasonCodesDecoded0 = [FindingReasonCode]()
            for string0 in findingReasonCodesContainer {
                if let string0 = string0 {
                    findingReasonCodesDecoded0?.append(string0)
                }
            }
        }
        findingReasonCodes = findingReasonCodesDecoded0
    }
}

extension RightsizingRecommendation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RightsizingRecommendation(accountId: \(String(describing: accountId)), currentInstance: \(String(describing: currentInstance)), findingReasonCodes: \(String(describing: findingReasonCodes)), modifyRecommendationDetail: \(String(describing: modifyRecommendationDetail)), rightsizingType: \(String(describing: rightsizingType)), terminateRecommendationDetail: \(String(describing: terminateRecommendationDetail)))"}
}

/// <p>Recommendations to rightsize resources.</p>
public struct RightsizingRecommendation: Equatable {
    /// <p>The account that this recommendation is for.</p>
    public let accountId: String?
    /// <p> Context regarding the current instance.</p>
    public let currentInstance: CurrentInstance?
    /// <p>
    ///             The list of possible reasons why the recommendation is generated such as under or over utilization of specific metrics (for example, CPU, Memory, Network).
    ///         </p>
    public let findingReasonCodes: [FindingReasonCode]?
    /// <p> Details for modification recommendations.  </p>
    public let modifyRecommendationDetail: ModifyRecommendationDetail?
    /// <p>Recommendation to either terminate or modify the resource.</p>
    public let rightsizingType: RightsizingType?
    /// <p>Details for termination recommendations.</p>
    public let terminateRecommendationDetail: TerminateRecommendationDetail?

    public init (
        accountId: String? = nil,
        currentInstance: CurrentInstance? = nil,
        findingReasonCodes: [FindingReasonCode]? = nil,
        modifyRecommendationDetail: ModifyRecommendationDetail? = nil,
        rightsizingType: RightsizingType? = nil,
        terminateRecommendationDetail: TerminateRecommendationDetail? = nil
    )
    {
        self.accountId = accountId
        self.currentInstance = currentInstance
        self.findingReasonCodes = findingReasonCodes
        self.modifyRecommendationDetail = modifyRecommendationDetail
        self.rightsizingType = rightsizingType
        self.terminateRecommendationDetail = terminateRecommendationDetail
    }
}

extension RightsizingRecommendationConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case benefitsConsidered = "BenefitsConsidered"
        case recommendationTarget = "RecommendationTarget"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if benefitsConsidered != false {
            try encodeContainer.encode(benefitsConsidered, forKey: .benefitsConsidered)
        }
        if let recommendationTarget = recommendationTarget {
            try encodeContainer.encode(recommendationTarget.rawValue, forKey: .recommendationTarget)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationTargetDecoded = try containerValues.decodeIfPresent(RecommendationTarget.self, forKey: .recommendationTarget)
        recommendationTarget = recommendationTargetDecoded
        let benefitsConsideredDecoded = try containerValues.decode(Bool.self, forKey: .benefitsConsidered)
        benefitsConsidered = benefitsConsideredDecoded
    }
}

extension RightsizingRecommendationConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RightsizingRecommendationConfiguration(benefitsConsidered: \(String(describing: benefitsConsidered)), recommendationTarget: \(String(describing: recommendationTarget)))"}
}

/// <p> Enables you to customize recommendations across two attributes. You can choose to view
///             recommendations for instances within the same instance families or across different instance
///             families. You can also choose to view your estimated savings associated with recommendations
///             with consideration of existing Savings Plans or RI benefits, or
///             neither. </p>
public struct RightsizingRecommendationConfiguration: Equatable {
    /// <p>
    ///             The option to consider RI or Savings Plans discount benefits in your savings calculation. The default value is <code>TRUE</code>.
    ///         </p>
    public let benefitsConsidered: Bool
    /// <p>
    ///             The option to see recommendations within the same instance family, or recommendations for instances across other families. The default value is <code>SAME_INSTANCE_FAMILY</code>.
    ///         </p>
    public let recommendationTarget: RecommendationTarget?

    public init (
        benefitsConsidered: Bool = false,
        recommendationTarget: RecommendationTarget? = nil
    )
    {
        self.benefitsConsidered = benefitsConsidered
        self.recommendationTarget = recommendationTarget
    }
}

extension RightsizingRecommendationMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalMetadata = "AdditionalMetadata"
        case generationTimestamp = "GenerationTimestamp"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case recommendationId = "RecommendationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalMetadata = additionalMetadata {
            try encodeContainer.encode(additionalMetadata, forKey: .additionalMetadata)
        }
        if let generationTimestamp = generationTimestamp {
            try encodeContainer.encode(generationTimestamp, forKey: .generationTimestamp)
        }
        if let lookbackPeriodInDays = lookbackPeriodInDays {
            try encodeContainer.encode(lookbackPeriodInDays.rawValue, forKey: .lookbackPeriodInDays)
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let generationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .generationTimestamp)
        generationTimestamp = generationTimestampDecoded
        let lookbackPeriodInDaysDecoded = try containerValues.decodeIfPresent(LookbackPeriodInDays.self, forKey: .lookbackPeriodInDays)
        lookbackPeriodInDays = lookbackPeriodInDaysDecoded
        let additionalMetadataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .additionalMetadata)
        additionalMetadata = additionalMetadataDecoded
    }
}

extension RightsizingRecommendationMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RightsizingRecommendationMetadata(additionalMetadata: \(String(describing: additionalMetadata)), generationTimestamp: \(String(describing: generationTimestamp)), lookbackPeriodInDays: \(String(describing: lookbackPeriodInDays)), recommendationId: \(String(describing: recommendationId)))"}
}

/// <p>Metadata for this recommendation set.</p>
public struct RightsizingRecommendationMetadata: Equatable {
    /// <p>Additional metadata that may be applicable to the recommendation.</p>
    public let additionalMetadata: String?
    /// <p> The timestamp for when AWS made this recommendation.</p>
    public let generationTimestamp: String?
    /// <p> How many days of previous usage that AWS considers when making this
    ///             recommendation.</p>
    public let lookbackPeriodInDays: LookbackPeriodInDays?
    /// <p> The ID for this specific recommendation.</p>
    public let recommendationId: String?

    public init (
        additionalMetadata: String? = nil,
        generationTimestamp: String? = nil,
        lookbackPeriodInDays: LookbackPeriodInDays? = nil,
        recommendationId: String? = nil
    )
    {
        self.additionalMetadata = additionalMetadata
        self.generationTimestamp = generationTimestamp
        self.lookbackPeriodInDays = lookbackPeriodInDays
        self.recommendationId = recommendationId
    }
}

extension RightsizingRecommendationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case estimatedTotalMonthlySavingsAmount = "EstimatedTotalMonthlySavingsAmount"
        case savingsCurrencyCode = "SavingsCurrencyCode"
        case savingsPercentage = "SavingsPercentage"
        case totalRecommendationCount = "TotalRecommendationCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let estimatedTotalMonthlySavingsAmount = estimatedTotalMonthlySavingsAmount {
            try encodeContainer.encode(estimatedTotalMonthlySavingsAmount, forKey: .estimatedTotalMonthlySavingsAmount)
        }
        if let savingsCurrencyCode = savingsCurrencyCode {
            try encodeContainer.encode(savingsCurrencyCode, forKey: .savingsCurrencyCode)
        }
        if let savingsPercentage = savingsPercentage {
            try encodeContainer.encode(savingsPercentage, forKey: .savingsPercentage)
        }
        if let totalRecommendationCount = totalRecommendationCount {
            try encodeContainer.encode(totalRecommendationCount, forKey: .totalRecommendationCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalRecommendationCountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .totalRecommendationCount)
        totalRecommendationCount = totalRecommendationCountDecoded
        let estimatedTotalMonthlySavingsAmountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedTotalMonthlySavingsAmount)
        estimatedTotalMonthlySavingsAmount = estimatedTotalMonthlySavingsAmountDecoded
        let savingsCurrencyCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .savingsCurrencyCode)
        savingsCurrencyCode = savingsCurrencyCodeDecoded
        let savingsPercentageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .savingsPercentage)
        savingsPercentage = savingsPercentageDecoded
    }
}

extension RightsizingRecommendationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RightsizingRecommendationSummary(estimatedTotalMonthlySavingsAmount: \(String(describing: estimatedTotalMonthlySavingsAmount)), savingsCurrencyCode: \(String(describing: savingsCurrencyCode)), savingsPercentage: \(String(describing: savingsPercentage)), totalRecommendationCount: \(String(describing: totalRecommendationCount)))"}
}

/// <p> Summary of rightsizing recommendations  </p>
public struct RightsizingRecommendationSummary: Equatable {
    /// <p> Estimated total savings resulting from modifications, on a monthly basis.</p>
    public let estimatedTotalMonthlySavingsAmount: String?
    /// <p> The currency code that AWS used to calculate the savings.</p>
    public let savingsCurrencyCode: String?
    /// <p> Savings percentage based on the recommended modifications, relative to the total
    ///             On-Demand
    ///             costs associated with these instances.</p>
    public let savingsPercentage: String?
    /// <p> Total number of instance recommendations.</p>
    public let totalRecommendationCount: String?

    public init (
        estimatedTotalMonthlySavingsAmount: String? = nil,
        savingsCurrencyCode: String? = nil,
        savingsPercentage: String? = nil,
        totalRecommendationCount: String? = nil
    )
    {
        self.estimatedTotalMonthlySavingsAmount = estimatedTotalMonthlySavingsAmount
        self.savingsCurrencyCode = savingsCurrencyCode
        self.savingsPercentage = savingsPercentage
        self.totalRecommendationCount = totalRecommendationCount
    }
}

public enum RightsizingType {
    case modify
    case terminate
    case sdkUnknown(String)
}

extension RightsizingType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RightsizingType] {
        return [
            .modify,
            .terminate,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .modify: return "MODIFY"
        case .terminate: return "TERMINATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RightsizingType(rawValue: rawValue) ?? RightsizingType.sdkUnknown(rawValue)
    }
}

extension RootCause: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case linkedAccount = "LinkedAccount"
        case region = "Region"
        case service = "Service"
        case usageType = "UsageType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let linkedAccount = linkedAccount {
            try encodeContainer.encode(linkedAccount, forKey: .linkedAccount)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let service = service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let usageType = usageType {
            try encodeContainer.encode(usageType, forKey: .usageType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .service)
        service = serviceDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let linkedAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkedAccount)
        linkedAccount = linkedAccountDecoded
        let usageTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .usageType)
        usageType = usageTypeDecoded
    }
}

extension RootCause: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RootCause(linkedAccount: \(String(describing: linkedAccount)), region: \(String(describing: region)), service: \(String(describing: service)), usageType: \(String(describing: usageType)))"}
}

/// <p>
///         The combination of AWS service, linked account, Region, and usage type where a cost anomaly is observed.
///     </p>
public struct RootCause: Equatable {
    /// <p>
    ///         The linked account value associated with the cost anomaly.
    ///     </p>
    public let linkedAccount: String?
    /// <p>
    ///         The AWS Region associated with the cost anomaly.
    ///     </p>
    public let region: String?
    /// <p>
    ///         The AWS service name associated with the cost anomaly.
    ///     </p>
    public let service: String?
    /// <p>
    ///         The <code>UsageType</code> value associated with the cost anomaly.
    ///     </p>
    public let usageType: String?

    public init (
        linkedAccount: String? = nil,
        region: String? = nil,
        service: String? = nil,
        usageType: String? = nil
    )
    {
        self.linkedAccount = linkedAccount
        self.region = region
        self.service = service
        self.usageType = usageType
    }
}

extension SavingsPlansAmortizedCommitment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amortizedRecurringCommitment = "AmortizedRecurringCommitment"
        case amortizedUpfrontCommitment = "AmortizedUpfrontCommitment"
        case totalAmortizedCommitment = "TotalAmortizedCommitment"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amortizedRecurringCommitment = amortizedRecurringCommitment {
            try encodeContainer.encode(amortizedRecurringCommitment, forKey: .amortizedRecurringCommitment)
        }
        if let amortizedUpfrontCommitment = amortizedUpfrontCommitment {
            try encodeContainer.encode(amortizedUpfrontCommitment, forKey: .amortizedUpfrontCommitment)
        }
        if let totalAmortizedCommitment = totalAmortizedCommitment {
            try encodeContainer.encode(totalAmortizedCommitment, forKey: .totalAmortizedCommitment)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amortizedRecurringCommitmentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amortizedRecurringCommitment)
        amortizedRecurringCommitment = amortizedRecurringCommitmentDecoded
        let amortizedUpfrontCommitmentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amortizedUpfrontCommitment)
        amortizedUpfrontCommitment = amortizedUpfrontCommitmentDecoded
        let totalAmortizedCommitmentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .totalAmortizedCommitment)
        totalAmortizedCommitment = totalAmortizedCommitmentDecoded
    }
}

extension SavingsPlansAmortizedCommitment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlansAmortizedCommitment(amortizedRecurringCommitment: \(String(describing: amortizedRecurringCommitment)), amortizedUpfrontCommitment: \(String(describing: amortizedUpfrontCommitment)), totalAmortizedCommitment: \(String(describing: totalAmortizedCommitment)))"}
}

/// <p>The amortized amount of Savings Plans purchased in a specific account during a specific time interval.</p>
public struct SavingsPlansAmortizedCommitment: Equatable {
    /// <p>The amortized amount of your Savings Plans commitment that was purchased with either a <code>Partial</code> or a <code>NoUpfront</code>.</p>
    public let amortizedRecurringCommitment: String?
    /// <p>The amortized amount of your Savings Plans commitment that was purchased with an <code>Upfront</code> or <code>PartialUpfront</code> Savings Plans.</p>
    public let amortizedUpfrontCommitment: String?
    /// <p>The total amortized amount of your Savings Plans commitment, regardless of your Savings Plans purchase method. </p>
    public let totalAmortizedCommitment: String?

    public init (
        amortizedRecurringCommitment: String? = nil,
        amortizedUpfrontCommitment: String? = nil,
        totalAmortizedCommitment: String? = nil
    )
    {
        self.amortizedRecurringCommitment = amortizedRecurringCommitment
        self.amortizedUpfrontCommitment = amortizedUpfrontCommitment
        self.totalAmortizedCommitment = totalAmortizedCommitment
    }
}

extension SavingsPlansCoverage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case coverage = "Coverage"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let coverage = coverage {
            try encodeContainer.encode(coverage, forKey: .coverage)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let coverageDecoded = try containerValues.decodeIfPresent(SavingsPlansCoverageData.self, forKey: .coverage)
        coverage = coverageDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
    }
}

extension SavingsPlansCoverage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlansCoverage(attributes: \(String(describing: attributes)), coverage: \(String(describing: coverage)), timePeriod: \(String(describing: timePeriod)))"}
}

/// <p>The amount of Savings Plans eligible usage that is covered by Savings Plans. All calculations consider the On-Demand equivalent of your Savings Plans usage.</p>
public struct SavingsPlansCoverage: Equatable {
    /// <p>The attribute that applies to a specific <code>Dimension</code>.</p>
    public let attributes: [String:String]?
    /// <p>The amount of Savings Plans eligible usage that the Savings Plans covered.</p>
    public let coverage: SavingsPlansCoverageData?
    /// <p>The time period of the request.
    ///         </p>
    public let timePeriod: DateInterval?

    public init (
        attributes: [String:String]? = nil,
        coverage: SavingsPlansCoverageData? = nil,
        timePeriod: DateInterval? = nil
    )
    {
        self.attributes = attributes
        self.coverage = coverage
        self.timePeriod = timePeriod
    }
}

extension SavingsPlansCoverageData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case coveragePercentage = "CoveragePercentage"
        case onDemandCost = "OnDemandCost"
        case spendCoveredBySavingsPlans = "SpendCoveredBySavingsPlans"
        case totalCost = "TotalCost"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coveragePercentage = coveragePercentage {
            try encodeContainer.encode(coveragePercentage, forKey: .coveragePercentage)
        }
        if let onDemandCost = onDemandCost {
            try encodeContainer.encode(onDemandCost, forKey: .onDemandCost)
        }
        if let spendCoveredBySavingsPlans = spendCoveredBySavingsPlans {
            try encodeContainer.encode(spendCoveredBySavingsPlans, forKey: .spendCoveredBySavingsPlans)
        }
        if let totalCost = totalCost {
            try encodeContainer.encode(totalCost, forKey: .totalCost)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let spendCoveredBySavingsPlansDecoded = try containerValues.decodeIfPresent(String.self, forKey: .spendCoveredBySavingsPlans)
        spendCoveredBySavingsPlans = spendCoveredBySavingsPlansDecoded
        let onDemandCostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .onDemandCost)
        onDemandCost = onDemandCostDecoded
        let totalCostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .totalCost)
        totalCost = totalCostDecoded
        let coveragePercentageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .coveragePercentage)
        coveragePercentage = coveragePercentageDecoded
    }
}

extension SavingsPlansCoverageData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlansCoverageData(coveragePercentage: \(String(describing: coveragePercentage)), onDemandCost: \(String(describing: onDemandCost)), spendCoveredBySavingsPlans: \(String(describing: spendCoveredBySavingsPlans)), totalCost: \(String(describing: totalCost)))"}
}

/// <p>Specific coverage percentage, On-Demand costs, and spend covered by Savings Plans, and total Savings Plans costs for an account.</p>
public struct SavingsPlansCoverageData: Equatable {
    /// <p>The percentage of your existing Savings Plans covered usage, divided by all of your
    ///             eligible Savings Plans usage in an account(or set of accounts).</p>
    public let coveragePercentage: String?
    /// <p>The cost of your AWS usage at the public On-Demand rate.</p>
    public let onDemandCost: String?
    /// <p>The amount of your AWS usage that is covered by a Savings Plans.</p>
    public let spendCoveredBySavingsPlans: String?
    /// <p>The total cost of your AWS usage, regardless of your purchase option.</p>
    public let totalCost: String?

    public init (
        coveragePercentage: String? = nil,
        onDemandCost: String? = nil,
        spendCoveredBySavingsPlans: String? = nil,
        totalCost: String? = nil
    )
    {
        self.coveragePercentage = coveragePercentage
        self.onDemandCost = onDemandCost
        self.spendCoveredBySavingsPlans = spendCoveredBySavingsPlans
        self.totalCost = totalCost
    }
}

public enum SavingsPlansDataType {
    case amortizedCommitment
    case attributes
    case savings
    case utilization
    case sdkUnknown(String)
}

extension SavingsPlansDataType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SavingsPlansDataType] {
        return [
            .amortizedCommitment,
            .attributes,
            .savings,
            .utilization,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .amortizedCommitment: return "AMORTIZED_COMMITMENT"
        case .attributes: return "ATTRIBUTES"
        case .savings: return "SAVINGS"
        case .utilization: return "UTILIZATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SavingsPlansDataType(rawValue: rawValue) ?? SavingsPlansDataType.sdkUnknown(rawValue)
    }
}

extension SavingsPlansDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case instanceFamily = "InstanceFamily"
        case offeringId = "OfferingId"
        case region = "Region"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceFamily = instanceFamily {
            try encodeContainer.encode(instanceFamily, forKey: .instanceFamily)
        }
        if let offeringId = offeringId {
            try encodeContainer.encode(offeringId, forKey: .offeringId)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
        let instanceFamilyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceFamily)
        instanceFamily = instanceFamilyDecoded
        let offeringIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .offeringId)
        offeringId = offeringIdDecoded
    }
}

extension SavingsPlansDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlansDetails(instanceFamily: \(String(describing: instanceFamily)), offeringId: \(String(describing: offeringId)), region: \(String(describing: region)))"}
}

/// <p>Attribute details on a specific Savings Plan.</p>
public struct SavingsPlansDetails: Equatable {
    /// <p>A group of instance types that Savings Plans applies to.</p>
    public let instanceFamily: String?
    /// <p>The unique ID used to distinguish Savings Plans from one another.</p>
    public let offeringId: String?
    /// <p>A collection of AWS resources in a geographic area. Each AWS Region is isolated and independent of the other Regions.</p>
    public let region: String?

    public init (
        instanceFamily: String? = nil,
        offeringId: String? = nil,
        region: String? = nil
    )
    {
        self.instanceFamily = instanceFamily
        self.offeringId = offeringId
        self.region = region
    }
}

extension SavingsPlansPurchaseRecommendation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountScope = "AccountScope"
        case lookbackPeriodInDays = "LookbackPeriodInDays"
        case paymentOption = "PaymentOption"
        case savingsPlansPurchaseRecommendationDetails = "SavingsPlansPurchaseRecommendationDetails"
        case savingsPlansPurchaseRecommendationSummary = "SavingsPlansPurchaseRecommendationSummary"
        case savingsPlansType = "SavingsPlansType"
        case termInYears = "TermInYears"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountScope = accountScope {
            try encodeContainer.encode(accountScope.rawValue, forKey: .accountScope)
        }
        if let lookbackPeriodInDays = lookbackPeriodInDays {
            try encodeContainer.encode(lookbackPeriodInDays.rawValue, forKey: .lookbackPeriodInDays)
        }
        if let paymentOption = paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let savingsPlansPurchaseRecommendationDetails = savingsPlansPurchaseRecommendationDetails {
            var savingsPlansPurchaseRecommendationDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .savingsPlansPurchaseRecommendationDetails)
            for savingsplanspurchaserecommendationdetaillist0 in savingsPlansPurchaseRecommendationDetails {
                try savingsPlansPurchaseRecommendationDetailsContainer.encode(savingsplanspurchaserecommendationdetaillist0)
            }
        }
        if let savingsPlansPurchaseRecommendationSummary = savingsPlansPurchaseRecommendationSummary {
            try encodeContainer.encode(savingsPlansPurchaseRecommendationSummary, forKey: .savingsPlansPurchaseRecommendationSummary)
        }
        if let savingsPlansType = savingsPlansType {
            try encodeContainer.encode(savingsPlansType.rawValue, forKey: .savingsPlansType)
        }
        if let termInYears = termInYears {
            try encodeContainer.encode(termInYears.rawValue, forKey: .termInYears)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountScopeDecoded = try containerValues.decodeIfPresent(AccountScope.self, forKey: .accountScope)
        accountScope = accountScopeDecoded
        let savingsPlansTypeDecoded = try containerValues.decodeIfPresent(SupportedSavingsPlansType.self, forKey: .savingsPlansType)
        savingsPlansType = savingsPlansTypeDecoded
        let termInYearsDecoded = try containerValues.decodeIfPresent(TermInYears.self, forKey: .termInYears)
        termInYears = termInYearsDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(PaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let lookbackPeriodInDaysDecoded = try containerValues.decodeIfPresent(LookbackPeriodInDays.self, forKey: .lookbackPeriodInDays)
        lookbackPeriodInDays = lookbackPeriodInDaysDecoded
        let savingsPlansPurchaseRecommendationDetailsContainer = try containerValues.decodeIfPresent([SavingsPlansPurchaseRecommendationDetail?].self, forKey: .savingsPlansPurchaseRecommendationDetails)
        var savingsPlansPurchaseRecommendationDetailsDecoded0:[SavingsPlansPurchaseRecommendationDetail]? = nil
        if let savingsPlansPurchaseRecommendationDetailsContainer = savingsPlansPurchaseRecommendationDetailsContainer {
            savingsPlansPurchaseRecommendationDetailsDecoded0 = [SavingsPlansPurchaseRecommendationDetail]()
            for structure0 in savingsPlansPurchaseRecommendationDetailsContainer {
                if let structure0 = structure0 {
                    savingsPlansPurchaseRecommendationDetailsDecoded0?.append(structure0)
                }
            }
        }
        savingsPlansPurchaseRecommendationDetails = savingsPlansPurchaseRecommendationDetailsDecoded0
        let savingsPlansPurchaseRecommendationSummaryDecoded = try containerValues.decodeIfPresent(SavingsPlansPurchaseRecommendationSummary.self, forKey: .savingsPlansPurchaseRecommendationSummary)
        savingsPlansPurchaseRecommendationSummary = savingsPlansPurchaseRecommendationSummaryDecoded
    }
}

extension SavingsPlansPurchaseRecommendation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlansPurchaseRecommendation(accountScope: \(String(describing: accountScope)), lookbackPeriodInDays: \(String(describing: lookbackPeriodInDays)), paymentOption: \(String(describing: paymentOption)), savingsPlansPurchaseRecommendationDetails: \(String(describing: savingsPlansPurchaseRecommendationDetails)), savingsPlansPurchaseRecommendationSummary: \(String(describing: savingsPlansPurchaseRecommendationSummary)), savingsPlansType: \(String(describing: savingsPlansType)), termInYears: \(String(describing: termInYears)))"}
}

/// <p>Contains your request parameters, Savings Plan Recommendations Summary, and Details.</p>
public struct SavingsPlansPurchaseRecommendation: Equatable {
    /// <p>The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to <code>PAYER</code>. If the value is <code>LINKED</code>, recommendations are calculated for individual member accounts only.</p>
    public let accountScope: AccountScope?
    /// <p>The lookback period in days, used to generate the recommendation.</p>
    public let lookbackPeriodInDays: LookbackPeriodInDays?
    /// <p>The payment option used to generate the recommendation.</p>
    public let paymentOption: PaymentOption?
    /// <p>Details for the Savings Plans we recommend that you purchase to cover existing Savings
    ///             Plans eligible workloads.</p>
    public let savingsPlansPurchaseRecommendationDetails: [SavingsPlansPurchaseRecommendationDetail]?
    /// <p>Summary metrics for your Savings Plans Recommendations. </p>
    public let savingsPlansPurchaseRecommendationSummary: SavingsPlansPurchaseRecommendationSummary?
    /// <p>The requested Savings Plans recommendation type.</p>
    public let savingsPlansType: SupportedSavingsPlansType?
    /// <p>The Savings Plans recommendation term in years, used to generate the recommendation.</p>
    public let termInYears: TermInYears?

    public init (
        accountScope: AccountScope? = nil,
        lookbackPeriodInDays: LookbackPeriodInDays? = nil,
        paymentOption: PaymentOption? = nil,
        savingsPlansPurchaseRecommendationDetails: [SavingsPlansPurchaseRecommendationDetail]? = nil,
        savingsPlansPurchaseRecommendationSummary: SavingsPlansPurchaseRecommendationSummary? = nil,
        savingsPlansType: SupportedSavingsPlansType? = nil,
        termInYears: TermInYears? = nil
    )
    {
        self.accountScope = accountScope
        self.lookbackPeriodInDays = lookbackPeriodInDays
        self.paymentOption = paymentOption
        self.savingsPlansPurchaseRecommendationDetails = savingsPlansPurchaseRecommendationDetails
        self.savingsPlansPurchaseRecommendationSummary = savingsPlansPurchaseRecommendationSummary
        self.savingsPlansType = savingsPlansType
        self.termInYears = termInYears
    }
}

extension SavingsPlansPurchaseRecommendationDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case currencyCode = "CurrencyCode"
        case currentAverageHourlyOnDemandSpend = "CurrentAverageHourlyOnDemandSpend"
        case currentMaximumHourlyOnDemandSpend = "CurrentMaximumHourlyOnDemandSpend"
        case currentMinimumHourlyOnDemandSpend = "CurrentMinimumHourlyOnDemandSpend"
        case estimatedAverageUtilization = "EstimatedAverageUtilization"
        case estimatedMonthlySavingsAmount = "EstimatedMonthlySavingsAmount"
        case estimatedOnDemandCost = "EstimatedOnDemandCost"
        case estimatedOnDemandCostWithCurrentCommitment = "EstimatedOnDemandCostWithCurrentCommitment"
        case estimatedROI = "EstimatedROI"
        case estimatedSPCost = "EstimatedSPCost"
        case estimatedSavingsAmount = "EstimatedSavingsAmount"
        case estimatedSavingsPercentage = "EstimatedSavingsPercentage"
        case hourlyCommitmentToPurchase = "HourlyCommitmentToPurchase"
        case savingsPlansDetails = "SavingsPlansDetails"
        case upfrontCost = "UpfrontCost"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let currencyCode = currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let currentAverageHourlyOnDemandSpend = currentAverageHourlyOnDemandSpend {
            try encodeContainer.encode(currentAverageHourlyOnDemandSpend, forKey: .currentAverageHourlyOnDemandSpend)
        }
        if let currentMaximumHourlyOnDemandSpend = currentMaximumHourlyOnDemandSpend {
            try encodeContainer.encode(currentMaximumHourlyOnDemandSpend, forKey: .currentMaximumHourlyOnDemandSpend)
        }
        if let currentMinimumHourlyOnDemandSpend = currentMinimumHourlyOnDemandSpend {
            try encodeContainer.encode(currentMinimumHourlyOnDemandSpend, forKey: .currentMinimumHourlyOnDemandSpend)
        }
        if let estimatedAverageUtilization = estimatedAverageUtilization {
            try encodeContainer.encode(estimatedAverageUtilization, forKey: .estimatedAverageUtilization)
        }
        if let estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount {
            try encodeContainer.encode(estimatedMonthlySavingsAmount, forKey: .estimatedMonthlySavingsAmount)
        }
        if let estimatedOnDemandCost = estimatedOnDemandCost {
            try encodeContainer.encode(estimatedOnDemandCost, forKey: .estimatedOnDemandCost)
        }
        if let estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitment {
            try encodeContainer.encode(estimatedOnDemandCostWithCurrentCommitment, forKey: .estimatedOnDemandCostWithCurrentCommitment)
        }
        if let estimatedROI = estimatedROI {
            try encodeContainer.encode(estimatedROI, forKey: .estimatedROI)
        }
        if let estimatedSPCost = estimatedSPCost {
            try encodeContainer.encode(estimatedSPCost, forKey: .estimatedSPCost)
        }
        if let estimatedSavingsAmount = estimatedSavingsAmount {
            try encodeContainer.encode(estimatedSavingsAmount, forKey: .estimatedSavingsAmount)
        }
        if let estimatedSavingsPercentage = estimatedSavingsPercentage {
            try encodeContainer.encode(estimatedSavingsPercentage, forKey: .estimatedSavingsPercentage)
        }
        if let hourlyCommitmentToPurchase = hourlyCommitmentToPurchase {
            try encodeContainer.encode(hourlyCommitmentToPurchase, forKey: .hourlyCommitmentToPurchase)
        }
        if let savingsPlansDetails = savingsPlansDetails {
            try encodeContainer.encode(savingsPlansDetails, forKey: .savingsPlansDetails)
        }
        if let upfrontCost = upfrontCost {
            try encodeContainer.encode(upfrontCost, forKey: .upfrontCost)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlansDetailsDecoded = try containerValues.decodeIfPresent(SavingsPlansDetails.self, forKey: .savingsPlansDetails)
        savingsPlansDetails = savingsPlansDetailsDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let upfrontCostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .upfrontCost)
        upfrontCost = upfrontCostDecoded
        let estimatedROIDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedROI)
        estimatedROI = estimatedROIDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let estimatedSPCostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedSPCost)
        estimatedSPCost = estimatedSPCostDecoded
        let estimatedOnDemandCostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedOnDemandCost)
        estimatedOnDemandCost = estimatedOnDemandCostDecoded
        let estimatedOnDemandCostWithCurrentCommitmentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedOnDemandCostWithCurrentCommitment)
        estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitmentDecoded
        let estimatedSavingsAmountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedSavingsAmount)
        estimatedSavingsAmount = estimatedSavingsAmountDecoded
        let estimatedSavingsPercentageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedSavingsPercentage)
        estimatedSavingsPercentage = estimatedSavingsPercentageDecoded
        let hourlyCommitmentToPurchaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hourlyCommitmentToPurchase)
        hourlyCommitmentToPurchase = hourlyCommitmentToPurchaseDecoded
        let estimatedAverageUtilizationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedAverageUtilization)
        estimatedAverageUtilization = estimatedAverageUtilizationDecoded
        let estimatedMonthlySavingsAmountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedMonthlySavingsAmount)
        estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmountDecoded
        let currentMinimumHourlyOnDemandSpendDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentMinimumHourlyOnDemandSpend)
        currentMinimumHourlyOnDemandSpend = currentMinimumHourlyOnDemandSpendDecoded
        let currentMaximumHourlyOnDemandSpendDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentMaximumHourlyOnDemandSpend)
        currentMaximumHourlyOnDemandSpend = currentMaximumHourlyOnDemandSpendDecoded
        let currentAverageHourlyOnDemandSpendDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentAverageHourlyOnDemandSpend)
        currentAverageHourlyOnDemandSpend = currentAverageHourlyOnDemandSpendDecoded
    }
}

extension SavingsPlansPurchaseRecommendationDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlansPurchaseRecommendationDetail(accountId: \(String(describing: accountId)), currencyCode: \(String(describing: currencyCode)), currentAverageHourlyOnDemandSpend: \(String(describing: currentAverageHourlyOnDemandSpend)), currentMaximumHourlyOnDemandSpend: \(String(describing: currentMaximumHourlyOnDemandSpend)), currentMinimumHourlyOnDemandSpend: \(String(describing: currentMinimumHourlyOnDemandSpend)), estimatedAverageUtilization: \(String(describing: estimatedAverageUtilization)), estimatedMonthlySavingsAmount: \(String(describing: estimatedMonthlySavingsAmount)), estimatedOnDemandCost: \(String(describing: estimatedOnDemandCost)), estimatedOnDemandCostWithCurrentCommitment: \(String(describing: estimatedOnDemandCostWithCurrentCommitment)), estimatedROI: \(String(describing: estimatedROI)), estimatedSPCost: \(String(describing: estimatedSPCost)), estimatedSavingsAmount: \(String(describing: estimatedSavingsAmount)), estimatedSavingsPercentage: \(String(describing: estimatedSavingsPercentage)), hourlyCommitmentToPurchase: \(String(describing: hourlyCommitmentToPurchase)), savingsPlansDetails: \(String(describing: savingsPlansDetails)), upfrontCost: \(String(describing: upfrontCost)))"}
}

/// <p>Details for your recommended Savings Plans.</p>
public struct SavingsPlansPurchaseRecommendationDetail: Equatable {
    /// <p>The <code>AccountID</code> the recommendation is generated for.</p>
    public let accountId: String?
    /// <p>The currency code AWS used to generate the recommendations and present potential
    ///             savings.</p>
    public let currencyCode: String?
    /// <p>The average value of hourly On-Demand spend over the lookback period of the applicable usage type.</p>
    public let currentAverageHourlyOnDemandSpend: String?
    /// <p>The highest value of hourly On-Demand spend over the lookback period of the applicable usage type.</p>
    public let currentMaximumHourlyOnDemandSpend: String?
    /// <p>The lowest value of hourly On-Demand spend over the lookback period of the applicable usage type.</p>
    public let currentMinimumHourlyOnDemandSpend: String?
    /// <p>The estimated utilization of the recommended Savings Plans.</p>
    public let estimatedAverageUtilization: String?
    /// <p>The estimated monthly savings amount, based on the recommended Savings Plans.</p>
    public let estimatedMonthlySavingsAmount: String?
    /// <p>The remaining On-Demand cost estimated to not be covered by the recommended Savings Plans, over the length of the lookback period.</p>
    public let estimatedOnDemandCost: String?
    /// <p>
    ///             The estimated On-Demand costs you would expect with no additional commitment, based on your usage of the selected time period and the Savings Plans you own.
    ///         </p>
    public let estimatedOnDemandCostWithCurrentCommitment: String?
    /// <p>The estimated return on investment based on the recommended Savings Plans purchased. This is calculated as <code>estimatedSavingsAmount</code>/ <code>estimatedSPCost</code>*100.</p>
    public let estimatedROI: String?
    /// <p>The cost of the recommended Savings Plans over the length of the lookback period.</p>
    public let estimatedSPCost: String?
    /// <p>The estimated savings amount based on the recommended Savings Plans over the length of the lookback period.</p>
    public let estimatedSavingsAmount: String?
    /// <p>The estimated savings percentage relative to the total cost of applicable On-Demand usage over the lookback period.</p>
    public let estimatedSavingsPercentage: String?
    /// <p>The recommended hourly commitment level for the Savings Plans type, and configuration based on the usage during the lookback period.</p>
    public let hourlyCommitmentToPurchase: String?
    /// <p>Details for your recommended Savings Plans.</p>
    public let savingsPlansDetails: SavingsPlansDetails?
    /// <p>The upfront cost of the recommended Savings Plans, based on the selected payment option.</p>
    public let upfrontCost: String?

    public init (
        accountId: String? = nil,
        currencyCode: String? = nil,
        currentAverageHourlyOnDemandSpend: String? = nil,
        currentMaximumHourlyOnDemandSpend: String? = nil,
        currentMinimumHourlyOnDemandSpend: String? = nil,
        estimatedAverageUtilization: String? = nil,
        estimatedMonthlySavingsAmount: String? = nil,
        estimatedOnDemandCost: String? = nil,
        estimatedOnDemandCostWithCurrentCommitment: String? = nil,
        estimatedROI: String? = nil,
        estimatedSPCost: String? = nil,
        estimatedSavingsAmount: String? = nil,
        estimatedSavingsPercentage: String? = nil,
        hourlyCommitmentToPurchase: String? = nil,
        savingsPlansDetails: SavingsPlansDetails? = nil,
        upfrontCost: String? = nil
    )
    {
        self.accountId = accountId
        self.currencyCode = currencyCode
        self.currentAverageHourlyOnDemandSpend = currentAverageHourlyOnDemandSpend
        self.currentMaximumHourlyOnDemandSpend = currentMaximumHourlyOnDemandSpend
        self.currentMinimumHourlyOnDemandSpend = currentMinimumHourlyOnDemandSpend
        self.estimatedAverageUtilization = estimatedAverageUtilization
        self.estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount
        self.estimatedOnDemandCost = estimatedOnDemandCost
        self.estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitment
        self.estimatedROI = estimatedROI
        self.estimatedSPCost = estimatedSPCost
        self.estimatedSavingsAmount = estimatedSavingsAmount
        self.estimatedSavingsPercentage = estimatedSavingsPercentage
        self.hourlyCommitmentToPurchase = hourlyCommitmentToPurchase
        self.savingsPlansDetails = savingsPlansDetails
        self.upfrontCost = upfrontCost
    }
}

extension SavingsPlansPurchaseRecommendationMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalMetadata = "AdditionalMetadata"
        case generationTimestamp = "GenerationTimestamp"
        case recommendationId = "RecommendationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalMetadata = additionalMetadata {
            try encodeContainer.encode(additionalMetadata, forKey: .additionalMetadata)
        }
        if let generationTimestamp = generationTimestamp {
            try encodeContainer.encode(generationTimestamp, forKey: .generationTimestamp)
        }
        if let recommendationId = recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let generationTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .generationTimestamp)
        generationTimestamp = generationTimestampDecoded
        let additionalMetadataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .additionalMetadata)
        additionalMetadata = additionalMetadataDecoded
    }
}

extension SavingsPlansPurchaseRecommendationMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlansPurchaseRecommendationMetadata(additionalMetadata: \(String(describing: additionalMetadata)), generationTimestamp: \(String(describing: generationTimestamp)), recommendationId: \(String(describing: recommendationId)))"}
}

/// <p>Metadata about your Savings Plans Purchase Recommendations.</p>
public struct SavingsPlansPurchaseRecommendationMetadata: Equatable {
    /// <p>Additional metadata that may be applicable to the recommendation.</p>
    public let additionalMetadata: String?
    /// <p>The timestamp showing when the recommendations were generated.</p>
    public let generationTimestamp: String?
    /// <p>The unique identifier for the recommendation set.</p>
    public let recommendationId: String?

    public init (
        additionalMetadata: String? = nil,
        generationTimestamp: String? = nil,
        recommendationId: String? = nil
    )
    {
        self.additionalMetadata = additionalMetadata
        self.generationTimestamp = generationTimestamp
        self.recommendationId = recommendationId
    }
}

extension SavingsPlansPurchaseRecommendationSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currencyCode = "CurrencyCode"
        case currentOnDemandSpend = "CurrentOnDemandSpend"
        case dailyCommitmentToPurchase = "DailyCommitmentToPurchase"
        case estimatedMonthlySavingsAmount = "EstimatedMonthlySavingsAmount"
        case estimatedOnDemandCostWithCurrentCommitment = "EstimatedOnDemandCostWithCurrentCommitment"
        case estimatedROI = "EstimatedROI"
        case estimatedSavingsAmount = "EstimatedSavingsAmount"
        case estimatedSavingsPercentage = "EstimatedSavingsPercentage"
        case estimatedTotalCost = "EstimatedTotalCost"
        case hourlyCommitmentToPurchase = "HourlyCommitmentToPurchase"
        case totalRecommendationCount = "TotalRecommendationCount"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let currentOnDemandSpend = currentOnDemandSpend {
            try encodeContainer.encode(currentOnDemandSpend, forKey: .currentOnDemandSpend)
        }
        if let dailyCommitmentToPurchase = dailyCommitmentToPurchase {
            try encodeContainer.encode(dailyCommitmentToPurchase, forKey: .dailyCommitmentToPurchase)
        }
        if let estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount {
            try encodeContainer.encode(estimatedMonthlySavingsAmount, forKey: .estimatedMonthlySavingsAmount)
        }
        if let estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitment {
            try encodeContainer.encode(estimatedOnDemandCostWithCurrentCommitment, forKey: .estimatedOnDemandCostWithCurrentCommitment)
        }
        if let estimatedROI = estimatedROI {
            try encodeContainer.encode(estimatedROI, forKey: .estimatedROI)
        }
        if let estimatedSavingsAmount = estimatedSavingsAmount {
            try encodeContainer.encode(estimatedSavingsAmount, forKey: .estimatedSavingsAmount)
        }
        if let estimatedSavingsPercentage = estimatedSavingsPercentage {
            try encodeContainer.encode(estimatedSavingsPercentage, forKey: .estimatedSavingsPercentage)
        }
        if let estimatedTotalCost = estimatedTotalCost {
            try encodeContainer.encode(estimatedTotalCost, forKey: .estimatedTotalCost)
        }
        if let hourlyCommitmentToPurchase = hourlyCommitmentToPurchase {
            try encodeContainer.encode(hourlyCommitmentToPurchase, forKey: .hourlyCommitmentToPurchase)
        }
        if let totalRecommendationCount = totalRecommendationCount {
            try encodeContainer.encode(totalRecommendationCount, forKey: .totalRecommendationCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let estimatedROIDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedROI)
        estimatedROI = estimatedROIDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let estimatedTotalCostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedTotalCost)
        estimatedTotalCost = estimatedTotalCostDecoded
        let currentOnDemandSpendDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currentOnDemandSpend)
        currentOnDemandSpend = currentOnDemandSpendDecoded
        let estimatedSavingsAmountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedSavingsAmount)
        estimatedSavingsAmount = estimatedSavingsAmountDecoded
        let totalRecommendationCountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .totalRecommendationCount)
        totalRecommendationCount = totalRecommendationCountDecoded
        let dailyCommitmentToPurchaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dailyCommitmentToPurchase)
        dailyCommitmentToPurchase = dailyCommitmentToPurchaseDecoded
        let hourlyCommitmentToPurchaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hourlyCommitmentToPurchase)
        hourlyCommitmentToPurchase = hourlyCommitmentToPurchaseDecoded
        let estimatedSavingsPercentageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedSavingsPercentage)
        estimatedSavingsPercentage = estimatedSavingsPercentageDecoded
        let estimatedMonthlySavingsAmountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedMonthlySavingsAmount)
        estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmountDecoded
        let estimatedOnDemandCostWithCurrentCommitmentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedOnDemandCostWithCurrentCommitment)
        estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitmentDecoded
    }
}

extension SavingsPlansPurchaseRecommendationSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlansPurchaseRecommendationSummary(currencyCode: \(String(describing: currencyCode)), currentOnDemandSpend: \(String(describing: currentOnDemandSpend)), dailyCommitmentToPurchase: \(String(describing: dailyCommitmentToPurchase)), estimatedMonthlySavingsAmount: \(String(describing: estimatedMonthlySavingsAmount)), estimatedOnDemandCostWithCurrentCommitment: \(String(describing: estimatedOnDemandCostWithCurrentCommitment)), estimatedROI: \(String(describing: estimatedROI)), estimatedSavingsAmount: \(String(describing: estimatedSavingsAmount)), estimatedSavingsPercentage: \(String(describing: estimatedSavingsPercentage)), estimatedTotalCost: \(String(describing: estimatedTotalCost)), hourlyCommitmentToPurchase: \(String(describing: hourlyCommitmentToPurchase)), totalRecommendationCount: \(String(describing: totalRecommendationCount)))"}
}

/// <p>Summary metrics for your Savings Plans Purchase Recommendations.</p>
public struct SavingsPlansPurchaseRecommendationSummary: Equatable {
    /// <p>The currency code AWS used to generate the recommendations and present potential
    ///             savings.</p>
    public let currencyCode: String?
    /// <p>The current total on demand spend of the applicable usage types over the lookback period.</p>
    public let currentOnDemandSpend: String?
    /// <p>The recommended Savings Plans cost on a daily (24 hourly) basis.</p>
    public let dailyCommitmentToPurchase: String?
    /// <p>The estimated monthly savings amount, based on the recommended Savings Plans purchase.</p>
    public let estimatedMonthlySavingsAmount: String?
    /// <p>
    ///             The estimated On-Demand costs you would expect with no additional commitment, based on your usage of the selected time period and the Savings Plans you own.
    ///         </p>
    public let estimatedOnDemandCostWithCurrentCommitment: String?
    /// <p>The estimated return on investment based on the recommended Savings Plans and estimated savings.</p>
    public let estimatedROI: String?
    /// <p>The estimated total savings over the lookback period, based on the purchase of the recommended Savings Plans.</p>
    public let estimatedSavingsAmount: String?
    /// <p>The estimated savings relative to the total cost of On-Demand usage, over the lookback period. This is calculated as <code>estimatedSavingsAmount</code>/ <code>CurrentOnDemandSpend</code>*100.</p>
    public let estimatedSavingsPercentage: String?
    /// <p>The estimated total cost of the usage after purchasing the recommended Savings Plans. This is a sum of the cost of Savings Plans during this term, and the remaining On-Demand usage.</p>
    public let estimatedTotalCost: String?
    /// <p>The recommended hourly commitment based on the recommendation parameters.</p>
    public let hourlyCommitmentToPurchase: String?
    /// <p>The aggregate number of Savings Plans recommendations that exist for your account.</p>
    public let totalRecommendationCount: String?

    public init (
        currencyCode: String? = nil,
        currentOnDemandSpend: String? = nil,
        dailyCommitmentToPurchase: String? = nil,
        estimatedMonthlySavingsAmount: String? = nil,
        estimatedOnDemandCostWithCurrentCommitment: String? = nil,
        estimatedROI: String? = nil,
        estimatedSavingsAmount: String? = nil,
        estimatedSavingsPercentage: String? = nil,
        estimatedTotalCost: String? = nil,
        hourlyCommitmentToPurchase: String? = nil,
        totalRecommendationCount: String? = nil
    )
    {
        self.currencyCode = currencyCode
        self.currentOnDemandSpend = currentOnDemandSpend
        self.dailyCommitmentToPurchase = dailyCommitmentToPurchase
        self.estimatedMonthlySavingsAmount = estimatedMonthlySavingsAmount
        self.estimatedOnDemandCostWithCurrentCommitment = estimatedOnDemandCostWithCurrentCommitment
        self.estimatedROI = estimatedROI
        self.estimatedSavingsAmount = estimatedSavingsAmount
        self.estimatedSavingsPercentage = estimatedSavingsPercentage
        self.estimatedTotalCost = estimatedTotalCost
        self.hourlyCommitmentToPurchase = hourlyCommitmentToPurchase
        self.totalRecommendationCount = totalRecommendationCount
    }
}

extension SavingsPlansSavings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case netSavings = "NetSavings"
        case onDemandCostEquivalent = "OnDemandCostEquivalent"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let netSavings = netSavings {
            try encodeContainer.encode(netSavings, forKey: .netSavings)
        }
        if let onDemandCostEquivalent = onDemandCostEquivalent {
            try encodeContainer.encode(onDemandCostEquivalent, forKey: .onDemandCostEquivalent)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let netSavingsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .netSavings)
        netSavings = netSavingsDecoded
        let onDemandCostEquivalentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .onDemandCostEquivalent)
        onDemandCostEquivalent = onDemandCostEquivalentDecoded
    }
}

extension SavingsPlansSavings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlansSavings(netSavings: \(String(describing: netSavings)), onDemandCostEquivalent: \(String(describing: onDemandCostEquivalent)))"}
}

/// <p>The amount of savings you're accumulating, against the public On-Demand rate of the usage accrued in an account.</p>
public struct SavingsPlansSavings: Equatable {
    /// <p>The savings amount that you are accumulating for the usage that is covered by a Savings Plans, when compared to the On-Demand equivalent of the same usage.</p>
    public let netSavings: String?
    /// <p>How much the amount that the usage would have cost if it was
    ///             accrued
    ///             at the On-Demand rate.</p>
    public let onDemandCostEquivalent: String?

    public init (
        netSavings: String? = nil,
        onDemandCostEquivalent: String? = nil
    )
    {
        self.netSavings = netSavings
        self.onDemandCostEquivalent = onDemandCostEquivalent
    }
}

extension SavingsPlansUtilization: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case totalCommitment = "TotalCommitment"
        case unusedCommitment = "UnusedCommitment"
        case usedCommitment = "UsedCommitment"
        case utilizationPercentage = "UtilizationPercentage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let totalCommitment = totalCommitment {
            try encodeContainer.encode(totalCommitment, forKey: .totalCommitment)
        }
        if let unusedCommitment = unusedCommitment {
            try encodeContainer.encode(unusedCommitment, forKey: .unusedCommitment)
        }
        if let usedCommitment = usedCommitment {
            try encodeContainer.encode(usedCommitment, forKey: .usedCommitment)
        }
        if let utilizationPercentage = utilizationPercentage {
            try encodeContainer.encode(utilizationPercentage, forKey: .utilizationPercentage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalCommitmentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .totalCommitment)
        totalCommitment = totalCommitmentDecoded
        let usedCommitmentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .usedCommitment)
        usedCommitment = usedCommitmentDecoded
        let unusedCommitmentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unusedCommitment)
        unusedCommitment = unusedCommitmentDecoded
        let utilizationPercentageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .utilizationPercentage)
        utilizationPercentage = utilizationPercentageDecoded
    }
}

extension SavingsPlansUtilization: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlansUtilization(totalCommitment: \(String(describing: totalCommitment)), unusedCommitment: \(String(describing: unusedCommitment)), usedCommitment: \(String(describing: usedCommitment)), utilizationPercentage: \(String(describing: utilizationPercentage)))"}
}

/// <p>The measurement of how well you are using your existing Savings Plans.</p>
public struct SavingsPlansUtilization: Equatable {
    /// <p>The total amount of Savings Plans commitment that's been purchased in an account (or set of accounts).</p>
    public let totalCommitment: String?
    /// <p>The amount of your Savings Plans commitment that was not consumed from Savings Plans eligible usage in a specific period.</p>
    public let unusedCommitment: String?
    /// <p>The amount of your Savings Plans commitment that was consumed from Savings Plans eligible usage in a specific period.</p>
    public let usedCommitment: String?
    /// <p>The amount of <code>UsedCommitment</code> divided by the <code>TotalCommitment</code> for your Savings Plans.</p>
    public let utilizationPercentage: String?

    public init (
        totalCommitment: String? = nil,
        unusedCommitment: String? = nil,
        usedCommitment: String? = nil,
        utilizationPercentage: String? = nil
    )
    {
        self.totalCommitment = totalCommitment
        self.unusedCommitment = unusedCommitment
        self.usedCommitment = usedCommitment
        self.utilizationPercentage = utilizationPercentage
    }
}

extension SavingsPlansUtilizationAggregates: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amortizedCommitment = "AmortizedCommitment"
        case savings = "Savings"
        case utilization = "Utilization"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amortizedCommitment = amortizedCommitment {
            try encodeContainer.encode(amortizedCommitment, forKey: .amortizedCommitment)
        }
        if let savings = savings {
            try encodeContainer.encode(savings, forKey: .savings)
        }
        if let utilization = utilization {
            try encodeContainer.encode(utilization, forKey: .utilization)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let utilizationDecoded = try containerValues.decodeIfPresent(SavingsPlansUtilization.self, forKey: .utilization)
        utilization = utilizationDecoded
        let savingsDecoded = try containerValues.decodeIfPresent(SavingsPlansSavings.self, forKey: .savings)
        savings = savingsDecoded
        let amortizedCommitmentDecoded = try containerValues.decodeIfPresent(SavingsPlansAmortizedCommitment.self, forKey: .amortizedCommitment)
        amortizedCommitment = amortizedCommitmentDecoded
    }
}

extension SavingsPlansUtilizationAggregates: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlansUtilizationAggregates(amortizedCommitment: \(String(describing: amortizedCommitment)), savings: \(String(describing: savings)), utilization: \(String(describing: utilization)))"}
}

/// <p>The aggregated utilization metrics for your Savings Plans usage.</p>
public struct SavingsPlansUtilizationAggregates: Equatable {
    /// <p>The total amortized commitment for a Savings Plans. This includes the sum of the upfront and recurring Savings Plans fees.</p>
    public let amortizedCommitment: SavingsPlansAmortizedCommitment?
    /// <p>The amount saved by using existing Savings Plans. Savings returns both net savings from Savings Plans, as well as the <code>onDemandCostEquivalent</code> of the Savings Plans when considering the utilization rate.</p>
    public let savings: SavingsPlansSavings?
    /// <p>A ratio of your effectiveness of using existing Savings Plans to apply to workloads that are Savings Plans eligible.</p>
    public let utilization: SavingsPlansUtilization?

    public init (
        amortizedCommitment: SavingsPlansAmortizedCommitment? = nil,
        savings: SavingsPlansSavings? = nil,
        utilization: SavingsPlansUtilization? = nil
    )
    {
        self.amortizedCommitment = amortizedCommitment
        self.savings = savings
        self.utilization = utilization
    }
}

extension SavingsPlansUtilizationByTime: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amortizedCommitment = "AmortizedCommitment"
        case savings = "Savings"
        case timePeriod = "TimePeriod"
        case utilization = "Utilization"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amortizedCommitment = amortizedCommitment {
            try encodeContainer.encode(amortizedCommitment, forKey: .amortizedCommitment)
        }
        if let savings = savings {
            try encodeContainer.encode(savings, forKey: .savings)
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
        if let utilization = utilization {
            try encodeContainer.encode(utilization, forKey: .utilization)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let utilizationDecoded = try containerValues.decodeIfPresent(SavingsPlansUtilization.self, forKey: .utilization)
        utilization = utilizationDecoded
        let savingsDecoded = try containerValues.decodeIfPresent(SavingsPlansSavings.self, forKey: .savings)
        savings = savingsDecoded
        let amortizedCommitmentDecoded = try containerValues.decodeIfPresent(SavingsPlansAmortizedCommitment.self, forKey: .amortizedCommitment)
        amortizedCommitment = amortizedCommitmentDecoded
    }
}

extension SavingsPlansUtilizationByTime: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlansUtilizationByTime(amortizedCommitment: \(String(describing: amortizedCommitment)), savings: \(String(describing: savings)), timePeriod: \(String(describing: timePeriod)), utilization: \(String(describing: utilization)))"}
}

/// <p>The amount of Savings Plans utilization, in hours.</p>
public struct SavingsPlansUtilizationByTime: Equatable {
    /// <p>The total amortized commitment for a Savings Plans. This includes the sum of the upfront and recurring Savings Plans fees.</p>
    public let amortizedCommitment: SavingsPlansAmortizedCommitment?
    /// <p>The amount saved by using existing Savings Plans. Savings returns both net savings from Savings Plans as well as the <code>onDemandCostEquivalent</code> of the Savings Plans when considering the utilization rate.</p>
    public let savings: SavingsPlansSavings?
    /// <p>The time period of the request.
    ///         </p>
    public let timePeriod: DateInterval?
    /// <p>A ratio of your effectiveness of using existing Savings Plans to apply to workloads that are Savings Plans eligible.</p>
    public let utilization: SavingsPlansUtilization?

    public init (
        amortizedCommitment: SavingsPlansAmortizedCommitment? = nil,
        savings: SavingsPlansSavings? = nil,
        timePeriod: DateInterval? = nil,
        utilization: SavingsPlansUtilization? = nil
    )
    {
        self.amortizedCommitment = amortizedCommitment
        self.savings = savings
        self.timePeriod = timePeriod
        self.utilization = utilization
    }
}

extension SavingsPlansUtilizationDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amortizedCommitment = "AmortizedCommitment"
        case attributes = "Attributes"
        case savings = "Savings"
        case savingsPlanArn = "SavingsPlanArn"
        case utilization = "Utilization"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amortizedCommitment = amortizedCommitment {
            try encodeContainer.encode(amortizedCommitment, forKey: .amortizedCommitment)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, attributes0) in attributes {
                try attributesContainer.encode(attributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let savings = savings {
            try encodeContainer.encode(savings, forKey: .savings)
        }
        if let savingsPlanArn = savingsPlanArn {
            try encodeContainer.encode(savingsPlanArn, forKey: .savingsPlanArn)
        }
        if let utilization = utilization {
            try encodeContainer.encode(utilization, forKey: .utilization)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlanArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .savingsPlanArn)
        savingsPlanArn = savingsPlanArnDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, attributevalue0) in attributesContainer {
                if let attributevalue0 = attributevalue0 {
                    attributesDecoded0?[key0] = attributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let utilizationDecoded = try containerValues.decodeIfPresent(SavingsPlansUtilization.self, forKey: .utilization)
        utilization = utilizationDecoded
        let savingsDecoded = try containerValues.decodeIfPresent(SavingsPlansSavings.self, forKey: .savings)
        savings = savingsDecoded
        let amortizedCommitmentDecoded = try containerValues.decodeIfPresent(SavingsPlansAmortizedCommitment.self, forKey: .amortizedCommitment)
        amortizedCommitment = amortizedCommitmentDecoded
    }
}

extension SavingsPlansUtilizationDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SavingsPlansUtilizationDetail(amortizedCommitment: \(String(describing: amortizedCommitment)), attributes: \(String(describing: attributes)), savings: \(String(describing: savings)), savingsPlanArn: \(String(describing: savingsPlanArn)), utilization: \(String(describing: utilization)))"}
}

/// <p>A single daily or monthly Savings Plans utilization rate, and details for your account. A management account in an organization have access to member accounts. You can use <code>GetDimensionValues</code> to determine the possible dimension values. </p>
public struct SavingsPlansUtilizationDetail: Equatable {
    /// <p>The total amortized commitment for a Savings Plans. Includes the sum of the upfront and recurring Savings Plans fees.</p>
    public let amortizedCommitment: SavingsPlansAmortizedCommitment?
    /// <p>The attribute that applies to a specific <code>Dimension</code>.</p>
    public let attributes: [String:String]?
    /// <p>The amount saved by using existing Savings Plans. Savings returns both net savings from savings plans as well as the <code>onDemandCostEquivalent</code> of the Savings Plans when considering the utilization rate.</p>
    public let savings: SavingsPlansSavings?
    /// <p>The unique Amazon Resource Name (ARN) for a particular Savings Plan.</p>
    public let savingsPlanArn: String?
    /// <p>A ratio of your effectiveness of using existing Savings Plans to apply to workloads that are Savings Plans eligible.</p>
    public let utilization: SavingsPlansUtilization?

    public init (
        amortizedCommitment: SavingsPlansAmortizedCommitment? = nil,
        attributes: [String:String]? = nil,
        savings: SavingsPlansSavings? = nil,
        savingsPlanArn: String? = nil,
        utilization: SavingsPlansUtilization? = nil
    )
    {
        self.amortizedCommitment = amortizedCommitment
        self.attributes = attributes
        self.savings = savings
        self.savingsPlanArn = savingsPlanArn
        self.utilization = utilization
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p> You've reached the limit on the number of resources you can create, or exceeded the
///             size of an individual resource. </p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceSpecification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eC2Specification = "EC2Specification"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eC2Specification = eC2Specification {
            try encodeContainer.encode(eC2Specification, forKey: .eC2Specification)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eC2SpecificationDecoded = try containerValues.decodeIfPresent(EC2Specification.self, forKey: .eC2Specification)
        eC2Specification = eC2SpecificationDecoded
    }
}

extension ServiceSpecification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceSpecification(eC2Specification: \(String(describing: eC2Specification)))"}
}

/// <p>Hardware specifications for the service that you want recommendations
///             for.</p>
public struct ServiceSpecification: Equatable {
    /// <p>The Amazon EC2 hardware specifications that you want AWS to provide recommendations
    ///             for.</p>
    public let eC2Specification: EC2Specification?

    public init (
        eC2Specification: EC2Specification? = nil
    )
    {
        self.eC2Specification = eC2Specification
    }
}

extension SortDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension SortDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SortDefinition(key: \(String(describing: key)), sortOrder: \(String(describing: sortOrder)))"}
}

/// <p>The details of how to sort the data.</p>
public struct SortDefinition: Equatable {
    /// <p>The key by which to sort the data.</p>
    public let key: String?
    /// <p>The order in which to sort the data.</p>
    public let sortOrder: SortOrder?

    public init (
        key: String? = nil,
        sortOrder: SortOrder? = nil
    )
    {
        self.key = key
        self.sortOrder = sortOrder
    }
}

public enum SortOrder {
    case ascending
    case descending
    case sdkUnknown(String)
}

extension SortOrder : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SortOrder] {
        return [
            .ascending,
            .descending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ascending: return "ASCENDING"
        case .descending: return "DESCENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
    }
}

extension Subscriber: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case status = "Status"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SubscriberType.self, forKey: .type)
        type = typeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SubscriberStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension Subscriber: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Subscriber(address: \(String(describing: address)), status: \(String(describing: status)), type: \(String(describing: type)))"}
}

/// <p>
///         The recipient of <code>AnomalySubscription</code> notifications.
///     </p>
public struct Subscriber: Equatable {
    /// <p> The email address or SNS Amazon Resource Name (ARN), depending on the <code>Type</code>. </p>
    public let address: String?
    /// <p> Indicates if the subscriber accepts the notifications. </p>
    public let status: SubscriberStatus?
    /// <p>
    ///         The notification delivery channel.
    ///     </p>
    public let type: SubscriberType?

    public init (
        address: String? = nil,
        status: SubscriberStatus? = nil,
        type: SubscriberType? = nil
    )
    {
        self.address = address
        self.status = status
        self.type = type
    }
}

public enum SubscriberStatus {
    case confirmed
    case declined
    case sdkUnknown(String)
}

extension SubscriberStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SubscriberStatus] {
        return [
            .confirmed,
            .declined,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .confirmed: return "CONFIRMED"
        case .declined: return "DECLINED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SubscriberStatus(rawValue: rawValue) ?? SubscriberStatus.sdkUnknown(rawValue)
    }
}

public enum SubscriberType {
    case email
    case sns
    case sdkUnknown(String)
}

extension SubscriberType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SubscriberType] {
        return [
            .email,
            .sns,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .email: return "EMAIL"
        case .sns: return "SNS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SubscriberType(rawValue: rawValue) ?? SubscriberType.sdkUnknown(rawValue)
    }
}

public enum SupportedSavingsPlansType {
    case computeSp
    case ec2InstanceSp
    case sagemakerSp
    case sdkUnknown(String)
}

extension SupportedSavingsPlansType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SupportedSavingsPlansType] {
        return [
            .computeSp,
            .ec2InstanceSp,
            .sagemakerSp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .computeSp: return "COMPUTE_SP"
        case .ec2InstanceSp: return "EC2_INSTANCE_SP"
        case .sagemakerSp: return "SAGEMAKER_SP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SupportedSavingsPlansType(rawValue: rawValue) ?? SupportedSavingsPlansType.sdkUnknown(rawValue)
    }
}

extension TagValues: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case matchOptions = "MatchOptions"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let matchOptions = matchOptions {
            var matchOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchOptions)
            for matchoptions0 in matchOptions {
                try matchOptionsContainer.encode(matchoptions0.rawValue)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for values0 in values {
                try valuesContainer.encode(values0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
        let matchOptionsContainer = try containerValues.decodeIfPresent([MatchOption?].self, forKey: .matchOptions)
        var matchOptionsDecoded0:[MatchOption]? = nil
        if let matchOptionsContainer = matchOptionsContainer {
            matchOptionsDecoded0 = [MatchOption]()
            for string0 in matchOptionsContainer {
                if let string0 = string0 {
                    matchOptionsDecoded0?.append(string0)
                }
            }
        }
        matchOptions = matchOptionsDecoded0
    }
}

extension TagValues: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagValues(key: \(String(describing: key)), matchOptions: \(String(describing: matchOptions)), values: \(String(describing: values)))"}
}

/// <p>The values that are available for a tag.</p>
/// 		       <p>If <code>Values</code> and <code>Key</code> are not specified, the <code>ABSENT</code>
///             <code>MatchOption</code> is applied to all tags. That is, filtering on resources with no tags.</p>
///          <p>If <code>Values</code> is provided and <code>Key</code> is not specified, the <code>ABSENT</code>
///             <code>MatchOption</code> is applied to the tag <code>Key</code> only. That is, filtering on resources without the given tag key.</p>
public struct TagValues: Equatable {
    /// <p>The key for the tag.</p>
    public let key: String?
    /// <p>The match options that you can use to filter your results.
    ///                 <code>MatchOptions</code> is only applicable for actions related to Cost Category.
    ///             The default values for <code>MatchOptions</code> are <code>EQUALS</code> and
    ///                 <code>CASE_SENSITIVE</code>.</p>
    public let matchOptions: [MatchOption]?
    /// <p>The specific value of the tag.</p>
    public let values: [String]?

    public init (
        key: String? = nil,
        matchOptions: [MatchOption]? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.matchOptions = matchOptions
        self.values = values
    }
}

extension TargetInstance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currencyCode = "CurrencyCode"
        case defaultTargetInstance = "DefaultTargetInstance"
        case estimatedMonthlyCost = "EstimatedMonthlyCost"
        case estimatedMonthlySavings = "EstimatedMonthlySavings"
        case expectedResourceUtilization = "ExpectedResourceUtilization"
        case platformDifferences = "PlatformDifferences"
        case resourceDetails = "ResourceDetails"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if defaultTargetInstance != false {
            try encodeContainer.encode(defaultTargetInstance, forKey: .defaultTargetInstance)
        }
        if let estimatedMonthlyCost = estimatedMonthlyCost {
            try encodeContainer.encode(estimatedMonthlyCost, forKey: .estimatedMonthlyCost)
        }
        if let estimatedMonthlySavings = estimatedMonthlySavings {
            try encodeContainer.encode(estimatedMonthlySavings, forKey: .estimatedMonthlySavings)
        }
        if let expectedResourceUtilization = expectedResourceUtilization {
            try encodeContainer.encode(expectedResourceUtilization, forKey: .expectedResourceUtilization)
        }
        if let platformDifferences = platformDifferences {
            var platformDifferencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .platformDifferences)
            for platformdifferences0 in platformDifferences {
                try platformDifferencesContainer.encode(platformdifferences0.rawValue)
            }
        }
        if let resourceDetails = resourceDetails {
            try encodeContainer.encode(resourceDetails, forKey: .resourceDetails)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let estimatedMonthlyCostDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedMonthlyCost)
        estimatedMonthlyCost = estimatedMonthlyCostDecoded
        let estimatedMonthlySavingsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedMonthlySavings)
        estimatedMonthlySavings = estimatedMonthlySavingsDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let defaultTargetInstanceDecoded = try containerValues.decode(Bool.self, forKey: .defaultTargetInstance)
        defaultTargetInstance = defaultTargetInstanceDecoded
        let resourceDetailsDecoded = try containerValues.decodeIfPresent(ResourceDetails.self, forKey: .resourceDetails)
        resourceDetails = resourceDetailsDecoded
        let expectedResourceUtilizationDecoded = try containerValues.decodeIfPresent(ResourceUtilization.self, forKey: .expectedResourceUtilization)
        expectedResourceUtilization = expectedResourceUtilizationDecoded
        let platformDifferencesContainer = try containerValues.decodeIfPresent([PlatformDifference?].self, forKey: .platformDifferences)
        var platformDifferencesDecoded0:[PlatformDifference]? = nil
        if let platformDifferencesContainer = platformDifferencesContainer {
            platformDifferencesDecoded0 = [PlatformDifference]()
            for string0 in platformDifferencesContainer {
                if let string0 = string0 {
                    platformDifferencesDecoded0?.append(string0)
                }
            }
        }
        platformDifferences = platformDifferencesDecoded0
    }
}

extension TargetInstance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TargetInstance(currencyCode: \(String(describing: currencyCode)), defaultTargetInstance: \(String(describing: defaultTargetInstance)), estimatedMonthlyCost: \(String(describing: estimatedMonthlyCost)), estimatedMonthlySavings: \(String(describing: estimatedMonthlySavings)), expectedResourceUtilization: \(String(describing: expectedResourceUtilization)), platformDifferences: \(String(describing: platformDifferences)), resourceDetails: \(String(describing: resourceDetails)))"}
}

/// <p> Details on recommended instance.</p>
public struct TargetInstance: Equatable {
    /// <p> The currency code that AWS used to calculate the costs for this instance.</p>
    public let currencyCode: String?
    /// <p> Indicates whether this recommendation is the defaulted AWS recommendation.</p>
    public let defaultTargetInstance: Bool
    /// <p> Expected cost to operate this instance type on a monthly basis.</p>
    public let estimatedMonthlyCost: String?
    /// <p> Estimated savings resulting from modification, on a monthly basis.</p>
    public let estimatedMonthlySavings: String?
    /// <p> Expected utilization metrics for target instance type.</p>
    public let expectedResourceUtilization: ResourceUtilization?
    /// <p>
    ///             Explains the actions you might need to take in order to successfully migrate your workloads from the current instance type to the recommended instance type.
    ///         </p>
    public let platformDifferences: [PlatformDifference]?
    /// <p> Details on the target instance type.  </p>
    public let resourceDetails: ResourceDetails?

    public init (
        currencyCode: String? = nil,
        defaultTargetInstance: Bool = false,
        estimatedMonthlyCost: String? = nil,
        estimatedMonthlySavings: String? = nil,
        expectedResourceUtilization: ResourceUtilization? = nil,
        platformDifferences: [PlatformDifference]? = nil,
        resourceDetails: ResourceDetails? = nil
    )
    {
        self.currencyCode = currencyCode
        self.defaultTargetInstance = defaultTargetInstance
        self.estimatedMonthlyCost = estimatedMonthlyCost
        self.estimatedMonthlySavings = estimatedMonthlySavings
        self.expectedResourceUtilization = expectedResourceUtilization
        self.platformDifferences = platformDifferences
        self.resourceDetails = resourceDetails
    }
}

public enum TermInYears {
    case oneYear
    case threeYears
    case sdkUnknown(String)
}

extension TermInYears : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TermInYears] {
        return [
            .oneYear,
            .threeYears,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .oneYear: return "ONE_YEAR"
        case .threeYears: return "THREE_YEARS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TermInYears(rawValue: rawValue) ?? TermInYears.sdkUnknown(rawValue)
    }
}

extension TerminateRecommendationDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currencyCode = "CurrencyCode"
        case estimatedMonthlySavings = "EstimatedMonthlySavings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencyCode = currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let estimatedMonthlySavings = estimatedMonthlySavings {
            try encodeContainer.encode(estimatedMonthlySavings, forKey: .estimatedMonthlySavings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let estimatedMonthlySavingsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .estimatedMonthlySavings)
        estimatedMonthlySavings = estimatedMonthlySavingsDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
    }
}

extension TerminateRecommendationDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TerminateRecommendationDetail(currencyCode: \(String(describing: currencyCode)), estimatedMonthlySavings: \(String(describing: estimatedMonthlySavings)))"}
}

/// <p> Details on termination recommendation.  </p>
public struct TerminateRecommendationDetail: Equatable {
    /// <p> The currency code that AWS used to calculate the costs for this instance.</p>
    public let currencyCode: String?
    /// <p> Estimated savings resulting from modification, on a monthly basis.</p>
    public let estimatedMonthlySavings: String?

    public init (
        currencyCode: String? = nil,
        estimatedMonthlySavings: String? = nil
    )
    {
        self.currencyCode = currencyCode
        self.estimatedMonthlySavings = estimatedMonthlySavings
    }
}

extension TotalImpactFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endValue = "EndValue"
        case numericOperator = "NumericOperator"
        case startValue = "StartValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if endValue != 0.0 {
            try encodeContainer.encode(endValue, forKey: .endValue)
        }
        if let numericOperator = numericOperator {
            try encodeContainer.encode(numericOperator.rawValue, forKey: .numericOperator)
        }
        if startValue != 0.0 {
            try encodeContainer.encode(startValue, forKey: .startValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numericOperatorDecoded = try containerValues.decodeIfPresent(NumericOperator.self, forKey: .numericOperator)
        numericOperator = numericOperatorDecoded
        let startValueDecoded = try containerValues.decode(Double.self, forKey: .startValue)
        startValue = startValueDecoded
        let endValueDecoded = try containerValues.decode(Double.self, forKey: .endValue)
        endValue = endValueDecoded
    }
}

extension TotalImpactFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TotalImpactFilter(endValue: \(String(describing: endValue)), numericOperator: \(String(describing: numericOperator)), startValue: \(String(describing: startValue)))"}
}

/// <p> Filters cost anomalies based on the total impact. </p>
public struct TotalImpactFilter: Equatable {
    /// <p> The upper bound dollar value used in the filter. </p>
    public let endValue: Double
    /// <p>
    ///         The comparing value used in the filter.
    ///     </p>
    public let numericOperator: NumericOperator?
    /// <p>
    ///         The lower bound dollar value used in the filter.
    ///     </p>
    public let startValue: Double

    public init (
        endValue: Double = 0.0,
        numericOperator: NumericOperator? = nil,
        startValue: Double = 0.0
    )
    {
        self.endValue = endValue
        self.numericOperator = numericOperator
        self.startValue = startValue
    }
}

extension UnknownMonitorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnknownMonitorException(message: \(String(describing: message)))"}
}

extension UnknownMonitorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnknownMonitorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cost anomaly monitor does not exist for the account.
///         </p>
public struct UnknownMonitorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnknownMonitorExceptionBody: Equatable {
    public let message: String?
}

extension UnknownMonitorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnknownSubscriptionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnknownSubscriptionException(message: \(String(describing: message)))"}
}

extension UnknownSubscriptionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnknownSubscriptionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The cost anomaly subscription does not exist for the account.
///         </p>
public struct UnknownSubscriptionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnknownSubscriptionExceptionBody: Equatable {
    public let message: String?
}

extension UnknownSubscriptionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnresolvableUsageUnitException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnresolvableUsageUnitException(message: \(String(describing: message)))"}
}

extension UnresolvableUsageUnitException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnresolvableUsageUnitExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Cost Explorer was unable to identify the usage unit. Provide <code>UsageType/UsageTypeGroup</code> filter selections that contain matching units, for example: <code>hours</code>.</p>
public struct UnresolvableUsageUnitException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct UnresolvableUsageUnitExceptionBody: Equatable {
    public let message: String?
}

extension UnresolvableUsageUnitExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateAnomalyMonitorInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAnomalyMonitorInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAnomalyMonitorInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAnomalyMonitorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAnomalyMonitorInput>
    public typealias MOutput = OperationOutput<UpdateAnomalyMonitorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAnomalyMonitorOutputError>
}

extension UpdateAnomalyMonitorInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAnomalyMonitorInput(monitorArn: \(String(describing: monitorArn)), monitorName: \(String(describing: monitorName)))"}
}

extension UpdateAnomalyMonitorInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case monitorArn = "MonitorArn"
        case monitorName = "MonitorName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let monitorArn = monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let monitorName = monitorName {
            try encodeContainer.encode(monitorName, forKey: .monitorName)
        }
    }
}

public struct UpdateAnomalyMonitorInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAnomalyMonitorInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAnomalyMonitorInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAnomalyMonitorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAnomalyMonitorInput>
    public typealias MOutput = OperationOutput<UpdateAnomalyMonitorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAnomalyMonitorOutputError>
}

public struct UpdateAnomalyMonitorInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAnomalyMonitorInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAnomalyMonitorInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAnomalyMonitorOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAnomalyMonitorInput>
    public typealias MOutput = OperationOutput<UpdateAnomalyMonitorOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAnomalyMonitorOutputError>
}

public struct UpdateAnomalyMonitorInput: Equatable {
    /// <p> Cost anomaly monitor Amazon Resource Names (ARNs). </p>
    public let monitorArn: String?
    /// <p>
    ///       The new name for the cost anomaly monitor.
    ///     </p>
    public let monitorName: String?

    public init (
        monitorArn: String? = nil,
        monitorName: String? = nil
    )
    {
        self.monitorArn = monitorArn
        self.monitorName = monitorName
    }
}

struct UpdateAnomalyMonitorInputBody: Equatable {
    public let monitorArn: String?
    public let monitorName: String?
}

extension UpdateAnomalyMonitorInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case monitorArn = "MonitorArn"
        case monitorName = "MonitorName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let monitorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .monitorName)
        monitorName = monitorNameDecoded
    }
}

extension UpdateAnomalyMonitorOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAnomalyMonitorOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownMonitorException" : self = .unknownMonitorException(try UnknownMonitorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAnomalyMonitorOutputError: Swift.Error, Equatable {
    case limitExceededException(LimitExceededException)
    case unknownMonitorException(UnknownMonitorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAnomalyMonitorOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAnomalyMonitorOutputResponse(monitorArn: \(String(describing: monitorArn)))"}
}

extension UpdateAnomalyMonitorOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAnomalyMonitorOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.monitorArn = output.monitorArn
        } else {
            self.monitorArn = nil
        }
    }
}

public struct UpdateAnomalyMonitorOutputResponse: Equatable {
    /// <p>
    ///       A cost anomaly monitor ARN.
    ///     </p>
    public let monitorArn: String?

    public init (
        monitorArn: String? = nil
    )
    {
        self.monitorArn = monitorArn
    }
}

struct UpdateAnomalyMonitorOutputResponseBody: Equatable {
    public let monitorArn: String?
}

extension UpdateAnomalyMonitorOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case monitorArn = "MonitorArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
    }
}

public struct UpdateAnomalySubscriptionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAnomalySubscriptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAnomalySubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAnomalySubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAnomalySubscriptionInput>
    public typealias MOutput = OperationOutput<UpdateAnomalySubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAnomalySubscriptionOutputError>
}

extension UpdateAnomalySubscriptionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAnomalySubscriptionInput(frequency: \(String(describing: frequency)), monitorArnList: \(String(describing: monitorArnList)), subscribers: \(String(describing: subscribers)), subscriptionArn: \(String(describing: subscriptionArn)), subscriptionName: \(String(describing: subscriptionName)), threshold: \(String(describing: threshold)))"}
}

extension UpdateAnomalySubscriptionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case frequency = "Frequency"
        case monitorArnList = "MonitorArnList"
        case subscribers = "Subscribers"
        case subscriptionArn = "SubscriptionArn"
        case subscriptionName = "SubscriptionName"
        case threshold = "Threshold"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let frequency = frequency {
            try encodeContainer.encode(frequency.rawValue, forKey: .frequency)
        }
        if let monitorArnList = monitorArnList {
            var monitorArnListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monitorArnList)
            for monitorarnlist0 in monitorArnList {
                try monitorArnListContainer.encode(monitorarnlist0)
            }
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscribers0 in subscribers {
                try subscribersContainer.encode(subscribers0)
            }
        }
        if let subscriptionArn = subscriptionArn {
            try encodeContainer.encode(subscriptionArn, forKey: .subscriptionArn)
        }
        if let subscriptionName = subscriptionName {
            try encodeContainer.encode(subscriptionName, forKey: .subscriptionName)
        }
        if let threshold = threshold {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
    }
}

public struct UpdateAnomalySubscriptionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAnomalySubscriptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAnomalySubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAnomalySubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAnomalySubscriptionInput>
    public typealias MOutput = OperationOutput<UpdateAnomalySubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAnomalySubscriptionOutputError>
}

public struct UpdateAnomalySubscriptionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAnomalySubscriptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAnomalySubscriptionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAnomalySubscriptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAnomalySubscriptionInput>
    public typealias MOutput = OperationOutput<UpdateAnomalySubscriptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAnomalySubscriptionOutputError>
}

public struct UpdateAnomalySubscriptionInput: Equatable {
    /// <p>
    ///       The update to the frequency value at which subscribers will receive notifications.
    ///     </p>
    public let frequency: AnomalySubscriptionFrequency?
    /// <p>
    ///       A list of cost anomaly monitor ARNs.
    ///     </p>
    public let monitorArnList: [String]?
    /// <p>
    ///       The update to the subscriber list.
    ///     </p>
    public let subscribers: [Subscriber]?
    /// <p> A cost anomaly subscription Amazon Resource Name (ARN). </p>
    public let subscriptionArn: String?
    /// <p>
    ///       The subscription's new name.
    ///     </p>
    public let subscriptionName: String?
    /// <p>
    ///       The update to the threshold value for receiving notifications.
    ///     </p>
    public let threshold: Double?

    public init (
        frequency: AnomalySubscriptionFrequency? = nil,
        monitorArnList: [String]? = nil,
        subscribers: [Subscriber]? = nil,
        subscriptionArn: String? = nil,
        subscriptionName: String? = nil,
        threshold: Double? = nil
    )
    {
        self.frequency = frequency
        self.monitorArnList = monitorArnList
        self.subscribers = subscribers
        self.subscriptionArn = subscriptionArn
        self.subscriptionName = subscriptionName
        self.threshold = threshold
    }
}

struct UpdateAnomalySubscriptionInputBody: Equatable {
    public let subscriptionArn: String?
    public let threshold: Double?
    public let frequency: AnomalySubscriptionFrequency?
    public let monitorArnList: [String]?
    public let subscribers: [Subscriber]?
    public let subscriptionName: String?
}

extension UpdateAnomalySubscriptionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case frequency = "Frequency"
        case monitorArnList = "MonitorArnList"
        case subscribers = "Subscribers"
        case subscriptionArn = "SubscriptionArn"
        case subscriptionName = "SubscriptionName"
        case threshold = "Threshold"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .threshold)
        threshold = thresholdDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(AnomalySubscriptionFrequency.self, forKey: .frequency)
        frequency = frequencyDecoded
        let monitorArnListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .monitorArnList)
        var monitorArnListDecoded0:[String]? = nil
        if let monitorArnListContainer = monitorArnListContainer {
            monitorArnListDecoded0 = [String]()
            for string0 in monitorArnListContainer {
                if let string0 = string0 {
                    monitorArnListDecoded0?.append(string0)
                }
            }
        }
        monitorArnList = monitorArnListDecoded0
        let subscribersContainer = try containerValues.decodeIfPresent([Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
        let subscriptionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionName)
        subscriptionName = subscriptionNameDecoded
    }
}

extension UpdateAnomalySubscriptionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAnomalySubscriptionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownMonitorException" : self = .unknownMonitorException(try UnknownMonitorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnknownSubscriptionException" : self = .unknownSubscriptionException(try UnknownSubscriptionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAnomalySubscriptionOutputError: Swift.Error, Equatable {
    case limitExceededException(LimitExceededException)
    case unknownMonitorException(UnknownMonitorException)
    case unknownSubscriptionException(UnknownSubscriptionException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAnomalySubscriptionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAnomalySubscriptionOutputResponse(subscriptionArn: \(String(describing: subscriptionArn)))"}
}

extension UpdateAnomalySubscriptionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAnomalySubscriptionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.subscriptionArn = output.subscriptionArn
        } else {
            self.subscriptionArn = nil
        }
    }
}

public struct UpdateAnomalySubscriptionOutputResponse: Equatable {
    /// <p>
    ///       A cost anomaly subscription ARN.
    ///     </p>
    public let subscriptionArn: String?

    public init (
        subscriptionArn: String? = nil
    )
    {
        self.subscriptionArn = subscriptionArn
    }
}

struct UpdateAnomalySubscriptionOutputResponseBody: Equatable {
    public let subscriptionArn: String?
}

extension UpdateAnomalySubscriptionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case subscriptionArn = "SubscriptionArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subscriptionArn)
        subscriptionArn = subscriptionArnDecoded
    }
}

public struct UpdateCostCategoryDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateCostCategoryDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCostCategoryDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCostCategoryDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCostCategoryDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateCostCategoryDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCostCategoryDefinitionOutputError>
}

extension UpdateCostCategoryDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCostCategoryDefinitionInput(costCategoryArn: \(String(describing: costCategoryArn)), defaultValue: \(String(describing: defaultValue)), ruleVersion: \(String(describing: ruleVersion)), rules: \(String(describing: rules)))"}
}

extension UpdateCostCategoryDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case defaultValue = "DefaultValue"
        case ruleVersion = "RuleVersion"
        case rules = "Rules"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costCategoryArn = costCategoryArn {
            try encodeContainer.encode(costCategoryArn, forKey: .costCategoryArn)
        }
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let ruleVersion = ruleVersion {
            try encodeContainer.encode(ruleVersion.rawValue, forKey: .ruleVersion)
        }
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for costcategoryruleslist0 in rules {
                try rulesContainer.encode(costcategoryruleslist0)
            }
        }
    }
}

public struct UpdateCostCategoryDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCostCategoryDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCostCategoryDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCostCategoryDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCostCategoryDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateCostCategoryDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCostCategoryDefinitionOutputError>
}

public struct UpdateCostCategoryDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCostCategoryDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCostCategoryDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCostCategoryDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCostCategoryDefinitionInput>
    public typealias MOutput = OperationOutput<UpdateCostCategoryDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCostCategoryDefinitionOutputError>
}

public struct UpdateCostCategoryDefinitionInput: Equatable {
    /// <p>The unique identifier for your Cost Category.</p>
    public let costCategoryArn: String?
    /// <p>The default value for the cost category.</p>
    public let defaultValue: String?
    /// <p>The rule schema version in this particular Cost Category.</p>
    public let ruleVersion: CostCategoryRuleVersion?
    /// <p>The <code>Expression</code> object used to categorize costs. For more information, see
    ///         <a href="https://docs.aws.amazon.com/aws-cost-management/latest/APIReference/API_CostCategoryRule.html">CostCategoryRule </a>. </p>
    public let rules: [CostCategoryRule]?

    public init (
        costCategoryArn: String? = nil,
        defaultValue: String? = nil,
        ruleVersion: CostCategoryRuleVersion? = nil,
        rules: [CostCategoryRule]? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.defaultValue = defaultValue
        self.ruleVersion = ruleVersion
        self.rules = rules
    }
}

struct UpdateCostCategoryDefinitionInputBody: Equatable {
    public let costCategoryArn: String?
    public let ruleVersion: CostCategoryRuleVersion?
    public let rules: [CostCategoryRule]?
    public let defaultValue: String?
}

extension UpdateCostCategoryDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case defaultValue = "DefaultValue"
        case ruleVersion = "RuleVersion"
        case rules = "Rules"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
        let ruleVersionDecoded = try containerValues.decodeIfPresent(CostCategoryRuleVersion.self, forKey: .ruleVersion)
        ruleVersion = ruleVersionDecoded
        let rulesContainer = try containerValues.decodeIfPresent([CostCategoryRule?].self, forKey: .rules)
        var rulesDecoded0:[CostCategoryRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [CostCategoryRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let defaultValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension UpdateCostCategoryDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCostCategoryDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCostCategoryDefinitionOutputError: Swift.Error, Equatable {
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCostCategoryDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCostCategoryDefinitionOutputResponse(costCategoryArn: \(String(describing: costCategoryArn)), effectiveStart: \(String(describing: effectiveStart)))"}
}

extension UpdateCostCategoryDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateCostCategoryDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.costCategoryArn = output.costCategoryArn
            self.effectiveStart = output.effectiveStart
        } else {
            self.costCategoryArn = nil
            self.effectiveStart = nil
        }
    }
}

public struct UpdateCostCategoryDefinitionOutputResponse: Equatable {
    /// <p>
    ///       The unique identifier for your Cost Category.
    ///     </p>
    public let costCategoryArn: String?
    /// <p>
    ///       The Cost Category's effective start date.
    ///     </p>
    public let effectiveStart: String?

    public init (
        costCategoryArn: String? = nil,
        effectiveStart: String? = nil
    )
    {
        self.costCategoryArn = costCategoryArn
        self.effectiveStart = effectiveStart
    }
}

struct UpdateCostCategoryDefinitionOutputResponseBody: Equatable {
    public let costCategoryArn: String?
    public let effectiveStart: String?
}

extension UpdateCostCategoryDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case costCategoryArn = "CostCategoryArn"
        case effectiveStart = "EffectiveStart"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costCategoryArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .costCategoryArn)
        costCategoryArn = costCategoryArnDecoded
        let effectiveStartDecoded = try containerValues.decodeIfPresent(String.self, forKey: .effectiveStart)
        effectiveStart = effectiveStartDecoded
    }
}

extension UtilizationByTime: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groups = "Groups"
        case timePeriod = "TimePeriod"
        case total = "Total"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for reservationutilizationgroups0 in groups {
                try groupsContainer.encode(reservationutilizationgroups0)
            }
        }
        if let timePeriod = timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timePeriodDecoded = try containerValues.decodeIfPresent(DateInterval.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let groupsContainer = try containerValues.decodeIfPresent([ReservationUtilizationGroup?].self, forKey: .groups)
        var groupsDecoded0:[ReservationUtilizationGroup]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [ReservationUtilizationGroup]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let totalDecoded = try containerValues.decodeIfPresent(ReservationAggregates.self, forKey: .total)
        total = totalDecoded
    }
}

extension UtilizationByTime: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UtilizationByTime(groups: \(String(describing: groups)), timePeriod: \(String(describing: timePeriod)), total: \(String(describing: total)))"}
}

/// <p>The amount of utilization, in hours.</p>
public struct UtilizationByTime: Equatable {
    /// <p>The groups that this utilization result uses.</p>
    public let groups: [ReservationUtilizationGroup]?
    /// <p>The period of time that this utilization was used for.</p>
    public let timePeriod: DateInterval?
    /// <p>The total number of reservation hours that were used.</p>
    public let total: ReservationAggregates?

    public init (
        groups: [ReservationUtilizationGroup]? = nil,
        timePeriod: DateInterval? = nil,
        total: ReservationAggregates? = nil
    )
    {
        self.groups = groups
        self.timePeriod = timePeriod
        self.total = total
    }
}
