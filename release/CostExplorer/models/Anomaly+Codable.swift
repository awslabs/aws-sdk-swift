// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension Anomaly: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomalyEndDate = "AnomalyEndDate"
        case anomalyId = "AnomalyId"
        case anomalyScore = "AnomalyScore"
        case anomalyStartDate = "AnomalyStartDate"
        case dimensionValue = "DimensionValue"
        case feedback = "Feedback"
        case impact = "Impact"
        case monitorArn = "MonitorArn"
        case rootCauses = "RootCauses"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomalyEndDate = anomalyEndDate {
            try encodeContainer.encode(anomalyEndDate, forKey: .anomalyEndDate)
        }
        if let anomalyId = anomalyId {
            try encodeContainer.encode(anomalyId, forKey: .anomalyId)
        }
        if let anomalyScore = anomalyScore {
            try encodeContainer.encode(anomalyScore, forKey: .anomalyScore)
        }
        if let anomalyStartDate = anomalyStartDate {
            try encodeContainer.encode(anomalyStartDate, forKey: .anomalyStartDate)
        }
        if let dimensionValue = dimensionValue {
            try encodeContainer.encode(dimensionValue, forKey: .dimensionValue)
        }
        if let feedback = feedback {
            try encodeContainer.encode(feedback.rawValue, forKey: .feedback)
        }
        if let impact = impact {
            try encodeContainer.encode(impact, forKey: .impact)
        }
        if let monitorArn = monitorArn {
            try encodeContainer.encode(monitorArn, forKey: .monitorArn)
        }
        if let rootCauses = rootCauses {
            var rootCausesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rootCauses)
            for rootcauses0 in rootCauses {
                try rootCausesContainer.encode(rootcauses0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let anomalyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyId)
        anomalyId = anomalyIdDecoded
        let anomalyStartDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyStartDate)
        anomalyStartDate = anomalyStartDateDecoded
        let anomalyEndDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .anomalyEndDate)
        anomalyEndDate = anomalyEndDateDecoded
        let dimensionValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dimensionValue)
        dimensionValue = dimensionValueDecoded
        let rootCausesContainer = try containerValues.decodeIfPresent([RootCause].self, forKey: .rootCauses)
        var rootCausesDecoded0:[RootCause]? = nil
        if let rootCausesContainer = rootCausesContainer {
            rootCausesDecoded0 = [RootCause]()
            for structure0 in rootCausesContainer {
                rootCausesDecoded0?.append(structure0)
            }
        }
        rootCauses = rootCausesDecoded0
        let anomalyScoreDecoded = try containerValues.decodeIfPresent(AnomalyScore.self, forKey: .anomalyScore)
        anomalyScore = anomalyScoreDecoded
        let impactDecoded = try containerValues.decodeIfPresent(Impact.self, forKey: .impact)
        impact = impactDecoded
        let monitorArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .monitorArn)
        monitorArn = monitorArnDecoded
        let feedbackDecoded = try containerValues.decodeIfPresent(AnomalyFeedbackType.self, forKey: .feedback)
        feedback = feedbackDecoded
    }
}
