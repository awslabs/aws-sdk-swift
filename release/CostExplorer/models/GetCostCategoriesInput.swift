// Code generated by smithy-swift-codegen. DO NOT EDIT!



public struct GetCostCategoriesInput: Equatable {
    /// <p>The unique name of the Cost Category.</p>
    public let costCategoryName: String?
    /// <p>Use <code>Expression</code> to filter by cost or by usage. There are two patterns: </p>
    ///         <ul>
    ///             <li>
    ///                 <p>Simple dimension values - You can set the dimension name and values for the
    ///                     filters that you plan to use. For example, you can filter for
    ///                     <code>REGION==us-east-1 OR REGION==us-west-1</code>. For <code>GetRightsizingRecommendation</code>, the Region is a full name (for example, <code>REGION==US East (N. Virginia)</code>. The
    ///                         <code>Expression</code> example looks like:</p>
    ///                 <p>
    ///                   <code>{ "Dimensions": { "Key": "REGION", "Values": [ "us-east-1",
    ///                         “us-west-1” ] } }</code>
    ///                 </p>
    ///                 <p>The list of dimension values are OR'd together to retrieve cost or usage
    ///                     data. You can create <code>Expression</code> and <code>DimensionValues</code>
    ///                     objects using either <code>with*</code> methods or <code>set*</code> methods in
    ///                     multiple lines. </p>
    ///             </li>
    ///             <li>
    ///                 <p>Compound dimension values with logical operations - You can use multiple
    ///                         <code>Expression</code> types and the logical operators
    ///                         <code>AND/OR/NOT</code> to create a list of one or more
    ///                         <code>Expression</code> objects. This allows you to filter on more advanced
    ///                     options. For example, you can filter on <code>((REGION == us-east-1 OR
    ///                         REGION == us-west-1) OR (TAG.Type == Type1)) AND (USAGE_TYPE !=
    ///                         DataTransfer)</code>. The <code>Expression</code> for that looks like
    ///                     this:</p>
    ///                 <p>
    ///                   <code>{ "And": [ {"Or": [ {"Dimensions": { "Key": "REGION",
    ///                         "Values": [ "us-east-1", "us-west-1" ] }}, {"Tags": { "Key": "TagName",
    ///                         "Values": ["Value1"] } } ]}, {"Not": {"Dimensions": { "Key": "USAGE_TYPE",
    ///                         "Values": ["DataTransfer"] }}} ] } </code>
    ///                </p>
    ///                 <note>
    ///                     <p>Because each <code>Expression</code> can have only one operator, the
    ///                         service returns an error if more than one is specified. The following
    ///                         example shows an <code>Expression</code> object that creates an
    ///                         error.</p>
    ///                 </note>
    ///                 <p>
    ///                     <code> { "And": [ ... ], "DimensionValues": { "Dimension": "USAGE_TYPE",
    ///                         "Values": [ "DataTransfer" ] } } </code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///         <note>
    ///             <p>For the <code>GetRightsizingRecommendation</code> action, a combination of OR and NOT is not
    ///                 supported. OR is not supported between different dimensions, or dimensions and tags.
    ///                 NOT operators aren't supported.
    ///                 Dimensions
    ///                 are also limited to <code>LINKED_ACCOUNT</code>, <code>REGION</code>, or
    ///                     <code>RIGHTSIZING_TYPE</code>.</p>
    /// 					
    /// 					       <p>For the <code>GetReservationPurchaseRecommendation</code> action, only NOT is supported. AND and OR are not supported. Dimensions are limited to <code>LINKED_ACCOUNT</code>.</p>
    /// 					
    /// 					
    /// 					
    ///          </note>
    public let filter: Expression?
    /// <p>This field is only used when <code>SortBy</code> is provided in the request.</p>
    /// 	        <p>The maximum number of objects that to be returned for this request.  If <code>MaxResults</code> is not specified with <code>SortBy</code>, the request will return 1000 results as the default value for this parameter.</p>
    /// 	        <p>For <code>GetCostCategories</code>, MaxResults has an upper limit of 1000.</p>
    public let maxResults: Int
    /// <p>If the number of objects that are still available for retrieval exceeds the limit, AWS returns a NextPageToken value in the response. To retrieve the next batch of objects, provide the NextPageToken from the prior call in your next request.</p>
    public let nextPageToken: String?
    /// <p>The value that you want to search the filter values for.</p>
    /// 	        <p>If you do not specify a <code>CostCategoryName</code>, <code>SearchString</code> will be used to filter Cost Category names that match the <code>SearchString</code> pattern. If you do specifiy a <code>CostCategoryName</code>, <code>SearchString</code> will be used to filter Cost Category values that match the <code>SearchString</code> pattern.</p>
    public let searchString: String?
    /// <p>The value by which you want to sort the data.</p>
    /// 	        <p>The key represents cost and usage metrics. The following values are supported:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>BlendedCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UnblendedCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>AmortizedCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NetAmortizedCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NetUnblendedCost</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>UsageQuantity</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>NormalizedUsageAmount</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    ///          <p>Supported values for <code>SortOrder</code> are <code>ASCENDING</code> or <code>DESCENDING</code>.</p>
    ///          <p>When using <code>SortBy</code>, <code>NextPageToken</code> and <code>SearchString</code> are not supported.</p>
    public let sortBy: [SortDefinition]?
    /// <p>The time period of the request.
    ///         </p>
    public let timePeriod: DateInterval?

    public init (
        costCategoryName: String? = nil,
        filter: Expression? = nil,
        maxResults: Int = 0,
        nextPageToken: String? = nil,
        searchString: String? = nil,
        sortBy: [SortDefinition]? = nil,
        timePeriod: DateInterval? = nil
    )
    {
        self.costCategoryName = costCategoryName
        self.filter = filter
        self.maxResults = maxResults
        self.nextPageToken = nextPageToken
        self.searchString = searchString
        self.sortBy = sortBy
        self.timePeriod = timePeriod
    }
}

extension GetCostCategoriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCostCategoriesInput(costCategoryName: \(String(describing: costCategoryName)), filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextPageToken: \(String(describing: nextPageToken)), searchString: \(String(describing: searchString)), sortBy: \(String(describing: sortBy)), timePeriod: \(String(describing: timePeriod)))"}
}
