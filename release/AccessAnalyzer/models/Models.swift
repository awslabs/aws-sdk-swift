// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccessPreview: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyzerArn
        case configurations
        case createdAt
        case id
        case status
        case statusReason
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let configurations = configurations {
            var configurationsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .configurations)
            for (dictKey0, configurationsmap0) in configurations {
                try configurationsContainer.encode(configurationsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let analyzerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let configurationsContainer = try containerValues.decodeIfPresent([String: Configuration?].self, forKey: .configurations)
        var configurationsDecoded0: [String:Configuration]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [String:Configuration]()
            for (key0, configuration0) in configurationsContainer {
                if let configuration0 = configuration0 {
                    configurationsDecoded0?[key0] = configuration0
                }
            }
        }
        configurations = configurationsDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AccessPreviewStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(AccessPreviewStatusReason.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension AccessPreview: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessPreview(analyzerArn: \(String(describing: analyzerArn)), configurations: \(String(describing: configurations)), createdAt: \(String(describing: createdAt)), id: \(String(describing: id)), status: \(String(describing: status)), statusReason: \(String(describing: statusReason)))"}
}

/// <p>Contains information about an access preview.</p>
public struct AccessPreview: Equatable {
    /// <p>The ARN of the analyzer used to generate the access preview.</p>
    public let analyzerArn: String?
    /// <p>A map of resource ARNs for the proposed resource configuration.</p>
    public let configurations: [String:Configuration]?
    /// <p>The time at which the access preview was created.</p>
    public let createdAt: Date?
    /// <p>The unique ID for the access preview.</p>
    public let id: String?
    /// <p>The status of the access preview.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Creating</code> - The access preview creation is in progress.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Completed</code> - The access preview is complete. You can preview findings
    ///                for external access to the resource.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Failed</code> - The access preview creation has failed.</p>
    ///             </li>
    ///          </ul>
    public let status: AccessPreviewStatus?
    /// <p>Provides more details about the current status of the access preview.</p>
    ///          <p>For example, if the creation of the access preview fails, a <code>Failed</code> status
    ///          is returned. This failure can be due to an internal issue with the analysis or due to an
    ///          invalid resource configuration.</p>
    public let statusReason: AccessPreviewStatusReason?

    public init (
        analyzerArn: String? = nil,
        configurations: [String:Configuration]? = nil,
        createdAt: Date? = nil,
        id: String? = nil,
        status: AccessPreviewStatus? = nil,
        statusReason: AccessPreviewStatusReason? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.configurations = configurations
        self.createdAt = createdAt
        self.id = id
        self.status = status
        self.statusReason = statusReason
    }
}

extension AccessPreviewFinding: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
        case changeType
        case condition
        case createdAt
        case error
        case existingFindingId
        case existingFindingStatus
        case id
        case isPublic
        case principal
        case resource
        case resourceOwnerAccount
        case resourceType
        case sources
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            var actionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .action)
            for actionlist0 in action {
                try actionContainer.encode(actionlist0)
            }
        }
        if let changeType = changeType {
            try encodeContainer.encode(changeType.rawValue, forKey: .changeType)
        }
        if let condition = condition {
            var conditionContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .condition)
            for (dictKey0, conditionkeymap0) in condition {
                try conditionContainer.encode(conditionkeymap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let existingFindingId = existingFindingId {
            try encodeContainer.encode(existingFindingId, forKey: .existingFindingId)
        }
        if let existingFindingStatus = existingFindingStatus {
            try encodeContainer.encode(existingFindingStatus.rawValue, forKey: .existingFindingStatus)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let isPublic = isPublic {
            try encodeContainer.encode(isPublic, forKey: .isPublic)
        }
        if let principal = principal {
            var principalContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .principal)
            for (dictKey0, principalmap0) in principal {
                try principalContainer.encode(principalmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceOwnerAccount = resourceOwnerAccount {
            try encodeContainer.encode(resourceOwnerAccount, forKey: .resourceOwnerAccount)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for findingsourcelist0 in sources {
                try sourcesContainer.encode(findingsourcelist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let existingFindingIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .existingFindingId)
        existingFindingId = existingFindingIdDecoded
        let existingFindingStatusDecoded = try containerValues.decodeIfPresent(FindingStatus.self, forKey: .existingFindingStatus)
        existingFindingStatus = existingFindingStatusDecoded
        let principalContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .principal)
        var principalDecoded0: [String:String]? = nil
        if let principalContainer = principalContainer {
            principalDecoded0 = [String:String]()
            for (key0, string0) in principalContainer {
                if let string0 = string0 {
                    principalDecoded0?[key0] = string0
                }
            }
        }
        principal = principalDecoded0
        let actionContainer = try containerValues.decodeIfPresent([String?].self, forKey: .action)
        var actionDecoded0:[String]? = nil
        if let actionContainer = actionContainer {
            actionDecoded0 = [String]()
            for string0 in actionContainer {
                if let string0 = string0 {
                    actionDecoded0?.append(string0)
                }
            }
        }
        action = actionDecoded0
        let conditionContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .condition)
        var conditionDecoded0: [String:String]? = nil
        if let conditionContainer = conditionContainer {
            conditionDecoded0 = [String:String]()
            for (key0, string0) in conditionContainer {
                if let string0 = string0 {
                    conditionDecoded0?[key0] = string0
                }
            }
        }
        condition = conditionDecoded0
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
        let isPublicDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isPublic)
        isPublic = isPublicDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let changeTypeDecoded = try containerValues.decodeIfPresent(FindingChangeType.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FindingStatus.self, forKey: .status)
        status = statusDecoded
        let resourceOwnerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceOwnerAccount)
        resourceOwnerAccount = resourceOwnerAccountDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([FindingSource?].self, forKey: .sources)
        var sourcesDecoded0:[FindingSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [FindingSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension AccessPreviewFinding: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessPreviewFinding(action: \(String(describing: action)), changeType: \(String(describing: changeType)), condition: \(String(describing: condition)), createdAt: \(String(describing: createdAt)), error: \(String(describing: error)), existingFindingId: \(String(describing: existingFindingId)), existingFindingStatus: \(String(describing: existingFindingStatus)), id: \(String(describing: id)), isPublic: \(String(describing: isPublic)), principal: \(String(describing: principal)), resource: \(String(describing: resource)), resourceOwnerAccount: \(String(describing: resourceOwnerAccount)), resourceType: \(String(describing: resourceType)), sources: \(String(describing: sources)), status: \(String(describing: status)))"}
}

/// <p>An access preview finding generated by the access preview.</p>
public struct AccessPreviewFinding: Equatable {
    /// <p>The action in the analyzed policy statement that an external principal has permission to
    ///          perform.</p>
    public let action: [String]?
    /// <p>Provides context on how the access preview finding compares to existing access
    ///          identified in Access Analyzer.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>New</code> - The finding is for newly-introduced access.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Unchanged</code> - The preview finding is an existing finding that would
    ///                remain unchanged.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Changed</code> - The preview finding is an existing finding with a change in
    ///                status.</p>
    ///             </li>
    ///          </ul>
    ///          <p>For example, a <code>Changed</code> finding with preview status <code>Resolved</code>
    ///          and existing status <code>Active</code> indicates the existing <code>Active</code> finding
    ///          would become <code>Resolved</code> as a result of the proposed permissions change.</p>
    public let changeType: FindingChangeType?
    /// <p>The condition in the analyzed policy statement that resulted in a finding.</p>
    public let condition: [String:String]?
    /// <p>The time at which the access preview finding was created.</p>
    public let createdAt: Date?
    /// <p>An error.</p>
    public let error: String?
    /// <p>The existing ID of the finding in Access Analyzer, provided only for existing findings.</p>
    public let existingFindingId: String?
    /// <p>The existing status of the finding, provided only for existing findings.</p>
    public let existingFindingStatus: FindingStatus?
    /// <p>The ID of the access preview finding. This ID uniquely identifies the element in the
    ///          list of access preview findings and is not related to the finding ID in Access
    ///          Analyzer.</p>
    public let id: String?
    /// <p>Indicates whether the policy that generated the finding allows public access to the
    ///          resource.</p>
    public let isPublic: Bool?
    /// <p>The external principal that has access to a resource within the zone of trust.</p>
    public let principal: [String:String]?
    /// <p>The resource that an external principal has access to. This is the resource associated
    ///          with the access preview.</p>
    public let resource: String?
    /// <p>The AWS account ID that owns the resource. For most AWS resources, the owning
    ///          account is the account in which the resource was created.</p>
    public let resourceOwnerAccount: String?
    /// <p>The type of the resource that can be accessed in the finding.</p>
    public let resourceType: ResourceType?
    /// <p>The sources of the finding. This indicates how the access that generated the finding is
    ///          granted. It is populated for Amazon S3 bucket findings.</p>
    public let sources: [FindingSource]?
    /// <p>The preview status of the finding. This is what the status of the finding would be after
    ///          permissions deployment. For example, a <code>Changed</code> finding with preview status
    ///             <code>Resolved</code> and existing status <code>Active</code> indicates the existing
    ///             <code>Active</code> finding would become <code>Resolved</code> as a result of the
    ///          proposed permissions change.</p>
    public let status: FindingStatus?

    public init (
        action: [String]? = nil,
        changeType: FindingChangeType? = nil,
        condition: [String:String]? = nil,
        createdAt: Date? = nil,
        error: String? = nil,
        existingFindingId: String? = nil,
        existingFindingStatus: FindingStatus? = nil,
        id: String? = nil,
        isPublic: Bool? = nil,
        principal: [String:String]? = nil,
        resource: String? = nil,
        resourceOwnerAccount: String? = nil,
        resourceType: ResourceType? = nil,
        sources: [FindingSource]? = nil,
        status: FindingStatus? = nil
    )
    {
        self.action = action
        self.changeType = changeType
        self.condition = condition
        self.createdAt = createdAt
        self.error = error
        self.existingFindingId = existingFindingId
        self.existingFindingStatus = existingFindingStatus
        self.id = id
        self.isPublic = isPublic
        self.principal = principal
        self.resource = resource
        self.resourceOwnerAccount = resourceOwnerAccount
        self.resourceType = resourceType
        self.sources = sources
        self.status = status
    }
}

public enum AccessPreviewStatus {
    case completed
    case creating
    case failed
    case sdkUnknown(String)
}

extension AccessPreviewStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AccessPreviewStatus] {
        return [
            .completed,
            .creating,
            .failed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .creating: return "CREATING"
        case .failed: return "FAILED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AccessPreviewStatus(rawValue: rawValue) ?? AccessPreviewStatus.sdkUnknown(rawValue)
    }
}

extension AccessPreviewStatusReason: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(AccessPreviewStatusReasonCode.self, forKey: .code)
        code = codeDecoded
    }
}

extension AccessPreviewStatusReason: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessPreviewStatusReason(code: \(String(describing: code)))"}
}

/// <p>Provides more details about the current status of the access preview. For example, if
///          the creation of the access preview fails, a <code>Failed</code> status is returned. This
///          failure can be due to an internal issue with the analysis or due to an invalid proposed
///          resource configuration.</p>
public struct AccessPreviewStatusReason: Equatable {
    /// <p>The reason code for the current status of the access preview.</p>
    public let code: AccessPreviewStatusReasonCode?

    public init (
        code: AccessPreviewStatusReasonCode? = nil
    )
    {
        self.code = code
    }
}

public enum AccessPreviewStatusReasonCode {
    case internalError
    case invalidConfiguration
    case sdkUnknown(String)
}

extension AccessPreviewStatusReasonCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AccessPreviewStatusReasonCode] {
        return [
            .internalError,
            .invalidConfiguration,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .internalError: return "INTERNAL_ERROR"
        case .invalidConfiguration: return "INVALID_CONFIGURATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AccessPreviewStatusReasonCode(rawValue: rawValue) ?? AccessPreviewStatusReasonCode.sdkUnknown(rawValue)
    }
}

extension AccessPreviewSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyzerArn
        case createdAt
        case id
        case status
        case statusReason
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let analyzerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AccessPreviewStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(AccessPreviewStatusReason.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension AccessPreviewSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessPreviewSummary(analyzerArn: \(String(describing: analyzerArn)), createdAt: \(String(describing: createdAt)), id: \(String(describing: id)), status: \(String(describing: status)), statusReason: \(String(describing: statusReason)))"}
}

/// <p>Contains a summary of information about an access preview.</p>
public struct AccessPreviewSummary: Equatable {
    /// <p>The ARN of the analyzer used to generate the access preview.</p>
    public let analyzerArn: String?
    /// <p>The time at which the access preview was created.</p>
    public let createdAt: Date?
    /// <p>The unique ID for the access preview.</p>
    public let id: String?
    /// <p>The status of the access preview.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Creating</code> - The access preview creation is in progress.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Completed</code> - The access preview is complete and previews the findings
    ///                for external access to the resource.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Failed</code> - The access preview creation has failed.</p>
    ///             </li>
    ///          </ul>
    public let status: AccessPreviewStatus?
    /// <p>Provides more details about the current status of the access preview. For example, if
    ///          the creation of the access preview fails, a <code>Failed</code> status is returned. This
    ///          failure can be due to an internal issue with the analysis or due to an invalid proposed
    ///          resource configuration.</p>
    public let statusReason: AccessPreviewStatusReason?

    public init (
        analyzerArn: String? = nil,
        createdAt: Date? = nil,
        id: String? = nil,
        status: AccessPreviewStatus? = nil,
        statusReason: AccessPreviewStatusReason? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.createdAt = createdAt
        self.id = id
        self.status = status
        self.statusReason = statusReason
    }
}

extension AclGrantee: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
        case sdkUnknown
        case uri
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .id(id):
                if let id = id {
                    try container.encode(id, forKey: .id)
                }
            case let .uri(uri):
                if let uri = uri {
                    try container.encode(uri, forKey: .uri)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try values.decodeIfPresent(String.self, forKey: .id)
        if let id = idDecoded {
            self = .id(id)
            return
        }
        let uriDecoded = try values.decodeIfPresent(String.self, forKey: .uri)
        if let uri = uriDecoded {
            self = .uri(uri)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>You specify each grantee as a type-value pair using one of these types. You can specify
///          only one type of grantee. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutBucketAcl.html">PutBucketAcl</a>.</p>
public enum AclGrantee: Equatable, Hashable {
    /// <p>The value specified is the canonical user ID of an AWS account.</p>
    case id(String?)
    /// <p>Used for granting permissions to a predefined group.</p>
    case uri(String?)
    case sdkUnknown(String?)
}

public enum AclPermission {
    case fullControl
    case read
    case readAcp
    case write
    case writeAcp
    case sdkUnknown(String)
}

extension AclPermission : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AclPermission] {
        return [
            .fullControl,
            .read,
            .readAcp,
            .write,
            .writeAcp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .fullControl: return "FULL_CONTROL"
        case .read: return "READ"
        case .readAcp: return "READ_ACP"
        case .write: return "WRITE"
        case .writeAcp: return "WRITE_ACP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AclPermission(rawValue: rawValue) ?? AclPermission.sdkUnknown(rawValue)
    }
}

extension AnalyzedResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions
        case analyzedAt
        case createdAt
        case error
        case isPublic
        case resourceArn
        case resourceOwnerAccount
        case resourceType
        case sharedVia
        case status
        case updatedAt
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actionlist0 in actions {
                try actionsContainer.encode(actionlist0)
            }
        }
        if let analyzedAt = analyzedAt {
            try encodeContainer.encode(analyzedAt.timeIntervalSince1970, forKey: .analyzedAt)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let isPublic = isPublic {
            try encodeContainer.encode(isPublic, forKey: .isPublic)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceOwnerAccount = resourceOwnerAccount {
            try encodeContainer.encode(resourceOwnerAccount, forKey: .resourceOwnerAccount)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sharedVia = sharedVia {
            var sharedViaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sharedVia)
            for sharedvialist0 in sharedVia {
                try sharedViaContainer.encode(sharedvialist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let analyzedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .analyzedAt)
        analyzedAt = analyzedAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let isPublicDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isPublic)
        isPublic = isPublicDecoded
        let actionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .actions)
        var actionsDecoded0:[String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
        let sharedViaContainer = try containerValues.decodeIfPresent([String?].self, forKey: .sharedVia)
        var sharedViaDecoded0:[String]? = nil
        if let sharedViaContainer = sharedViaContainer {
            sharedViaDecoded0 = [String]()
            for string0 in sharedViaContainer {
                if let string0 = string0 {
                    sharedViaDecoded0?.append(string0)
                }
            }
        }
        sharedVia = sharedViaDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(FindingStatus.self, forKey: .status)
        status = statusDecoded
        let resourceOwnerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceOwnerAccount)
        resourceOwnerAccount = resourceOwnerAccountDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
    }
}

extension AnalyzedResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnalyzedResource(actions: \(String(describing: actions)), analyzedAt: \(String(describing: analyzedAt)), createdAt: \(String(describing: createdAt)), error: \(String(describing: error)), isPublic: \(String(describing: isPublic)), resourceArn: \(String(describing: resourceArn)), resourceOwnerAccount: \(String(describing: resourceOwnerAccount)), resourceType: \(String(describing: resourceType)), sharedVia: \(String(describing: sharedVia)), status: \(String(describing: status)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>Contains details about the analyzed resource.</p>
public struct AnalyzedResource: Equatable {
    /// <p>The actions that an external principal is granted permission to use by the policy that
    ///          generated the finding.</p>
    public let actions: [String]?
    /// <p>The time at which the resource was analyzed.</p>
    public let analyzedAt: Date?
    /// <p>The time at which the finding was created.</p>
    public let createdAt: Date?
    /// <p>An error message.</p>
    public let error: String?
    /// <p>Indicates whether the policy that generated the finding grants public access to the
    ///          resource.</p>
    public let isPublic: Bool?
    /// <p>The ARN of the resource that was analyzed.</p>
    public let resourceArn: String?
    /// <p>The AWS account ID that owns the resource.</p>
    public let resourceOwnerAccount: String?
    /// <p>The type of the resource that was analyzed.</p>
    public let resourceType: ResourceType?
    /// <p>Indicates how the access that generated the finding is granted. This is populated for
    ///          Amazon S3 bucket findings.</p>
    public let sharedVia: [String]?
    /// <p>The current status of the finding generated from the analyzed resource.</p>
    public let status: FindingStatus?
    /// <p>The time at which the finding was updated.</p>
    public let updatedAt: Date?

    public init (
        actions: [String]? = nil,
        analyzedAt: Date? = nil,
        createdAt: Date? = nil,
        error: String? = nil,
        isPublic: Bool? = nil,
        resourceArn: String? = nil,
        resourceOwnerAccount: String? = nil,
        resourceType: ResourceType? = nil,
        sharedVia: [String]? = nil,
        status: FindingStatus? = nil,
        updatedAt: Date? = nil
    )
    {
        self.actions = actions
        self.analyzedAt = analyzedAt
        self.createdAt = createdAt
        self.error = error
        self.isPublic = isPublic
        self.resourceArn = resourceArn
        self.resourceOwnerAccount = resourceOwnerAccount
        self.resourceType = resourceType
        self.sharedVia = sharedVia
        self.status = status
        self.updatedAt = updatedAt
    }
}

extension AnalyzedResourceSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case resourceOwnerAccount
        case resourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceOwnerAccount = resourceOwnerAccount {
            try encodeContainer.encode(resourceOwnerAccount, forKey: .resourceOwnerAccount)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let resourceOwnerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceOwnerAccount)
        resourceOwnerAccount = resourceOwnerAccountDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension AnalyzedResourceSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnalyzedResourceSummary(resourceArn: \(String(describing: resourceArn)), resourceOwnerAccount: \(String(describing: resourceOwnerAccount)), resourceType: \(String(describing: resourceType)))"}
}

/// <p>Contains the ARN of the analyzed resource.</p>
public struct AnalyzedResourceSummary: Equatable {
    /// <p>The ARN of the analyzed resource.</p>
    public let resourceArn: String?
    /// <p>The AWS account ID that owns the resource.</p>
    public let resourceOwnerAccount: String?
    /// <p>The type of resource that was analyzed.</p>
    public let resourceType: ResourceType?

    public init (
        resourceArn: String? = nil,
        resourceOwnerAccount: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.resourceArn = resourceArn
        self.resourceOwnerAccount = resourceOwnerAccount
        self.resourceType = resourceType
    }
}

public enum AnalyzerStatus {
    case active
    case creating
    case disabled
    case failed
    case sdkUnknown(String)
}

extension AnalyzerStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AnalyzerStatus] {
        return [
            .active,
            .creating,
            .disabled,
            .failed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .disabled: return "DISABLED"
        case .failed: return "FAILED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AnalyzerStatus(rawValue: rawValue) ?? AnalyzerStatus.sdkUnknown(rawValue)
    }
}

extension AnalyzerSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case lastResourceAnalyzed
        case lastResourceAnalyzedAt
        case name
        case status
        case statusReason
        case tags
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let lastResourceAnalyzed = lastResourceAnalyzed {
            try encodeContainer.encode(lastResourceAnalyzed, forKey: .lastResourceAnalyzed)
        }
        if let lastResourceAnalyzedAt = lastResourceAnalyzedAt {
            try encodeContainer.encode(lastResourceAnalyzedAt.timeIntervalSince1970, forKey: .lastResourceAnalyzedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(`Type`.self, forKey: .type)
        type = typeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastResourceAnalyzedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastResourceAnalyzed)
        lastResourceAnalyzed = lastResourceAnalyzedDecoded
        let lastResourceAnalyzedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastResourceAnalyzedAt)
        lastResourceAnalyzedAt = lastResourceAnalyzedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(AnalyzerStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(StatusReason.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension AnalyzerSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AnalyzerSummary(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), lastResourceAnalyzed: \(String(describing: lastResourceAnalyzed)), lastResourceAnalyzedAt: \(String(describing: lastResourceAnalyzedAt)), name: \(String(describing: name)), status: \(String(describing: status)), statusReason: \(String(describing: statusReason)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

/// <p>Contains information about the analyzer.</p>
public struct AnalyzerSummary: Equatable {
    /// <p>The ARN of the analyzer.</p>
    public let arn: String?
    /// <p>A timestamp for the time at which the analyzer was created.</p>
    public let createdAt: Date?
    /// <p>The resource that was most recently analyzed by the analyzer.</p>
    public let lastResourceAnalyzed: String?
    /// <p>The time at which the most recently analyzed resource was analyzed.</p>
    public let lastResourceAnalyzedAt: Date?
    /// <p>The name of the analyzer.</p>
    public let name: String?
    /// <p>The status of the analyzer. An <code>Active</code> analyzer successfully monitors
    ///          supported resources and generates new findings. The analyzer is <code>Disabled</code> when
    ///          a user action, such as removing trusted access for AWS IAM Access Analyzer from AWS Organizations,
    ///          causes the analyzer to stop generating new findings. The status is <code>Creating</code>
    ///          when the analyzer creation is in progress and <code>Failed</code> when the analyzer
    ///          creation has failed. </p>
    public let status: AnalyzerStatus?
    /// <p>The <code>statusReason</code> provides more details about the current status of the
    ///          analyzer. For example, if the creation for the analyzer fails, a <code>Failed</code> status
    ///          is returned. For an analyzer with organization as the type, this failure can be due to an
    ///          issue with creating the service-linked roles required in the member accounts of the AWS
    ///          organization.</p>
    public let statusReason: StatusReason?
    /// <p>The tags added to the analyzer.</p>
    public let tags: [String:String]?
    /// <p>The type of analyzer, which corresponds to the zone of trust chosen for the
    ///          analyzer.</p>
    public let type: `Type`?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        lastResourceAnalyzed: String? = nil,
        lastResourceAnalyzedAt: Date? = nil,
        name: String? = nil,
        status: AnalyzerStatus? = nil,
        statusReason: StatusReason? = nil,
        tags: [String:String]? = nil,
        type: `Type`? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.lastResourceAnalyzed = lastResourceAnalyzed
        self.lastResourceAnalyzedAt = lastResourceAnalyzedAt
        self.name = name
        self.status = status
        self.statusReason = statusReason
        self.tags = tags
        self.type = type
    }
}

public struct ApplyArchiveRuleInputBodyMiddleware: Middleware {
    public let id: String = "ApplyArchiveRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApplyArchiveRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<ApplyArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApplyArchiveRuleInput>
    public typealias MOutput = OperationOutput<ApplyArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApplyArchiveRuleOutputError>
}

extension ApplyArchiveRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplyArchiveRuleInput(analyzerArn: \(String(describing: analyzerArn)), clientToken: \(String(describing: clientToken)), ruleName: \(String(describing: ruleName)))"}
}

extension ApplyArchiveRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyzerArn
        case clientToken
        case ruleName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }
}

public struct ApplyArchiveRuleInputHeadersMiddleware: Middleware {
    public let id: String = "ApplyArchiveRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApplyArchiveRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<ApplyArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApplyArchiveRuleInput>
    public typealias MOutput = OperationOutput<ApplyArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApplyArchiveRuleOutputError>
}

public struct ApplyArchiveRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "ApplyArchiveRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ApplyArchiveRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<ApplyArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ApplyArchiveRuleInput>
    public typealias MOutput = OperationOutput<ApplyArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ApplyArchiveRuleOutputError>
}

/// <p>Retroactively applies an archive rule.</p>
public struct ApplyArchiveRuleInput: Equatable {
    /// <p>The Amazon resource name (ARN) of the analyzer.</p>
    public let analyzerArn: String?
    /// <p>A client token.</p>
    public var clientToken: String?
    /// <p>The name of the rule to apply.</p>
    public let ruleName: String?

    public init (
        analyzerArn: String? = nil,
        clientToken: String? = nil,
        ruleName: String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.clientToken = clientToken
        self.ruleName = ruleName
    }
}

struct ApplyArchiveRuleInputBody: Equatable {
    public let analyzerArn: String?
    public let ruleName: String?
    public let clientToken: String?
}

extension ApplyArchiveRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyzerArn
        case clientToken
        case ruleName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let ruleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension ApplyArchiveRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ApplyArchiveRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ApplyArchiveRuleOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ApplyArchiveRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplyArchiveRuleOutputResponse()"}
}

extension ApplyArchiveRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ApplyArchiveRuleOutputResponse: Equatable {

    public init() {}
}

struct ApplyArchiveRuleOutputResponseBody: Equatable {
}

extension ApplyArchiveRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ArchiveRuleSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case filter
        case ruleName
        case updatedAt
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .filter)
            for (dictKey0, filtercriteriamap0) in filter {
                try filterContainer.encode(filtercriteriamap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let filterContainer = try containerValues.decodeIfPresent([String: Criterion?].self, forKey: .filter)
        var filterDecoded0: [String:Criterion]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [String:Criterion]()
            for (key0, criterion0) in filterContainer {
                if let criterion0 = criterion0 {
                    filterDecoded0?[key0] = criterion0
                }
            }
        }
        filter = filterDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension ArchiveRuleSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ArchiveRuleSummary(createdAt: \(String(describing: createdAt)), filter: \(String(describing: filter)), ruleName: \(String(describing: ruleName)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>Contains information about an archive rule.</p>
public struct ArchiveRuleSummary: Equatable {
    /// <p>The time at which the archive rule was created.</p>
    public let createdAt: Date?
    /// <p>A filter used to define the archive rule.</p>
    public let filter: [String:Criterion]?
    /// <p>The name of the archive rule.</p>
    public let ruleName: String?
    /// <p>The time at which the archive rule was last updated.</p>
    public let updatedAt: Date?

    public init (
        createdAt: Date? = nil,
        filter: [String:Criterion]? = nil,
        ruleName: String? = nil,
        updatedAt: Date? = nil
    )
    {
        self.createdAt = createdAt
        self.filter = filter
        self.ruleName = ruleName
        self.updatedAt = updatedAt
    }
}

extension CancelPolicyGenerationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelPolicyGenerationInput(jobId: \(String(describing: jobId)))"}
}

extension CancelPolicyGenerationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CancelPolicyGenerationInputHeadersMiddleware: Middleware {
    public let id: String = "CancelPolicyGenerationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelPolicyGenerationInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelPolicyGenerationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelPolicyGenerationInput>
    public typealias MOutput = OperationOutput<CancelPolicyGenerationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelPolicyGenerationOutputError>
}

public struct CancelPolicyGenerationInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelPolicyGenerationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelPolicyGenerationInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelPolicyGenerationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelPolicyGenerationInput>
    public typealias MOutput = OperationOutput<CancelPolicyGenerationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelPolicyGenerationOutputError>
}

public struct CancelPolicyGenerationInput: Equatable {
    /// <p>The <code>JobId</code> that is returned by the <code>StartPolicyGeneration</code>
    ///          operation. The <code>JobId</code> can be used with <code>GetGeneratedPolicy</code> to
    ///          retrieve the generated policies or used with <code>CancelPolicyGeneration</code> to cancel
    ///          the policy generation request.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CancelPolicyGenerationInputBody: Equatable {
}

extension CancelPolicyGenerationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CancelPolicyGenerationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelPolicyGenerationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelPolicyGenerationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelPolicyGenerationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelPolicyGenerationOutputResponse()"}
}

extension CancelPolicyGenerationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CancelPolicyGenerationOutputResponse: Equatable {

    public init() {}
}

struct CancelPolicyGenerationOutputResponseBody: Equatable {
}

extension CancelPolicyGenerationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CloudTrailDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessRole
        case endTime
        case startTime
        case trails
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessRole = accessRole {
            try encodeContainer.encode(accessRole, forKey: .accessRole)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let trails = trails {
            var trailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trails)
            for traillist0 in trails {
                try trailsContainer.encode(traillist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailsContainer = try containerValues.decodeIfPresent([Trail?].self, forKey: .trails)
        var trailsDecoded0:[Trail]? = nil
        if let trailsContainer = trailsContainer {
            trailsDecoded0 = [Trail]()
            for structure0 in trailsContainer {
                if let structure0 = structure0 {
                    trailsDecoded0?.append(structure0)
                }
            }
        }
        trails = trailsDecoded0
        let accessRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessRole)
        accessRole = accessRoleDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension CloudTrailDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudTrailDetails(accessRole: \(String(describing: accessRole)), endTime: \(String(describing: endTime)), startTime: \(String(describing: startTime)), trails: \(String(describing: trails)))"}
}

/// <p>Contains information about CloudTrail access.</p>
public struct CloudTrailDetails: Equatable {
    /// <p>The ARN of the service role that Access Analyzer uses to access your CloudTrail trail and
    ///          service last accessed information.</p>
    public let accessRole: String?
    /// <p>The end of the time range for which Access Analyzer reviews your CloudTrail events. Events with
    ///          a timestamp after this time are not considered to generate a policy. If this is not
    ///          included in the request, the default value is the current time.</p>
    public let endTime: Date?
    /// <p>The start of the time range for which Access Analyzer reviews your CloudTrail events. Events
    ///          with a timestamp before this time are not considered to generate a policy.</p>
    public let startTime: Date?
    /// <p>A <code>Trail</code> object that contains settings for a trail.</p>
    public let trails: [Trail]?

    public init (
        accessRole: String? = nil,
        endTime: Date? = nil,
        startTime: Date? = nil,
        trails: [Trail]? = nil
    )
    {
        self.accessRole = accessRole
        self.endTime = endTime
        self.startTime = startTime
        self.trails = trails
    }
}

extension CloudTrailProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime
        case startTime
        case trailProperties
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let trailProperties = trailProperties {
            var trailPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trailProperties)
            for trailpropertieslist0 in trailProperties {
                try trailPropertiesContainer.encode(trailpropertieslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trailPropertiesContainer = try containerValues.decodeIfPresent([TrailProperties?].self, forKey: .trailProperties)
        var trailPropertiesDecoded0:[TrailProperties]? = nil
        if let trailPropertiesContainer = trailPropertiesContainer {
            trailPropertiesDecoded0 = [TrailProperties]()
            for structure0 in trailPropertiesContainer {
                if let structure0 = structure0 {
                    trailPropertiesDecoded0?.append(structure0)
                }
            }
        }
        trailProperties = trailPropertiesDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension CloudTrailProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudTrailProperties(endTime: \(String(describing: endTime)), startTime: \(String(describing: startTime)), trailProperties: \(String(describing: trailProperties)))"}
}

/// <p>Contains information about CloudTrail access.</p>
public struct CloudTrailProperties: Equatable {
    /// <p>The end of the time range for which Access Analyzer reviews your CloudTrail events. Events with
    ///          a timestamp after this time are not considered to generate a policy. If this is not
    ///          included in the request, the default value is the current time.</p>
    public let endTime: Date?
    /// <p>The start of the time range for which Access Analyzer reviews your CloudTrail events. Events
    ///          with a timestamp before this time are not considered to generate a policy.</p>
    public let startTime: Date?
    /// <p>A <code>TrailProperties</code> object that contains settings for trail
    ///          properties.</p>
    public let trailProperties: [TrailProperties]?

    public init (
        endTime: Date? = nil,
        startTime: Date? = nil,
        trailProperties: [TrailProperties]? = nil
    )
    {
        self.endTime = endTime
        self.startTime = startTime
        self.trailProperties = trailProperties
    }
}

extension Configuration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iamRole
        case kmsKey
        case s3Bucket
        case sdkUnknown
        case secretsManagerSecret
        case sqsQueue
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .iamRole(iamRole):
                if let iamRole = iamRole {
                    try container.encode(iamRole, forKey: .iamRole)
                }
            case let .kmsKey(kmsKey):
                if let kmsKey = kmsKey {
                    try container.encode(kmsKey, forKey: .kmsKey)
                }
            case let .s3Bucket(s3Bucket):
                if let s3Bucket = s3Bucket {
                    try container.encode(s3Bucket, forKey: .s3Bucket)
                }
            case let .secretsManagerSecret(secretsManagerSecret):
                if let secretsManagerSecret = secretsManagerSecret {
                    try container.encode(secretsManagerSecret, forKey: .secretsManagerSecret)
                }
            case let .sqsQueue(sqsQueue):
                if let sqsQueue = sqsQueue {
                    try container.encode(sqsQueue, forKey: .sqsQueue)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let iamRoleDecoded = try values.decodeIfPresent(IamRoleConfiguration.self, forKey: .iamRole)
        if let iamRole = iamRoleDecoded {
            self = .iamRole(iamRole)
            return
        }
        let kmsKeyDecoded = try values.decodeIfPresent(KmsKeyConfiguration.self, forKey: .kmsKey)
        if let kmsKey = kmsKeyDecoded {
            self = .kmsKey(kmsKey)
            return
        }
        let secretsManagerSecretDecoded = try values.decodeIfPresent(SecretsManagerSecretConfiguration.self, forKey: .secretsManagerSecret)
        if let secretsManagerSecret = secretsManagerSecretDecoded {
            self = .secretsManagerSecret(secretsManagerSecret)
            return
        }
        let s3BucketDecoded = try values.decodeIfPresent(S3BucketConfiguration.self, forKey: .s3Bucket)
        if let s3Bucket = s3BucketDecoded {
            self = .s3Bucket(s3Bucket)
            return
        }
        let sqsQueueDecoded = try values.decodeIfPresent(SqsQueueConfiguration.self, forKey: .sqsQueue)
        if let sqsQueue = sqsQueueDecoded {
            self = .sqsQueue(sqsQueue)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>Access control configuration structures for your resource. You specify the configuration
///          as a type-value pair. You can specify only one type of access control configuration.</p>
public enum Configuration: Equatable {
    /// <p>The access control configuration is for an IAM role. </p>
    case iamRole(IamRoleConfiguration?)
    /// <p>The access control configuration is for a KMS key. </p>
    case kmsKey(KmsKeyConfiguration?)
    /// <p>The access control configuration is for a Secrets Manager secret.</p>
    case secretsManagerSecret(SecretsManagerSecretConfiguration?)
    /// <p>The access control configuration is for an Amazon S3 Bucket. </p>
    case s3Bucket(S3BucketConfiguration?)
    /// <p>The access control configuration is for an SQS queue. </p>
    case sqsQueue(SqsQueueConfiguration?)
    case sdkUnknown(String?)
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A conflict exception error.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The ID of the resource.</p>
    public var resourceId: String?
    /// <p>The resource type.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct CreateAccessPreviewInputBodyMiddleware: Middleware {
    public let id: String = "CreateAccessPreviewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccessPreviewInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccessPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccessPreviewInput>
    public typealias MOutput = OperationOutput<CreateAccessPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccessPreviewOutputError>
}

extension CreateAccessPreviewInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAccessPreviewInput(analyzerArn: \(String(describing: analyzerArn)), clientToken: \(String(describing: clientToken)), configurations: \(String(describing: configurations)))"}
}

extension CreateAccessPreviewInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyzerArn
        case clientToken
        case configurations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let configurations = configurations {
            var configurationsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .configurations)
            for (dictKey0, configurationsmap0) in configurations {
                try configurationsContainer.encode(configurationsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateAccessPreviewInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAccessPreviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccessPreviewInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccessPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccessPreviewInput>
    public typealias MOutput = OperationOutput<CreateAccessPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccessPreviewOutputError>
}

public struct CreateAccessPreviewInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAccessPreviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAccessPreviewInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAccessPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAccessPreviewInput>
    public typealias MOutput = OperationOutput<CreateAccessPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAccessPreviewOutputError>
}

public struct CreateAccessPreviewInput: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of
    ///             the account analyzer</a> used to generate the access preview. You can only create an
    ///          access preview for analyzers with an <code>Account</code> type and <code>Active</code>
    ///          status.</p>
    public let analyzerArn: String?
    /// <p>A client token.</p>
    public var clientToken: String?
    /// <p>Access control configuration for your resource that is used to generate the access
    ///          preview. The access preview includes findings for external access allowed to the resource
    ///          with the proposed access control configuration. The configuration must contain exactly one
    ///          element.</p>
    public let configurations: [String:Configuration]?

    public init (
        analyzerArn: String? = nil,
        clientToken: String? = nil,
        configurations: [String:Configuration]? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.clientToken = clientToken
        self.configurations = configurations
    }
}

struct CreateAccessPreviewInputBody: Equatable {
    public let analyzerArn: String?
    public let configurations: [String:Configuration]?
    public let clientToken: String?
}

extension CreateAccessPreviewInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyzerArn
        case clientToken
        case configurations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let configurationsContainer = try containerValues.decodeIfPresent([String: Configuration?].self, forKey: .configurations)
        var configurationsDecoded0: [String:Configuration]? = nil
        if let configurationsContainer = configurationsContainer {
            configurationsDecoded0 = [String:Configuration]()
            for (key0, configuration0) in configurationsContainer {
                if let configuration0 = configuration0 {
                    configurationsDecoded0?[key0] = configuration0
                }
            }
        }
        configurations = configurationsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateAccessPreviewOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccessPreviewOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAccessPreviewOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccessPreviewOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAccessPreviewOutputResponse(id: \(String(describing: id)))"}
}

extension CreateAccessPreviewOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAccessPreviewOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct CreateAccessPreviewOutputResponse: Equatable {
    /// <p>The unique ID for the access preview.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct CreateAccessPreviewOutputResponseBody: Equatable {
    public let id: String?
}

extension CreateAccessPreviewOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

public struct CreateAnalyzerInputBodyMiddleware: Middleware {
    public let id: String = "CreateAnalyzerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAnalyzerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAnalyzerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAnalyzerInput>
    public typealias MOutput = OperationOutput<CreateAnalyzerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAnalyzerOutputError>
}

extension CreateAnalyzerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAnalyzerInput(analyzerName: \(String(describing: analyzerName)), archiveRules: \(String(describing: archiveRules)), clientToken: \(String(describing: clientToken)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

extension CreateAnalyzerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyzerName
        case archiveRules
        case clientToken
        case tags
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerName = analyzerName {
            try encodeContainer.encode(analyzerName, forKey: .analyzerName)
        }
        if let archiveRules = archiveRules {
            var archiveRulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .archiveRules)
            for inlinearchiveruleslist0 in archiveRules {
                try archiveRulesContainer.encode(inlinearchiveruleslist0)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateAnalyzerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAnalyzerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAnalyzerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAnalyzerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAnalyzerInput>
    public typealias MOutput = OperationOutput<CreateAnalyzerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAnalyzerOutputError>
}

public struct CreateAnalyzerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAnalyzerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAnalyzerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAnalyzerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAnalyzerInput>
    public typealias MOutput = OperationOutput<CreateAnalyzerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAnalyzerOutputError>
}

/// <p>Creates an analyzer.</p>
public struct CreateAnalyzerInput: Equatable {
    /// <p>The name of the analyzer to create.</p>
    public let analyzerName: String?
    /// <p>Specifies the archive rules to add for the analyzer. Archive rules automatically archive
    ///          findings that meet the criteria you define for the rule.</p>
    public let archiveRules: [InlineArchiveRule]?
    /// <p>A client token.</p>
    public var clientToken: String?
    /// <p>The tags to apply to the analyzer.</p>
    public let tags: [String:String]?
    /// <p>The type of analyzer to create. Only ACCOUNT and ORGANIZATION analyzers are supported.
    ///          You can create only one analyzer per account per Region. You can create up to 5 analyzers
    ///          per organization per Region.</p>
    public let type: `Type`?

    public init (
        analyzerName: String? = nil,
        archiveRules: [InlineArchiveRule]? = nil,
        clientToken: String? = nil,
        tags: [String:String]? = nil,
        type: `Type`? = nil
    )
    {
        self.analyzerName = analyzerName
        self.archiveRules = archiveRules
        self.clientToken = clientToken
        self.tags = tags
        self.type = type
    }
}

struct CreateAnalyzerInputBody: Equatable {
    public let analyzerName: String?
    public let type: `Type`?
    public let archiveRules: [InlineArchiveRule]?
    public let tags: [String:String]?
    public let clientToken: String?
}

extension CreateAnalyzerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyzerName
        case archiveRules
        case clientToken
        case tags
        case type
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analyzerName)
        analyzerName = analyzerNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(`Type`.self, forKey: .type)
        type = typeDecoded
        let archiveRulesContainer = try containerValues.decodeIfPresent([InlineArchiveRule?].self, forKey: .archiveRules)
        var archiveRulesDecoded0:[InlineArchiveRule]? = nil
        if let archiveRulesContainer = archiveRulesContainer {
            archiveRulesDecoded0 = [InlineArchiveRule]()
            for structure0 in archiveRulesContainer {
                if let structure0 = structure0 {
                    archiveRulesDecoded0?.append(structure0)
                }
            }
        }
        archiveRules = archiveRulesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateAnalyzerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAnalyzerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAnalyzerOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAnalyzerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAnalyzerOutputResponse(arn: \(String(describing: arn)))"}
}

extension CreateAnalyzerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAnalyzerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

/// <p>The response to the request to create an analyzer.</p>
public struct CreateAnalyzerOutputResponse: Equatable {
    /// <p>The ARN of the analyzer that was created by the request.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreateAnalyzerOutputResponseBody: Equatable {
    public let arn: String?
}

extension CreateAnalyzerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct CreateArchiveRuleInputBodyMiddleware: Middleware {
    public let id: String = "CreateArchiveRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateArchiveRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateArchiveRuleInput>
    public typealias MOutput = OperationOutput<CreateArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateArchiveRuleOutputError>
}

extension CreateArchiveRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateArchiveRuleInput(analyzerName: \(String(describing: analyzerName)), clientToken: \(String(describing: clientToken)), filter: \(String(describing: filter)), ruleName: \(String(describing: ruleName)))"}
}

extension CreateArchiveRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case filter
        case ruleName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .filter)
            for (dictKey0, filtercriteriamap0) in filter {
                try filterContainer.encode(filtercriteriamap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }
}

public struct CreateArchiveRuleInputHeadersMiddleware: Middleware {
    public let id: String = "CreateArchiveRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateArchiveRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateArchiveRuleInput>
    public typealias MOutput = OperationOutput<CreateArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateArchiveRuleOutputError>
}

public struct CreateArchiveRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateArchiveRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateArchiveRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateArchiveRuleInput>
    public typealias MOutput = OperationOutput<CreateArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateArchiveRuleOutputError>
}

/// <p>Creates an archive rule.</p>
public struct CreateArchiveRuleInput: Equatable {
    /// <p>The name of the created analyzer.</p>
    public let analyzerName: String?
    /// <p>A client token.</p>
    public var clientToken: String?
    /// <p>The criteria for the rule.</p>
    public let filter: [String:Criterion]?
    /// <p>The name of the rule to create.</p>
    public let ruleName: String?

    public init (
        analyzerName: String? = nil,
        clientToken: String? = nil,
        filter: [String:Criterion]? = nil,
        ruleName: String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.clientToken = clientToken
        self.filter = filter
        self.ruleName = ruleName
    }
}

struct CreateArchiveRuleInputBody: Equatable {
    public let ruleName: String?
    public let filter: [String:Criterion]?
    public let clientToken: String?
}

extension CreateArchiveRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case filter
        case ruleName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let filterContainer = try containerValues.decodeIfPresent([String: Criterion?].self, forKey: .filter)
        var filterDecoded0: [String:Criterion]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [String:Criterion]()
            for (key0, criterion0) in filterContainer {
                if let criterion0 = criterion0 {
                    filterDecoded0?[key0] = criterion0
                }
            }
        }
        filter = filterDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateArchiveRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateArchiveRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateArchiveRuleOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateArchiveRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateArchiveRuleOutputResponse()"}
}

extension CreateArchiveRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateArchiveRuleOutputResponse: Equatable {

    public init() {}
}

struct CreateArchiveRuleOutputResponseBody: Equatable {
}

extension CreateArchiveRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Criterion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contains
        case eq
        case exists
        case neq
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contains = contains {
            var containsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contains)
            for valuelist0 in contains {
                try containsContainer.encode(valuelist0)
            }
        }
        if let eq = eq {
            var eqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eq)
            for valuelist0 in eq {
                try eqContainer.encode(valuelist0)
            }
        }
        if let exists = exists {
            try encodeContainer.encode(exists, forKey: .exists)
        }
        if let neq = neq {
            var neqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .neq)
            for valuelist0 in neq {
                try neqContainer.encode(valuelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eqContainer = try containerValues.decodeIfPresent([String?].self, forKey: .eq)
        var eqDecoded0:[String]? = nil
        if let eqContainer = eqContainer {
            eqDecoded0 = [String]()
            for string0 in eqContainer {
                if let string0 = string0 {
                    eqDecoded0?.append(string0)
                }
            }
        }
        eq = eqDecoded0
        let neqContainer = try containerValues.decodeIfPresent([String?].self, forKey: .neq)
        var neqDecoded0:[String]? = nil
        if let neqContainer = neqContainer {
            neqDecoded0 = [String]()
            for string0 in neqContainer {
                if let string0 = string0 {
                    neqDecoded0?.append(string0)
                }
            }
        }
        neq = neqDecoded0
        let containsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .contains)
        var containsDecoded0:[String]? = nil
        if let containsContainer = containsContainer {
            containsDecoded0 = [String]()
            for string0 in containsContainer {
                if let string0 = string0 {
                    containsDecoded0?.append(string0)
                }
            }
        }
        contains = containsDecoded0
        let existsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .exists)
        exists = existsDecoded
    }
}

extension Criterion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Criterion(contains: \(String(describing: contains)), eq: \(String(describing: eq)), exists: \(String(describing: exists)), neq: \(String(describing: neq)))"}
}

/// <p>The criteria to use in the filter that defines the archive rule.</p>
public struct Criterion: Equatable {
    /// <p>A "contains" operator to match for the filter used to create the rule.</p>
    public let contains: [String]?
    /// <p>An "equals" operator to match for the filter used to create the rule.</p>
    public let eq: [String]?
    /// <p>An "exists" operator to match for the filter used to create the rule. </p>
    public let exists: Bool?
    /// <p>A "not equals" operator to match for the filter used to create the rule.</p>
    public let neq: [String]?

    public init (
        contains: [String]? = nil,
        eq: [String]? = nil,
        exists: Bool? = nil,
        neq: [String]? = nil
    )
    {
        self.contains = contains
        self.eq = eq
        self.exists = exists
        self.neq = neq
    }
}

extension DeleteAnalyzerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAnalyzerInput(analyzerName: \(String(describing: analyzerName)), clientToken: \(String(describing: clientToken)))"}
}

extension DeleteAnalyzerInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAnalyzerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAnalyzerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAnalyzerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAnalyzerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAnalyzerInput>
    public typealias MOutput = OperationOutput<DeleteAnalyzerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAnalyzerOutputError>
}

public struct DeleteAnalyzerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAnalyzerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAnalyzerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAnalyzerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = URLQueryItem(name: "clientToken".urlPercentEncoding(), value: String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAnalyzerInput>
    public typealias MOutput = OperationOutput<DeleteAnalyzerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAnalyzerOutputError>
}

/// <p>Deletes an analyzer.</p>
public struct DeleteAnalyzerInput: Equatable {
    /// <p>The name of the analyzer to delete.</p>
    public let analyzerName: String?
    /// <p>A client token.</p>
    public var clientToken: String?

    public init (
        analyzerName: String? = nil,
        clientToken: String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.clientToken = clientToken
    }
}

struct DeleteAnalyzerInputBody: Equatable {
}

extension DeleteAnalyzerInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAnalyzerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAnalyzerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAnalyzerOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAnalyzerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAnalyzerOutputResponse()"}
}

extension DeleteAnalyzerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAnalyzerOutputResponse: Equatable {

    public init() {}
}

struct DeleteAnalyzerOutputResponseBody: Equatable {
}

extension DeleteAnalyzerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteArchiveRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteArchiveRuleInput(analyzerName: \(String(describing: analyzerName)), clientToken: \(String(describing: clientToken)), ruleName: \(String(describing: ruleName)))"}
}

extension DeleteArchiveRuleInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteArchiveRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteArchiveRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteArchiveRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteArchiveRuleInput>
    public typealias MOutput = OperationOutput<DeleteArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteArchiveRuleOutputError>
}

public struct DeleteArchiveRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteArchiveRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteArchiveRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = URLQueryItem(name: "clientToken".urlPercentEncoding(), value: String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteArchiveRuleInput>
    public typealias MOutput = OperationOutput<DeleteArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteArchiveRuleOutputError>
}

/// <p>Deletes an archive rule.</p>
public struct DeleteArchiveRuleInput: Equatable {
    /// <p>The name of the analyzer that associated with the archive rule to delete.</p>
    public let analyzerName: String?
    /// <p>A client token.</p>
    public var clientToken: String?
    /// <p>The name of the rule to delete.</p>
    public let ruleName: String?

    public init (
        analyzerName: String? = nil,
        clientToken: String? = nil,
        ruleName: String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.clientToken = clientToken
        self.ruleName = ruleName
    }
}

struct DeleteArchiveRuleInputBody: Equatable {
}

extension DeleteArchiveRuleInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteArchiveRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteArchiveRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteArchiveRuleOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteArchiveRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteArchiveRuleOutputResponse()"}
}

extension DeleteArchiveRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteArchiveRuleOutputResponse: Equatable {

    public init() {}
}

struct DeleteArchiveRuleOutputResponseBody: Equatable {
}

extension DeleteArchiveRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Finding: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
        case analyzedAt
        case condition
        case createdAt
        case error
        case id
        case isPublic
        case principal
        case resource
        case resourceOwnerAccount
        case resourceType
        case sources
        case status
        case updatedAt
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            var actionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .action)
            for actionlist0 in action {
                try actionContainer.encode(actionlist0)
            }
        }
        if let analyzedAt = analyzedAt {
            try encodeContainer.encode(analyzedAt.timeIntervalSince1970, forKey: .analyzedAt)
        }
        if let condition = condition {
            var conditionContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .condition)
            for (dictKey0, conditionkeymap0) in condition {
                try conditionContainer.encode(conditionkeymap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let isPublic = isPublic {
            try encodeContainer.encode(isPublic, forKey: .isPublic)
        }
        if let principal = principal {
            var principalContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .principal)
            for (dictKey0, principalmap0) in principal {
                try principalContainer.encode(principalmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceOwnerAccount = resourceOwnerAccount {
            try encodeContainer.encode(resourceOwnerAccount, forKey: .resourceOwnerAccount)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for findingsourcelist0 in sources {
                try sourcesContainer.encode(findingsourcelist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let principalContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .principal)
        var principalDecoded0: [String:String]? = nil
        if let principalContainer = principalContainer {
            principalDecoded0 = [String:String]()
            for (key0, string0) in principalContainer {
                if let string0 = string0 {
                    principalDecoded0?[key0] = string0
                }
            }
        }
        principal = principalDecoded0
        let actionContainer = try containerValues.decodeIfPresent([String?].self, forKey: .action)
        var actionDecoded0:[String]? = nil
        if let actionContainer = actionContainer {
            actionDecoded0 = [String]()
            for string0 in actionContainer {
                if let string0 = string0 {
                    actionDecoded0?.append(string0)
                }
            }
        }
        action = actionDecoded0
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
        let isPublicDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isPublic)
        isPublic = isPublicDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let conditionContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .condition)
        var conditionDecoded0: [String:String]? = nil
        if let conditionContainer = conditionContainer {
            conditionDecoded0 = [String:String]()
            for (key0, string0) in conditionContainer {
                if let string0 = string0 {
                    conditionDecoded0?[key0] = string0
                }
            }
        }
        condition = conditionDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let analyzedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .analyzedAt)
        analyzedAt = analyzedAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FindingStatus.self, forKey: .status)
        status = statusDecoded
        let resourceOwnerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceOwnerAccount)
        resourceOwnerAccount = resourceOwnerAccountDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([FindingSource?].self, forKey: .sources)
        var sourcesDecoded0:[FindingSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [FindingSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension Finding: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Finding(action: \(String(describing: action)), analyzedAt: \(String(describing: analyzedAt)), condition: \(String(describing: condition)), createdAt: \(String(describing: createdAt)), error: \(String(describing: error)), id: \(String(describing: id)), isPublic: \(String(describing: isPublic)), principal: \(String(describing: principal)), resource: \(String(describing: resource)), resourceOwnerAccount: \(String(describing: resourceOwnerAccount)), resourceType: \(String(describing: resourceType)), sources: \(String(describing: sources)), status: \(String(describing: status)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>Contains information about a finding.</p>
public struct Finding: Equatable {
    /// <p>The action in the analyzed policy statement that an external principal has permission to
    ///          use.</p>
    public let action: [String]?
    /// <p>The time at which the resource was analyzed.</p>
    public let analyzedAt: Date?
    /// <p>The condition in the analyzed policy statement that resulted in a finding.</p>
    public let condition: [String:String]?
    /// <p>The time at which the finding was generated.</p>
    public let createdAt: Date?
    /// <p>An error.</p>
    public let error: String?
    /// <p>The ID of the finding.</p>
    public let id: String?
    /// <p>Indicates whether the policy that generated the finding allows public access to the
    ///          resource.</p>
    public let isPublic: Bool?
    /// <p>The external principal that access to a resource within the zone of trust.</p>
    public let principal: [String:String]?
    /// <p>The resource that an external principal has access to.</p>
    public let resource: String?
    /// <p>The AWS account ID that owns the resource.</p>
    public let resourceOwnerAccount: String?
    /// <p>The type of the resource identified in the finding.</p>
    public let resourceType: ResourceType?
    /// <p>The sources of the finding. This indicates how the access that generated the finding is
    ///          granted. It is populated for Amazon S3 bucket findings.</p>
    public let sources: [FindingSource]?
    /// <p>The current status of the finding.</p>
    public let status: FindingStatus?
    /// <p>The time at which the finding was updated.</p>
    public let updatedAt: Date?

    public init (
        action: [String]? = nil,
        analyzedAt: Date? = nil,
        condition: [String:String]? = nil,
        createdAt: Date? = nil,
        error: String? = nil,
        id: String? = nil,
        isPublic: Bool? = nil,
        principal: [String:String]? = nil,
        resource: String? = nil,
        resourceOwnerAccount: String? = nil,
        resourceType: ResourceType? = nil,
        sources: [FindingSource]? = nil,
        status: FindingStatus? = nil,
        updatedAt: Date? = nil
    )
    {
        self.action = action
        self.analyzedAt = analyzedAt
        self.condition = condition
        self.createdAt = createdAt
        self.error = error
        self.id = id
        self.isPublic = isPublic
        self.principal = principal
        self.resource = resource
        self.resourceOwnerAccount = resourceOwnerAccount
        self.resourceType = resourceType
        self.sources = sources
        self.status = status
        self.updatedAt = updatedAt
    }
}

public enum FindingChangeType {
    case changed
    case new
    case unchanged
    case sdkUnknown(String)
}

extension FindingChangeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FindingChangeType] {
        return [
            .changed,
            .new,
            .unchanged,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .changed: return "CHANGED"
        case .new: return "NEW"
        case .unchanged: return "UNCHANGED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FindingChangeType(rawValue: rawValue) ?? FindingChangeType.sdkUnknown(rawValue)
    }
}

extension FindingSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detail
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detail = detail {
            try encodeContainer.encode(detail, forKey: .detail)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(FindingSourceType.self, forKey: .type)
        type = typeDecoded
        let detailDecoded = try containerValues.decodeIfPresent(FindingSourceDetail.self, forKey: .detail)
        detail = detailDecoded
    }
}

extension FindingSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FindingSource(detail: \(String(describing: detail)), type: \(String(describing: type)))"}
}

/// <p>The source of the finding. This indicates how the access that generated the finding is
///          granted. It is populated for Amazon S3 bucket findings.</p>
public struct FindingSource: Equatable {
    /// <p>Includes details about how the access that generated the finding is granted. This is
    ///          populated for Amazon S3 bucket findings.</p>
    public let detail: FindingSourceDetail?
    /// <p>Indicates the type of access that generated the finding.</p>
    public let type: FindingSourceType?

    public init (
        detail: FindingSourceDetail? = nil,
        type: FindingSourceType? = nil
    )
    {
        self.detail = detail
        self.type = type
    }
}

extension FindingSourceDetail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessPointArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPointArn = accessPointArn {
            try encodeContainer.encode(accessPointArn, forKey: .accessPointArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPointArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessPointArn)
        accessPointArn = accessPointArnDecoded
    }
}

extension FindingSourceDetail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FindingSourceDetail(accessPointArn: \(String(describing: accessPointArn)))"}
}

/// <p>Includes details about how the access that generated the finding is granted. This is
///          populated for Amazon S3 bucket findings.</p>
public struct FindingSourceDetail: Equatable {
    /// <p>The ARN of the access point that generated the finding.</p>
    public let accessPointArn: String?

    public init (
        accessPointArn: String? = nil
    )
    {
        self.accessPointArn = accessPointArn
    }
}

public enum FindingSourceType {
    case bucketAcl
    case policy
    case s3AccessPoint
    case sdkUnknown(String)
}

extension FindingSourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FindingSourceType] {
        return [
            .bucketAcl,
            .policy,
            .s3AccessPoint,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bucketAcl: return "BUCKET_ACL"
        case .policy: return "POLICY"
        case .s3AccessPoint: return "S3_ACCESS_POINT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FindingSourceType(rawValue: rawValue) ?? FindingSourceType.sdkUnknown(rawValue)
    }
}

public enum FindingStatus {
    case active
    case archived
    case resolved
    case sdkUnknown(String)
}

extension FindingStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FindingStatus] {
        return [
            .active,
            .archived,
            .resolved,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .archived: return "ARCHIVED"
        case .resolved: return "RESOLVED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FindingStatus(rawValue: rawValue) ?? FindingStatus.sdkUnknown(rawValue)
    }
}

public enum FindingStatusUpdate {
    case active
    case archived
    case sdkUnknown(String)
}

extension FindingStatusUpdate : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FindingStatusUpdate] {
        return [
            .active,
            .archived,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .archived: return "ARCHIVED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FindingStatusUpdate(rawValue: rawValue) ?? FindingStatusUpdate.sdkUnknown(rawValue)
    }
}

extension FindingSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
        case analyzedAt
        case condition
        case createdAt
        case error
        case id
        case isPublic
        case principal
        case resource
        case resourceOwnerAccount
        case resourceType
        case sources
        case status
        case updatedAt
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            var actionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .action)
            for actionlist0 in action {
                try actionContainer.encode(actionlist0)
            }
        }
        if let analyzedAt = analyzedAt {
            try encodeContainer.encode(analyzedAt.timeIntervalSince1970, forKey: .analyzedAt)
        }
        if let condition = condition {
            var conditionContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .condition)
            for (dictKey0, conditionkeymap0) in condition {
                try conditionContainer.encode(conditionkeymap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let isPublic = isPublic {
            try encodeContainer.encode(isPublic, forKey: .isPublic)
        }
        if let principal = principal {
            var principalContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .principal)
            for (dictKey0, principalmap0) in principal {
                try principalContainer.encode(principalmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let resourceOwnerAccount = resourceOwnerAccount {
            try encodeContainer.encode(resourceOwnerAccount, forKey: .resourceOwnerAccount)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for findingsourcelist0 in sources {
                try sourcesContainer.encode(findingsourcelist0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let principalContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .principal)
        var principalDecoded0: [String:String]? = nil
        if let principalContainer = principalContainer {
            principalDecoded0 = [String:String]()
            for (key0, string0) in principalContainer {
                if let string0 = string0 {
                    principalDecoded0?[key0] = string0
                }
            }
        }
        principal = principalDecoded0
        let actionContainer = try containerValues.decodeIfPresent([String?].self, forKey: .action)
        var actionDecoded0:[String]? = nil
        if let actionContainer = actionContainer {
            actionDecoded0 = [String]()
            for string0 in actionContainer {
                if let string0 = string0 {
                    actionDecoded0?.append(string0)
                }
            }
        }
        action = actionDecoded0
        let resourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resource)
        resource = resourceDecoded
        let isPublicDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isPublic)
        isPublic = isPublicDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let conditionContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .condition)
        var conditionDecoded0: [String:String]? = nil
        if let conditionContainer = conditionContainer {
            conditionDecoded0 = [String:String]()
            for (key0, string0) in conditionContainer {
                if let string0 = string0 {
                    conditionDecoded0?[key0] = string0
                }
            }
        }
        condition = conditionDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let analyzedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .analyzedAt)
        analyzedAt = analyzedAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FindingStatus.self, forKey: .status)
        status = statusDecoded
        let resourceOwnerAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceOwnerAccount)
        resourceOwnerAccount = resourceOwnerAccountDecoded
        let errorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .error)
        error = errorDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([FindingSource?].self, forKey: .sources)
        var sourcesDecoded0:[FindingSource]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [FindingSource]()
            for structure0 in sourcesContainer {
                if let structure0 = structure0 {
                    sourcesDecoded0?.append(structure0)
                }
            }
        }
        sources = sourcesDecoded0
    }
}

extension FindingSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FindingSummary(action: \(String(describing: action)), analyzedAt: \(String(describing: analyzedAt)), condition: \(String(describing: condition)), createdAt: \(String(describing: createdAt)), error: \(String(describing: error)), id: \(String(describing: id)), isPublic: \(String(describing: isPublic)), principal: \(String(describing: principal)), resource: \(String(describing: resource)), resourceOwnerAccount: \(String(describing: resourceOwnerAccount)), resourceType: \(String(describing: resourceType)), sources: \(String(describing: sources)), status: \(String(describing: status)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>Contains information about a finding.</p>
public struct FindingSummary: Equatable {
    /// <p>The action in the analyzed policy statement that an external principal has permission to
    ///          use.</p>
    public let action: [String]?
    /// <p>The time at which the resource-based policy that generated the finding was
    ///          analyzed.</p>
    public let analyzedAt: Date?
    /// <p>The condition in the analyzed policy statement that resulted in a finding.</p>
    public let condition: [String:String]?
    /// <p>The time at which the finding was created.</p>
    public let createdAt: Date?
    /// <p>The error that resulted in an Error finding.</p>
    public let error: String?
    /// <p>The ID of the finding.</p>
    public let id: String?
    /// <p>Indicates whether the finding reports a resource that has a policy that allows public
    ///          access.</p>
    public let isPublic: Bool?
    /// <p>The external principal that has access to a resource within the zone of trust.</p>
    public let principal: [String:String]?
    /// <p>The resource that the external principal has access to.</p>
    public let resource: String?
    /// <p>The AWS account ID that owns the resource.</p>
    public let resourceOwnerAccount: String?
    /// <p>The type of the resource that the external principal has access to.</p>
    public let resourceType: ResourceType?
    /// <p>The sources of the finding. This indicates how the access that generated the finding is
    ///          granted. It is populated for Amazon S3 bucket findings.</p>
    public let sources: [FindingSource]?
    /// <p>The status of the finding.</p>
    public let status: FindingStatus?
    /// <p>The time at which the finding was most recently updated.</p>
    public let updatedAt: Date?

    public init (
        action: [String]? = nil,
        analyzedAt: Date? = nil,
        condition: [String:String]? = nil,
        createdAt: Date? = nil,
        error: String? = nil,
        id: String? = nil,
        isPublic: Bool? = nil,
        principal: [String:String]? = nil,
        resource: String? = nil,
        resourceOwnerAccount: String? = nil,
        resourceType: ResourceType? = nil,
        sources: [FindingSource]? = nil,
        status: FindingStatus? = nil,
        updatedAt: Date? = nil
    )
    {
        self.action = action
        self.analyzedAt = analyzedAt
        self.condition = condition
        self.createdAt = createdAt
        self.error = error
        self.id = id
        self.isPublic = isPublic
        self.principal = principal
        self.resource = resource
        self.resourceOwnerAccount = resourceOwnerAccount
        self.resourceType = resourceType
        self.sources = sources
        self.status = status
        self.updatedAt = updatedAt
    }
}

extension GeneratedPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension GeneratedPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GeneratedPolicy(policy: \(String(describing: policy)))"}
}

/// <p>Contains the text for the generated policy.</p>
public struct GeneratedPolicy: Equatable {
    /// <p>The text to use as the content for the new policy. The policy is created using the
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreatePolicy.html">CreatePolicy</a> action.</p>
    public let policy: String?

    public init (
        policy: String? = nil
    )
    {
        self.policy = policy
    }
}

extension GeneratedPolicyProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudTrailProperties
        case isComplete
        case principalArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudTrailProperties = cloudTrailProperties {
            try encodeContainer.encode(cloudTrailProperties, forKey: .cloudTrailProperties)
        }
        if let isComplete = isComplete {
            try encodeContainer.encode(isComplete, forKey: .isComplete)
        }
        if let principalArn = principalArn {
            try encodeContainer.encode(principalArn, forKey: .principalArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isCompleteDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isComplete)
        isComplete = isCompleteDecoded
        let principalArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalArn)
        principalArn = principalArnDecoded
        let cloudTrailPropertiesDecoded = try containerValues.decodeIfPresent(CloudTrailProperties.self, forKey: .cloudTrailProperties)
        cloudTrailProperties = cloudTrailPropertiesDecoded
    }
}

extension GeneratedPolicyProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GeneratedPolicyProperties(cloudTrailProperties: \(String(describing: cloudTrailProperties)), isComplete: \(String(describing: isComplete)), principalArn: \(String(describing: principalArn)))"}
}

/// <p>Contains the generated policy details.</p>
public struct GeneratedPolicyProperties: Equatable {
    /// <p>Lists details about the <code>Trail</code> used to generated policy.</p>
    public let cloudTrailProperties: CloudTrailProperties?
    /// <p>This value is set to <code>true</code> if the generated policy contains all possible actions for a
    ///          service that Access Analyzer identified from the CloudTrail trail that you specified, and
    ///          <code>false</code> otherwise.</p>
    public let isComplete: Bool?
    /// <p>The ARN of the IAM entity (user or role) for which you are generating a policy.</p>
    public let principalArn: String?

    public init (
        cloudTrailProperties: CloudTrailProperties? = nil,
        isComplete: Bool? = nil,
        principalArn: String? = nil
    )
    {
        self.cloudTrailProperties = cloudTrailProperties
        self.isComplete = isComplete
        self.principalArn = principalArn
    }
}

extension GeneratedPolicyResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case generatedPolicies
        case properties
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let generatedPolicies = generatedPolicies {
            var generatedPoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .generatedPolicies)
            for generatedpolicylist0 in generatedPolicies {
                try generatedPoliciesContainer.encode(generatedpolicylist0)
            }
        }
        if let properties = properties {
            try encodeContainer.encode(properties, forKey: .properties)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertiesDecoded = try containerValues.decodeIfPresent(GeneratedPolicyProperties.self, forKey: .properties)
        properties = propertiesDecoded
        let generatedPoliciesContainer = try containerValues.decodeIfPresent([GeneratedPolicy?].self, forKey: .generatedPolicies)
        var generatedPoliciesDecoded0:[GeneratedPolicy]? = nil
        if let generatedPoliciesContainer = generatedPoliciesContainer {
            generatedPoliciesDecoded0 = [GeneratedPolicy]()
            for structure0 in generatedPoliciesContainer {
                if let structure0 = structure0 {
                    generatedPoliciesDecoded0?.append(structure0)
                }
            }
        }
        generatedPolicies = generatedPoliciesDecoded0
    }
}

extension GeneratedPolicyResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GeneratedPolicyResult(generatedPolicies: \(String(describing: generatedPolicies)), properties: \(String(describing: properties)))"}
}

/// <p>Contains the text for the generated policy and its details.</p>
public struct GeneratedPolicyResult: Equatable {
    /// <p>The text to use as the content for the new policy. The policy is created using the
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/APIReference/API_CreatePolicy.html">CreatePolicy</a> action.</p>
    public let generatedPolicies: [GeneratedPolicy]?
    /// <p>A <code>GeneratedPolicyProperties</code> object that contains properties of the
    ///          generated policy.</p>
    public let properties: GeneratedPolicyProperties?

    public init (
        generatedPolicies: [GeneratedPolicy]? = nil,
        properties: GeneratedPolicyProperties? = nil
    )
    {
        self.generatedPolicies = generatedPolicies
        self.properties = properties
    }
}

extension GetAccessPreviewInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessPreviewInput(accessPreviewId: \(String(describing: accessPreviewId)), analyzerArn: \(String(describing: analyzerArn)))"}
}

extension GetAccessPreviewInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAccessPreviewInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccessPreviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessPreviewInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessPreviewInput>
    public typealias MOutput = OperationOutput<GetAccessPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessPreviewOutputError>
}

public struct GetAccessPreviewInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccessPreviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessPreviewInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let analyzerArn = input.operationInput.analyzerArn {
            let analyzerArnQueryItem = URLQueryItem(name: "analyzerArn".urlPercentEncoding(), value: String(analyzerArn).urlPercentEncoding())
            input.builder.withQueryItem(analyzerArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessPreviewInput>
    public typealias MOutput = OperationOutput<GetAccessPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessPreviewOutputError>
}

public struct GetAccessPreviewInput: Equatable {
    /// <p>The unique ID for the access preview.</p>
    public let accessPreviewId: String?
    /// <p>The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of
    ///             the analyzer</a> used to generate the access preview.</p>
    public let analyzerArn: String?

    public init (
        accessPreviewId: String? = nil,
        analyzerArn: String? = nil
    )
    {
        self.accessPreviewId = accessPreviewId
        self.analyzerArn = analyzerArn
    }
}

struct GetAccessPreviewInputBody: Equatable {
}

extension GetAccessPreviewInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAccessPreviewOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccessPreviewOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccessPreviewOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessPreviewOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessPreviewOutputResponse(accessPreview: \(String(describing: accessPreview)))"}
}

extension GetAccessPreviewOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccessPreviewOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessPreview = output.accessPreview
        } else {
            self.accessPreview = nil
        }
    }
}

public struct GetAccessPreviewOutputResponse: Equatable {
    /// <p>An object that contains information about the access preview.</p>
    public let accessPreview: AccessPreview?

    public init (
        accessPreview: AccessPreview? = nil
    )
    {
        self.accessPreview = accessPreview
    }
}

struct GetAccessPreviewOutputResponseBody: Equatable {
    public let accessPreview: AccessPreview?
}

extension GetAccessPreviewOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessPreview
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPreviewDecoded = try containerValues.decodeIfPresent(AccessPreview.self, forKey: .accessPreview)
        accessPreview = accessPreviewDecoded
    }
}

extension GetAnalyzedResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAnalyzedResourceInput(analyzerArn: \(String(describing: analyzerArn)), resourceArn: \(String(describing: resourceArn)))"}
}

extension GetAnalyzedResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAnalyzedResourceInputHeadersMiddleware: Middleware {
    public let id: String = "GetAnalyzedResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAnalyzedResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAnalyzedResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAnalyzedResourceInput>
    public typealias MOutput = OperationOutput<GetAnalyzedResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAnalyzedResourceOutputError>
}

public struct GetAnalyzedResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAnalyzedResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAnalyzedResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAnalyzedResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        if let analyzerArn = input.operationInput.analyzerArn {
            let analyzerArnQueryItem = URLQueryItem(name: "analyzerArn".urlPercentEncoding(), value: String(analyzerArn).urlPercentEncoding())
            input.builder.withQueryItem(analyzerArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAnalyzedResourceInput>
    public typealias MOutput = OperationOutput<GetAnalyzedResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAnalyzedResourceOutputError>
}

/// <p>Retrieves an analyzed resource.</p>
public struct GetAnalyzedResourceInput: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of
    ///             the analyzer</a> to retrieve information from.</p>
    public let analyzerArn: String?
    /// <p>The ARN of the resource to retrieve information about.</p>
    public let resourceArn: String?

    public init (
        analyzerArn: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.resourceArn = resourceArn
    }
}

struct GetAnalyzedResourceInputBody: Equatable {
}

extension GetAnalyzedResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAnalyzedResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAnalyzedResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAnalyzedResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAnalyzedResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAnalyzedResourceOutputResponse(resource: \(String(describing: resource)))"}
}

extension GetAnalyzedResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAnalyzedResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resource = output.resource
        } else {
            self.resource = nil
        }
    }
}

/// <p>The response to the request.</p>
public struct GetAnalyzedResourceOutputResponse: Equatable {
    /// <p>An <code>AnalyzedResource</code> object that contains information that Access Analyzer found
    ///          when it analyzed the resource.</p>
    public let resource: AnalyzedResource?

    public init (
        resource: AnalyzedResource? = nil
    )
    {
        self.resource = resource
    }
}

struct GetAnalyzedResourceOutputResponseBody: Equatable {
    public let resource: AnalyzedResource?
}

extension GetAnalyzedResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resource
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(AnalyzedResource.self, forKey: .resource)
        resource = resourceDecoded
    }
}

extension GetAnalyzerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAnalyzerInput(analyzerName: \(String(describing: analyzerName)))"}
}

extension GetAnalyzerInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAnalyzerInputHeadersMiddleware: Middleware {
    public let id: String = "GetAnalyzerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAnalyzerInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAnalyzerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAnalyzerInput>
    public typealias MOutput = OperationOutput<GetAnalyzerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAnalyzerOutputError>
}

public struct GetAnalyzerInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAnalyzerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAnalyzerInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAnalyzerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAnalyzerInput>
    public typealias MOutput = OperationOutput<GetAnalyzerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAnalyzerOutputError>
}

/// <p>Retrieves an analyzer.</p>
public struct GetAnalyzerInput: Equatable {
    /// <p>The name of the analyzer retrieved.</p>
    public let analyzerName: String?

    public init (
        analyzerName: String? = nil
    )
    {
        self.analyzerName = analyzerName
    }
}

struct GetAnalyzerInputBody: Equatable {
}

extension GetAnalyzerInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAnalyzerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAnalyzerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAnalyzerOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAnalyzerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAnalyzerOutputResponse(analyzer: \(String(describing: analyzer)))"}
}

extension GetAnalyzerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAnalyzerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.analyzer = output.analyzer
        } else {
            self.analyzer = nil
        }
    }
}

/// <p>The response to the request.</p>
public struct GetAnalyzerOutputResponse: Equatable {
    /// <p>An <code>AnalyzerSummary</code> object that contains information about the
    ///          analyzer.</p>
    public let analyzer: AnalyzerSummary?

    public init (
        analyzer: AnalyzerSummary? = nil
    )
    {
        self.analyzer = analyzer
    }
}

struct GetAnalyzerOutputResponseBody: Equatable {
    public let analyzer: AnalyzerSummary?
}

extension GetAnalyzerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyzer
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerDecoded = try containerValues.decodeIfPresent(AnalyzerSummary.self, forKey: .analyzer)
        analyzer = analyzerDecoded
    }
}

extension GetArchiveRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetArchiveRuleInput(analyzerName: \(String(describing: analyzerName)), ruleName: \(String(describing: ruleName)))"}
}

extension GetArchiveRuleInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetArchiveRuleInputHeadersMiddleware: Middleware {
    public let id: String = "GetArchiveRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetArchiveRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetArchiveRuleInput>
    public typealias MOutput = OperationOutput<GetArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetArchiveRuleOutputError>
}

public struct GetArchiveRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "GetArchiveRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetArchiveRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<GetArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetArchiveRuleInput>
    public typealias MOutput = OperationOutput<GetArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetArchiveRuleOutputError>
}

/// <p>Retrieves an archive rule.</p>
public struct GetArchiveRuleInput: Equatable {
    /// <p>The name of the analyzer to retrieve rules from.</p>
    public let analyzerName: String?
    /// <p>The name of the rule to retrieve.</p>
    public let ruleName: String?

    public init (
        analyzerName: String? = nil,
        ruleName: String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.ruleName = ruleName
    }
}

struct GetArchiveRuleInputBody: Equatable {
}

extension GetArchiveRuleInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetArchiveRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetArchiveRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetArchiveRuleOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetArchiveRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetArchiveRuleOutputResponse(archiveRule: \(String(describing: archiveRule)))"}
}

extension GetArchiveRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetArchiveRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.archiveRule = output.archiveRule
        } else {
            self.archiveRule = nil
        }
    }
}

/// <p>The response to the request.</p>
public struct GetArchiveRuleOutputResponse: Equatable {
    /// <p>Contains information about an archive rule.</p>
    public let archiveRule: ArchiveRuleSummary?

    public init (
        archiveRule: ArchiveRuleSummary? = nil
    )
    {
        self.archiveRule = archiveRule
    }
}

struct GetArchiveRuleOutputResponseBody: Equatable {
    public let archiveRule: ArchiveRuleSummary?
}

extension GetArchiveRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case archiveRule
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveRuleDecoded = try containerValues.decodeIfPresent(ArchiveRuleSummary.self, forKey: .archiveRule)
        archiveRule = archiveRuleDecoded
    }
}

extension GetFindingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFindingInput(analyzerArn: \(String(describing: analyzerArn)), id: \(String(describing: id)))"}
}

extension GetFindingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetFindingInputHeadersMiddleware: Middleware {
    public let id: String = "GetFindingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingInput>
    public typealias MOutput = OperationOutput<GetFindingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingOutputError>
}

public struct GetFindingInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFindingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFindingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFindingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let analyzerArn = input.operationInput.analyzerArn {
            let analyzerArnQueryItem = URLQueryItem(name: "analyzerArn".urlPercentEncoding(), value: String(analyzerArn).urlPercentEncoding())
            input.builder.withQueryItem(analyzerArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFindingInput>
    public typealias MOutput = OperationOutput<GetFindingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFindingOutputError>
}

/// <p>Retrieves a finding.</p>
public struct GetFindingInput: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of
    ///             the analyzer</a> that generated the finding.</p>
    public let analyzerArn: String?
    /// <p>The ID of the finding to retrieve.</p>
    public let id: String?

    public init (
        analyzerArn: String? = nil,
        id: String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.id = id
    }
}

struct GetFindingInputBody: Equatable {
}

extension GetFindingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetFindingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFindingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFindingOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFindingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFindingOutputResponse(finding: \(String(describing: finding)))"}
}

extension GetFindingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFindingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.finding = output.finding
        } else {
            self.finding = nil
        }
    }
}

/// <p>The response to the request.</p>
public struct GetFindingOutputResponse: Equatable {
    /// <p>A <code>finding</code> object that contains finding details.</p>
    public let finding: Finding?

    public init (
        finding: Finding? = nil
    )
    {
        self.finding = finding
    }
}

struct GetFindingOutputResponseBody: Equatable {
    public let finding: Finding?
}

extension GetFindingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case finding
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingDecoded = try containerValues.decodeIfPresent(Finding.self, forKey: .finding)
        finding = findingDecoded
    }
}

extension GetGeneratedPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGeneratedPolicyInput(includeResourcePlaceholders: \(String(describing: includeResourcePlaceholders)), includeServiceLevelTemplate: \(String(describing: includeServiceLevelTemplate)), jobId: \(String(describing: jobId)))"}
}

extension GetGeneratedPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetGeneratedPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetGeneratedPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGeneratedPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGeneratedPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGeneratedPolicyInput>
    public typealias MOutput = OperationOutput<GetGeneratedPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGeneratedPolicyOutputError>
}

public struct GetGeneratedPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetGeneratedPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGeneratedPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGeneratedPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let includeResourcePlaceholders = input.operationInput.includeResourcePlaceholders {
            let includeResourcePlaceholdersQueryItem = URLQueryItem(name: "includeResourcePlaceholders".urlPercentEncoding(), value: String(includeResourcePlaceholders).urlPercentEncoding())
            input.builder.withQueryItem(includeResourcePlaceholdersQueryItem)
        }
        if let includeServiceLevelTemplate = input.operationInput.includeServiceLevelTemplate {
            let includeServiceLevelTemplateQueryItem = URLQueryItem(name: "includeServiceLevelTemplate".urlPercentEncoding(), value: String(includeServiceLevelTemplate).urlPercentEncoding())
            input.builder.withQueryItem(includeServiceLevelTemplateQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGeneratedPolicyInput>
    public typealias MOutput = OperationOutput<GetGeneratedPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGeneratedPolicyOutputError>
}

public struct GetGeneratedPolicyInput: Equatable {
    /// <p>The level of detail that you want to generate. You can specify whether to generate
    ///          policies with placeholders for resource ARNs for actions that support resource level
    ///          granularity in policies.</p>
    ///          <p>For example, in the resource section of a policy, you can receive a placeholder such as
    ///             <code>"Resource":"arn:aws:s3:::${BucketName}"</code> instead of <code>"*"</code>.</p>
    public let includeResourcePlaceholders: Bool?
    /// <p>The level of detail that you want to generate. You can specify whether to generate
    ///          service-level policies. </p>
    ///          <p>Access Analyzer uses <code>iam:servicelastaccessed</code> to identify services that have been
    ///          used recently to create this service-level template.</p>
    public let includeServiceLevelTemplate: Bool?
    /// <p>The <code>JobId</code> that is returned by the <code>StartPolicyGeneration</code>
    ///          operation. The <code>JobId</code> can be used with <code>GetGeneratedPolicy</code> to
    ///          retrieve the generated policies or used with <code>CancelPolicyGeneration</code> to cancel
    ///          the policy generation request.</p>
    public let jobId: String?

    public init (
        includeResourcePlaceholders: Bool? = nil,
        includeServiceLevelTemplate: Bool? = nil,
        jobId: String? = nil
    )
    {
        self.includeResourcePlaceholders = includeResourcePlaceholders
        self.includeServiceLevelTemplate = includeServiceLevelTemplate
        self.jobId = jobId
    }
}

struct GetGeneratedPolicyInputBody: Equatable {
}

extension GetGeneratedPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetGeneratedPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGeneratedPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGeneratedPolicyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGeneratedPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGeneratedPolicyOutputResponse(generatedPolicyResult: \(String(describing: generatedPolicyResult)), jobDetails: \(String(describing: jobDetails)))"}
}

extension GetGeneratedPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetGeneratedPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.generatedPolicyResult = output.generatedPolicyResult
            self.jobDetails = output.jobDetails
        } else {
            self.generatedPolicyResult = nil
            self.jobDetails = nil
        }
    }
}

public struct GetGeneratedPolicyOutputResponse: Equatable {
    /// <p>A <code>GeneratedPolicyResult</code> object that contains the generated policies and
    ///          associated details.</p>
    public let generatedPolicyResult: GeneratedPolicyResult?
    /// <p>A <code>GeneratedPolicyDetails</code> object that contains details about the generated
    ///          policy.</p>
    public let jobDetails: JobDetails?

    public init (
        generatedPolicyResult: GeneratedPolicyResult? = nil,
        jobDetails: JobDetails? = nil
    )
    {
        self.generatedPolicyResult = generatedPolicyResult
        self.jobDetails = jobDetails
    }
}

struct GetGeneratedPolicyOutputResponseBody: Equatable {
    public let jobDetails: JobDetails?
    public let generatedPolicyResult: GeneratedPolicyResult?
}

extension GetGeneratedPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case generatedPolicyResult
        case jobDetails
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDetailsDecoded = try containerValues.decodeIfPresent(JobDetails.self, forKey: .jobDetails)
        jobDetails = jobDetailsDecoded
        let generatedPolicyResultDecoded = try containerValues.decodeIfPresent(GeneratedPolicyResult.self, forKey: .generatedPolicyResult)
        generatedPolicyResult = generatedPolicyResultDecoded
    }
}

extension IamRoleConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case trustPolicy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trustPolicy = trustPolicy {
            try encodeContainer.encode(trustPolicy, forKey: .trustPolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trustPolicy)
        trustPolicy = trustPolicyDecoded
    }
}

extension IamRoleConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IamRoleConfiguration(trustPolicy: \(String(describing: trustPolicy)))"}
}

/// <p>The proposed access control configuration for an IAM role. You can propose a
///          configuration for a new IAM role or an existing IAM role that you own by specifying the
///          trust policy. If the configuration is for a new IAM role, you must specify the trust
///          policy. If the configuration is for an existing IAM role that you own and you do not
///          propose the trust policy, the access preview uses the existing trust policy for the role.
///          The proposed trust policy cannot be an empty string. For more information about role trust
///          policy limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html">IAM and STS
///          quotas</a>.</p>
public struct IamRoleConfiguration: Equatable {
    /// <p>The proposed trust policy for the IAM role.</p>
    public let trustPolicy: String?

    public init (
        trustPolicy: String? = nil
    )
    {
        self.trustPolicy = trustPolicy
    }
}

extension InlineArchiveRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter
        case ruleName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .filter)
            for (dictKey0, filtercriteriamap0) in filter {
                try filterContainer.encode(filtercriteriamap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let ruleName = ruleName {
            try encodeContainer.encode(ruleName, forKey: .ruleName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleName)
        ruleName = ruleNameDecoded
        let filterContainer = try containerValues.decodeIfPresent([String: Criterion?].self, forKey: .filter)
        var filterDecoded0: [String:Criterion]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [String:Criterion]()
            for (key0, criterion0) in filterContainer {
                if let criterion0 = criterion0 {
                    filterDecoded0?[key0] = criterion0
                }
            }
        }
        filter = filterDecoded0
    }
}

extension InlineArchiveRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InlineArchiveRule(filter: \(String(describing: filter)), ruleName: \(String(describing: ruleName)))"}
}

/// <p>An criterion statement in an archive rule. Each archive rule may have multiple
///          criteria.</p>
public struct InlineArchiveRule: Equatable {
    /// <p>The condition and values for a criterion.</p>
    public let filter: [String:Criterion]?
    /// <p>The name of the rule.</p>
    public let ruleName: String?

    public init (
        filter: [String:Criterion]? = nil,
        ruleName: String? = nil
    )
    {
        self.filter = filter
        self.ruleName = ruleName
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Internal server error.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = true
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    /// <p>The seconds to wait to retry.</p>
    public var retryAfterSeconds: Int?

    public init (
        message: String? = nil,
        retryAfterSeconds: Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternetConfiguration: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension InternetConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternetConfiguration()"}
}

/// <p>This configuration sets the Amazon S3 access point network origin to
///          <code>Internet</code>.</p>
public struct InternetConfiguration: Equatable {

    public init() {}
}

extension JobDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case completedOn
        case jobError
        case jobId
        case startedOn
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completedOn = completedOn {
            try encodeContainer.encode(completedOn.timeIntervalSince1970, forKey: .completedOn)
        }
        if let jobError = jobError {
            try encodeContainer.encode(jobError, forKey: .jobError)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let startedOn = startedOn {
            try encodeContainer.encode(startedOn.timeIntervalSince1970, forKey: .startedOn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .status)
        status = statusDecoded
        let startedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedOn)
        startedOn = startedOnDecoded
        let completedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedOn)
        completedOn = completedOnDecoded
        let jobErrorDecoded = try containerValues.decodeIfPresent(JobError.self, forKey: .jobError)
        jobError = jobErrorDecoded
    }
}

extension JobDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobDetails(completedOn: \(String(describing: completedOn)), jobError: \(String(describing: jobError)), jobId: \(String(describing: jobId)), startedOn: \(String(describing: startedOn)), status: \(String(describing: status)))"}
}

/// <p>Contains details about the policy generation request.</p>
public struct JobDetails: Equatable {
    /// <p>A timestamp of when the job was completed.</p>
    public let completedOn: Date?
    /// <p>Contains the details about the policy generation error.</p>
    public let jobError: JobError?
    /// <p>The <code>JobId</code> that is returned by the <code>StartPolicyGeneration</code>
    ///          operation. The <code>JobId</code> can be used with <code>GetGeneratedPolicy</code> to
    ///          retrieve the generated policies or used with <code>CancelPolicyGeneration</code> to cancel
    ///          the policy generation request.</p>
    public let jobId: String?
    /// <p>A timestamp of when the job was started.</p>
    public let startedOn: Date?
    /// <p>The status of the job request.</p>
    public let status: JobStatus?

    public init (
        completedOn: Date? = nil,
        jobError: JobError? = nil,
        jobId: String? = nil,
        startedOn: Date? = nil,
        status: JobStatus? = nil
    )
    {
        self.completedOn = completedOn
        self.jobError = jobError
        self.jobId = jobId
        self.startedOn = startedOn
        self.status = status
    }
}

extension JobError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(JobErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension JobError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JobError(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

/// <p>Contains the details about the policy generation error.</p>
public struct JobError: Equatable {
    /// <p>The job error code.</p>
    public let code: JobErrorCode?
    /// <p>Specific information about the error. For example, which service quota was exceeded or
    ///          which resource was not found.</p>
    public let message: String?

    public init (
        code: JobErrorCode? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

public enum JobErrorCode {
    case authorizationError
    case resourceNotFoundError
    case serviceError
    case serviceQuotaExceededError
    case sdkUnknown(String)
}

extension JobErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobErrorCode] {
        return [
            .authorizationError,
            .resourceNotFoundError,
            .serviceError,
            .serviceQuotaExceededError,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .authorizationError: return "AUTHORIZATION_ERROR"
        case .resourceNotFoundError: return "RESOURCE_NOT_FOUND_ERROR"
        case .serviceError: return "SERVICE_ERROR"
        case .serviceQuotaExceededError: return "SERVICE_QUOTA_EXCEEDED_ERROR"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobErrorCode(rawValue: rawValue) ?? JobErrorCode.sdkUnknown(rawValue)
    }
}

public enum JobStatus {
    case canceled
    case failed
    case inProgress
    case succeeded
    case sdkUnknown(String)
}

extension JobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobStatus] {
        return [
            .canceled,
            .failed,
            .inProgress,
            .succeeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canceled: return "CANCELED"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .succeeded: return "SUCCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
    }
}

extension KmsGrantConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case constraints
        case granteePrincipal
        case issuingAccount
        case operations
        case retiringPrincipal
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constraints = constraints {
            try encodeContainer.encode(constraints, forKey: .constraints)
        }
        if let granteePrincipal = granteePrincipal {
            try encodeContainer.encode(granteePrincipal, forKey: .granteePrincipal)
        }
        if let issuingAccount = issuingAccount {
            try encodeContainer.encode(issuingAccount, forKey: .issuingAccount)
        }
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for kmsgrantoperationslist0 in operations {
                try operationsContainer.encode(kmsgrantoperationslist0.rawValue)
            }
        }
        if let retiringPrincipal = retiringPrincipal {
            try encodeContainer.encode(retiringPrincipal, forKey: .retiringPrincipal)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let operationsContainer = try containerValues.decodeIfPresent([KmsGrantOperation?].self, forKey: .operations)
        var operationsDecoded0:[KmsGrantOperation]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [KmsGrantOperation]()
            for string0 in operationsContainer {
                if let string0 = string0 {
                    operationsDecoded0?.append(string0)
                }
            }
        }
        operations = operationsDecoded0
        let granteePrincipalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .granteePrincipal)
        granteePrincipal = granteePrincipalDecoded
        let retiringPrincipalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .retiringPrincipal)
        retiringPrincipal = retiringPrincipalDecoded
        let constraintsDecoded = try containerValues.decodeIfPresent(KmsGrantConstraints.self, forKey: .constraints)
        constraints = constraintsDecoded
        let issuingAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .issuingAccount)
        issuingAccount = issuingAccountDecoded
    }
}

extension KmsGrantConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KmsGrantConfiguration(constraints: \(String(describing: constraints)), granteePrincipal: \(String(describing: granteePrincipal)), issuingAccount: \(String(describing: issuingAccount)), operations: \(String(describing: operations)), retiringPrincipal: \(String(describing: retiringPrincipal)))"}
}

/// <p>A proposed grant configuration for a KMS key. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_CreateGrant.html">CreateGrant</a>.</p>
public struct KmsGrantConfiguration: Equatable {
    /// <p>Use this structure to propose allowing <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic
    ///             operations</a> in the grant only when the operation request includes the specified
    ///             <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">encryption
    ///          context</a>.</p>
    public let constraints: KmsGrantConstraints?
    /// <p>The principal that is given permission to perform the operations that the grant
    ///          permits.</p>
    public let granteePrincipal: String?
    /// <p> The AWS account under which the grant was issued. The account is used to propose KMS
    ///          grants issued by accounts other than the owner of the key.</p>
    public let issuingAccount: String?
    /// <p>A list of operations that the grant permits.</p>
    public let operations: [KmsGrantOperation]?
    /// <p>The principal that is given permission to retire the grant by using <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_RetireGrant.html">RetireGrant</a> operation.</p>
    public let retiringPrincipal: String?

    public init (
        constraints: KmsGrantConstraints? = nil,
        granteePrincipal: String? = nil,
        issuingAccount: String? = nil,
        operations: [KmsGrantOperation]? = nil,
        retiringPrincipal: String? = nil
    )
    {
        self.constraints = constraints
        self.granteePrincipal = granteePrincipal
        self.issuingAccount = issuingAccount
        self.operations = operations
        self.retiringPrincipal = retiringPrincipal
    }
}

extension KmsGrantConstraints: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case encryptionContextEquals
        case encryptionContextSubset
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionContextEquals = encryptionContextEquals {
            var encryptionContextEqualsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .encryptionContextEquals)
            for (dictKey0, kmsconstraintsmap0) in encryptionContextEquals {
                try encryptionContextEqualsContainer.encode(kmsconstraintsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let encryptionContextSubset = encryptionContextSubset {
            var encryptionContextSubsetContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .encryptionContextSubset)
            for (dictKey0, kmsconstraintsmap0) in encryptionContextSubset {
                try encryptionContextSubsetContainer.encode(kmsconstraintsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionContextEqualsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .encryptionContextEquals)
        var encryptionContextEqualsDecoded0: [String:String]? = nil
        if let encryptionContextEqualsContainer = encryptionContextEqualsContainer {
            encryptionContextEqualsDecoded0 = [String:String]()
            for (key0, kmsconstraintsvalue0) in encryptionContextEqualsContainer {
                if let kmsconstraintsvalue0 = kmsconstraintsvalue0 {
                    encryptionContextEqualsDecoded0?[key0] = kmsconstraintsvalue0
                }
            }
        }
        encryptionContextEquals = encryptionContextEqualsDecoded0
        let encryptionContextSubsetContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .encryptionContextSubset)
        var encryptionContextSubsetDecoded0: [String:String]? = nil
        if let encryptionContextSubsetContainer = encryptionContextSubsetContainer {
            encryptionContextSubsetDecoded0 = [String:String]()
            for (key0, kmsconstraintsvalue0) in encryptionContextSubsetContainer {
                if let kmsconstraintsvalue0 = kmsconstraintsvalue0 {
                    encryptionContextSubsetDecoded0?[key0] = kmsconstraintsvalue0
                }
            }
        }
        encryptionContextSubset = encryptionContextSubsetDecoded0
    }
}

extension KmsGrantConstraints: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KmsGrantConstraints(encryptionContextEquals: \(String(describing: encryptionContextEquals)), encryptionContextSubset: \(String(describing: encryptionContextSubset)))"}
}

/// <p>Use this structure to propose allowing <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic
///             operations</a> in the grant only when the operation request includes the specified
///             <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context">encryption
///          context</a>. You can specify only one type of encryption context. An empty map is
///          treated as not specified. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/APIReference/API_GrantConstraints.html">GrantConstraints</a>.</p>
public struct KmsGrantConstraints: Equatable {
    /// <p>A list of key-value pairs that must match the encryption context in the <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic
    ///             operation</a> request. The grant allows the operation only when the encryption
    ///          context in the request is the same as the encryption context specified in this
    ///          constraint.</p>
    public let encryptionContextEquals: [String:String]?
    /// <p>A list of key-value pairs that must be included in the encryption context of the <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#cryptographic-operations">cryptographic
    ///             operation</a> request. The grant allows the cryptographic operation only when the
    ///          encryption context in the request includes the key-value pairs specified in this
    ///          constraint, although it can include additional key-value pairs.</p>
    public let encryptionContextSubset: [String:String]?

    public init (
        encryptionContextEquals: [String:String]? = nil,
        encryptionContextSubset: [String:String]? = nil
    )
    {
        self.encryptionContextEquals = encryptionContextEquals
        self.encryptionContextSubset = encryptionContextSubset
    }
}

public enum KmsGrantOperation {
    case createGrant
    case decrypt
    case describeKey
    case encrypt
    case generateDataKey
    case generateDataKeyPair
    case generateDataKeyPairWithoutPlaintext
    case generateDataKeyWithoutPlaintext
    case getPublicKey
    case reencryptFrom
    case reencryptTo
    case retireGrant
    case sign
    case verify
    case sdkUnknown(String)
}

extension KmsGrantOperation : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [KmsGrantOperation] {
        return [
            .createGrant,
            .decrypt,
            .describeKey,
            .encrypt,
            .generateDataKey,
            .generateDataKeyPair,
            .generateDataKeyPairWithoutPlaintext,
            .generateDataKeyWithoutPlaintext,
            .getPublicKey,
            .reencryptFrom,
            .reencryptTo,
            .retireGrant,
            .sign,
            .verify,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createGrant: return "CreateGrant"
        case .decrypt: return "Decrypt"
        case .describeKey: return "DescribeKey"
        case .encrypt: return "Encrypt"
        case .generateDataKey: return "GenerateDataKey"
        case .generateDataKeyPair: return "GenerateDataKeyPair"
        case .generateDataKeyPairWithoutPlaintext: return "GenerateDataKeyPairWithoutPlaintext"
        case .generateDataKeyWithoutPlaintext: return "GenerateDataKeyWithoutPlaintext"
        case .getPublicKey: return "GetPublicKey"
        case .reencryptFrom: return "ReEncryptFrom"
        case .reencryptTo: return "ReEncryptTo"
        case .retireGrant: return "RetireGrant"
        case .sign: return "Sign"
        case .verify: return "Verify"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = KmsGrantOperation(rawValue: rawValue) ?? KmsGrantOperation.sdkUnknown(rawValue)
    }
}

extension KmsKeyConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grants
        case keyPolicies
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grants = grants {
            var grantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grants)
            for kmsgrantconfigurationslist0 in grants {
                try grantsContainer.encode(kmsgrantconfigurationslist0)
            }
        }
        if let keyPolicies = keyPolicies {
            var keyPoliciesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .keyPolicies)
            for (dictKey0, kmskeypoliciesmap0) in keyPolicies {
                try keyPoliciesContainer.encode(kmskeypoliciesmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyPoliciesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .keyPolicies)
        var keyPoliciesDecoded0: [String:String]? = nil
        if let keyPoliciesContainer = keyPoliciesContainer {
            keyPoliciesDecoded0 = [String:String]()
            for (key0, kmskeypolicy0) in keyPoliciesContainer {
                if let kmskeypolicy0 = kmskeypolicy0 {
                    keyPoliciesDecoded0?[key0] = kmskeypolicy0
                }
            }
        }
        keyPolicies = keyPoliciesDecoded0
        let grantsContainer = try containerValues.decodeIfPresent([KmsGrantConfiguration?].self, forKey: .grants)
        var grantsDecoded0:[KmsGrantConfiguration]? = nil
        if let grantsContainer = grantsContainer {
            grantsDecoded0 = [KmsGrantConfiguration]()
            for structure0 in grantsContainer {
                if let structure0 = structure0 {
                    grantsDecoded0?.append(structure0)
                }
            }
        }
        grants = grantsDecoded0
    }
}

extension KmsKeyConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KmsKeyConfiguration(grants: \(String(describing: grants)), keyPolicies: \(String(describing: keyPolicies)))"}
}

/// <p>Proposed access control configuration for a KMS key. You can propose a configuration for
///          a new KMS key or an existing KMS key that you own by specifying the key policy and KMS
///          grant configuration. If the configuration is for an existing key and you do not specify the
///          key policy, the access preview uses the existing policy for the key. If the access preview
///          is for a new resource and you do not specify the key policy, then the access preview uses
///          the default key policy. The proposed key policy cannot be an empty string. For more
///          information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default">Default key
///             policy</a>. For more information about key policy limits, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/resource-limits.html">Resource
///             quotas</a>.</p>
///          <p/>
public struct KmsKeyConfiguration: Equatable {
    /// <p>A list of proposed grant configurations for the KMS key. If the proposed grant
    ///          configuration is for an existing key, the access preview uses the proposed list of grant
    ///          configurations in place of the existing grants. Otherwise, the access preview uses the
    ///          existing grants for the key.</p>
    public let grants: [KmsGrantConfiguration]?
    /// <p>Resource policy configuration for the KMS key. The only valid value for the name of the
    ///          key policy is <code>default</code>. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default">Default key
    ///             policy</a>.</p>
    public let keyPolicies: [String:String]?

    public init (
        grants: [KmsGrantConfiguration]? = nil,
        keyPolicies: [String:String]? = nil
    )
    {
        self.grants = grants
        self.keyPolicies = keyPolicies
    }
}

public struct ListAccessPreviewFindingsInputBodyMiddleware: Middleware {
    public let id: String = "ListAccessPreviewFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccessPreviewFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccessPreviewFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccessPreviewFindingsInput>
    public typealias MOutput = OperationOutput<ListAccessPreviewFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccessPreviewFindingsOutputError>
}

extension ListAccessPreviewFindingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccessPreviewFindingsInput(accessPreviewId: \(String(describing: accessPreviewId)), analyzerArn: \(String(describing: analyzerArn)), filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAccessPreviewFindingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyzerArn
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .filter)
            for (dictKey0, filtercriteriamap0) in filter {
                try filterContainer.encode(filtercriteriamap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAccessPreviewFindingsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAccessPreviewFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccessPreviewFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccessPreviewFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccessPreviewFindingsInput>
    public typealias MOutput = OperationOutput<ListAccessPreviewFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccessPreviewFindingsOutputError>
}

public struct ListAccessPreviewFindingsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAccessPreviewFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccessPreviewFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccessPreviewFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccessPreviewFindingsInput>
    public typealias MOutput = OperationOutput<ListAccessPreviewFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccessPreviewFindingsOutputError>
}

public struct ListAccessPreviewFindingsInput: Equatable {
    /// <p>The unique ID for the access preview.</p>
    public let accessPreviewId: String?
    /// <p>The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of
    ///             the analyzer</a> used to generate the access.</p>
    public let analyzerArn: String?
    /// <p>Criteria to filter the returned findings.</p>
    public let filter: [String:Criterion]?
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int?
    /// <p>A token used for pagination of results returned.</p>
    public let nextToken: String?

    public init (
        accessPreviewId: String? = nil,
        analyzerArn: String? = nil,
        filter: [String:Criterion]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.accessPreviewId = accessPreviewId
        self.analyzerArn = analyzerArn
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccessPreviewFindingsInputBody: Equatable {
    public let analyzerArn: String?
    public let filter: [String:Criterion]?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListAccessPreviewFindingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyzerArn
        case filter
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let filterContainer = try containerValues.decodeIfPresent([String: Criterion?].self, forKey: .filter)
        var filterDecoded0: [String:Criterion]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [String:Criterion]()
            for (key0, criterion0) in filterContainer {
                if let criterion0 = criterion0 {
                    filterDecoded0?[key0] = criterion0
                }
            }
        }
        filter = filterDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAccessPreviewFindingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccessPreviewFindingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccessPreviewFindingsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessPreviewFindingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccessPreviewFindingsOutputResponse(findings: \(String(describing: findings)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAccessPreviewFindingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAccessPreviewFindingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.findings = output.findings
            self.nextToken = output.nextToken
        } else {
            self.findings = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessPreviewFindingsOutputResponse: Equatable {
    /// <p>A list of access preview findings that match the specified filter criteria.</p>
    public let findings: [AccessPreviewFinding]?
    /// <p>A token used for pagination of results returned.</p>
    public let nextToken: String?

    public init (
        findings: [AccessPreviewFinding]? = nil,
        nextToken: String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

struct ListAccessPreviewFindingsOutputResponseBody: Equatable {
    public let findings: [AccessPreviewFinding]?
    public let nextToken: String?
}

extension ListAccessPreviewFindingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findings
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([AccessPreviewFinding?].self, forKey: .findings)
        var findingsDecoded0:[AccessPreviewFinding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [AccessPreviewFinding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAccessPreviewsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccessPreviewsInput(analyzerArn: \(String(describing: analyzerArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAccessPreviewsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAccessPreviewsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAccessPreviewsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccessPreviewsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccessPreviewsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccessPreviewsInput>
    public typealias MOutput = OperationOutput<ListAccessPreviewsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccessPreviewsOutputError>
}

public struct ListAccessPreviewsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAccessPreviewsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAccessPreviewsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAccessPreviewsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let analyzerArn = input.operationInput.analyzerArn {
            let analyzerArnQueryItem = URLQueryItem(name: "analyzerArn".urlPercentEncoding(), value: String(analyzerArn).urlPercentEncoding())
            input.builder.withQueryItem(analyzerArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAccessPreviewsInput>
    public typealias MOutput = OperationOutput<ListAccessPreviewsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAccessPreviewsOutputError>
}

public struct ListAccessPreviewsInput: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of
    ///             the analyzer</a> used to generate the access preview.</p>
    public let analyzerArn: String?
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int?
    /// <p>A token used for pagination of results returned.</p>
    public let nextToken: String?

    public init (
        analyzerArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccessPreviewsInputBody: Equatable {
}

extension ListAccessPreviewsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAccessPreviewsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccessPreviewsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccessPreviewsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessPreviewsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAccessPreviewsOutputResponse(accessPreviews: \(String(describing: accessPreviews)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAccessPreviewsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAccessPreviewsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accessPreviews = output.accessPreviews
            self.nextToken = output.nextToken
        } else {
            self.accessPreviews = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessPreviewsOutputResponse: Equatable {
    /// <p>A list of access previews retrieved for the analyzer.</p>
    public let accessPreviews: [AccessPreviewSummary]?
    /// <p>A token used for pagination of results returned.</p>
    public let nextToken: String?

    public init (
        accessPreviews: [AccessPreviewSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.accessPreviews = accessPreviews
        self.nextToken = nextToken
    }
}

struct ListAccessPreviewsOutputResponseBody: Equatable {
    public let accessPreviews: [AccessPreviewSummary]?
    public let nextToken: String?
}

extension ListAccessPreviewsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accessPreviews
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPreviewsContainer = try containerValues.decodeIfPresent([AccessPreviewSummary?].self, forKey: .accessPreviews)
        var accessPreviewsDecoded0:[AccessPreviewSummary]? = nil
        if let accessPreviewsContainer = accessPreviewsContainer {
            accessPreviewsDecoded0 = [AccessPreviewSummary]()
            for structure0 in accessPreviewsContainer {
                if let structure0 = structure0 {
                    accessPreviewsDecoded0?.append(structure0)
                }
            }
        }
        accessPreviews = accessPreviewsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAnalyzedResourcesInputBodyMiddleware: Middleware {
    public let id: String = "ListAnalyzedResourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAnalyzedResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAnalyzedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAnalyzedResourcesInput>
    public typealias MOutput = OperationOutput<ListAnalyzedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAnalyzedResourcesOutputError>
}

extension ListAnalyzedResourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAnalyzedResourcesInput(analyzerArn: \(String(describing: analyzerArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceType: \(String(describing: resourceType)))"}
}

extension ListAnalyzedResourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyzerArn
        case maxResults
        case nextToken
        case resourceType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }
}

public struct ListAnalyzedResourcesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAnalyzedResourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAnalyzedResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAnalyzedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAnalyzedResourcesInput>
    public typealias MOutput = OperationOutput<ListAnalyzedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAnalyzedResourcesOutputError>
}

public struct ListAnalyzedResourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAnalyzedResourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAnalyzedResourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAnalyzedResourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAnalyzedResourcesInput>
    public typealias MOutput = OperationOutput<ListAnalyzedResourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAnalyzedResourcesOutputError>
}

/// <p>Retrieves a list of resources that have been analyzed.</p>
public struct ListAnalyzedResourcesInput: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of
    ///             the analyzer</a> to retrieve a list of analyzed resources from.</p>
    public let analyzerArn: String?
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int?
    /// <p>A token used for pagination of results returned.</p>
    public let nextToken: String?
    /// <p>The type of resource.</p>
    public let resourceType: ResourceType?

    public init (
        analyzerArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceType = resourceType
    }
}

struct ListAnalyzedResourcesInputBody: Equatable {
    public let analyzerArn: String?
    public let resourceType: ResourceType?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListAnalyzedResourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyzerArn
        case maxResults
        case nextToken
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAnalyzedResourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnalyzedResourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAnalyzedResourcesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnalyzedResourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAnalyzedResourcesOutputResponse(analyzedResources: \(String(describing: analyzedResources)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAnalyzedResourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAnalyzedResourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.analyzedResources = output.analyzedResources
            self.nextToken = output.nextToken
        } else {
            self.analyzedResources = nil
            self.nextToken = nil
        }
    }
}

/// <p>The response to the request.</p>
public struct ListAnalyzedResourcesOutputResponse: Equatable {
    /// <p>A list of resources that were analyzed.</p>
    public let analyzedResources: [AnalyzedResourceSummary]?
    /// <p>A token used for pagination of results returned.</p>
    public let nextToken: String?

    public init (
        analyzedResources: [AnalyzedResourceSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.analyzedResources = analyzedResources
        self.nextToken = nextToken
    }
}

struct ListAnalyzedResourcesOutputResponseBody: Equatable {
    public let analyzedResources: [AnalyzedResourceSummary]?
    public let nextToken: String?
}

extension ListAnalyzedResourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyzedResources
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzedResourcesContainer = try containerValues.decodeIfPresent([AnalyzedResourceSummary?].self, forKey: .analyzedResources)
        var analyzedResourcesDecoded0:[AnalyzedResourceSummary]? = nil
        if let analyzedResourcesContainer = analyzedResourcesContainer {
            analyzedResourcesDecoded0 = [AnalyzedResourceSummary]()
            for structure0 in analyzedResourcesContainer {
                if let structure0 = structure0 {
                    analyzedResourcesDecoded0?.append(structure0)
                }
            }
        }
        analyzedResources = analyzedResourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAnalyzersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAnalyzersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), type: \(String(describing: type)))"}
}

extension ListAnalyzersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAnalyzersInputHeadersMiddleware: Middleware {
    public let id: String = "ListAnalyzersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAnalyzersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAnalyzersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAnalyzersInput>
    public typealias MOutput = OperationOutput<ListAnalyzersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAnalyzersOutputError>
}

public struct ListAnalyzersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAnalyzersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAnalyzersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAnalyzersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let type = input.operationInput.type {
            let typeQueryItem = URLQueryItem(name: "type".urlPercentEncoding(), value: String(type.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(typeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAnalyzersInput>
    public typealias MOutput = OperationOutput<ListAnalyzersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAnalyzersOutputError>
}

/// <p>Retrieves a list of analyzers.</p>
public struct ListAnalyzersInput: Equatable {
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int?
    /// <p>A token used for pagination of results returned.</p>
    public let nextToken: String?
    /// <p>The type of analyzer.</p>
    public let type: `Type`?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        type: `Type`? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListAnalyzersInputBody: Equatable {
}

extension ListAnalyzersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAnalyzersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAnalyzersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAnalyzersOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAnalyzersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAnalyzersOutputResponse(analyzers: \(String(describing: analyzers)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAnalyzersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAnalyzersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.analyzers = output.analyzers
            self.nextToken = output.nextToken
        } else {
            self.analyzers = nil
            self.nextToken = nil
        }
    }
}

/// <p>The response to the request.</p>
public struct ListAnalyzersOutputResponse: Equatable {
    /// <p>The analyzers retrieved.</p>
    public let analyzers: [AnalyzerSummary]?
    /// <p>A token used for pagination of results returned.</p>
    public let nextToken: String?

    public init (
        analyzers: [AnalyzerSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.analyzers = analyzers
        self.nextToken = nextToken
    }
}

struct ListAnalyzersOutputResponseBody: Equatable {
    public let analyzers: [AnalyzerSummary]?
    public let nextToken: String?
}

extension ListAnalyzersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyzers
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzersContainer = try containerValues.decodeIfPresent([AnalyzerSummary?].self, forKey: .analyzers)
        var analyzersDecoded0:[AnalyzerSummary]? = nil
        if let analyzersContainer = analyzersContainer {
            analyzersDecoded0 = [AnalyzerSummary]()
            for structure0 in analyzersContainer {
                if let structure0 = structure0 {
                    analyzersDecoded0?.append(structure0)
                }
            }
        }
        analyzers = analyzersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListArchiveRulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListArchiveRulesInput(analyzerName: \(String(describing: analyzerName)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListArchiveRulesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListArchiveRulesInputHeadersMiddleware: Middleware {
    public let id: String = "ListArchiveRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListArchiveRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListArchiveRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListArchiveRulesInput>
    public typealias MOutput = OperationOutput<ListArchiveRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListArchiveRulesOutputError>
}

public struct ListArchiveRulesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListArchiveRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListArchiveRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListArchiveRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListArchiveRulesInput>
    public typealias MOutput = OperationOutput<ListArchiveRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListArchiveRulesOutputError>
}

/// <p>Retrieves a list of archive rules created for the specified analyzer.</p>
public struct ListArchiveRulesInput: Equatable {
    /// <p>The name of the analyzer to retrieve rules from.</p>
    public let analyzerName: String?
    /// <p>The maximum number of results to return in the request.</p>
    public let maxResults: Int?
    /// <p>A token used for pagination of results returned.</p>
    public let nextToken: String?

    public init (
        analyzerName: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListArchiveRulesInputBody: Equatable {
}

extension ListArchiveRulesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListArchiveRulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListArchiveRulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListArchiveRulesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListArchiveRulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListArchiveRulesOutputResponse(archiveRules: \(String(describing: archiveRules)), nextToken: \(String(describing: nextToken)))"}
}

extension ListArchiveRulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListArchiveRulesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.archiveRules = output.archiveRules
            self.nextToken = output.nextToken
        } else {
            self.archiveRules = nil
            self.nextToken = nil
        }
    }
}

/// <p>The response to the request.</p>
public struct ListArchiveRulesOutputResponse: Equatable {
    /// <p>A list of archive rules created for the specified analyzer.</p>
    public let archiveRules: [ArchiveRuleSummary]?
    /// <p>A token used for pagination of results returned.</p>
    public let nextToken: String?

    public init (
        archiveRules: [ArchiveRuleSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.archiveRules = archiveRules
        self.nextToken = nextToken
    }
}

struct ListArchiveRulesOutputResponseBody: Equatable {
    public let archiveRules: [ArchiveRuleSummary]?
    public let nextToken: String?
}

extension ListArchiveRulesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case archiveRules
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveRulesContainer = try containerValues.decodeIfPresent([ArchiveRuleSummary?].self, forKey: .archiveRules)
        var archiveRulesDecoded0:[ArchiveRuleSummary]? = nil
        if let archiveRulesContainer = archiveRulesContainer {
            archiveRulesDecoded0 = [ArchiveRuleSummary]()
            for structure0 in archiveRulesContainer {
                if let structure0 = structure0 {
                    archiveRulesDecoded0?.append(structure0)
                }
            }
        }
        archiveRules = archiveRulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFindingsInputBodyMiddleware: Middleware {
    public let id: String = "ListFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFindingsInput>
    public typealias MOutput = OperationOutput<ListFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFindingsOutputError>
}

extension ListFindingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFindingsInput(analyzerArn: \(String(describing: analyzerArn)), filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sort: \(String(describing: sort)))"}
}

extension ListFindingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyzerArn
        case filter
        case maxResults
        case nextToken
        case sort
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .filter)
            for (dictKey0, filtercriteriamap0) in filter {
                try filterContainer.encode(filtercriteriamap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sort = sort {
            try encodeContainer.encode(sort, forKey: .sort)
        }
    }
}

public struct ListFindingsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFindingsInput>
    public typealias MOutput = OperationOutput<ListFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFindingsOutputError>
}

public struct ListFindingsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFindingsInput>
    public typealias MOutput = OperationOutput<ListFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFindingsOutputError>
}

/// <p>Retrieves a list of findings generated by the specified analyzer.</p>
public struct ListFindingsInput: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of
    ///             the analyzer</a> to retrieve findings from.</p>
    public let analyzerArn: String?
    /// <p>A filter to match for the findings to return.</p>
    public let filter: [String:Criterion]?
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int?
    /// <p>A token used for pagination of results returned.</p>
    public let nextToken: String?
    /// <p>The sort order for the findings returned.</p>
    public let sort: SortCriteria?

    public init (
        analyzerArn: String? = nil,
        filter: [String:Criterion]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sort: SortCriteria? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
    }
}

struct ListFindingsInputBody: Equatable {
    public let analyzerArn: String?
    public let filter: [String:Criterion]?
    public let sort: SortCriteria?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListFindingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyzerArn
        case filter
        case maxResults
        case nextToken
        case sort
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let filterContainer = try containerValues.decodeIfPresent([String: Criterion?].self, forKey: .filter)
        var filterDecoded0: [String:Criterion]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [String:Criterion]()
            for (key0, criterion0) in filterContainer {
                if let criterion0 = criterion0 {
                    filterDecoded0?[key0] = criterion0
                }
            }
        }
        filter = filterDecoded0
        let sortDecoded = try containerValues.decodeIfPresent(SortCriteria.self, forKey: .sort)
        sort = sortDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFindingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFindingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFindingsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFindingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFindingsOutputResponse(findings: \(String(describing: findings)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFindingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFindingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.findings = output.findings
            self.nextToken = output.nextToken
        } else {
            self.findings = nil
            self.nextToken = nil
        }
    }
}

/// <p>The response to the request.</p>
public struct ListFindingsOutputResponse: Equatable {
    /// <p>A list of findings retrieved from the analyzer that match the filter criteria specified,
    ///          if any.</p>
    public let findings: [FindingSummary]?
    /// <p>A token used for pagination of results returned.</p>
    public let nextToken: String?

    public init (
        findings: [FindingSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

struct ListFindingsOutputResponseBody: Equatable {
    public let findings: [FindingSummary]?
    public let nextToken: String?
}

extension ListFindingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findings
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([FindingSummary?].self, forKey: .findings)
        var findingsDecoded0:[FindingSummary]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [FindingSummary]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPolicyGenerationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPolicyGenerationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), principalArn: \(String(describing: principalArn)))"}
}

extension ListPolicyGenerationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPolicyGenerationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPolicyGenerationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPolicyGenerationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPolicyGenerationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPolicyGenerationsInput>
    public typealias MOutput = OperationOutput<ListPolicyGenerationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPolicyGenerationsOutputError>
}

public struct ListPolicyGenerationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPolicyGenerationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPolicyGenerationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPolicyGenerationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let principalArn = input.operationInput.principalArn {
            let principalArnQueryItem = URLQueryItem(name: "principalArn".urlPercentEncoding(), value: String(principalArn).urlPercentEncoding())
            input.builder.withQueryItem(principalArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPolicyGenerationsInput>
    public typealias MOutput = OperationOutput<ListPolicyGenerationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPolicyGenerationsOutputError>
}

public struct ListPolicyGenerationsInput: Equatable {
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int?
    /// <p>A token used for pagination of results returned.</p>
    public let nextToken: String?
    /// <p>The ARN of the IAM entity (user or role) for which you are generating a policy. Use
    ///          this with <code>ListGeneratedPolicies</code> to filter the results to only include results
    ///          for a specific principal.</p>
    public let principalArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        principalArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principalArn = principalArn
    }
}

struct ListPolicyGenerationsInputBody: Equatable {
}

extension ListPolicyGenerationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPolicyGenerationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPolicyGenerationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPolicyGenerationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPolicyGenerationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPolicyGenerationsOutputResponse(nextToken: \(String(describing: nextToken)), policyGenerations: \(String(describing: policyGenerations)))"}
}

extension ListPolicyGenerationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPolicyGenerationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.policyGenerations = output.policyGenerations
        } else {
            self.nextToken = nil
            self.policyGenerations = nil
        }
    }
}

public struct ListPolicyGenerationsOutputResponse: Equatable {
    /// <p>A token used for pagination of results returned.</p>
    public let nextToken: String?
    /// <p>A <code>PolicyGeneration</code> object that contains details about the generated
    ///          policy.</p>
    public let policyGenerations: [PolicyGeneration]?

    public init (
        nextToken: String? = nil,
        policyGenerations: [PolicyGeneration]? = nil
    )
    {
        self.nextToken = nextToken
        self.policyGenerations = policyGenerations
    }
}

struct ListPolicyGenerationsOutputResponseBody: Equatable {
    public let policyGenerations: [PolicyGeneration]?
    public let nextToken: String?
}

extension ListPolicyGenerationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case policyGenerations
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyGenerationsContainer = try containerValues.decodeIfPresent([PolicyGeneration?].self, forKey: .policyGenerations)
        var policyGenerationsDecoded0:[PolicyGeneration]? = nil
        if let policyGenerationsContainer = policyGenerationsContainer {
            policyGenerationsDecoded0 = [PolicyGeneration]()
            for structure0 in policyGenerationsContainer {
                if let structure0 = structure0 {
                    policyGenerationsDecoded0?.append(structure0)
                }
            }
        }
        policyGenerations = policyGenerationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

/// <p>Retrieves a list of tags applied to the specified resource.</p>
public struct ListTagsForResourceInput: Equatable {
    /// <p>The ARN of the resource to retrieve tags from.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

/// <p>The response to the request.</p>
public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags that are applied to the specified resource.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum Locale {
    case de
    case en
    case es
    case fr
    case it
    case ja
    case ko
    case ptBr
    case zhCn
    case zhTw
    case sdkUnknown(String)
}

extension Locale : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Locale] {
        return [
            .de,
            .en,
            .es,
            .fr,
            .it,
            .ja,
            .ko,
            .ptBr,
            .zhCn,
            .zhTw,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .de: return "DE"
        case .en: return "EN"
        case .es: return "ES"
        case .fr: return "FR"
        case .it: return "IT"
        case .ja: return "JA"
        case .ko: return "KO"
        case .ptBr: return "PT_BR"
        case .zhCn: return "ZH_CN"
        case .zhTw: return "ZH_TW"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Locale(rawValue: rawValue) ?? Locale.sdkUnknown(rawValue)
    }
}

extension Location: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case path
        case span
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = path {
            var pathContainer = encodeContainer.nestedUnkeyedContainer(forKey: .path)
            for pathelementlist0 in path {
                try pathContainer.encode(pathelementlist0)
            }
        }
        if let span = span {
            try encodeContainer.encode(span, forKey: .span)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathContainer = try containerValues.decodeIfPresent([PathElement?].self, forKey: .path)
        var pathDecoded0:[PathElement]? = nil
        if let pathContainer = pathContainer {
            pathDecoded0 = [PathElement]()
            for union0 in pathContainer {
                if let union0 = union0 {
                    pathDecoded0?.append(union0)
                }
            }
        }
        path = pathDecoded0
        let spanDecoded = try containerValues.decodeIfPresent(Span.self, forKey: .span)
        span = spanDecoded
    }
}

extension Location: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Location(path: \(String(describing: path)), span: \(String(describing: span)))"}
}

/// <p>A location in a policy that is represented as a path through the JSON representation and
///          a corresponding span.</p>
public struct Location: Equatable {
    /// <p>A path in a policy, represented as a sequence of path elements.</p>
    public let path: [PathElement]?
    /// <p>A span in a policy.</p>
    public let span: Span?

    public init (
        path: [PathElement]? = nil,
        span: Span? = nil
    )
    {
        self.path = path
        self.span = span
    }
}

extension NetworkOriginConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case internetConfiguration
        case sdkUnknown
        case vpcConfiguration
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .internetConfiguration(internetConfiguration):
                if let internetConfiguration = internetConfiguration {
                    try container.encode(internetConfiguration, forKey: .internetConfiguration)
                }
            case let .vpcConfiguration(vpcConfiguration):
                if let vpcConfiguration = vpcConfiguration {
                    try container.encode(vpcConfiguration, forKey: .vpcConfiguration)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let vpcConfigurationDecoded = try values.decodeIfPresent(VpcConfiguration.self, forKey: .vpcConfiguration)
        if let vpcConfiguration = vpcConfigurationDecoded {
            self = .vpcConfiguration(vpcConfiguration)
            return
        }
        let internetConfigurationDecoded = try values.decodeIfPresent(InternetConfiguration.self, forKey: .internetConfiguration)
        if let internetConfiguration = internetConfigurationDecoded {
            self = .internetConfiguration(internetConfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>The proposed <code>InternetConfiguration</code> or <code>VpcConfiguration</code> to
///          apply to the Amazon S3 Access point. You can make the access point accessible from the internet,
///          or you can specify that all requests made through that access point must originate from a
///          specific virtual private cloud (VPC). You can specify only one type of network
///          configuration. For more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/creating-access-points.html">Creating access
///          points</a>.</p>
public enum NetworkOriginConfiguration: Equatable {
    /// <p> The proposed virtual private cloud (VPC) configuration for the Amazon S3 access point. For
    ///          more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_VpcConfiguration.html">VpcConfiguration</a>.
    ///       </p>
    case vpcConfiguration(VpcConfiguration?)
    /// <p>The configuration for the Amazon S3 access point with an <code>Internet</code> origin.</p>
    case internetConfiguration(InternetConfiguration?)
    case sdkUnknown(String?)
}

public enum OrderBy {
    case asc
    case desc
    case sdkUnknown(String)
}

extension OrderBy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OrderBy] {
        return [
            .asc,
            .desc,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .asc: return "ASC"
        case .desc: return "DESC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OrderBy(rawValue: rawValue) ?? OrderBy.sdkUnknown(rawValue)
    }
}

extension PathElement: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case index
        case key
        case sdkUnknown
        case substring
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .index(index):
                if let index = index {
                    try container.encode(index, forKey: .index)
                }
            case let .key(key):
                if let key = key {
                    try container.encode(key, forKey: .key)
                }
            case let .substring(substring):
                if let substring = substring {
                    try container.encode(substring, forKey: .substring)
                }
            case let .value(value):
                if let value = value {
                    try container.encode(value, forKey: .value)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let indexDecoded = try values.decodeIfPresent(Int.self, forKey: .index)
        if let index = indexDecoded {
            self = .index(index)
            return
        }
        let keyDecoded = try values.decodeIfPresent(String.self, forKey: .key)
        if let key = keyDecoded {
            self = .key(key)
            return
        }
        let substringDecoded = try values.decodeIfPresent(Substring.self, forKey: .substring)
        if let substring = substringDecoded {
            self = .substring(substring)
            return
        }
        let valueDecoded = try values.decodeIfPresent(String.self, forKey: .value)
        if let value = valueDecoded {
            self = .value(value)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>A single element in a path through the JSON representation of a policy.</p>
public enum PathElement: Equatable {
    /// <p>Refers to an index in a JSON array.</p>
    case index(Int?)
    /// <p>Refers to a key in a JSON object.</p>
    case key(String?)
    /// <p>Refers to a substring of a literal string in a JSON object.</p>
    case substring(Substring?)
    /// <p>Refers to the value associated with a given key in a JSON object.</p>
    case value(String?)
    case sdkUnknown(String?)
}

extension PolicyGeneration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case completedOn
        case jobId
        case principalArn
        case startedOn
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completedOn = completedOn {
            try encodeContainer.encode(completedOn.timeIntervalSince1970, forKey: .completedOn)
        }
        if let jobId = jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let principalArn = principalArn {
            try encodeContainer.encode(principalArn, forKey: .principalArn)
        }
        if let startedOn = startedOn {
            try encodeContainer.encode(startedOn.timeIntervalSince1970, forKey: .startedOn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let principalArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalArn)
        principalArn = principalArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .status)
        status = statusDecoded
        let startedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedOn)
        startedOn = startedOnDecoded
        let completedOnDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedOn)
        completedOn = completedOnDecoded
    }
}

extension PolicyGeneration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyGeneration(completedOn: \(String(describing: completedOn)), jobId: \(String(describing: jobId)), principalArn: \(String(describing: principalArn)), startedOn: \(String(describing: startedOn)), status: \(String(describing: status)))"}
}

/// <p>Contains details about the policy generation status and properties.</p>
public struct PolicyGeneration: Equatable {
    /// <p>A timestamp of when the policy generation was completed.</p>
    public let completedOn: Date?
    /// <p>The <code>JobId</code> that is returned by the <code>StartPolicyGeneration</code>
    ///          operation. The <code>JobId</code> can be used with <code>GetGeneratedPolicy</code> to
    ///          retrieve the generated policies or used with <code>CancelPolicyGeneration</code> to cancel
    ///          the policy generation request.</p>
    public let jobId: String?
    /// <p>The ARN of the IAM entity (user or role) for which you are generating a policy.</p>
    public let principalArn: String?
    /// <p>A timestamp of when the policy generation started.</p>
    public let startedOn: Date?
    /// <p>The status of the policy generation request.</p>
    public let status: JobStatus?

    public init (
        completedOn: Date? = nil,
        jobId: String? = nil,
        principalArn: String? = nil,
        startedOn: Date? = nil,
        status: JobStatus? = nil
    )
    {
        self.completedOn = completedOn
        self.jobId = jobId
        self.principalArn = principalArn
        self.startedOn = startedOn
        self.status = status
    }
}

extension PolicyGenerationDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case principalArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let principalArn = principalArn {
            try encodeContainer.encode(principalArn, forKey: .principalArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principalArn)
        principalArn = principalArnDecoded
    }
}

extension PolicyGenerationDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyGenerationDetails(principalArn: \(String(describing: principalArn)))"}
}

/// <p>Contains the ARN details about the IAM entity for which the policy is
///          generated.</p>
public struct PolicyGenerationDetails: Equatable {
    /// <p>The ARN of the IAM entity (user or role) for which you are generating a policy.</p>
    public let principalArn: String?

    public init (
        principalArn: String? = nil
    )
    {
        self.principalArn = principalArn
    }
}

public enum PolicyType {
    case identityPolicy
    case resourcePolicy
    case serviceControlPolicy
    case sdkUnknown(String)
}

extension PolicyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PolicyType] {
        return [
            .identityPolicy,
            .resourcePolicy,
            .serviceControlPolicy,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .identityPolicy: return "IDENTITY_POLICY"
        case .resourcePolicy: return "RESOURCE_POLICY"
        case .serviceControlPolicy: return "SERVICE_CONTROL_POLICY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PolicyType(rawValue: rawValue) ?? PolicyType.sdkUnknown(rawValue)
    }
}

extension Position: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case column
        case line
        case offset
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let column = column {
            try encodeContainer.encode(column, forKey: .column)
        }
        if let line = line {
            try encodeContainer.encode(line, forKey: .line)
        }
        if let offset = offset {
            try encodeContainer.encode(offset, forKey: .offset)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lineDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .line)
        line = lineDecoded
        let columnDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .column)
        column = columnDecoded
        let offsetDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .offset)
        offset = offsetDecoded
    }
}

extension Position: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Position(column: \(String(describing: column)), line: \(String(describing: line)), offset: \(String(describing: offset)))"}
}

/// <p>A position in a policy.</p>
public struct Position: Equatable {
    /// <p>The column of the position, starting from 0.</p>
    public let column: Int?
    /// <p>The line of the position, starting from 1.</p>
    public let line: Int?
    /// <p>The offset within the policy that corresponds to the position, starting from 0.</p>
    public let offset: Int?

    public init (
        column: Int? = nil,
        line: Int? = nil,
        offset: Int? = nil
    )
    {
        self.column = column
        self.line = line
        self.offset = offset
    }
}

public enum ReasonCode {
    case awsServiceAccessDisabled
    case delegatedAdministratorDeregistered
    case organizationDeleted
    case serviceLinkedRoleCreationFailed
    case sdkUnknown(String)
}

extension ReasonCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReasonCode] {
        return [
            .awsServiceAccessDisabled,
            .delegatedAdministratorDeregistered,
            .organizationDeleted,
            .serviceLinkedRoleCreationFailed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsServiceAccessDisabled: return "AWS_SERVICE_ACCESS_DISABLED"
        case .delegatedAdministratorDeregistered: return "DELEGATED_ADMINISTRATOR_DEREGISTERED"
        case .organizationDeleted: return "ORGANIZATION_DELETED"
        case .serviceLinkedRoleCreationFailed: return "SERVICE_LINKED_ROLE_CREATION_FAILED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReasonCode(rawValue: rawValue) ?? ReasonCode.sdkUnknown(rawValue)
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource could not be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The ID of the resource.</p>
    public var resourceId: String?
    /// <p>The type of the resource.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public enum ResourceType {
    case awsIamRole
    case awsKmsKey
    case awsLambdaFunction
    case awsLambdaLayerversion
    case awsS3Bucket
    case awsSecretsmanagerSecret
    case awsSqsQueue
    case sdkUnknown(String)
}

extension ResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceType] {
        return [
            .awsIamRole,
            .awsKmsKey,
            .awsLambdaFunction,
            .awsLambdaLayerversion,
            .awsS3Bucket,
            .awsSecretsmanagerSecret,
            .awsSqsQueue,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsIamRole: return "AWS::IAM::Role"
        case .awsKmsKey: return "AWS::KMS::Key"
        case .awsLambdaFunction: return "AWS::Lambda::Function"
        case .awsLambdaLayerversion: return "AWS::Lambda::LayerVersion"
        case .awsS3Bucket: return "AWS::S3::Bucket"
        case .awsSecretsmanagerSecret: return "AWS::SecretsManager::Secret"
        case .awsSqsQueue: return "AWS::SQS::Queue"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
    }
}

extension S3AccessPointConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessPointPolicy
        case networkOrigin
        case publicAccessBlock
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPointPolicy = accessPointPolicy {
            try encodeContainer.encode(accessPointPolicy, forKey: .accessPointPolicy)
        }
        if let networkOrigin = networkOrigin {
            try encodeContainer.encode(networkOrigin, forKey: .networkOrigin)
        }
        if let publicAccessBlock = publicAccessBlock {
            try encodeContainer.encode(publicAccessBlock, forKey: .publicAccessBlock)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPointPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessPointPolicy)
        accessPointPolicy = accessPointPolicyDecoded
        let publicAccessBlockDecoded = try containerValues.decodeIfPresent(S3PublicAccessBlockConfiguration.self, forKey: .publicAccessBlock)
        publicAccessBlock = publicAccessBlockDecoded
        let networkOriginDecoded = try containerValues.decodeIfPresent(NetworkOriginConfiguration.self, forKey: .networkOrigin)
        networkOrigin = networkOriginDecoded
    }
}

extension S3AccessPointConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3AccessPointConfiguration(accessPointPolicy: \(String(describing: accessPointPolicy)), networkOrigin: \(String(describing: networkOrigin)), publicAccessBlock: \(String(describing: publicAccessBlock)))"}
}

/// <p>The configuration for an Amazon S3 access point for the bucket. You can propose up to 10
///          access points per bucket. If the proposed Amazon S3 access point configuration is for an
///          existing bucket, the access preview uses the proposed access point configuration in place
///          of the existing access points. To propose an access point without a policy, you can provide
///          an empty string as the access point policy. For more information, see <a href="https://docs.aws.amazon.com/https:/docs.aws.amazon.com/AmazonS3/latest/dev/creating-access-points.html">Creating access points</a>. For more information about access point policy limits,
///          see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/access-points-restrictions-limitations.html">Access points
///             restrictions and limitations</a>.</p>
public struct S3AccessPointConfiguration: Equatable {
    /// <p>The access point policy.</p>
    public let accessPointPolicy: String?
    /// <p>The proposed <code>Internet</code> and <code>VpcConfiguration</code> to apply to this
    ///          Amazon S3 access point. If the access preview is for a new resource and neither is specified,
    ///          the access preview uses <code>Internet</code> for the network origin. If the access preview
    ///          is for an existing resource and neither is specified, the access preview uses the exiting
    ///          network origin.</p>
    public let networkOrigin: NetworkOriginConfiguration?
    /// <p>The proposed <code>S3PublicAccessBlock</code> configuration to apply to this Amazon S3 Access
    ///          Point.</p>
    public let publicAccessBlock: S3PublicAccessBlockConfiguration?

    public init (
        accessPointPolicy: String? = nil,
        networkOrigin: NetworkOriginConfiguration? = nil,
        publicAccessBlock: S3PublicAccessBlockConfiguration? = nil
    )
    {
        self.accessPointPolicy = accessPointPolicy
        self.networkOrigin = networkOrigin
        self.publicAccessBlock = publicAccessBlock
    }
}

extension S3BucketAclGrantConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grantee
        case permission
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grantee = grantee {
            try encodeContainer.encode(grantee, forKey: .grantee)
        }
        if let permission = permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionDecoded = try containerValues.decodeIfPresent(AclPermission.self, forKey: .permission)
        permission = permissionDecoded
        let granteeDecoded = try containerValues.decodeIfPresent(AclGrantee.self, forKey: .grantee)
        grantee = granteeDecoded
    }
}

extension S3BucketAclGrantConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3BucketAclGrantConfiguration(grantee: \(String(describing: grantee)), permission: \(String(describing: permission)))"}
}

/// <p>A proposed access control list grant configuration for an Amazon S3 bucket. For more
///          information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#setting-acls">How to Specify an
///          ACL</a>.</p>
public struct S3BucketAclGrantConfiguration: Equatable {
    /// <p>The grantee to whom you’re assigning access rights.</p>
    public let grantee: AclGrantee?
    /// <p>The permissions being granted.</p>
    public let permission: AclPermission?

    public init (
        grantee: AclGrantee? = nil,
        permission: AclPermission? = nil
    )
    {
        self.grantee = grantee
        self.permission = permission
    }
}

extension S3BucketConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessPoints
        case bucketAclGrants
        case bucketPolicy
        case bucketPublicAccessBlock
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPoints = accessPoints {
            var accessPointsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .accessPoints)
            for (dictKey0, s3accesspointconfigurationsmap0) in accessPoints {
                try accessPointsContainer.encode(s3accesspointconfigurationsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let bucketAclGrants = bucketAclGrants {
            var bucketAclGrantsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bucketAclGrants)
            for s3bucketaclgrantconfigurationslist0 in bucketAclGrants {
                try bucketAclGrantsContainer.encode(s3bucketaclgrantconfigurationslist0)
            }
        }
        if let bucketPolicy = bucketPolicy {
            try encodeContainer.encode(bucketPolicy, forKey: .bucketPolicy)
        }
        if let bucketPublicAccessBlock = bucketPublicAccessBlock {
            try encodeContainer.encode(bucketPublicAccessBlock, forKey: .bucketPublicAccessBlock)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucketPolicy)
        bucketPolicy = bucketPolicyDecoded
        let bucketAclGrantsContainer = try containerValues.decodeIfPresent([S3BucketAclGrantConfiguration?].self, forKey: .bucketAclGrants)
        var bucketAclGrantsDecoded0:[S3BucketAclGrantConfiguration]? = nil
        if let bucketAclGrantsContainer = bucketAclGrantsContainer {
            bucketAclGrantsDecoded0 = [S3BucketAclGrantConfiguration]()
            for structure0 in bucketAclGrantsContainer {
                if let structure0 = structure0 {
                    bucketAclGrantsDecoded0?.append(structure0)
                }
            }
        }
        bucketAclGrants = bucketAclGrantsDecoded0
        let bucketPublicAccessBlockDecoded = try containerValues.decodeIfPresent(S3PublicAccessBlockConfiguration.self, forKey: .bucketPublicAccessBlock)
        bucketPublicAccessBlock = bucketPublicAccessBlockDecoded
        let accessPointsContainer = try containerValues.decodeIfPresent([String: S3AccessPointConfiguration?].self, forKey: .accessPoints)
        var accessPointsDecoded0: [String:S3AccessPointConfiguration]? = nil
        if let accessPointsContainer = accessPointsContainer {
            accessPointsDecoded0 = [String:S3AccessPointConfiguration]()
            for (key0, s3accesspointconfiguration0) in accessPointsContainer {
                if let s3accesspointconfiguration0 = s3accesspointconfiguration0 {
                    accessPointsDecoded0?[key0] = s3accesspointconfiguration0
                }
            }
        }
        accessPoints = accessPointsDecoded0
    }
}

extension S3BucketConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3BucketConfiguration(accessPoints: \(String(describing: accessPoints)), bucketAclGrants: \(String(describing: bucketAclGrants)), bucketPolicy: \(String(describing: bucketPolicy)), bucketPublicAccessBlock: \(String(describing: bucketPublicAccessBlock)))"}
}

/// <p>Proposed access control configuration for an Amazon S3 bucket. You can propose a
///          configuration for a new Amazon S3 bucket or an existing Amazon S3 bucket that you own by specifying
///          the Amazon S3 bucket policy, bucket ACLs, bucket BPA settings, and Amazon S3 access points attached
///          to the bucket. If the configuration is for an existing Amazon S3 bucket and you do not specify
///          the Amazon S3 bucket policy, the access preview uses the existing policy attached to the bucket.
///          If the access preview is for a new resource and you do not specify the Amazon S3 bucket policy,
///          the access preview assumes a bucket without a policy. To propose deletion of an existing
///          bucket policy, you can specify an empty string. For more information about bucket policy
///          limits, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/example-bucket-policies.html">Bucket Policy
///          Examples</a>.</p>
public struct S3BucketConfiguration: Equatable {
    /// <p>The configuration of Amazon S3 access points for the bucket.</p>
    public let accessPoints: [String:S3AccessPointConfiguration]?
    /// <p>The proposed list of ACL grants for the Amazon S3 bucket. You can propose up to 100 ACL
    ///          grants per bucket. If the proposed grant configuration is for an existing bucket, the
    ///          access preview uses the proposed list of grant configurations in place of the existing
    ///          grants. Otherwise, the access preview uses the existing grants for the bucket.</p>
    public let bucketAclGrants: [S3BucketAclGrantConfiguration]?
    /// <p>The proposed bucket policy for the Amazon S3 bucket.</p>
    public let bucketPolicy: String?
    /// <p>The proposed block public access configuration for the Amazon S3 bucket.</p>
    public let bucketPublicAccessBlock: S3PublicAccessBlockConfiguration?

    public init (
        accessPoints: [String:S3AccessPointConfiguration]? = nil,
        bucketAclGrants: [S3BucketAclGrantConfiguration]? = nil,
        bucketPolicy: String? = nil,
        bucketPublicAccessBlock: S3PublicAccessBlockConfiguration? = nil
    )
    {
        self.accessPoints = accessPoints
        self.bucketAclGrants = bucketAclGrants
        self.bucketPolicy = bucketPolicy
        self.bucketPublicAccessBlock = bucketPublicAccessBlock
    }
}

extension S3PublicAccessBlockConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ignorePublicAcls
        case restrictPublicBuckets
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ignorePublicAcls = ignorePublicAcls {
            try encodeContainer.encode(ignorePublicAcls, forKey: .ignorePublicAcls)
        }
        if let restrictPublicBuckets = restrictPublicBuckets {
            try encodeContainer.encode(restrictPublicBuckets, forKey: .restrictPublicBuckets)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ignorePublicAclsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .ignorePublicAcls)
        ignorePublicAcls = ignorePublicAclsDecoded
        let restrictPublicBucketsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .restrictPublicBuckets)
        restrictPublicBuckets = restrictPublicBucketsDecoded
    }
}

extension S3PublicAccessBlockConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3PublicAccessBlockConfiguration(ignorePublicAcls: \(String(describing: ignorePublicAcls)), restrictPublicBuckets: \(String(describing: restrictPublicBuckets)))"}
}

/// <p>The <code>PublicAccessBlock</code> configuration to apply to this Amazon S3 bucket. If the
///          proposed configuration is for an existing Amazon S3 bucket and the configuration is not
///          specified, the access preview uses the existing setting. If the proposed configuration is
///          for a new bucket and the configuration is not specified, the access preview uses
///             <code>false</code>. If the proposed configuration is for a new access point and the
///          access point BPA configuration is not specified, the access preview uses <code>true</code>.
///          For more information, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket-publicaccessblockconfiguration.html">PublicAccessBlockConfiguration</a>. </p>
public struct S3PublicAccessBlockConfiguration: Equatable {
    /// <p> Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this
    ///          bucket. </p>
    public let ignorePublicAcls: Bool?
    /// <p> Specifies whether Amazon S3 should restrict public bucket policies for this bucket. </p>
    public let restrictPublicBuckets: Bool?

    public init (
        ignorePublicAcls: Bool? = nil,
        restrictPublicBuckets: Bool? = nil
    )
    {
        self.ignorePublicAcls = ignorePublicAcls
        self.restrictPublicBuckets = restrictPublicBuckets
    }
}

extension SecretsManagerSecretConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case kmsKeyId
        case secretPolicy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let secretPolicy = secretPolicy {
            try encodeContainer.encode(secretPolicy, forKey: .secretPolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let secretPolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretPolicy)
        secretPolicy = secretPolicyDecoded
    }
}

extension SecretsManagerSecretConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SecretsManagerSecretConfiguration(kmsKeyId: \(String(describing: kmsKeyId)), secretPolicy: \(String(describing: secretPolicy)))"}
}

/// <p>The configuration for a Secrets Manager secret. For more information, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_CreateSecret.html">CreateSecret</a>.</p>
///          <p>You can propose a configuration for a new secret or an existing secret that you own by
///          specifying the secret policy and optional KMS encryption key. If the configuration is for
///          an existing secret and you do not specify the secret policy, the access preview uses the
///          existing policy for the secret. If the access preview is for a new resource and you do not
///          specify the policy, the access preview assumes a secret without a policy. To propose
///          deletion of an existing policy, you can specify an empty string. If the proposed
///          configuration is for a new secret and you do not specify the KMS key ID, the access preview
///          uses the default CMK of the AWS account. If you specify an empty string for the KMS key
///          ID, the access preview uses the default CMK of the AWS account. For more information
///          about secret policy limits, see <a href="https://docs.aws.amazon.com/secretsmanager/latest/userguide/reference_limits.html">Quotas for AWS Secrets
///             Manager.</a>.</p>
public struct SecretsManagerSecretConfiguration: Equatable {
    /// <p>The proposed ARN, key ID, or alias of the AWS KMS customer master key (CMK).</p>
    public let kmsKeyId: String?
    /// <p>The proposed resource policy defining who can access or manage the secret.</p>
    public let secretPolicy: String?

    public init (
        kmsKeyId: String? = nil,
        secretPolicy: String? = nil
    )
    {
        self.kmsKeyId = kmsKeyId
        self.secretPolicy = secretPolicy
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Service quote met error.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The resource ID.</p>
    public var resourceId: String?
    /// <p>The resource type.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension SortCriteria: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName
        case orderBy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let orderBy = orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(OrderBy.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension SortCriteria: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SortCriteria(attributeName: \(String(describing: attributeName)), orderBy: \(String(describing: orderBy)))"}
}

/// <p>The criteria used to sort.</p>
public struct SortCriteria: Equatable {
    /// <p>The name of the attribute to sort on.</p>
    public let attributeName: String?
    /// <p>The sort order, ascending or descending.</p>
    public let orderBy: OrderBy?

    public init (
        attributeName: String? = nil,
        orderBy: OrderBy? = nil
    )
    {
        self.attributeName = attributeName
        self.orderBy = orderBy
    }
}

extension Span: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case end
        case start
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let end = end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let start = start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(Position.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeIfPresent(Position.self, forKey: .end)
        end = endDecoded
    }
}

extension Span: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Span(end: \(String(describing: end)), start: \(String(describing: start)))"}
}

/// <p>A span in a policy. The span consists of a start position (inclusive) and end position
///          (exclusive).</p>
public struct Span: Equatable {
    /// <p>The end position of the span (exclusive).</p>
    public let end: Position?
    /// <p>The start position of the span (inclusive).</p>
    public let start: Position?

    public init (
        end: Position? = nil,
        start: Position? = nil
    )
    {
        self.end = end
        self.start = start
    }
}

extension SqsQueueConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case queuePolicy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queuePolicy = queuePolicy {
            try encodeContainer.encode(queuePolicy, forKey: .queuePolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queuePolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .queuePolicy)
        queuePolicy = queuePolicyDecoded
    }
}

extension SqsQueueConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SqsQueueConfiguration(queuePolicy: \(String(describing: queuePolicy)))"}
}

/// <p>The proposed access control configuration for an SQS queue. You can propose a
///          configuration for a new SQS queue or an existing SQS queue that you own by specifying the
///          SQS policy. If the configuration is for an existing SQS queue and you do not specify the
///          SQS policy, the access preview uses the existing SQS policy for the queue. If the access
///          preview is for a new resource and you do not specify the policy, the access preview assumes
///          an SQS queue without a policy. To propose deletion of an existing SQS queue policy, you can
///          specify an empty string for the SQS policy. For more information about SQS policy limits,
///          see <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/quotas-policies.html">Quotas related
///             to policies</a>.</p>
public struct SqsQueueConfiguration: Equatable {
    /// <p> The proposed resource policy for the SQS queue. </p>
    public let queuePolicy: String?

    public init (
        queuePolicy: String? = nil
    )
    {
        self.queuePolicy = queuePolicy
    }
}

public struct StartPolicyGenerationInputBodyMiddleware: Middleware {
    public let id: String = "StartPolicyGenerationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartPolicyGenerationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartPolicyGenerationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartPolicyGenerationInput>
    public typealias MOutput = OperationOutput<StartPolicyGenerationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartPolicyGenerationOutputError>
}

extension StartPolicyGenerationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartPolicyGenerationInput(clientToken: \(String(describing: clientToken)), cloudTrailDetails: \(String(describing: cloudTrailDetails)), policyGenerationDetails: \(String(describing: policyGenerationDetails)))"}
}

extension StartPolicyGenerationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case cloudTrailDetails
        case policyGenerationDetails
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let cloudTrailDetails = cloudTrailDetails {
            try encodeContainer.encode(cloudTrailDetails, forKey: .cloudTrailDetails)
        }
        if let policyGenerationDetails = policyGenerationDetails {
            try encodeContainer.encode(policyGenerationDetails, forKey: .policyGenerationDetails)
        }
    }
}

public struct StartPolicyGenerationInputHeadersMiddleware: Middleware {
    public let id: String = "StartPolicyGenerationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartPolicyGenerationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartPolicyGenerationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartPolicyGenerationInput>
    public typealias MOutput = OperationOutput<StartPolicyGenerationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartPolicyGenerationOutputError>
}

public struct StartPolicyGenerationInputQueryItemMiddleware: Middleware {
    public let id: String = "StartPolicyGenerationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartPolicyGenerationInput>,
                  next: H) -> Swift.Result<OperationOutput<StartPolicyGenerationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartPolicyGenerationInput>
    public typealias MOutput = OperationOutput<StartPolicyGenerationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartPolicyGenerationOutputError>
}

public struct StartPolicyGenerationInput: Equatable {
    /// <p>A unique, case-sensitive identifier that you provide to ensure the idempotency of the
    ///          request. Idempotency ensures that an API request completes only once. With an idempotent
    ///          request, if the original request completes successfully, the subsequent retries with the
    ///          same client token return the result from the original successful request and they have no
    ///          additional effect.</p>
    ///          <p>If you do not specify a client token, one is automatically generated by the AWS
    ///          SDK.</p>
    public var clientToken: String?
    /// <p>A <code>CloudTrailDetails</code> object that contains details about a <code>Trail</code>
    ///          that you want to analyze to generate policies.</p>
    public let cloudTrailDetails: CloudTrailDetails?
    /// <p>Contains the ARN of the IAM entity (user or role) for which you are generating a
    ///          policy.</p>
    public let policyGenerationDetails: PolicyGenerationDetails?

    public init (
        clientToken: String? = nil,
        cloudTrailDetails: CloudTrailDetails? = nil,
        policyGenerationDetails: PolicyGenerationDetails? = nil
    )
    {
        self.clientToken = clientToken
        self.cloudTrailDetails = cloudTrailDetails
        self.policyGenerationDetails = policyGenerationDetails
    }
}

struct StartPolicyGenerationInputBody: Equatable {
    public let policyGenerationDetails: PolicyGenerationDetails?
    public let cloudTrailDetails: CloudTrailDetails?
    public let clientToken: String?
}

extension StartPolicyGenerationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case cloudTrailDetails
        case policyGenerationDetails
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyGenerationDetailsDecoded = try containerValues.decodeIfPresent(PolicyGenerationDetails.self, forKey: .policyGenerationDetails)
        policyGenerationDetails = policyGenerationDetailsDecoded
        let cloudTrailDetailsDecoded = try containerValues.decodeIfPresent(CloudTrailDetails.self, forKey: .cloudTrailDetails)
        cloudTrailDetails = cloudTrailDetailsDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartPolicyGenerationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartPolicyGenerationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartPolicyGenerationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartPolicyGenerationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartPolicyGenerationOutputResponse(jobId: \(String(describing: jobId)))"}
}

extension StartPolicyGenerationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartPolicyGenerationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

public struct StartPolicyGenerationOutputResponse: Equatable {
    /// <p>The <code>JobId</code> that is returned by the <code>StartPolicyGeneration</code>
    ///          operation. The <code>JobId</code> can be used with <code>GetGeneratedPolicy</code> to
    ///          retrieve the generated policies or used with <code>CancelPolicyGeneration</code> to cancel
    ///          the policy generation request.</p>
    public let jobId: String?

    public init (
        jobId: String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct StartPolicyGenerationOutputResponseBody: Equatable {
    public let jobId: String?
}

extension StartPolicyGenerationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

public struct StartResourceScanInputBodyMiddleware: Middleware {
    public let id: String = "StartResourceScanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartResourceScanInput>,
                  next: H) -> Swift.Result<OperationOutput<StartResourceScanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartResourceScanInput>
    public typealias MOutput = OperationOutput<StartResourceScanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartResourceScanOutputError>
}

extension StartResourceScanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartResourceScanInput(analyzerArn: \(String(describing: analyzerArn)), resourceArn: \(String(describing: resourceArn)))"}
}

extension StartResourceScanInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyzerArn
        case resourceArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct StartResourceScanInputHeadersMiddleware: Middleware {
    public let id: String = "StartResourceScanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartResourceScanInput>,
                  next: H) -> Swift.Result<OperationOutput<StartResourceScanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartResourceScanInput>
    public typealias MOutput = OperationOutput<StartResourceScanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartResourceScanOutputError>
}

public struct StartResourceScanInputQueryItemMiddleware: Middleware {
    public let id: String = "StartResourceScanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartResourceScanInput>,
                  next: H) -> Swift.Result<OperationOutput<StartResourceScanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartResourceScanInput>
    public typealias MOutput = OperationOutput<StartResourceScanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartResourceScanOutputError>
}

/// <p>Starts a scan of the policies applied to the specified resource.</p>
public struct StartResourceScanInput: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of
    ///             the analyzer</a> to use to scan the policies applied to the specified
    ///          resource.</p>
    public let analyzerArn: String?
    /// <p>The ARN of the resource to scan.</p>
    public let resourceArn: String?

    public init (
        analyzerArn: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.resourceArn = resourceArn
    }
}

struct StartResourceScanInputBody: Equatable {
    public let analyzerArn: String?
    public let resourceArn: String?
}

extension StartResourceScanInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyzerArn
        case resourceArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension StartResourceScanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartResourceScanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartResourceScanOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartResourceScanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartResourceScanOutputResponse()"}
}

extension StartResourceScanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StartResourceScanOutputResponse: Equatable {

    public init() {}
}

struct StartResourceScanOutputResponseBody: Equatable {
}

extension StartResourceScanOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StatusReason: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ReasonCode.self, forKey: .code)
        code = codeDecoded
    }
}

extension StatusReason: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StatusReason(code: \(String(describing: code)))"}
}

/// <p>Provides more details about the current status of the analyzer. For example, if the
///          creation for the analyzer fails, a <code>Failed</code> status is returned. For an analyzer
///          with organization as the type, this failure can be due to an issue with creating the
///          service-linked roles required in the member accounts of the AWS organization.</p>
public struct StatusReason: Equatable {
    /// <p>The reason code for the current status of the analyzer.</p>
    public let code: ReasonCode?

    public init (
        code: ReasonCode? = nil
    )
    {
        self.code = code
    }
}

extension Substring: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case length
        case start
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let length = length {
            try encodeContainer.encode(length, forKey: .length)
        }
        if let start = start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .start)
        start = startDecoded
        let lengthDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .length)
        length = lengthDecoded
    }
}

extension Substring: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Substring(length: \(String(describing: length)), start: \(String(describing: start)))"}
}

/// <p>A reference to a substring of a literal string in a JSON document.</p>
public struct Substring: Equatable {
    /// <p>The length of the substring.</p>
    public let length: Int?
    /// <p>The start index of the substring, starting from 0.</p>
    public let start: Int?

    public init (
        length: Int? = nil,
        start: Int? = nil
    )
    {
        self.length = length
        self.start = start
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

/// <p>Adds a tag to the specified resource.</p>
public struct TagResourceInput: Equatable {
    /// <p>The ARN of the resource to add the tag to.</p>
    public let resourceArn: String?
    /// <p>The tags to add to the resource.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The response to the request.</p>
public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Throttling limit exceeded error.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = true
    public var _isThrottling: Bool = true
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The seconds to wait to retry.</p>
    public var retryAfterSeconds: Int?

    public init (
        message: String? = nil,
        retryAfterSeconds: Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Trail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allRegions
        case cloudTrailArn
        case regions
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allRegions = allRegions {
            try encodeContainer.encode(allRegions, forKey: .allRegions)
        }
        if let cloudTrailArn = cloudTrailArn {
            try encodeContainer.encode(cloudTrailArn, forKey: .cloudTrailArn)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for regionlist0 in regions {
                try regionsContainer.encode(regionlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudTrailArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudTrailArn)
        cloudTrailArn = cloudTrailArnDecoded
        let regionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .regions)
        var regionsDecoded0:[String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let allRegionsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allRegions)
        allRegions = allRegionsDecoded
    }
}

extension Trail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Trail(allRegions: \(String(describing: allRegions)), cloudTrailArn: \(String(describing: cloudTrailArn)), regions: \(String(describing: regions)))"}
}

/// <p>Contains details about the CloudTrail trail being analyzed to generate a policy.</p>
public struct Trail: Equatable {
    /// <p>Possible values are <code>true</code> or <code>false</code>. If set to
    ///          <code>true</code>, Access Analyzer retrieves CloudTrail data from all regions to analyze and
    ///          generate a policy.</p>
    public let allRegions: Bool?
    /// <p>Specifies the ARN of the trail. The format of a trail ARN is
    ///             <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>.</p>
    public let cloudTrailArn: String?
    /// <p>A list of regions to get CloudTrail data from and analyze to generate a policy.</p>
    public let regions: [String]?

    public init (
        allRegions: Bool? = nil,
        cloudTrailArn: String? = nil,
        regions: [String]? = nil
    )
    {
        self.allRegions = allRegions
        self.cloudTrailArn = cloudTrailArn
        self.regions = regions
    }
}

extension TrailProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allRegions
        case cloudTrailArn
        case regions
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allRegions = allRegions {
            try encodeContainer.encode(allRegions, forKey: .allRegions)
        }
        if let cloudTrailArn = cloudTrailArn {
            try encodeContainer.encode(cloudTrailArn, forKey: .cloudTrailArn)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for regionlist0 in regions {
                try regionsContainer.encode(regionlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudTrailArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudTrailArn)
        cloudTrailArn = cloudTrailArnDecoded
        let regionsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .regions)
        var regionsDecoded0:[String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let allRegionsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allRegions)
        allRegions = allRegionsDecoded
    }
}

extension TrailProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TrailProperties(allRegions: \(String(describing: allRegions)), cloudTrailArn: \(String(describing: cloudTrailArn)), regions: \(String(describing: regions)))"}
}

/// <p>Contains details about the CloudTrail trail being analyzed to generate a policy.</p>
public struct TrailProperties: Equatable {
    /// <p>Possible values are <code>true</code> or <code>false</code>. If set to
    ///          <code>true</code>, Access Analyzer retrieves CloudTrail data from all regions to analyze and
    ///          generate a policy.</p>
    public let allRegions: Bool?
    /// <p>Specifies the ARN of the trail. The format of a trail ARN is
    ///             <code>arn:aws:cloudtrail:us-east-2:123456789012:trail/MyTrail</code>.</p>
    public let cloudTrailArn: String?
    /// <p>A list of regions to get CloudTrail data from and analyze to generate a policy.</p>
    public let regions: [String]?

    public init (
        allRegions: Bool? = nil,
        cloudTrailArn: String? = nil,
        regions: [String]? = nil
    )
    {
        self.allRegions = allRegions
        self.cloudTrailArn = cloudTrailArn
        self.regions = regions
    }
}

public enum `Type` {
    case account
    case organization
    case sdkUnknown(String)
}

extension `Type` : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [`Type`] {
        return [
            .account,
            .organization,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .account: return "ACCOUNT"
        case .organization: return "ORGANIZATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = `Type`(rawValue: rawValue) ?? `Type`.sdkUnknown(rawValue)
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

/// <p>Removes a tag from the specified resource.</p>
public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the resource to remove the tag from.</p>
    public let resourceArn: String?
    /// <p>The key for the tag to add.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// <p>The response to the request.</p>
public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateArchiveRuleInputBodyMiddleware: Middleware {
    public let id: String = "UpdateArchiveRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateArchiveRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateArchiveRuleInput>
    public typealias MOutput = OperationOutput<UpdateArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateArchiveRuleOutputError>
}

extension UpdateArchiveRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateArchiveRuleInput(analyzerName: \(String(describing: analyzerName)), clientToken: \(String(describing: clientToken)), filter: \(String(describing: filter)), ruleName: \(String(describing: ruleName)))"}
}

extension UpdateArchiveRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case filter
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let filter = filter {
            var filterContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .filter)
            for (dictKey0, filtercriteriamap0) in filter {
                try filterContainer.encode(filtercriteriamap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdateArchiveRuleInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateArchiveRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateArchiveRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateArchiveRuleInput>
    public typealias MOutput = OperationOutput<UpdateArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateArchiveRuleOutputError>
}

public struct UpdateArchiveRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateArchiveRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateArchiveRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateArchiveRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateArchiveRuleInput>
    public typealias MOutput = OperationOutput<UpdateArchiveRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateArchiveRuleOutputError>
}

/// <p>Updates the specified archive rule.</p>
public struct UpdateArchiveRuleInput: Equatable {
    /// <p>The name of the analyzer to update the archive rules for.</p>
    public let analyzerName: String?
    /// <p>A client token.</p>
    public var clientToken: String?
    /// <p>A filter to match for the rules to update. Only rules that match the filter are
    ///          updated.</p>
    public let filter: [String:Criterion]?
    /// <p>The name of the rule to update.</p>
    public let ruleName: String?

    public init (
        analyzerName: String? = nil,
        clientToken: String? = nil,
        filter: [String:Criterion]? = nil,
        ruleName: String? = nil
    )
    {
        self.analyzerName = analyzerName
        self.clientToken = clientToken
        self.filter = filter
        self.ruleName = ruleName
    }
}

struct UpdateArchiveRuleInputBody: Equatable {
    public let filter: [String:Criterion]?
    public let clientToken: String?
}

extension UpdateArchiveRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case filter
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterContainer = try containerValues.decodeIfPresent([String: Criterion?].self, forKey: .filter)
        var filterDecoded0: [String:Criterion]? = nil
        if let filterContainer = filterContainer {
            filterDecoded0 = [String:Criterion]()
            for (key0, criterion0) in filterContainer {
                if let criterion0 = criterion0 {
                    filterDecoded0?[key0] = criterion0
                }
            }
        }
        filter = filterDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateArchiveRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateArchiveRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateArchiveRuleOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateArchiveRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateArchiveRuleOutputResponse()"}
}

extension UpdateArchiveRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateArchiveRuleOutputResponse: Equatable {

    public init() {}
}

struct UpdateArchiveRuleOutputResponseBody: Equatable {
}

extension UpdateArchiveRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateFindingsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFindingsInput>
    public typealias MOutput = OperationOutput<UpdateFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFindingsOutputError>
}

extension UpdateFindingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFindingsInput(analyzerArn: \(String(describing: analyzerArn)), clientToken: \(String(describing: clientToken)), ids: \(String(describing: ids)), resourceArn: \(String(describing: resourceArn)), status: \(String(describing: status)))"}
}

extension UpdateFindingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case analyzerArn
        case clientToken
        case ids
        case resourceArn
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerArn = analyzerArn {
            try encodeContainer.encode(analyzerArn, forKey: .analyzerArn)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for findingidlist0 in ids {
                try idsContainer.encode(findingidlist0)
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct UpdateFindingsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFindingsInput>
    public typealias MOutput = OperationOutput<UpdateFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFindingsOutputError>
}

public struct UpdateFindingsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFindingsInput>
    public typealias MOutput = OperationOutput<UpdateFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFindingsOutputError>
}

/// <p>Updates findings with the new values provided in the request.</p>
public struct UpdateFindingsInput: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-getting-started.html#permission-resources">ARN of
    ///             the analyzer</a> that generated the findings to update.</p>
    public let analyzerArn: String?
    /// <p>A client token.</p>
    public var clientToken: String?
    /// <p>The IDs of the findings to update.</p>
    public let ids: [String]?
    /// <p>The ARN of the resource identified in the finding.</p>
    public let resourceArn: String?
    /// <p>The state represents the action to take to update the finding Status. Use
    ///             <code>ARCHIVE</code> to change an Active finding to an Archived finding. Use
    ///             <code>ACTIVE</code> to change an Archived finding to an Active finding.</p>
    public let status: FindingStatusUpdate?

    public init (
        analyzerArn: String? = nil,
        clientToken: String? = nil,
        ids: [String]? = nil,
        resourceArn: String? = nil,
        status: FindingStatusUpdate? = nil
    )
    {
        self.analyzerArn = analyzerArn
        self.clientToken = clientToken
        self.ids = ids
        self.resourceArn = resourceArn
        self.status = status
    }
}

struct UpdateFindingsInputBody: Equatable {
    public let analyzerArn: String?
    public let status: FindingStatusUpdate?
    public let ids: [String]?
    public let resourceArn: String?
    public let clientToken: String?
}

extension UpdateFindingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case analyzerArn
        case clientToken
        case ids
        case resourceArn
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .analyzerArn)
        analyzerArn = analyzerArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FindingStatusUpdate.self, forKey: .status)
        status = statusDecoded
        let idsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ids)
        var idsDecoded0:[String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateFindingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFindingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFindingsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFindingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFindingsOutputResponse()"}
}

extension UpdateFindingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateFindingsOutputResponse: Equatable {

    public init() {}
}

struct UpdateFindingsOutputResponseBody: Equatable {
}

extension UpdateFindingsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidatePolicyFinding: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case findingDetails
        case findingType
        case issueCode
        case learnMoreLink
        case locations
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingDetails = findingDetails {
            try encodeContainer.encode(findingDetails, forKey: .findingDetails)
        }
        if let findingType = findingType {
            try encodeContainer.encode(findingType.rawValue, forKey: .findingType)
        }
        if let issueCode = issueCode {
            try encodeContainer.encode(issueCode, forKey: .issueCode)
        }
        if let learnMoreLink = learnMoreLink {
            try encodeContainer.encode(learnMoreLink, forKey: .learnMoreLink)
        }
        if let locations = locations {
            var locationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .locations)
            for locationlist0 in locations {
                try locationsContainer.encode(locationlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingDetailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .findingDetails)
        findingDetails = findingDetailsDecoded
        let findingTypeDecoded = try containerValues.decodeIfPresent(ValidatePolicyFindingType.self, forKey: .findingType)
        findingType = findingTypeDecoded
        let issueCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .issueCode)
        issueCode = issueCodeDecoded
        let learnMoreLinkDecoded = try containerValues.decodeIfPresent(String.self, forKey: .learnMoreLink)
        learnMoreLink = learnMoreLinkDecoded
        let locationsContainer = try containerValues.decodeIfPresent([Location?].self, forKey: .locations)
        var locationsDecoded0:[Location]? = nil
        if let locationsContainer = locationsContainer {
            locationsDecoded0 = [Location]()
            for structure0 in locationsContainer {
                if let structure0 = structure0 {
                    locationsDecoded0?.append(structure0)
                }
            }
        }
        locations = locationsDecoded0
    }
}

extension ValidatePolicyFinding: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidatePolicyFinding(findingDetails: \(String(describing: findingDetails)), findingType: \(String(describing: findingType)), issueCode: \(String(describing: issueCode)), learnMoreLink: \(String(describing: learnMoreLink)), locations: \(String(describing: locations)))"}
}

/// <p>A finding in a policy. Each finding is an actionable recommendation that can be used to
///          improve the policy.</p>
public struct ValidatePolicyFinding: Equatable {
    /// <p>A localized message that explains the finding and provides guidance on how to address
    ///          it.</p>
    public let findingDetails: String?
    /// <p>The impact of the finding.</p>
    ///          <p>Security warnings report when the policy allows access that we consider overly
    ///          permissive.</p>
    ///          <p>Errors report when a part of the policy is not functional.</p>
    ///          <p>Warnings report non-security issues when a policy does not conform to policy writing
    ///          best practices.</p>
    ///          <p>Suggestions recommend stylistic improvements in the policy that do not impact
    ///          access.</p>
    public let findingType: ValidatePolicyFindingType?
    /// <p>The issue code provides an identifier of the issue associated with this finding.</p>
    public let issueCode: String?
    /// <p>A link to additional documentation about the type of finding.</p>
    public let learnMoreLink: String?
    /// <p>The list of locations in the policy document that are related to the finding. The issue
    ///          code provides a summary of an issue identified by the finding.</p>
    public let locations: [Location]?

    public init (
        findingDetails: String? = nil,
        findingType: ValidatePolicyFindingType? = nil,
        issueCode: String? = nil,
        learnMoreLink: String? = nil,
        locations: [Location]? = nil
    )
    {
        self.findingDetails = findingDetails
        self.findingType = findingType
        self.issueCode = issueCode
        self.learnMoreLink = learnMoreLink
        self.locations = locations
    }
}

public enum ValidatePolicyFindingType {
    case error
    case securityWarning
    case suggestion
    case warning
    case sdkUnknown(String)
}

extension ValidatePolicyFindingType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ValidatePolicyFindingType] {
        return [
            .error,
            .securityWarning,
            .suggestion,
            .warning,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .error: return "ERROR"
        case .securityWarning: return "SECURITY_WARNING"
        case .suggestion: return "SUGGESTION"
        case .warning: return "WARNING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ValidatePolicyFindingType(rawValue: rawValue) ?? ValidatePolicyFindingType.sdkUnknown(rawValue)
    }
}

public struct ValidatePolicyInputBodyMiddleware: Middleware {
    public let id: String = "ValidatePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidatePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidatePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidatePolicyInput>
    public typealias MOutput = OperationOutput<ValidatePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidatePolicyOutputError>
}

extension ValidatePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidatePolicyInput(locale: \(String(describing: locale)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), policyDocument: \(String(describing: policyDocument)), policyType: \(String(describing: policyType)))"}
}

extension ValidatePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case locale
        case policyDocument
        case policyType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let policyDocument = policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let policyType = policyType {
            try encodeContainer.encode(policyType.rawValue, forKey: .policyType)
        }
    }
}

public struct ValidatePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "ValidatePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidatePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidatePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidatePolicyInput>
    public typealias MOutput = OperationOutput<ValidatePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidatePolicyOutputError>
}

public struct ValidatePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "ValidatePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidatePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidatePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidatePolicyInput>
    public typealias MOutput = OperationOutput<ValidatePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidatePolicyOutputError>
}

public struct ValidatePolicyInput: Equatable {
    /// <p>The locale to use for localizing the findings.</p>
    public let locale: Locale?
    /// <p>The maximum number of results to return in the response.</p>
    public let maxResults: Int?
    /// <p>A token used for pagination of results returned.</p>
    public let nextToken: String?
    /// <p>The JSON policy document to use as the content for the policy.</p>
    public let policyDocument: String?
    /// <p>The type of policy to validate. Identity policies grant permissions to IAM principals.
    ///          Identity policies include managed and inline policies for IAM roles, users, and groups.
    ///          They also include service-control policies (SCPs) that are attached to an AWS
    ///          organization, organizational unit (OU), or an account.</p>
    ///          <p>Resource policies grant permissions on AWS resources. Resource policies include trust
    ///          policies for IAM roles and bucket policies for S3 buckets. You can provide a generic input
    ///          such as identity policy or resource policy or a specific input such as managed policy or S3
    ///          bucket policy. </p>
    public let policyType: PolicyType?

    public init (
        locale: Locale? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        policyDocument: String? = nil,
        policyType: PolicyType? = nil
    )
    {
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.policyDocument = policyDocument
        self.policyType = policyType
    }
}

struct ValidatePolicyInputBody: Equatable {
    public let locale: Locale?
    public let policyDocument: String?
    public let policyType: PolicyType?
}

extension ValidatePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locale
        case policyDocument
        case policyType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localeDecoded = try containerValues.decodeIfPresent(Locale.self, forKey: .locale)
        locale = localeDecoded
        let policyDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let policyTypeDecoded = try containerValues.decodeIfPresent(PolicyType.self, forKey: .policyType)
        policyType = policyTypeDecoded
    }
}

extension ValidatePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ValidatePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ValidatePolicyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ValidatePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidatePolicyOutputResponse(findings: \(String(describing: findings)), nextToken: \(String(describing: nextToken)))"}
}

extension ValidatePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidatePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.findings = output.findings
            self.nextToken = output.nextToken
        } else {
            self.findings = nil
            self.nextToken = nil
        }
    }
}

public struct ValidatePolicyOutputResponse: Equatable {
    /// <p>The list of findings in a policy returned by Access Analyzer based on its suite of policy
    ///          checks.</p>
    public let findings: [ValidatePolicyFinding]?
    /// <p>A token used for pagination of results returned.</p>
    public let nextToken: String?

    public init (
        findings: [ValidatePolicyFinding]? = nil,
        nextToken: String? = nil
    )
    {
        self.findings = findings
        self.nextToken = nextToken
    }
}

struct ValidatePolicyOutputResponseBody: Equatable {
    public let findings: [ValidatePolicyFinding]?
    public let nextToken: String?
}

extension ValidatePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findings
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([ValidatePolicyFinding?].self, forKey: .findings)
        var findingsDecoded0:[ValidatePolicyFinding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [ValidatePolicyFinding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(fieldList: \(String(describing: fieldList)), message: \(String(describing: message)), reason: \(String(describing: reason)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Validation exception error.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>A list of fields that didn't validate.</p>
    public var fieldList: [ValidationExceptionField]?
    public var message: String?
    /// <p>The reason for the exception.</p>
    public var reason: ValidationExceptionReason?

    public init (
        fieldList: [ValidationExceptionField]? = nil,
        message: String? = nil,
        reason: ValidationExceptionReason? = nil
    )
    {
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
    public let reason: ValidationExceptionReason?
    public let fieldList: [ValidationExceptionField]?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fieldList
        case message
        case reason
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension ValidationExceptionField: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationExceptionField: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationExceptionField(message: \(String(describing: message)), name: \(String(describing: name)))"}
}

/// <p>Contains information about a validation exception.</p>
public struct ValidationExceptionField: Equatable {
    /// <p>A message about the validation exception.</p>
    public let message: String?
    /// <p>The name of the validation exception.</p>
    public let name: String?

    public init (
        message: String? = nil,
        name: String? = nil
    )
    {
        self.message = message
        self.name = name
    }
}

public enum ValidationExceptionReason {
    case cannotParse
    case fieldValidationFailed
    case other
    case unknownOperation
    case sdkUnknown(String)
}

extension ValidationExceptionReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ValidationExceptionReason] {
        return [
            .cannotParse,
            .fieldValidationFailed,
            .other,
            .unknownOperation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cannotParse: return "cannotParse"
        case .fieldValidationFailed: return "fieldValidationFailed"
        case .other: return "other"
        case .unknownOperation: return "unknownOperation"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
    }
}

extension VpcConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case vpcId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension VpcConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcConfiguration(vpcId: \(String(describing: vpcId)))"}
}

/// <p> The proposed virtual private cloud (VPC) configuration for the Amazon S3 access point. For
///          more information, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/API/API_control_VpcConfiguration.html">VpcConfiguration</a>.
///       </p>
public struct VpcConfiguration: Equatable {
    /// <p> If this field is specified, this access point will only allow connections from the
    ///          specified VPC ID. </p>
    public let vpcId: String?

    public init (
        vpcId: String? = nil
    )
    {
        self.vpcId = vpcId
    }
}
