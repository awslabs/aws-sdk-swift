// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class AccessAnalyzerClient {
    let client: SdkHttpClient
    let config: AccessAnalyzerClientConfiguration
    let serviceName = "AccessAnalyzer"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: AccessAnalyzerClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class AccessAnalyzerClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> AccessAnalyzerClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try AccessAnalyzerClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension AccessAnalyzerClient: AccessAnalyzerClientProtocol {
    /// <p>Retroactively applies the archive rule to existing findings that meet the archive rule
    ///          criteria.</p>
    public func applyArchiveRule(input: ApplyArchiveRuleInput, completion: @escaping (SdkResult<ApplyArchiveRuleOutput, ApplyArchiveRuleOutputError>) -> Void)
    {
        let urlPath = "/archive-rule"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "applyArchiveRule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ApplyArchiveRuleInput, ApplyArchiveRuleOutput, ApplyArchiveRuleOutputError>(id: "applyArchiveRule")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<ApplyArchiveRuleOutput>, SdkError<ApplyArchiveRuleOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: ApplyArchiveRuleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ApplyArchiveRuleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ApplyArchiveRuleInput, ApplyArchiveRuleOutput, ApplyArchiveRuleOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ApplyArchiveRuleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Cancels the requested policy generation.</p>
    public func cancelPolicyGeneration(input: CancelPolicyGenerationInput, completion: @escaping (SdkResult<CancelPolicyGenerationOutput, CancelPolicyGenerationOutputError>) -> Void)
    {
        guard let jobId = input.jobId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component jobId unexpectedly nil"))))
            return
        }
        let urlPath = "/policy/generation/\(jobId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "cancelPolicyGeneration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CancelPolicyGenerationInput, CancelPolicyGenerationOutput, CancelPolicyGenerationOutputError>(id: "cancelPolicyGeneration")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CancelPolicyGenerationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CancelPolicyGenerationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CancelPolicyGenerationInput, CancelPolicyGenerationOutput, CancelPolicyGenerationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an access preview that allows you to preview Access Analyzer findings for your resource
    ///          before deploying resource permissions.</p>
    public func createAccessPreview(input: CreateAccessPreviewInput, completion: @escaping (SdkResult<CreateAccessPreviewOutput, CreateAccessPreviewOutputError>) -> Void)
    {
        let urlPath = "/access-preview"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createAccessPreview")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateAccessPreviewInput, CreateAccessPreviewOutput, CreateAccessPreviewOutputError>(id: "createAccessPreview")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateAccessPreviewOutput>, SdkError<CreateAccessPreviewOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateAccessPreviewInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateAccessPreviewInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateAccessPreviewInput, CreateAccessPreviewOutput, CreateAccessPreviewOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateAccessPreviewInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an analyzer for your account.</p>
    public func createAnalyzer(input: CreateAnalyzerInput, completion: @escaping (SdkResult<CreateAnalyzerOutput, CreateAnalyzerOutputError>) -> Void)
    {
        let urlPath = "/analyzer"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createAnalyzer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateAnalyzerInput, CreateAnalyzerOutput, CreateAnalyzerOutputError>(id: "createAnalyzer")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateAnalyzerOutput>, SdkError<CreateAnalyzerOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateAnalyzerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateAnalyzerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateAnalyzerInput, CreateAnalyzerOutput, CreateAnalyzerOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateAnalyzerInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an archive rule for the specified analyzer. Archive rules automatically archive
    ///          new findings that meet the criteria you define when you create the rule.</p>
    ///          <p>To learn about filter keys that you can use to create an archive rule, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-reference-filter-keys.html">Access Analyzer filter keys</a> in the <b>IAM User
    ///          Guide</b>.</p>
    public func createArchiveRule(input: CreateArchiveRuleInput, completion: @escaping (SdkResult<CreateArchiveRuleOutput, CreateArchiveRuleOutputError>) -> Void)
    {
        guard let analyzerName = input.analyzerName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component analyzerName unexpectedly nil"))))
            return
        }
        let urlPath = "/analyzer/\(analyzerName)/archive-rule"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createArchiveRule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateArchiveRuleInput, CreateArchiveRuleOutput, CreateArchiveRuleOutputError>(id: "createArchiveRule")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateArchiveRuleOutput>, SdkError<CreateArchiveRuleOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateArchiveRuleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateArchiveRuleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateArchiveRuleInput, CreateArchiveRuleOutput, CreateArchiveRuleOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateArchiveRuleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified analyzer. When you delete an analyzer, Access Analyzer is disabled for the
    ///          account or organization in the current or specific Region. All findings that were generated
    ///          by the analyzer are deleted. You cannot undo this action.</p>
    public func deleteAnalyzer(input: DeleteAnalyzerInput, completion: @escaping (SdkResult<DeleteAnalyzerOutput, DeleteAnalyzerOutputError>) -> Void)
    {
        guard let analyzerName = input.analyzerName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component analyzerName unexpectedly nil"))))
            return
        }
        let urlPath = "/analyzer/\(analyzerName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteAnalyzer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteAnalyzerInput, DeleteAnalyzerOutput, DeleteAnalyzerOutputError>(id: "deleteAnalyzer")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<DeleteAnalyzerOutput>, SdkError<DeleteAnalyzerOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: DeleteAnalyzerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteAnalyzerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteAnalyzerInput, DeleteAnalyzerOutput, DeleteAnalyzerOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the specified archive rule.</p>
    public func deleteArchiveRule(input: DeleteArchiveRuleInput, completion: @escaping (SdkResult<DeleteArchiveRuleOutput, DeleteArchiveRuleOutputError>) -> Void)
    {
        guard let analyzerName = input.analyzerName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component analyzerName unexpectedly nil"))))
            return
        }
        guard let ruleName = input.ruleName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component ruleName unexpectedly nil"))))
            return
        }
        let urlPath = "/analyzer/\(analyzerName)/archive-rule/\(ruleName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteArchiveRule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteArchiveRuleInput, DeleteArchiveRuleOutput, DeleteArchiveRuleOutputError>(id: "deleteArchiveRule")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<DeleteArchiveRuleOutput>, SdkError<DeleteArchiveRuleOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: DeleteArchiveRuleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteArchiveRuleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteArchiveRuleInput, DeleteArchiveRuleOutput, DeleteArchiveRuleOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves information about an access preview for the specified analyzer.</p>
    public func getAccessPreview(input: GetAccessPreviewInput, completion: @escaping (SdkResult<GetAccessPreviewOutput, GetAccessPreviewOutputError>) -> Void)
    {
        guard let accessPreviewId = input.accessPreviewId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component accessPreviewId unexpectedly nil"))))
            return
        }
        let urlPath = "/access-preview/\(accessPreviewId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getAccessPreview")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetAccessPreviewInput, GetAccessPreviewOutput, GetAccessPreviewOutputError>(id: "getAccessPreview")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetAccessPreviewInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetAccessPreviewInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetAccessPreviewInput, GetAccessPreviewOutput, GetAccessPreviewOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves information about a resource that was analyzed.</p>
    public func getAnalyzedResource(input: GetAnalyzedResourceInput, completion: @escaping (SdkResult<GetAnalyzedResourceOutput, GetAnalyzedResourceOutputError>) -> Void)
    {
        let urlPath = "/analyzed-resource"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getAnalyzedResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetAnalyzedResourceInput, GetAnalyzedResourceOutput, GetAnalyzedResourceOutputError>(id: "getAnalyzedResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetAnalyzedResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetAnalyzedResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetAnalyzedResourceInput, GetAnalyzedResourceOutput, GetAnalyzedResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves information about the specified analyzer.</p>
    public func getAnalyzer(input: GetAnalyzerInput, completion: @escaping (SdkResult<GetAnalyzerOutput, GetAnalyzerOutputError>) -> Void)
    {
        guard let analyzerName = input.analyzerName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component analyzerName unexpectedly nil"))))
            return
        }
        let urlPath = "/analyzer/\(analyzerName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getAnalyzer")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetAnalyzerInput, GetAnalyzerOutput, GetAnalyzerOutputError>(id: "getAnalyzer")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetAnalyzerInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetAnalyzerInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetAnalyzerInput, GetAnalyzerOutput, GetAnalyzerOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves information about an archive rule.</p>
    ///          <p>To learn about filter keys that you can use to create an archive rule, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-reference-filter-keys.html">Access Analyzer filter keys</a> in the <b>IAM User
    ///          Guide</b>.</p>
    public func getArchiveRule(input: GetArchiveRuleInput, completion: @escaping (SdkResult<GetArchiveRuleOutput, GetArchiveRuleOutputError>) -> Void)
    {
        guard let analyzerName = input.analyzerName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component analyzerName unexpectedly nil"))))
            return
        }
        guard let ruleName = input.ruleName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component ruleName unexpectedly nil"))))
            return
        }
        let urlPath = "/analyzer/\(analyzerName)/archive-rule/\(ruleName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getArchiveRule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetArchiveRuleInput, GetArchiveRuleOutput, GetArchiveRuleOutputError>(id: "getArchiveRule")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetArchiveRuleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetArchiveRuleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetArchiveRuleInput, GetArchiveRuleOutput, GetArchiveRuleOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves information about the specified finding.</p>
    public func getFinding(input: GetFindingInput, completion: @escaping (SdkResult<GetFindingOutput, GetFindingOutputError>) -> Void)
    {
        guard let id = input.id else {
            completion(.failure(.client(ClientError.serializationFailed("uri component id unexpectedly nil"))))
            return
        }
        let urlPath = "/finding/\(id)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getFinding")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetFindingInput, GetFindingOutput, GetFindingOutputError>(id: "getFinding")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetFindingInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetFindingInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetFindingInput, GetFindingOutput, GetFindingOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves the policy that was generated using <code>StartPolicyGeneration</code>.
    ///       </p>
    public func getGeneratedPolicy(input: GetGeneratedPolicyInput, completion: @escaping (SdkResult<GetGeneratedPolicyOutput, GetGeneratedPolicyOutputError>) -> Void)
    {
        guard let jobId = input.jobId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component jobId unexpectedly nil"))))
            return
        }
        let urlPath = "/policy/generation/\(jobId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getGeneratedPolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetGeneratedPolicyInput, GetGeneratedPolicyOutput, GetGeneratedPolicyOutputError>(id: "getGeneratedPolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetGeneratedPolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetGeneratedPolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetGeneratedPolicyInput, GetGeneratedPolicyOutput, GetGeneratedPolicyOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a list of access preview findings generated by the specified access
    ///          preview.</p>
    public func listAccessPreviewFindings(input: ListAccessPreviewFindingsInput, completion: @escaping (SdkResult<ListAccessPreviewFindingsOutput, ListAccessPreviewFindingsOutputError>) -> Void)
    {
        guard let accessPreviewId = input.accessPreviewId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component accessPreviewId unexpectedly nil"))))
            return
        }
        let urlPath = "/access-preview/\(accessPreviewId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listAccessPreviewFindings")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListAccessPreviewFindingsInput, ListAccessPreviewFindingsOutput, ListAccessPreviewFindingsOutputError>(id: "listAccessPreviewFindings")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListAccessPreviewFindingsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListAccessPreviewFindingsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListAccessPreviewFindingsInput, ListAccessPreviewFindingsOutput, ListAccessPreviewFindingsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListAccessPreviewFindingsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a list of access previews for the specified analyzer.</p>
    public func listAccessPreviews(input: ListAccessPreviewsInput, completion: @escaping (SdkResult<ListAccessPreviewsOutput, ListAccessPreviewsOutputError>) -> Void)
    {
        let urlPath = "/access-preview"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listAccessPreviews")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListAccessPreviewsInput, ListAccessPreviewsOutput, ListAccessPreviewsOutputError>(id: "listAccessPreviews")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListAccessPreviewsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListAccessPreviewsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListAccessPreviewsInput, ListAccessPreviewsOutput, ListAccessPreviewsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a list of resources of the specified type that have been analyzed by the
    ///          specified analyzer..</p>
    public func listAnalyzedResources(input: ListAnalyzedResourcesInput, completion: @escaping (SdkResult<ListAnalyzedResourcesOutput, ListAnalyzedResourcesOutputError>) -> Void)
    {
        let urlPath = "/analyzed-resource"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listAnalyzedResources")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListAnalyzedResourcesInput, ListAnalyzedResourcesOutput, ListAnalyzedResourcesOutputError>(id: "listAnalyzedResources")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListAnalyzedResourcesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListAnalyzedResourcesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListAnalyzedResourcesInput, ListAnalyzedResourcesOutput, ListAnalyzedResourcesOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListAnalyzedResourcesInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a list of analyzers.</p>
    public func listAnalyzers(input: ListAnalyzersInput, completion: @escaping (SdkResult<ListAnalyzersOutput, ListAnalyzersOutputError>) -> Void)
    {
        let urlPath = "/analyzer"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listAnalyzers")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListAnalyzersInput, ListAnalyzersOutput, ListAnalyzersOutputError>(id: "listAnalyzers")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListAnalyzersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListAnalyzersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListAnalyzersInput, ListAnalyzersOutput, ListAnalyzersOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a list of archive rules created for the specified analyzer.</p>
    public func listArchiveRules(input: ListArchiveRulesInput, completion: @escaping (SdkResult<ListArchiveRulesOutput, ListArchiveRulesOutputError>) -> Void)
    {
        guard let analyzerName = input.analyzerName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component analyzerName unexpectedly nil"))))
            return
        }
        let urlPath = "/analyzer/\(analyzerName)/archive-rule"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listArchiveRules")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListArchiveRulesInput, ListArchiveRulesOutput, ListArchiveRulesOutputError>(id: "listArchiveRules")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListArchiveRulesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListArchiveRulesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListArchiveRulesInput, ListArchiveRulesOutput, ListArchiveRulesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a list of findings generated by the specified analyzer.</p>
    ///          <p>To learn about filter keys that you can use to retrieve a list of findings, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access-analyzer-reference-filter-keys.html">Access Analyzer filter keys</a> in the <b>IAM User
    ///          Guide</b>.</p>
    public func listFindings(input: ListFindingsInput, completion: @escaping (SdkResult<ListFindingsOutput, ListFindingsOutputError>) -> Void)
    {
        let urlPath = "/finding"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listFindings")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListFindingsInput, ListFindingsOutput, ListFindingsOutputError>(id: "listFindings")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListFindingsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListFindingsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListFindingsInput, ListFindingsOutput, ListFindingsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ListFindingsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Lists all of the policy generations requested in the last seven days.</p>
    public func listPolicyGenerations(input: ListPolicyGenerationsInput, completion: @escaping (SdkResult<ListPolicyGenerationsOutput, ListPolicyGenerationsOutputError>) -> Void)
    {
        let urlPath = "/policy/generation"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listPolicyGenerations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListPolicyGenerationsInput, ListPolicyGenerationsOutput, ListPolicyGenerationsOutputError>(id: "listPolicyGenerations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListPolicyGenerationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListPolicyGenerationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListPolicyGenerationsInput, ListPolicyGenerationsOutput, ListPolicyGenerationsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Retrieves a list of tags applied to the specified resource.</p>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutput, ListTagsForResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutput, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutput, ListTagsForResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Starts the policy generation request.</p>
    public func startPolicyGeneration(input: StartPolicyGenerationInput, completion: @escaping (SdkResult<StartPolicyGenerationOutput, StartPolicyGenerationOutputError>) -> Void)
    {
        let urlPath = "/policy/generation"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startPolicyGeneration")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartPolicyGenerationInput, StartPolicyGenerationOutput, StartPolicyGenerationOutputError>(id: "startPolicyGeneration")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<StartPolicyGenerationOutput>, SdkError<StartPolicyGenerationOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: StartPolicyGenerationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartPolicyGenerationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartPolicyGenerationInput, StartPolicyGenerationOutput, StartPolicyGenerationOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StartPolicyGenerationInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Immediately starts a scan of the policies applied to the specified resource.</p>
    public func startResourceScan(input: StartResourceScanInput, completion: @escaping (SdkResult<StartResourceScanOutput, StartResourceScanOutputError>) -> Void)
    {
        let urlPath = "/resource/scan"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startResourceScan")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartResourceScanInput, StartResourceScanOutput, StartResourceScanOutputError>(id: "startResourceScan")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StartResourceScanInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartResourceScanInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartResourceScanInput, StartResourceScanOutput, StartResourceScanOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StartResourceScanInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds a tag to the specified resource.</p>
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutput, TagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutput, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutput, TagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes a tag from the specified resource.</p>
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutput, UntagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutput, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutput, UntagResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the criteria and values for the specified archive rule.</p>
    public func updateArchiveRule(input: UpdateArchiveRuleInput, completion: @escaping (SdkResult<UpdateArchiveRuleOutput, UpdateArchiveRuleOutputError>) -> Void)
    {
        guard let analyzerName = input.analyzerName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component analyzerName unexpectedly nil"))))
            return
        }
        guard let ruleName = input.ruleName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component ruleName unexpectedly nil"))))
            return
        }
        let urlPath = "/analyzer/\(analyzerName)/archive-rule/\(ruleName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateArchiveRule")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateArchiveRuleInput, UpdateArchiveRuleOutput, UpdateArchiveRuleOutputError>(id: "updateArchiveRule")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<UpdateArchiveRuleOutput>, SdkError<UpdateArchiveRuleOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateArchiveRuleInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateArchiveRuleInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateArchiveRuleInput, UpdateArchiveRuleOutput, UpdateArchiveRuleOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateArchiveRuleInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates the status for the specified findings.</p>
    public func updateFindings(input: UpdateFindingsInput, completion: @escaping (SdkResult<UpdateFindingsOutput, UpdateFindingsOutputError>) -> Void)
    {
        let urlPath = "/finding"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateFindings")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateFindingsInput, UpdateFindingsOutput, UpdateFindingsOutputError>(id: "updateFindings")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<UpdateFindingsOutput>, SdkError<UpdateFindingsOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateFindingsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateFindingsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateFindingsInput, UpdateFindingsOutput, UpdateFindingsOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateFindingsInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Requests the validation of a policy and returns a list of findings. The findings help
    ///          you identify issues and provide actionable recommendations to resolve the issue and enable
    ///          you to author functional policies that meet security best practices. </p>
    public func validatePolicy(input: ValidatePolicyInput, completion: @escaping (SdkResult<ValidatePolicyOutput, ValidatePolicyOutputError>) -> Void)
    {
        let urlPath = "/policy/validation"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "validatePolicy")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "access-analyzer.\(config.region).amazonaws.com")
                      .withSigningName(value: "access-analyzer")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ValidatePolicyInput, ValidatePolicyOutput, ValidatePolicyOutputError>(id: "validatePolicy")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ValidatePolicyInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ValidatePolicyInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ValidatePolicyInput, ValidatePolicyOutput, ValidatePolicyOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: ValidatePolicyInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
