// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You are not authorized to perform the action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The update or deletion of a resource caused an inconsistent state.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The ID of the resource.</p>
    public var resourceId: String?
    /// <p>The type of the resource.</p>
    public var resourceType: ResourceType?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: ResourceType?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct CreateDatasetInputBodyMiddleware: Middleware {
    public let id: String = "CreateDatasetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetOutputError>
}

extension CreateDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetInput(clientToken: \(String(describing: clientToken)), datasetSource: \(String(describing: datasetSource)), datasetType: \(String(describing: datasetType)), projectName: \(String(describing: projectName)))"}
}

extension CreateDatasetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case datasetSource = "DatasetSource"
        case datasetType = "DatasetType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetSource = datasetSource {
            try encodeContainer.encode(datasetSource, forKey: .datasetSource)
        }
        if let datasetType = datasetType {
            try encodeContainer.encode(datasetType, forKey: .datasetType)
        }
    }
}

public struct CreateDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDatasetInput>
    public typealias MOutput = OperationOutput<CreateDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDatasetOutputError>
}

public struct CreateDatasetInput: Equatable {
    /// <p>ClientToken is an idempotency token that ensures a call to <code>CreateDataset</code>
    ///       completes only once.  You choose the value to pass. For example, An issue,
    ///       such as an network outage, might prevent you from getting a response from <code>CreateDataset</code>.
    ///       In this case, safely retry your call
    ///        to <code>CreateDataset</code> by using the same <code>ClientToken</code> parameter value. An error occurs
    ///        if the other input parameters are not the same as in the first request. Using a different
    ///        value for <code>ClientToken</code> is considered a new call to <code>CreateDataset</code>. An idempotency
    ///        token is active for 8 hours.
    ///     </p>
    public var clientToken: String?
    /// <p>The location of the manifest file that Amazon Lookout for Vision uses to create the dataset.</p>
    ///          <p>If you don't specify <code>DatasetSource</code>, an empty dataset is created and the operation
    ///       synchronously returns. Later, you can add JSON Lines by calling <a>UpdateDatasetEntries</a>.
    ///      </p>
    ///          <p>If you specify a value for <code>DataSource</code>, the manifest at the S3 location
    ///      is validated and used to create the dataset. The call to <code>CreateDataset</code> is asynchronous
    ///      and might take a while to complete. To find out the current status, Check the value of <code>Status</code>
    ///      returned in a call to <a>DescribeDataset</a>.</p>
    public let datasetSource: DatasetSource?
    /// <p>The type of the dataset. Specify <code>train</code> for a training dataset.
    ///       Specify <code>test</code> for a test dataset.</p>
    public let datasetType: String?
    /// <p>The name of the project in which you want to create a dataset.</p>
    public let projectName: String?

    public init (
        clientToken: String? = nil,
        datasetSource: DatasetSource? = nil,
        datasetType: String? = nil,
        projectName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.datasetSource = datasetSource
        self.datasetType = datasetType
        self.projectName = projectName
    }
}

struct CreateDatasetInputBody: Equatable {
    public let datasetType: String?
    public let datasetSource: DatasetSource?
}

extension CreateDatasetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetSource = "DatasetSource"
        case datasetType = "DatasetType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let datasetSourceDecoded = try containerValues.decodeIfPresent(DatasetSource.self, forKey: .datasetSource)
        datasetSource = datasetSourceDecoded
    }
}

extension CreateDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDatasetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDatasetOutputResponse(datasetMetadata: \(String(describing: datasetMetadata)))"}
}

extension CreateDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDatasetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetMetadata = output.datasetMetadata
        } else {
            self.datasetMetadata = nil
        }
    }
}

public struct CreateDatasetOutputResponse: Equatable {
    /// <p>Information about the dataset.</p>
    public let datasetMetadata: DatasetMetadata?

    public init (
        datasetMetadata: DatasetMetadata? = nil
    )
    {
        self.datasetMetadata = datasetMetadata
    }
}

struct CreateDatasetOutputResponseBody: Equatable {
    public let datasetMetadata: DatasetMetadata?
}

extension CreateDatasetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetMetadata = "DatasetMetadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetMetadataDecoded = try containerValues.decodeIfPresent(DatasetMetadata.self, forKey: .datasetMetadata)
        datasetMetadata = datasetMetadataDecoded
    }
}

public struct CreateModelInputBodyMiddleware: Middleware {
    public let id: String = "CreateModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateModelInput>
    public typealias MOutput = OperationOutput<CreateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateModelOutputError>
}

extension CreateModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateModelInput(clientToken: \(String(describing: clientToken)), description: \(String(describing: description)), kmsKeyId: \(String(describing: kmsKeyId)), outputConfig: \(String(describing: outputConfig)), projectName: \(String(describing: projectName)), tags: \(String(describing: tags)))"}
}

extension CreateModelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case outputConfig = "OutputConfig"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let outputConfig = outputConfig {
            try encodeContainer.encode(outputConfig, forKey: .outputConfig)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateModelInputHeadersMiddleware: Middleware {
    public let id: String = "CreateModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateModelInput>
    public typealias MOutput = OperationOutput<CreateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateModelOutputError>
}

public struct CreateModelInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateModelInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateModelInput>
    public typealias MOutput = OperationOutput<CreateModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateModelOutputError>
}

public struct CreateModelInput: Equatable {
    /// <p>ClientToken is an idempotency token that ensures a call to <code>CreateModel</code>
    ///       completes only once.  You choose the value to pass. For example, An issue,
    ///       such as an network outage, might prevent you from getting a response from <code>CreateModel</code>.
    ///       In this case, safely retry your call
    ///        to <code>CreateModel</code> by using the same <code>ClientToken</code> parameter value. An error occurs
    ///        if the other input parameters are not the same as in the first request. Using a different
    ///        value for <code>ClientToken</code> is considered a new call to <code>CreateModel</code>. An idempotency
    ///        token is active for 8 hours.</p>
    public var clientToken: String?
    /// <p>A description for the version of the model.</p>
    public let description: String?
    /// <p>The identifier for your AWS Key Management Service (AWS KMS) customer master key (CMK).
    ///          The key is used to encrypt training and test images copied into the service for model training. Your
    ///          source images are unaffected.
    ///          If this parameter is not specified, the copied images are encrypted by a key that AWS owns and manages.</p>
    public let kmsKeyId: String?
    /// <p>The location where Amazon Lookout for Vision saves the training results.</p>
    public let outputConfig: OutputConfig?
    /// <p>The name of the project in which you want to create a model version.</p>
    public let projectName: String?
    /// <p>A set of tags (key-value pairs) that you want to attach to the model.</p>
    public let tags: [Tag]?

    public init (
        clientToken: String? = nil,
        description: String? = nil,
        kmsKeyId: String? = nil,
        outputConfig: OutputConfig? = nil,
        projectName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.kmsKeyId = kmsKeyId
        self.outputConfig = outputConfig
        self.projectName = projectName
        self.tags = tags
    }
}

struct CreateModelInputBody: Equatable {
    public let description: String?
    public let outputConfig: OutputConfig?
    public let kmsKeyId: String?
    public let tags: [Tag]?
}

extension CreateModelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case kmsKeyId = "KmsKeyId"
        case outputConfig = "OutputConfig"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(OutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateModelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateModelOutputResponse(modelMetadata: \(String(describing: modelMetadata)))"}
}

extension CreateModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.modelMetadata = output.modelMetadata
        } else {
            self.modelMetadata = nil
        }
    }
}

public struct CreateModelOutputResponse: Equatable {
    /// <p>The response from a call to <code>CreateModel</code>.</p>
    public let modelMetadata: ModelMetadata?

    public init (
        modelMetadata: ModelMetadata? = nil
    )
    {
        self.modelMetadata = modelMetadata
    }
}

struct CreateModelOutputResponseBody: Equatable {
    public let modelMetadata: ModelMetadata?
}

extension CreateModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case modelMetadata = "ModelMetadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelMetadataDecoded = try containerValues.decodeIfPresent(ModelMetadata.self, forKey: .modelMetadata)
        modelMetadata = modelMetadataDecoded
    }
}

public struct CreateProjectInputBodyMiddleware: Middleware {
    public let id: String = "CreateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

extension CreateProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProjectInput(clientToken: \(String(describing: clientToken)), projectName: \(String(describing: projectName)))"}
}

extension CreateProjectInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case projectName = "ProjectName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
    }
}

public struct CreateProjectInputHeadersMiddleware: Middleware {
    public let id: String = "CreateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateProjectInput>
    public typealias MOutput = OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateProjectOutputError>
}

public struct CreateProjectInput: Equatable {
    /// <p>ClientToken is an idempotency token that ensures a call to <code>CreateProject</code>
    ///       completes only once.  You choose the value to pass. For example, An issue,
    ///       such as an network outage, might prevent you from getting a response from <code>CreateProject</code>.
    ///       In this case, safely retry your call
    ///        to <code>CreateProject</code> by using the same <code>ClientToken</code> parameter value. An error occurs
    ///        if the other input parameters are not the same as in the first request. Using a different
    ///        value for <code>ClientToken</code> is considered a new call to <code>CreateProject</code>. An idempotency
    ///        token is active for 8 hours.</p>
    public var clientToken: String?
    /// <p>The name for the project.</p>
    public let projectName: String?

    public init (
        clientToken: String? = nil,
        projectName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.projectName = projectName
    }
}

struct CreateProjectInputBody: Equatable {
    public let projectName: String?
}

extension CreateProjectInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case projectName = "ProjectName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
    }
}

extension CreateProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProjectOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateProjectOutputResponse(projectMetadata: \(String(describing: projectMetadata)))"}
}

extension CreateProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.projectMetadata = output.projectMetadata
        } else {
            self.projectMetadata = nil
        }
    }
}

public struct CreateProjectOutputResponse: Equatable {
    /// <p>Information about the project.</p>
    public let projectMetadata: ProjectMetadata?

    public init (
        projectMetadata: ProjectMetadata? = nil
    )
    {
        self.projectMetadata = projectMetadata
    }
}

struct CreateProjectOutputResponseBody: Equatable {
    public let projectMetadata: ProjectMetadata?
}

extension CreateProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case projectMetadata = "ProjectMetadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectMetadataDecoded = try containerValues.decodeIfPresent(ProjectMetadata.self, forKey: .projectMetadata)
        projectMetadata = projectMetadataDecoded
    }
}

extension DatasetDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTimestamp = "CreationTimestamp"
        case datasetType = "DatasetType"
        case imageStats = "ImageStats"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case projectName = "ProjectName"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp.timeIntervalSince1970, forKey: .creationTimestamp)
        }
        if let datasetType = datasetType {
            try encodeContainer.encode(datasetType, forKey: .datasetType)
        }
        if let imageStats = imageStats {
            try encodeContainer.encode(imageStats, forKey: .imageStats)
        }
        if let lastUpdatedTimestamp = lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp.timeIntervalSince1970, forKey: .lastUpdatedTimestamp)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let datasetTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DatasetStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let imageStatsDecoded = try containerValues.decodeIfPresent(DatasetImageStats.self, forKey: .imageStats)
        imageStats = imageStatsDecoded
    }
}

extension DatasetDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetDescription(creationTimestamp: \(String(describing: creationTimestamp)), datasetType: \(String(describing: datasetType)), imageStats: \(String(describing: imageStats)), lastUpdatedTimestamp: \(String(describing: lastUpdatedTimestamp)), projectName: \(String(describing: projectName)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)))"}
}

/// <p>The description for a dataset. For more information, see <a>DescribeDataset</a>.</p>
public struct DatasetDescription: Equatable {
    /// <p>The Unix timestamp for the time and date that the dataset was created.</p>
    public let creationTimestamp: Date?
    /// <p>The type of the dataset. The value <code>train</code> represents a training dataset or single dataset project.
    ///       The value <code>test</code> represents a test dataset.</p>
    public let datasetType: String?
    /// <p></p>
    public let imageStats: DatasetImageStats?
    /// <p>The Unix timestamp for the date and time that the dataset was last updated.</p>
    public let lastUpdatedTimestamp: Date?
    /// <p>The name of the project that contains the dataset.</p>
    public let projectName: String?
    /// <p>The status of the dataset.</p>
    public let status: DatasetStatus?
    /// <p>The status message for the dataset. </p>
    public let statusMessage: String?

    public init (
        creationTimestamp: Date? = nil,
        datasetType: String? = nil,
        imageStats: DatasetImageStats? = nil,
        lastUpdatedTimestamp: Date? = nil,
        projectName: String? = nil,
        status: DatasetStatus? = nil,
        statusMessage: String? = nil
    )
    {
        self.creationTimestamp = creationTimestamp
        self.datasetType = datasetType
        self.imageStats = imageStats
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.projectName = projectName
        self.status = status
        self.statusMessage = statusMessage
    }
}

extension DatasetGroundTruthManifest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Object = "S3Object"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Object = s3Object {
            try encodeContainer.encode(s3Object, forKey: .s3Object)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ObjectDecoded = try containerValues.decodeIfPresent(InputS3Object.self, forKey: .s3Object)
        s3Object = s3ObjectDecoded
    }
}

extension DatasetGroundTruthManifest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetGroundTruthManifest(s3Object: \(String(describing: s3Object)))"}
}

/// <p>Location information about a manifest file. You can use a manifest file to
///       create a dataset.</p>
public struct DatasetGroundTruthManifest: Equatable {
    /// <p>The S3 bucket location for the manifest file.</p>
    public let s3Object: InputS3Object?

    public init (
        s3Object: InputS3Object? = nil
    )
    {
        self.s3Object = s3Object
    }
}

extension DatasetImageStats: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case anomaly = "Anomaly"
        case labeled = "Labeled"
        case normal = "Normal"
        case total = "Total"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let anomaly = anomaly {
            try encodeContainer.encode(anomaly, forKey: .anomaly)
        }
        if let labeled = labeled {
            try encodeContainer.encode(labeled, forKey: .labeled)
        }
        if let normal = normal {
            try encodeContainer.encode(normal, forKey: .normal)
        }
        if let total = total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .total)
        total = totalDecoded
        let labeledDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .labeled)
        labeled = labeledDecoded
        let normalDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .normal)
        normal = normalDecoded
        let anomalyDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .anomaly)
        anomaly = anomalyDecoded
    }
}

extension DatasetImageStats: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetImageStats(anomaly: \(String(describing: anomaly)), labeled: \(String(describing: labeled)), normal: \(String(describing: normal)), total: \(String(describing: total)))"}
}

/// <p>Statistics about the images in a dataset.</p>
public struct DatasetImageStats: Equatable {
    /// <p>the total number of images labeled as an anomaly.</p>
    public let anomaly: Int?
    /// <p>The total number of labeled images.</p>
    public let labeled: Int?
    /// <p>The total number of images labeled as normal.</p>
    public let normal: Int?
    /// <p>The total number of images in the dataset.</p>
    public let total: Int?

    public init (
        anomaly: Int? = nil,
        labeled: Int? = nil,
        normal: Int? = nil,
        total: Int? = nil
    )
    {
        self.anomaly = anomaly
        self.labeled = labeled
        self.normal = normal
        self.total = total
    }
}

extension DatasetMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTimestamp = "CreationTimestamp"
        case datasetType = "DatasetType"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp.timeIntervalSince1970, forKey: .creationTimestamp)
        }
        if let datasetType = datasetType {
            try encodeContainer.encode(datasetType, forKey: .datasetType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .datasetType)
        datasetType = datasetTypeDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DatasetStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension DatasetMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetMetadata(creationTimestamp: \(String(describing: creationTimestamp)), datasetType: \(String(describing: datasetType)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)))"}
}

/// <p>Sumary information for an Amazon Lookout for Vision dataset.</p>
public struct DatasetMetadata: Equatable {
    /// <p>The Unix timestamp for the date and time that the dataset was created. </p>
    public let creationTimestamp: Date?
    /// <p>The type of the dataset.</p>
    public let datasetType: String?
    /// <p>The status for the dataset.</p>
    public let status: DatasetStatus?
    /// <p>The status message for the dataset.</p>
    public let statusMessage: String?

    public init (
        creationTimestamp: Date? = nil,
        datasetType: String? = nil,
        status: DatasetStatus? = nil,
        statusMessage: String? = nil
    )
    {
        self.creationTimestamp = creationTimestamp
        self.datasetType = datasetType
        self.status = status
        self.statusMessage = statusMessage
    }
}

extension DatasetSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groundTruthManifest = "GroundTruthManifest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groundTruthManifest = groundTruthManifest {
            try encodeContainer.encode(groundTruthManifest, forKey: .groundTruthManifest)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groundTruthManifestDecoded = try containerValues.decodeIfPresent(DatasetGroundTruthManifest.self, forKey: .groundTruthManifest)
        groundTruthManifest = groundTruthManifestDecoded
    }
}

extension DatasetSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DatasetSource(groundTruthManifest: \(String(describing: groundTruthManifest)))"}
}

/// <p>Information about the location of a manifest file that Amazon Lookout for Vision uses to to create a dataset.</p>
public struct DatasetSource: Equatable {
    /// <p>Location information for the manifest file.</p>
    public let groundTruthManifest: DatasetGroundTruthManifest?

    public init (
        groundTruthManifest: DatasetGroundTruthManifest? = nil
    )
    {
        self.groundTruthManifest = groundTruthManifest
    }
}

public enum DatasetStatus {
    case createComplete
    case createFailed
    case createInProgress
    case deleteComplete
    case deleteFailed
    case deleteInProgress
    case updateComplete
    case updateFailedRollbackComplete
    case updateFailedRollbackInProgress
    case updateInProgress
    case sdkUnknown(String)
}

extension DatasetStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DatasetStatus] {
        return [
            .createComplete,
            .createFailed,
            .createInProgress,
            .deleteComplete,
            .deleteFailed,
            .deleteInProgress,
            .updateComplete,
            .updateFailedRollbackComplete,
            .updateFailedRollbackInProgress,
            .updateInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createComplete: return "CREATE_COMPLETE"
        case .createFailed: return "CREATE_FAILED"
        case .createInProgress: return "CREATE_IN_PROGRESS"
        case .deleteComplete: return "DELETE_COMPLETE"
        case .deleteFailed: return "DELETE_FAILED"
        case .deleteInProgress: return "DELETE_IN_PROGRESS"
        case .updateComplete: return "UPDATE_COMPLETE"
        case .updateFailedRollbackComplete: return "UPDATE_FAILED_ROLLBACK_COMPLETE"
        case .updateFailedRollbackInProgress: return "UPDATE_FAILED_ROLLBACK_IN_PROGRESS"
        case .updateInProgress: return "UPDATE_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DatasetStatus(rawValue: rawValue) ?? DatasetStatus.sdkUnknown(rawValue)
    }
}

extension DeleteDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetInput(clientToken: \(String(describing: clientToken)), datasetType: \(String(describing: datasetType)), projectName: \(String(describing: projectName)))"}
}

extension DeleteDatasetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDatasetInput>
    public typealias MOutput = OperationOutput<DeleteDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDatasetOutputError>
}

public struct DeleteDatasetInput: Equatable {
    /// <p>ClientToken is an idempotency token that ensures a call to <code>DeleteDataset</code>
    ///       completes only once.  You choose the value to pass. For example, An issue,
    ///       such as an network outage, might prevent you from getting a response from <code>DeleteDataset</code>.
    ///       In this case, safely retry your call
    ///        to <code>DeleteDataset</code> by using the same <code>ClientToken</code> parameter value. An error occurs
    ///        if the other input parameters are not the same as in the first request. Using a different
    ///        value for <code>ClientToken</code> is considered a new call to <code>DeleteDataset</code>. An idempotency
    ///        token is active for 8 hours.</p>
    public var clientToken: String?
    /// <p>The type of the dataset to delete. Specify <code>train</code> to delete the training dataset.
    ///       Specify <code>test</code> to delete the test dataset. To delete the dataset in a single dataset project,
    ///          specify <code>train</code>.</p>
    public let datasetType: String?
    /// <p>The name of the project that contains the dataset that you want to delete.</p>
    public let projectName: String?

    public init (
        clientToken: String? = nil,
        datasetType: String? = nil,
        projectName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.datasetType = datasetType
        self.projectName = projectName
    }
}

struct DeleteDatasetInputBody: Equatable {
}

extension DeleteDatasetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDatasetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDatasetOutputResponse()"}
}

extension DeleteDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDatasetOutputResponse: Equatable {

    public init() {}
}

struct DeleteDatasetOutputResponseBody: Equatable {
}

extension DeleteDatasetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteModelInput(clientToken: \(String(describing: clientToken)), modelVersion: \(String(describing: modelVersion)), projectName: \(String(describing: projectName)))"}
}

extension DeleteModelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteModelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteModelInput>
    public typealias MOutput = OperationOutput<DeleteModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteModelOutputError>
}

public struct DeleteModelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteModelInput>
    public typealias MOutput = OperationOutput<DeleteModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteModelOutputError>
}

public struct DeleteModelInput: Equatable {
    /// <p>ClientToken is an idempotency token that ensures a call to <code>DeleteModel</code>
    ///       completes only once.  You choose the value to pass. For example, An issue,
    ///       such as an network outage, might prevent you from getting a response from <code>DeleteModel</code>.
    ///       In this case, safely retry your call
    ///        to <code>DeleteModel</code> by using the same <code>ClientToken</code> parameter value. An error occurs
    ///        if the other input parameters are not the same as in the first request. Using a different
    ///        value for <code>ClientToken</code> is considered a new call to <code>DeleteModel</code>. An idempotency
    ///        token is active for 8 hours.</p>
    public var clientToken: String?
    /// <p>The version of the model that you want to delete.</p>
    public let modelVersion: String?
    /// <p>The name of the project that contains the model that you want to delete.</p>
    public let projectName: String?

    public init (
        clientToken: String? = nil,
        modelVersion: String? = nil,
        projectName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

struct DeleteModelInputBody: Equatable {
}

extension DeleteModelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteModelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteModelOutputResponse(modelArn: \(String(describing: modelArn)))"}
}

extension DeleteModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.modelArn = output.modelArn
        } else {
            self.modelArn = nil
        }
    }
}

public struct DeleteModelOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the model that was deleted.</p>
    public let modelArn: String?

    public init (
        modelArn: String? = nil
    )
    {
        self.modelArn = modelArn
    }
}

struct DeleteModelOutputResponseBody: Equatable {
    public let modelArn: String?
}

extension DeleteModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case modelArn = "ModelArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
    }
}

extension DeleteProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProjectInput(clientToken: \(String(describing: clientToken)), projectName: \(String(describing: projectName)))"}
}

extension DeleteProjectInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteProjectInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInput: Equatable {
    /// <p>ClientToken is an idempotency token that ensures a call to <code>DeleteProject</code>
    ///          completes only once.  You choose the value to pass. For example, An issue,
    ///          such as an network outage, might prevent you from getting a response from <code>DeleteProject</code>.
    ///          In this case, safely retry your call
    ///          to <code>DeleteProject</code> by using the same <code>ClientToken</code> parameter value. An error occurs
    ///          if the other input parameters are not the same as in the first request. Using a different
    ///          value for <code>ClientToken</code> is considered a new call to <code>DeleteProject</code>. An idempotency
    ///          token is active for 8 hours.</p>
    public var clientToken: String?
    /// <p>The name of the project to delete.</p>
    public let projectName: String?

    public init (
        clientToken: String? = nil,
        projectName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.projectName = projectName
    }
}

struct DeleteProjectInputBody: Equatable {
}

extension DeleteProjectInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProjectOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProjectOutputResponse(projectArn: \(String(describing: projectArn)))"}
}

extension DeleteProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.projectArn = output.projectArn
        } else {
            self.projectArn = nil
        }
    }
}

public struct DeleteProjectOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the project that was deleted.</p>
    public let projectArn: String?

    public init (
        projectArn: String? = nil
    )
    {
        self.projectArn = projectArn
    }
}

struct DeleteProjectOutputResponseBody: Equatable {
    public let projectArn: String?
}

extension DeleteProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case projectArn = "ProjectArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
    }
}

extension DescribeDatasetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetInput(datasetType: \(String(describing: datasetType)), projectName: \(String(describing: projectName)))"}
}

extension DescribeDatasetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeDatasetInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeDatasetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeDatasetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeDatasetInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeDatasetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeDatasetInput>
    public typealias MOutput = OperationOutput<DescribeDatasetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeDatasetOutputError>
}

public struct DescribeDatasetInput: Equatable {
    /// <p>The type of the dataset to describe. Specify <code>train</code> to describe the
    ///       training dataset. Specify <code>test</code> to describe the test dataset.
    ///       If you have a single dataset project, specify <code>train</code>
    ///          </p>
    public let datasetType: String?
    /// <p>The name of the project that contains the dataset that you want to describe.</p>
    public let projectName: String?

    public init (
        datasetType: String? = nil,
        projectName: String? = nil
    )
    {
        self.datasetType = datasetType
        self.projectName = projectName
    }
}

struct DescribeDatasetInputBody: Equatable {
}

extension DescribeDatasetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeDatasetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDatasetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDatasetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDatasetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeDatasetOutputResponse(datasetDescription: \(String(describing: datasetDescription)))"}
}

extension DescribeDatasetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeDatasetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetDescription = output.datasetDescription
        } else {
            self.datasetDescription = nil
        }
    }
}

public struct DescribeDatasetOutputResponse: Equatable {
    /// <p>The description of the requested dataset. </p>
    public let datasetDescription: DatasetDescription?

    public init (
        datasetDescription: DatasetDescription? = nil
    )
    {
        self.datasetDescription = datasetDescription
    }
}

struct DescribeDatasetOutputResponseBody: Equatable {
    public let datasetDescription: DatasetDescription?
}

extension DescribeDatasetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetDescription = "DatasetDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetDescriptionDecoded = try containerValues.decodeIfPresent(DatasetDescription.self, forKey: .datasetDescription)
        datasetDescription = datasetDescriptionDecoded
    }
}

extension DescribeModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeModelInput(modelVersion: \(String(describing: modelVersion)), projectName: \(String(describing: projectName)))"}
}

extension DescribeModelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeModelInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeModelInput>
    public typealias MOutput = OperationOutput<DescribeModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeModelOutputError>
}

public struct DescribeModelInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeModelInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeModelInput>
    public typealias MOutput = OperationOutput<DescribeModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeModelOutputError>
}

public struct DescribeModelInput: Equatable {
    /// <p>The version of the model that you want to describe.</p>
    public let modelVersion: String?
    /// <p>The project that contains the version of a model that you want to describe.</p>
    public let projectName: String?

    public init (
        modelVersion: String? = nil,
        projectName: String? = nil
    )
    {
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

struct DescribeModelInputBody: Equatable {
}

extension DescribeModelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeModelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeModelOutputResponse(modelDescription: \(String(describing: modelDescription)))"}
}

extension DescribeModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.modelDescription = output.modelDescription
        } else {
            self.modelDescription = nil
        }
    }
}

public struct DescribeModelOutputResponse: Equatable {
    /// <p>Contains the description of the model.</p>
    public let modelDescription: ModelDescription?

    public init (
        modelDescription: ModelDescription? = nil
    )
    {
        self.modelDescription = modelDescription
    }
}

struct DescribeModelOutputResponseBody: Equatable {
    public let modelDescription: ModelDescription?
}

extension DescribeModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case modelDescription = "ModelDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelDescriptionDecoded = try containerValues.decodeIfPresent(ModelDescription.self, forKey: .modelDescription)
        modelDescription = modelDescriptionDecoded
    }
}

extension DescribeProjectInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProjectInput(projectName: \(String(describing: projectName)))"}
}

extension DescribeProjectInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeProjectInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInput: Equatable {
    /// <p>The name of the project that you want to describe.</p>
    public let projectName: String?

    public init (
        projectName: String? = nil
    )
    {
        self.projectName = projectName
    }
}

struct DescribeProjectInputBody: Equatable {
}

extension DescribeProjectInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeProjectOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProjectOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProjectOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProjectOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProjectOutputResponse(projectDescription: \(String(describing: projectDescription)))"}
}

extension DescribeProjectOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeProjectOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.projectDescription = output.projectDescription
        } else {
            self.projectDescription = nil
        }
    }
}

public struct DescribeProjectOutputResponse: Equatable {
    /// <p>The description of the project.</p>
    public let projectDescription: ProjectDescription?

    public init (
        projectDescription: ProjectDescription? = nil
    )
    {
        self.projectDescription = projectDescription
    }
}

struct DescribeProjectOutputResponseBody: Equatable {
    public let projectDescription: ProjectDescription?
}

extension DescribeProjectOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case projectDescription = "ProjectDescription"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectDescriptionDecoded = try containerValues.decodeIfPresent(ProjectDescription.self, forKey: .projectDescription)
        projectDescription = projectDescriptionDecoded
    }
}

public struct DetectAnomaliesInputBodyMiddleware: Middleware {
    public let id: String = "DetectAnomaliesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectAnomaliesInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectAnomaliesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let body = input.operationInput.body {
            let data = body
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectAnomaliesInput>
    public typealias MOutput = OperationOutput<DetectAnomaliesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectAnomaliesOutputError>
}

extension DetectAnomaliesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectAnomaliesInput(body: \(String(describing: body)), contentType: \(String(describing: contentType)), modelVersion: \(String(describing: modelVersion)), projectName: \(String(describing: projectName)))"}
}

extension DetectAnomaliesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body.base64EncodedString(), forKey: .body)
        }
    }
}

public struct DetectAnomaliesInputHeadersMiddleware: Middleware {
    public let id: String = "DetectAnomaliesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectAnomaliesInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectAnomaliesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let contentType = input.operationInput.contentType {
            input.builder.withHeader(name: "Content-Type", value: String(contentType))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectAnomaliesInput>
    public typealias MOutput = OperationOutput<DetectAnomaliesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectAnomaliesOutputError>
}

public struct DetectAnomaliesInputQueryItemMiddleware: Middleware {
    public let id: String = "DetectAnomaliesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DetectAnomaliesInput>,
                  next: H) -> Swift.Result<OperationOutput<DetectAnomaliesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DetectAnomaliesInput>
    public typealias MOutput = OperationOutput<DetectAnomaliesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DetectAnomaliesOutputError>
}

public struct DetectAnomaliesInput: Equatable {
    /// <p>The unencrypted image bytes that you want to analyze. </p>
    public let body: Data?
    /// <p>The type of the image passed in <code>Body</code>.
    ///          Valid values are <code>image/png</code> (PNG format images) and <code>image/jpeg</code> (JPG format images). </p>
    public let contentType: String?
    /// <p>The version of the model that you want to use.</p>
    public let modelVersion: String?
    /// <p>The name of the project that contains the model version that you want to use.</p>
    public let projectName: String?

    public init (
        body: Data? = nil,
        contentType: String? = nil,
        modelVersion: String? = nil,
        projectName: String? = nil
    )
    {
        self.body = body
        self.contentType = contentType
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

struct DetectAnomaliesInputBody: Equatable {
    public let body: Data?
}

extension DetectAnomaliesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .body)
        body = bodyDecoded
    }
}

extension DetectAnomaliesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DetectAnomaliesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DetectAnomaliesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DetectAnomaliesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectAnomaliesOutputResponse(detectAnomalyResult: \(String(describing: detectAnomalyResult)))"}
}

extension DetectAnomaliesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DetectAnomaliesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.detectAnomalyResult = output.detectAnomalyResult
        } else {
            self.detectAnomalyResult = nil
        }
    }
}

public struct DetectAnomaliesOutputResponse: Equatable {
    /// <p>The results of the <code>DetectAnomalies</code> operation.</p>
    public let detectAnomalyResult: DetectAnomalyResult?

    public init (
        detectAnomalyResult: DetectAnomalyResult? = nil
    )
    {
        self.detectAnomalyResult = detectAnomalyResult
    }
}

struct DetectAnomaliesOutputResponseBody: Equatable {
    public let detectAnomalyResult: DetectAnomalyResult?
}

extension DetectAnomaliesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case detectAnomalyResult = "DetectAnomalyResult"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectAnomalyResultDecoded = try containerValues.decodeIfPresent(DetectAnomalyResult.self, forKey: .detectAnomalyResult)
        detectAnomalyResult = detectAnomalyResultDecoded
    }
}

extension DetectAnomalyResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case confidence = "Confidence"
        case isAnomalous = "IsAnomalous"
        case source = "Source"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let confidence = confidence {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if isAnomalous != false {
            try encodeContainer.encode(isAnomalous, forKey: .isAnomalous)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(ImageSource.self, forKey: .source)
        source = sourceDecoded
        let isAnomalousDecoded = try containerValues.decode(Bool.self, forKey: .isAnomalous)
        isAnomalous = isAnomalousDecoded
        let confidenceDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .confidence)
        confidence = confidenceDecoded
    }
}

extension DetectAnomalyResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DetectAnomalyResult(confidence: \(String(describing: confidence)), isAnomalous: \(String(describing: isAnomalous)), source: \(String(describing: source)))"}
}

/// <p>The prediction results from a call to <a>DetectAnomalies</a>.</p>
public struct DetectAnomalyResult: Equatable {
    /// <p>The confidence that Amazon Lookout for Vision has in the accuracy of the prediction.</p>
    public let confidence: Float?
    /// <p>True if the image contains an anomaly, otherwise false.</p>
    public let isAnomalous: Bool
    /// <p>The source of the image that was analyzed. <code>direct</code> means that the
    ///       images was supplied from the local computer. No other values are supported.</p>
    public let source: ImageSource?

    public init (
        confidence: Float? = nil,
        isAnomalous: Bool = false,
        source: ImageSource? = nil
    )
    {
        self.confidence = confidence
        self.isAnomalous = isAnomalous
        self.source = source
    }
}

extension ImageSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension ImageSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageSource(type: \(String(describing: type)))"}
}

/// <p>The source for an image.</p>
public struct ImageSource: Equatable {
    /// <p>The type of the image.</p>
    public let type: String?

    public init (
        type: String? = nil
    )
    {
        self.type = type
    }
}

extension InputS3Object: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case key = "Key"
        case versionId = "VersionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let versionId = versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension InputS3Object: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputS3Object(bucket: \(String(describing: bucket)), key: \(String(describing: key)), versionId: \(String(describing: versionId)))"}
}

/// <p>Amazon S3 Location information for an input manifest file. </p>
public struct InputS3Object: Equatable {
    /// <p>The Amazon S3 bucket that contains the manifest.</p>
    public let bucket: String?
    /// <p>The name and location of the manifest file withiin the bucket.</p>
    public let key: String?
    /// <p>The version ID of the bucket.</p>
    public let versionId: String?

    public init (
        bucket: String? = nil,
        key: String? = nil,
        versionId: String? = nil
    )
    {
        self.bucket = bucket
        self.key = key
        self.versionId = versionId
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon Lookout for Vision experienced a service issue. Try your call again.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    /// <p>The period of time, in seconds, before the operation can be retried.</p>
    public var retryAfterSeconds: Int

    public init (
        message: String? = nil,
        retryAfterSeconds: Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDatasetEntriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetEntriesInput(afterCreationDate: \(String(describing: afterCreationDate)), anomalyClass: \(String(describing: anomalyClass)), beforeCreationDate: \(String(describing: beforeCreationDate)), datasetType: \(String(describing: datasetType)), labeled: \(String(describing: labeled)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), projectName: \(String(describing: projectName)), sourceRefContains: \(String(describing: sourceRefContains)))"}
}

extension ListDatasetEntriesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDatasetEntriesInputHeadersMiddleware: Middleware {
    public let id: String = "ListDatasetEntriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetEntriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetEntriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetEntriesInput>
    public typealias MOutput = OperationOutput<ListDatasetEntriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetEntriesOutputError>
}

public struct ListDatasetEntriesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDatasetEntriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDatasetEntriesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDatasetEntriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let sourceRefContains = input.operationInput.sourceRefContains {
            let sourceRefContainsQueryItem = URLQueryItem(name: "sourceRefContains".urlPercentEncoding(), value: String(sourceRefContains).urlPercentEncoding())
            input.builder.withQueryItem(sourceRefContainsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let labeled = input.operationInput.labeled {
            let labeledQueryItem = URLQueryItem(name: "labeled".urlPercentEncoding(), value: String(labeled).urlPercentEncoding())
            input.builder.withQueryItem(labeledQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let beforeCreationDate = input.operationInput.beforeCreationDate {
            let beforeCreationDateQueryItem = URLQueryItem(name: "createdBefore".urlPercentEncoding(), value: String(beforeCreationDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(beforeCreationDateQueryItem)
        }
        if let afterCreationDate = input.operationInput.afterCreationDate {
            let afterCreationDateQueryItem = URLQueryItem(name: "createdAfter".urlPercentEncoding(), value: String(afterCreationDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(afterCreationDateQueryItem)
        }
        if let anomalyClass = input.operationInput.anomalyClass {
            let anomalyClassQueryItem = URLQueryItem(name: "anomalyClass".urlPercentEncoding(), value: String(anomalyClass).urlPercentEncoding())
            input.builder.withQueryItem(anomalyClassQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDatasetEntriesInput>
    public typealias MOutput = OperationOutput<ListDatasetEntriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDatasetEntriesOutputError>
}

public struct ListDatasetEntriesInput: Equatable {
    /// <p>Only includes entries after the specified date in the response. For example, <code>2020-06-23T00:00:00</code>.</p>
    public let afterCreationDate: Date?
    /// <p>Specify <code>normal</code> to include only normal images. Specify <code>anomaly</code> to only include
    ///          anomalous entries. If you don't specify a value, Amazon Lookout for Vision returns normal and anomalous images.</p>
    public let anomalyClass: String?
    /// <p>Only includes entries before the specified date in the response. For example, <code>2020-06-23T00:00:00</code>.</p>
    public let beforeCreationDate: Date?
    /// <p>The type of the dataset that you want to list.  Specify <code>train</code> to list
    ///          the training dataset. Specify <code>test</code> to list the test dataset. If you have a single dataset
    ///       project, specify <code>train</code>.</p>
    public let datasetType: String?
    /// <p>Specify <code>true</code> to include labeled entries, otherwise specify <code>false</code>. If you
    ///       don't specify a value, Lookout for Vision returns all entries.</p>
    public let labeled: Bool?
    /// <p>The maximum number of results to return per paginated call. The largest value you can specify is 100.
    ///          If you specify a value greater than 100, a ValidationException
    ///          error occurs. The default value is 100.</p>
    public let maxResults: Int?
    /// <p>If the previous response was incomplete (because there is more data to retrieve),
    ///          Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to
    ///          retrieve the next set of dataset entries.</p>
    public let nextToken: String?
    /// <p>The name of the project that contains the dataset that you want to list.</p>
    public let projectName: String?
    /// <p>Perform a "contains" search on the  values of the <code>source-ref</code> key within the dataset.
    ///          For example a value of "IMG_17"  returns all JSON Lines where the <code>source-ref</code> key value matches <i>*IMG_17*</i>.</p>
    public let sourceRefContains: String?

    public init (
        afterCreationDate: Date? = nil,
        anomalyClass: String? = nil,
        beforeCreationDate: Date? = nil,
        datasetType: String? = nil,
        labeled: Bool? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        projectName: String? = nil,
        sourceRefContains: String? = nil
    )
    {
        self.afterCreationDate = afterCreationDate
        self.anomalyClass = anomalyClass
        self.beforeCreationDate = beforeCreationDate
        self.datasetType = datasetType
        self.labeled = labeled
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
        self.sourceRefContains = sourceRefContains
    }
}

struct ListDatasetEntriesInputBody: Equatable {
}

extension ListDatasetEntriesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDatasetEntriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetEntriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDatasetEntriesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetEntriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDatasetEntriesOutputResponse(datasetEntries: \(String(describing: datasetEntries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDatasetEntriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDatasetEntriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.datasetEntries = output.datasetEntries
            self.nextToken = output.nextToken
        } else {
            self.datasetEntries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDatasetEntriesOutputResponse: Equatable {
    /// <p>A list of the entries (JSON Lines) within the dataset.</p>
    public let datasetEntries: [String]?
    /// <p>If the response is truncated, Amazon Lookout for Vision returns this token
    ///          that you can use in the subsequent request to retrieve the next set ofdataset entries.</p>
    public let nextToken: String?

    public init (
        datasetEntries: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.datasetEntries = datasetEntries
        self.nextToken = nextToken
    }
}

struct ListDatasetEntriesOutputResponseBody: Equatable {
    public let datasetEntries: [String]?
    public let nextToken: String?
}

extension ListDatasetEntriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case datasetEntries = "DatasetEntries"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetEntriesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .datasetEntries)
        var datasetEntriesDecoded0:[String]? = nil
        if let datasetEntriesContainer = datasetEntriesContainer {
            datasetEntriesDecoded0 = [String]()
            for string0 in datasetEntriesContainer {
                if let string0 = string0 {
                    datasetEntriesDecoded0?.append(string0)
                }
            }
        }
        datasetEntries = datasetEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListModelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListModelsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), projectName: \(String(describing: projectName)))"}
}

extension ListModelsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListModelsInputHeadersMiddleware: Middleware {
    public let id: String = "ListModelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListModelsInput>
    public typealias MOutput = OperationOutput<ListModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListModelsOutputError>
}

public struct ListModelsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListModelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListModelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListModelsInput>
    public typealias MOutput = OperationOutput<ListModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListModelsOutputError>
}

public struct ListModelsInput: Equatable {
    /// <p>The maximum number of results to return per paginated call. The largest value you can specify is 100.
    ///          If you specify a value greater than 100, a ValidationException
    ///          error occurs. The default value is 100.</p>
    public let maxResults: Int?
    /// <p>If the previous response was incomplete (because there is more data to retrieve),
    ///          Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to
    ///          retrieve the next set of models.</p>
    public let nextToken: String?
    /// <p>The name of the project that contains the model versions that you want to list.</p>
    public let projectName: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        projectName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectName = projectName
    }
}

struct ListModelsInputBody: Equatable {
}

extension ListModelsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListModelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListModelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListModelsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListModelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListModelsOutputResponse(models: \(String(describing: models)), nextToken: \(String(describing: nextToken)))"}
}

extension ListModelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListModelsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.models = output.models
            self.nextToken = output.nextToken
        } else {
            self.models = nil
            self.nextToken = nil
        }
    }
}

public struct ListModelsOutputResponse: Equatable {
    /// <p>A list of model versions in the specified project. </p>
    public let models: [ModelMetadata]?
    /// <p>If the response is truncated, Amazon Lookout for Vision returns this token
    ///          that you can use in the subsequent request to retrieve the next set of models. </p>
    public let nextToken: String?

    public init (
        models: [ModelMetadata]? = nil,
        nextToken: String? = nil
    )
    {
        self.models = models
        self.nextToken = nextToken
    }
}

struct ListModelsOutputResponseBody: Equatable {
    public let models: [ModelMetadata]?
    public let nextToken: String?
}

extension ListModelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case models = "Models"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelsContainer = try containerValues.decodeIfPresent([ModelMetadata?].self, forKey: .models)
        var modelsDecoded0:[ModelMetadata]? = nil
        if let modelsContainer = modelsContainer {
            modelsDecoded0 = [ModelMetadata]()
            for structure0 in modelsContainer {
                if let structure0 = structure0 {
                    modelsDecoded0?.append(structure0)
                }
            }
        }
        models = modelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProjectsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListProjectsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListProjectsInputHeadersMiddleware: Middleware {
    public let id: String = "ListProjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProjectsInput>
    public typealias MOutput = OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProjectsOutputError>
}

public struct ListProjectsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProjectsInput>
    public typealias MOutput = OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProjectsOutputError>
}

public struct ListProjectsInput: Equatable {
    /// <p>The maximum number of results to return per paginated call. The largest value you can specify is 100.
    ///          If you specify a value greater than 100, a ValidationException
    ///          error occurs. The default value is 100.</p>
    public let maxResults: Int?
    /// <p>If the previous response was incomplete (because there is more data to retrieve),
    ///          Amazon Lookout for Vision returns a pagination token in the response. You can use this pagination token to
    ///          retrieve the next set of projects.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListProjectsInputBody: Equatable {
}

extension ListProjectsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListProjectsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProjectsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProjectsOutputResponse(nextToken: \(String(describing: nextToken)), projects: \(String(describing: projects)))"}
}

extension ListProjectsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.projects = output.projects
        } else {
            self.nextToken = nil
            self.projects = nil
        }
    }
}

public struct ListProjectsOutputResponse: Equatable {
    /// <p>If the response is truncated, Amazon Lookout for Vision returns this token
    ///          that you can use in the subsequent request to retrieve the next set of projects.</p>
    public let nextToken: String?
    /// <p>A list of projects in your AWS account.</p>
    public let projects: [ProjectMetadata]?

    public init (
        nextToken: String? = nil,
        projects: [ProjectMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.projects = projects
    }
}

struct ListProjectsOutputResponseBody: Equatable {
    public let projects: [ProjectMetadata]?
    public let nextToken: String?
}

extension ListProjectsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case projects = "Projects"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectsContainer = try containerValues.decodeIfPresent([ProjectMetadata?].self, forKey: .projects)
        var projectsDecoded0:[ProjectMetadata]? = nil
        if let projectsContainer = projectsContainer {
            projectsDecoded0 = [ProjectMetadata]()
            for structure0 in projectsContainer {
                if let structure0 = structure0 {
                    projectsDecoded0?.append(structure0)
                }
            }
        }
        projects = projectsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the model for which you want to list tags. </p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A map of tag keys and values attached to the specified model.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ModelDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTimestamp = "CreationTimestamp"
        case description = "Description"
        case evaluationEndTimestamp = "EvaluationEndTimestamp"
        case evaluationManifest = "EvaluationManifest"
        case evaluationResult = "EvaluationResult"
        case kmsKeyId = "KmsKeyId"
        case modelArn = "ModelArn"
        case modelVersion = "ModelVersion"
        case outputConfig = "OutputConfig"
        case performance = "Performance"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp.timeIntervalSince1970, forKey: .creationTimestamp)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let evaluationEndTimestamp = evaluationEndTimestamp {
            try encodeContainer.encode(evaluationEndTimestamp.timeIntervalSince1970, forKey: .evaluationEndTimestamp)
        }
        if let evaluationManifest = evaluationManifest {
            try encodeContainer.encode(evaluationManifest, forKey: .evaluationManifest)
        }
        if let evaluationResult = evaluationResult {
            try encodeContainer.encode(evaluationResult, forKey: .evaluationResult)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let modelArn = modelArn {
            try encodeContainer.encode(modelArn, forKey: .modelArn)
        }
        if let modelVersion = modelVersion {
            try encodeContainer.encode(modelVersion, forKey: .modelVersion)
        }
        if let outputConfig = outputConfig {
            try encodeContainer.encode(outputConfig, forKey: .outputConfig)
        }
        if let performance = performance {
            try encodeContainer.encode(performance, forKey: .performance)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
        let modelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ModelStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let performanceDecoded = try containerValues.decodeIfPresent(ModelPerformance.self, forKey: .performance)
        performance = performanceDecoded
        let outputConfigDecoded = try containerValues.decodeIfPresent(OutputConfig.self, forKey: .outputConfig)
        outputConfig = outputConfigDecoded
        let evaluationManifestDecoded = try containerValues.decodeIfPresent(OutputS3Object.self, forKey: .evaluationManifest)
        evaluationManifest = evaluationManifestDecoded
        let evaluationResultDecoded = try containerValues.decodeIfPresent(OutputS3Object.self, forKey: .evaluationResult)
        evaluationResult = evaluationResultDecoded
        let evaluationEndTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .evaluationEndTimestamp)
        evaluationEndTimestamp = evaluationEndTimestampDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension ModelDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModelDescription(creationTimestamp: \(String(describing: creationTimestamp)), description: \(String(describing: description)), evaluationEndTimestamp: \(String(describing: evaluationEndTimestamp)), evaluationManifest: \(String(describing: evaluationManifest)), evaluationResult: \(String(describing: evaluationResult)), kmsKeyId: \(String(describing: kmsKeyId)), modelArn: \(String(describing: modelArn)), modelVersion: \(String(describing: modelVersion)), outputConfig: \(String(describing: outputConfig)), performance: \(String(describing: performance)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)))"}
}

/// <p>Describes an Amazon Lookout for Vision model.</p>
public struct ModelDescription: Equatable {
    /// <p>The unix timestamp for the date and time that the model was created. </p>
    public let creationTimestamp: Date?
    /// <p>The description for the model.</p>
    public let description: String?
    /// <p>The unix timestamp for the date and time that the evaluation ended. </p>
    public let evaluationEndTimestamp: Date?
    /// <p>The S3 location where Amazon Lookout for Vision saves the manifest file
    ///          that was used to test the trained model and generate the performance scores.</p>
    public let evaluationManifest: OutputS3Object?
    /// <p>The S3 location where Amazon Lookout for Vision saves the performance metrics.</p>
    public let evaluationResult: OutputS3Object?
    /// <p>The identifer for the AWS Key Management Service (AWS KMS) key that was used to encrypt the model
    ///          during training.</p>
    public let kmsKeyId: String?
    /// <p>The Amazon Resource Name (ARN) of the model.</p>
    public let modelArn: String?
    /// <p>The version of the model</p>
    public let modelVersion: String?
    /// <p>The S3 location where Amazon Lookout for Vision saves model training files.</p>
    public let outputConfig: OutputConfig?
    /// <p>Performance metrics for the model. Created during training.</p>
    public let performance: ModelPerformance?
    /// <p>The status of the model.</p>
    public let status: ModelStatus?
    /// <p>The status message for the model.</p>
    public let statusMessage: String?

    public init (
        creationTimestamp: Date? = nil,
        description: String? = nil,
        evaluationEndTimestamp: Date? = nil,
        evaluationManifest: OutputS3Object? = nil,
        evaluationResult: OutputS3Object? = nil,
        kmsKeyId: String? = nil,
        modelArn: String? = nil,
        modelVersion: String? = nil,
        outputConfig: OutputConfig? = nil,
        performance: ModelPerformance? = nil,
        status: ModelStatus? = nil,
        statusMessage: String? = nil
    )
    {
        self.creationTimestamp = creationTimestamp
        self.description = description
        self.evaluationEndTimestamp = evaluationEndTimestamp
        self.evaluationManifest = evaluationManifest
        self.evaluationResult = evaluationResult
        self.kmsKeyId = kmsKeyId
        self.modelArn = modelArn
        self.modelVersion = modelVersion
        self.outputConfig = outputConfig
        self.performance = performance
        self.status = status
        self.statusMessage = statusMessage
    }
}

public enum ModelHostingStatus {
    case hosted
    case hostingFailed
    case startingHosting
    case stoppingHosting
    case systemUpdating
    case sdkUnknown(String)
}

extension ModelHostingStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ModelHostingStatus] {
        return [
            .hosted,
            .hostingFailed,
            .startingHosting,
            .stoppingHosting,
            .systemUpdating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .hosted: return "HOSTED"
        case .hostingFailed: return "HOSTING_FAILED"
        case .startingHosting: return "STARTING_HOSTING"
        case .stoppingHosting: return "STOPPING_HOSTING"
        case .systemUpdating: return "SYSTEM_UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ModelHostingStatus(rawValue: rawValue) ?? ModelHostingStatus.sdkUnknown(rawValue)
    }
}

extension ModelMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTimestamp = "CreationTimestamp"
        case description = "Description"
        case modelArn = "ModelArn"
        case modelVersion = "ModelVersion"
        case performance = "Performance"
        case status = "Status"
        case statusMessage = "StatusMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp.timeIntervalSince1970, forKey: .creationTimestamp)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let modelArn = modelArn {
            try encodeContainer.encode(modelArn, forKey: .modelArn)
        }
        if let modelVersion = modelVersion {
            try encodeContainer.encode(modelVersion, forKey: .modelVersion)
        }
        if let performance = performance {
            try encodeContainer.encode(performance, forKey: .performance)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
        let modelArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelArn)
        modelArn = modelArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ModelStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let performanceDecoded = try containerValues.decodeIfPresent(ModelPerformance.self, forKey: .performance)
        performance = performanceDecoded
    }
}

extension ModelMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModelMetadata(creationTimestamp: \(String(describing: creationTimestamp)), description: \(String(describing: description)), modelArn: \(String(describing: modelArn)), modelVersion: \(String(describing: modelVersion)), performance: \(String(describing: performance)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)))"}
}

/// <p>Describes an Amazon Lookout for Vision model.</p>
public struct ModelMetadata: Equatable {
    /// <p>The unix timestamp for the date and time that the model was created. </p>
    public let creationTimestamp: Date?
    /// <p>The description for the model.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of the model.</p>
    public let modelArn: String?
    /// <p>The version of the model.</p>
    public let modelVersion: String?
    /// <p>Performance metrics for the model. Not available until training has successfully completed.</p>
    public let performance: ModelPerformance?
    /// <p>The status of the model.</p>
    public let status: ModelStatus?
    /// <p>The status message for the model.</p>
    public let statusMessage: String?

    public init (
        creationTimestamp: Date? = nil,
        description: String? = nil,
        modelArn: String? = nil,
        modelVersion: String? = nil,
        performance: ModelPerformance? = nil,
        status: ModelStatus? = nil,
        statusMessage: String? = nil
    )
    {
        self.creationTimestamp = creationTimestamp
        self.description = description
        self.modelArn = modelArn
        self.modelVersion = modelVersion
        self.performance = performance
        self.status = status
        self.statusMessage = statusMessage
    }
}

extension ModelPerformance: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case f1Score = "F1Score"
        case precision = "Precision"
        case recall = "Recall"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let f1Score = f1Score {
            try encodeContainer.encode(f1Score, forKey: .f1Score)
        }
        if let precision = precision {
            try encodeContainer.encode(precision, forKey: .precision)
        }
        if let recall = recall {
            try encodeContainer.encode(recall, forKey: .recall)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let f1ScoreDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .f1Score)
        f1Score = f1ScoreDecoded
        let recallDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .recall)
        recall = recallDecoded
        let precisionDecoded = try containerValues.decodeIfPresent(Float.self, forKey: .precision)
        precision = precisionDecoded
    }
}

extension ModelPerformance: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModelPerformance(f1Score: \(String(describing: f1Score)), precision: \(String(describing: precision)), recall: \(String(describing: recall)))"}
}

/// <p>Information about the evaluation performance of a trained model. </p>
public struct ModelPerformance: Equatable {
    /// <p>The overall F1 score metric for the trained model.</p>
    public let f1Score: Float?
    /// <p>The overall precision metric value for the trained model.</p>
    public let precision: Float?
    /// <p>The overall recall metric value for the trained model. </p>
    public let recall: Float?

    public init (
        f1Score: Float? = nil,
        precision: Float? = nil,
        recall: Float? = nil
    )
    {
        self.f1Score = f1Score
        self.precision = precision
        self.recall = recall
    }
}

public enum ModelStatus {
    case deleting
    case hosted
    case hostingFailed
    case startingHosting
    case stoppingHosting
    case systemUpdating
    case trained
    case training
    case trainingFailed
    case sdkUnknown(String)
}

extension ModelStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ModelStatus] {
        return [
            .deleting,
            .hosted,
            .hostingFailed,
            .startingHosting,
            .stoppingHosting,
            .systemUpdating,
            .trained,
            .training,
            .trainingFailed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deleting: return "DELETING"
        case .hosted: return "HOSTED"
        case .hostingFailed: return "HOSTING_FAILED"
        case .startingHosting: return "STARTING_HOSTING"
        case .stoppingHosting: return "STOPPING_HOSTING"
        case .systemUpdating: return "SYSTEM_UPDATING"
        case .trained: return "TRAINED"
        case .training: return "TRAINING"
        case .trainingFailed: return "TRAINING_FAILED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ModelStatus(rawValue: rawValue) ?? ModelStatus.sdkUnknown(rawValue)
    }
}

extension OutputConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Location = "S3Location"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationDecoded = try containerValues.decodeIfPresent(S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension OutputConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputConfig(s3Location: \(String(describing: s3Location)))"}
}

/// <p>The S3 location where Amazon Lookout for Vision saves model training files.</p>
public struct OutputConfig: Equatable {
    /// <p>The S3 location for the output.</p>
    public let s3Location: S3Location?

    public init (
        s3Location: S3Location? = nil
    )
    {
        self.s3Location = s3Location
    }
}

extension OutputS3Object: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case key = "Key"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
    }
}

extension OutputS3Object: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutputS3Object(bucket: \(String(describing: bucket)), key: \(String(describing: key)))"}
}

/// <p>The S3 location where Amazon Lookout for Vision saves training output.</p>
public struct OutputS3Object: Equatable {
    /// <p>The bucket that contains the training output.</p>
    public let bucket: String?
    /// <p>The location of the training output in the bucket.</p>
    public let key: String?

    public init (
        bucket: String? = nil,
        key: String? = nil
    )
    {
        self.bucket = bucket
        self.key = key
    }
}

extension ProjectDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTimestamp = "CreationTimestamp"
        case datasets = "Datasets"
        case projectArn = "ProjectArn"
        case projectName = "ProjectName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp.timeIntervalSince1970, forKey: .creationTimestamp)
        }
        if let datasets = datasets {
            var datasetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .datasets)
            for datasetmetadatalist0 in datasets {
                try datasetsContainer.encode(datasetmetadatalist0)
            }
        }
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let datasetsContainer = try containerValues.decodeIfPresent([DatasetMetadata?].self, forKey: .datasets)
        var datasetsDecoded0:[DatasetMetadata]? = nil
        if let datasetsContainer = datasetsContainer {
            datasetsDecoded0 = [DatasetMetadata]()
            for structure0 in datasetsContainer {
                if let structure0 = structure0 {
                    datasetsDecoded0?.append(structure0)
                }
            }
        }
        datasets = datasetsDecoded0
    }
}

extension ProjectDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectDescription(creationTimestamp: \(String(describing: creationTimestamp)), datasets: \(String(describing: datasets)), projectArn: \(String(describing: projectArn)), projectName: \(String(describing: projectName)))"}
}

/// <p>Describe an Amazon Lookout for Vision project. For more information, see <a>DescribeProject</a>.</p>
public struct ProjectDescription: Equatable {
    /// <p>The unix timestamp for the date and time that the project was created. </p>
    public let creationTimestamp: Date?
    /// <p>A list of datasets in the project.</p>
    public let datasets: [DatasetMetadata]?
    /// <p>The Amazon Resource Name (ARN) of the project.</p>
    public let projectArn: String?
    /// <p>The name of the project.</p>
    public let projectName: String?

    public init (
        creationTimestamp: Date? = nil,
        datasets: [DatasetMetadata]? = nil,
        projectArn: String? = nil,
        projectName: String? = nil
    )
    {
        self.creationTimestamp = creationTimestamp
        self.datasets = datasets
        self.projectArn = projectArn
        self.projectName = projectName
    }
}

extension ProjectMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationTimestamp = "CreationTimestamp"
        case projectArn = "ProjectArn"
        case projectName = "ProjectName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTimestamp = creationTimestamp {
            try encodeContainer.encode(creationTimestamp.timeIntervalSince1970, forKey: .creationTimestamp)
        }
        if let projectArn = projectArn {
            try encodeContainer.encode(projectArn, forKey: .projectArn)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
    }
}

extension ProjectMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProjectMetadata(creationTimestamp: \(String(describing: creationTimestamp)), projectArn: \(String(describing: projectArn)), projectName: \(String(describing: projectName)))"}
}

/// <p>Metadata about an Amazon Lookout for Vision project.</p>
public struct ProjectMetadata: Equatable {
    /// <p>The unix timestamp for the date and time that the project was created. </p>
    public let creationTimestamp: Date?
    /// <p>The Amazon Resource Name (ARN) of the project.</p>
    public let projectArn: String?
    /// <p>The name of the project.</p>
    public let projectName: String?

    public init (
        creationTimestamp: Date? = nil,
        projectArn: String? = nil,
        projectName: String? = nil
    )
    {
        self.creationTimestamp = creationTimestamp
        self.projectArn = projectArn
        self.projectName = projectName
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource could not be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The ID of the resource.</p>
    public var resourceId: String?
    /// <p>The type of the resource.</p>
    public var resourceType: ResourceType?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: ResourceType?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public enum ResourceType {
    case dataset
    case model
    case project
    case trial
    case sdkUnknown(String)
}

extension ResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceType] {
        return [
            .dataset,
            .model,
            .project,
            .trial,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dataset: return "DATASET"
        case .model: return "MODEL"
        case .project: return "PROJECT"
        case .trial: return "TRIAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
    }
}

extension S3Location: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bucket = "Bucket"
        case prefix = "Prefix"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension S3Location: CustomDebugStringConvertible {
    public var debugDescription: String {
        "S3Location(bucket: \(String(describing: bucket)), prefix: \(String(describing: prefix)))"}
}

/// <p>Information about the location training output.</p>
public struct S3Location: Equatable {
    /// <p>The S3 bucket that contains the training output.</p>
    public let bucket: String?
    /// <p>The path of the folder, within the S3 bucket, that contains the training output.</p>
    public let prefix: String?

    public init (
        bucket: String? = nil,
        prefix: String? = nil
    )
    {
        self.bucket = bucket
        self.prefix = prefix
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)), quotaCode: \(String(describing: quotaCode)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)), serviceCode: \(String(describing: serviceCode)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A service quota was exceeded the allowed limit. For more information, see
///         Limits in Amazon Lookout for Vision in the Amazon Lookout for Vision Developer Guide. </p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The quota code. </p>
    public var quotaCode: String?
    /// <p>The ID of the resource.</p>
    public var resourceId: String?
    /// <p>The type of the resource.</p>
    public var resourceType: ResourceType?
    /// <p>The service code. </p>
    public var serviceCode: String?

    public init (
        message: String? = nil,
        quotaCode: String? = nil,
        resourceId: String? = nil,
        resourceType: ResourceType? = nil,
        serviceCode: String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: ResourceType?
    public let quotaCode: String?
    public let serviceCode: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

public struct StartModelInputBodyMiddleware: Middleware {
    public let id: String = "StartModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartModelInput>,
                  next: H) -> Swift.Result<OperationOutput<StartModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartModelInput>
    public typealias MOutput = OperationOutput<StartModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartModelOutputError>
}

extension StartModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartModelInput(clientToken: \(String(describing: clientToken)), minInferenceUnits: \(String(describing: minInferenceUnits)), modelVersion: \(String(describing: modelVersion)), projectName: \(String(describing: projectName)))"}
}

extension StartModelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case minInferenceUnits = "MinInferenceUnits"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let minInferenceUnits = minInferenceUnits {
            try encodeContainer.encode(minInferenceUnits, forKey: .minInferenceUnits)
        }
    }
}

public struct StartModelInputHeadersMiddleware: Middleware {
    public let id: String = "StartModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartModelInput>,
                  next: H) -> Swift.Result<OperationOutput<StartModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartModelInput>
    public typealias MOutput = OperationOutput<StartModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartModelOutputError>
}

public struct StartModelInputQueryItemMiddleware: Middleware {
    public let id: String = "StartModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartModelInput>,
                  next: H) -> Swift.Result<OperationOutput<StartModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartModelInput>
    public typealias MOutput = OperationOutput<StartModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartModelOutputError>
}

public struct StartModelInput: Equatable {
    /// <p>ClientToken is an idempotency token that ensures a call to <code>StartModel</code>
    ///          completes only once.  You choose the value to pass. For example, An issue,
    ///          such as an network outage, might prevent you from getting a response from <code>StartModel</code>.
    ///          In this case, safely retry your call
    ///          to <code>StartModel</code> by using the same <code>ClientToken</code> parameter value. An error occurs
    ///          if the other input parameters are not the same as in the first request. Using a different
    ///          value for <code>ClientToken</code> is considered a new call to <code>StartModel</code>. An idempotency
    ///          token is active for 8 hours.
    ///       </p>
    public var clientToken: String?
    /// <p>The minimum number of inference units to use. A single
    ///          inference unit represents 1 hour of processing and can support up to 5 Transaction Pers Second (TPS).
    ///          Use a higher number to increase the TPS throughput of your model. You are charged for the number
    ///          of inference units that you use.
    ///       </p>
    public let minInferenceUnits: Int?
    /// <p>The version of the model that you want to start.</p>
    public let modelVersion: String?
    /// <p>The name of the project that contains the model that you want to start.</p>
    public let projectName: String?

    public init (
        clientToken: String? = nil,
        minInferenceUnits: Int? = nil,
        modelVersion: String? = nil,
        projectName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.minInferenceUnits = minInferenceUnits
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

struct StartModelInputBody: Equatable {
    public let minInferenceUnits: Int?
}

extension StartModelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case minInferenceUnits = "MinInferenceUnits"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minInferenceUnitsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minInferenceUnits)
        minInferenceUnits = minInferenceUnitsDecoded
    }
}

extension StartModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartModelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartModelOutputResponse(status: \(String(describing: status)))"}
}

extension StartModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct StartModelOutputResponse: Equatable {
    /// <p>The current running status of the model.</p>
    public let status: ModelHostingStatus?

    public init (
        status: ModelHostingStatus? = nil
    )
    {
        self.status = status
    }
}

struct StartModelOutputResponseBody: Equatable {
    public let status: ModelHostingStatus?
}

extension StartModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ModelHostingStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension StopModelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopModelInput(clientToken: \(String(describing: clientToken)), modelVersion: \(String(describing: modelVersion)), projectName: \(String(describing: projectName)))"}
}

extension StopModelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct StopModelInputHeadersMiddleware: Middleware {
    public let id: String = "StopModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopModelInput>,
                  next: H) -> Swift.Result<OperationOutput<StopModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopModelInput>
    public typealias MOutput = OperationOutput<StopModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopModelOutputError>
}

public struct StopModelInputQueryItemMiddleware: Middleware {
    public let id: String = "StopModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopModelInput>,
                  next: H) -> Swift.Result<OperationOutput<StopModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopModelInput>
    public typealias MOutput = OperationOutput<StopModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopModelOutputError>
}

public struct StopModelInput: Equatable {
    /// <p>ClientToken is an idempotency token that ensures a call to <code>StopModel</code>
    ///          completes only once.  You choose the value to pass. For example, An issue,
    ///          such as an network outage, might prevent you from getting a response from <code>StopModel</code>.
    ///          In this case, safely retry your call
    ///          to <code>StopModel</code> by using the same <code>ClientToken</code> parameter value. An error occurs
    ///          if the other input parameters are not the same as in the first request. Using a different
    ///          value for <code>ClientToken</code> is considered a new call to <code>StopModel</code>. An idempotency
    ///          token is active for 8 hours.
    ///
    ///
    ///       </p>
    public var clientToken: String?
    /// <p>The version of the model that you want to stop.</p>
    public let modelVersion: String?
    /// <p>The name of the project that contains the model that you want to stop.</p>
    public let projectName: String?

    public init (
        clientToken: String? = nil,
        modelVersion: String? = nil,
        projectName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.modelVersion = modelVersion
        self.projectName = projectName
    }
}

struct StopModelInputBody: Equatable {
}

extension StopModelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension StopModelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopModelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopModelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopModelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopModelOutputResponse(status: \(String(describing: status)))"}
}

extension StopModelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StopModelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct StopModelOutputResponse: Equatable {
    /// <p>The status of the model.</p>
    public let status: ModelHostingStatus?

    public init (
        status: ModelHostingStatus? = nil
    )
    {
        self.status = status
    }
}

struct StopModelOutputResponseBody: Equatable {
    public let status: ModelHostingStatus?
}

extension StopModelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ModelHostingStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A key and value pair that is attached to the specified Amazon Lookout for Vision model.</p>
public struct Tag: Equatable {
    /// <p>The key of the tag that is attached to the specified model.</p>
    public let key: String?
    /// <p>The value of the tag that is attached to the specified model.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the model to assign the tags.</p>
    public let resourceArn: String?
    /// <p>The key-value tags to assign to the model.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)), quotaCode: \(String(describing: quotaCode)), retryAfterSeconds: \(String(describing: retryAfterSeconds)), serviceCode: \(String(describing: serviceCode)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon Lookout for Vision is temporarily unable to process the request. Try your call again.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The quota code. </p>
    public var quotaCode: String?
    /// <p>The period of time, in seconds, before the operation can be retried. </p>
    public var retryAfterSeconds: Int
    /// <p>The service code. </p>
    public var serviceCode: String?

    public init (
        message: String? = nil,
        quotaCode: String? = nil,
        retryAfterSeconds: Int = 0,
        serviceCode: String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
    public let quotaCode: String?
    public let serviceCode: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the model from which you want to remove tags. </p>
    public let resourceArn: String?
    /// <p>A list of the keys of the tags that you want to remove.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDatasetEntriesInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDatasetEntriesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDatasetEntriesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDatasetEntriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDatasetEntriesInput>
    public typealias MOutput = OperationOutput<UpdateDatasetEntriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDatasetEntriesOutputError>
}

extension UpdateDatasetEntriesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDatasetEntriesInput(changes: \(String(describing: changes)), clientToken: \(String(describing: clientToken)), datasetType: \(String(describing: datasetType)), projectName: \(String(describing: projectName)))"}
}

extension UpdateDatasetEntriesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case changes = "Changes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changes = changes {
            try encodeContainer.encode(changes.base64EncodedString(), forKey: .changes)
        }
    }
}

public struct UpdateDatasetEntriesInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDatasetEntriesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDatasetEntriesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDatasetEntriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            input.builder.withHeader(name: "X-Amzn-Client-Token", value: String(clientToken))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDatasetEntriesInput>
    public typealias MOutput = OperationOutput<UpdateDatasetEntriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDatasetEntriesOutputError>
}

public struct UpdateDatasetEntriesInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDatasetEntriesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDatasetEntriesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDatasetEntriesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDatasetEntriesInput>
    public typealias MOutput = OperationOutput<UpdateDatasetEntriesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDatasetEntriesOutputError>
}

public struct UpdateDatasetEntriesInput: Equatable {
    /// <p>The entries to add to the dataset.</p>
    public let changes: Data?
    /// <p>ClientToken is an idempotency token that ensures a call to <code>UpdateDatasetEntries</code>
    ///          completes only once.  You choose the value to pass. For example, An issue,
    ///          such as an network outage, might prevent you from getting a response from <code>UpdateDatasetEntries</code>.
    ///          In this case, safely retry your call
    ///          to <code>UpdateDatasetEntries</code> by using the same <code>ClientToken</code> parameter value. An error occurs
    ///          if the other input parameters are not the same as in the first request. Using a different
    ///          value for <code>ClientToken</code> is considered a new call to <code>UpdateDatasetEntries</code>. An idempotency
    ///          token is active for 8 hours.
    ///       </p>
    public var clientToken: String?
    /// <p>The type of the dataset that you want to update. Specify <code>train</code> to update
    ///       the training dataset. Specify <code>test</code> to update the test dataset. If you
    ///        have a single dataset project, specify <code>train</code>.</p>
    public let datasetType: String?
    /// <p>The name of the project that contains the dataset that you want to update.</p>
    public let projectName: String?

    public init (
        changes: Data? = nil,
        clientToken: String? = nil,
        datasetType: String? = nil,
        projectName: String? = nil
    )
    {
        self.changes = changes
        self.clientToken = clientToken
        self.datasetType = datasetType
        self.projectName = projectName
    }
}

struct UpdateDatasetEntriesInputBody: Equatable {
    public let changes: Data?
}

extension UpdateDatasetEntriesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changes = "Changes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .changes)
        changes = changesDecoded
    }
}

extension UpdateDatasetEntriesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatasetEntriesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDatasetEntriesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatasetEntriesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDatasetEntriesOutputResponse(status: \(String(describing: status)))"}
}

extension UpdateDatasetEntriesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDatasetEntriesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct UpdateDatasetEntriesOutputResponse: Equatable {
    /// <p>The status of the dataset update.</p>
    public let status: DatasetStatus?

    public init (
        status: DatasetStatus? = nil
    )
    {
        self.status = status
    }
}

struct UpdateDatasetEntriesOutputResponseBody: Equatable {
    public let status: DatasetStatus?
}

extension UpdateDatasetEntriesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(DatasetStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An input validation error occured. For example, invalid characters in a project name,
///       or if a pagination token is invalid.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
