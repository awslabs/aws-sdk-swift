// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AssumeRoleInputBodyMiddleware: Middleware {
    public let id: String = "AssumeRoleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssumeRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<AssumeRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssumeRoleInput>
    public typealias MOutput = OperationOutput<AssumeRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssumeRoleOutputError>
}

extension AssumeRoleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssumeRoleInput(durationSeconds: \(String(describing: durationSeconds)), externalId: \(String(describing: externalId)), policy: \(String(describing: policy)), policyArns: \(String(describing: policyArns)), roleArn: \(String(describing: roleArn)), roleSessionName: \(String(describing: roleSessionName)), serialNumber: \(String(describing: serialNumber)), sourceIdentity: \(String(describing: sourceIdentity)), tags: \(String(describing: tags)), tokenCode: \(String(describing: tokenCode)), transitiveTagKeys: \(String(describing: transitiveTagKeys)))"}
}

extension AssumeRoleInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let durationSeconds = durationSeconds {
            try container.encode(durationSeconds, forKey: Key("DurationSeconds"))
        }
        if let externalId = externalId {
            try container.encode(externalId, forKey: Key("ExternalId"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: Key("Policy"))
        }
        if let policyArns = policyArns {
            var policyArnsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PolicyArns"))
            for (index0, policydescriptortype0) in policyArns.enumerated() {
                try policyArnsContainer.encode(policydescriptortype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: Key("RoleArn"))
        }
        if let roleSessionName = roleSessionName {
            try container.encode(roleSessionName, forKey: Key("RoleSessionName"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: Key("SerialNumber"))
        }
        if let sourceIdentity = sourceIdentity {
            try container.encode(sourceIdentity, forKey: Key("SourceIdentity"))
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tokenCode = tokenCode {
            try container.encode(tokenCode, forKey: Key("TokenCode"))
        }
        if let transitiveTagKeys = transitiveTagKeys {
            var transitiveTagKeysContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("TransitiveTagKeys"))
            for (index0, tagkeytype0) in transitiveTagKeys.enumerated() {
                try transitiveTagKeysContainer.encode(tagkeytype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("AssumeRole", forKey:Key("Action"))
        try container.encode("2011-06-15", forKey:Key("Version"))
    }
}

public struct AssumeRoleInputHeadersMiddleware: Middleware {
    public let id: String = "AssumeRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssumeRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<AssumeRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssumeRoleInput>
    public typealias MOutput = OperationOutput<AssumeRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssumeRoleOutputError>
}

public struct AssumeRoleInputQueryItemMiddleware: Middleware {
    public let id: String = "AssumeRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssumeRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<AssumeRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssumeRoleInput>
    public typealias MOutput = OperationOutput<AssumeRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssumeRoleOutputError>
}

public struct AssumeRoleInput: Equatable {
    /// <p>The duration, in seconds, of the role session. The value specified can can range from
    ///          900 seconds (15 minutes) up to the maximum session duration that is set for the role. The
    ///          maximum session duration setting can have a value from 1 hour to 12 hours. If you specify a
    ///          value higher than this setting or the administrator setting (whichever is lower), the
    ///          operation fails. For example, if you specify a session duration of 12 hours, but your
    ///          administrator set the maximum session duration to 6 hours, your operation fails. To learn
    ///          how to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html#id_roles_use_view-role-max-session">View the
    ///             Maximum Session Duration Setting for a Role</a> in the
    ///             <i>IAM User Guide</i>.</p>
    ///          <p>By default, the value is set to <code>3600</code> seconds. </p>
    ///          <note>
    ///             <p>The <code>DurationSeconds</code> parameter is separate from the duration of a console
    ///             session that you might request using the returned credentials. The request to the
    ///             federation endpoint for a console sign-in token takes a <code>SessionDuration</code>
    ///             parameter that specifies the maximum length of the console session. For more
    ///             information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-custom-url.html">Creating a URL
    ///                that Enables Federated Users to Access the AWS Management Console</a> in the
    ///                <i>IAM User Guide</i>.</p>
    ///          </note>
    public let durationSeconds: Int?
    /// <p>A unique identifier that might be required when you assume a role in another account. If
    ///          the administrator of the account to which the role belongs provided you with an external
    ///          ID, then provide that value in the <code>ExternalId</code> parameter. This value can be any
    ///          string, such as a passphrase or account number. A cross-account role is usually set up to
    ///          trust everyone in an account. Therefore, the administrator of the trusting account might
    ///          send an external ID to the administrator of the trusted account. That way, only someone
    ///          with the ID can assume the role, rather than everyone in the account. For more information
    ///          about the external ID, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_create_for-user_externalid.html">How to Use an External ID
    ///             When Granting Access to Your AWS Resources to a Third Party</a> in the
    ///             <i>IAM User Guide</i>.</p>
    ///          <p>The regex used to validate this parameter is a string of
    ///     characters consisting of upper- and lower-case alphanumeric characters with no spaces.
    ///     You can also include underscores or any of the following characters: =,.@:/-</p>
    public let externalId: String?
    /// <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
    ///          <p>This parameter is optional. Passing policies to this operation returns new
    ///          temporary credentials. The resulting session's permissions are the intersection of the
    ///          role's identity-based policy and the session policies. You can use the role's temporary
    ///          credentials in subsequent AWS API calls to access resources in the account that owns
    ///          the role. You cannot use session policies to grant more permissions than those allowed
    ///          by the identity-based policy of the role that is being assumed. For more information, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    ///             Policies</a> in the <i>IAM User Guide</i>.</p>
    ///          <p>The plaintext that you use for both inline and managed session policies can't exceed
    ///          2,048 characters. The JSON policy characters can be any ASCII character from the space
    ///          character to the end of the valid character list (\u0020 through \u00FF). It can also
    ///          include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
    ///          characters.</p>
    ///          <note>
    ///             <p>An AWS conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///             </p>
    ///          </note>
    public let policy: String?
    /// <p>The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as
    ///          managed session policies. The policies must exist in the same account as the role.</p>
    ///          <p>This parameter is optional. You can provide up to 10 managed policy ARNs. However, the
    ///          plaintext that you use for both inline and managed session policies can't exceed 2,048
    ///          characters. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and AWS
    ///             Service Namespaces</a> in the AWS General Reference.</p>
    ///          <note>
    ///             <p>An AWS conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///             </p>
    ///          </note>
    ///
    ///          <p>Passing policies to this operation returns new
    ///          temporary credentials. The resulting session's permissions are the intersection of the
    ///          role's identity-based policy and the session policies. You can use the role's temporary
    ///          credentials in subsequent AWS API calls to access resources in the account that owns
    ///          the role. You cannot use session policies to grant more permissions than those allowed
    ///          by the identity-based policy of the role that is being assumed. For more information, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    ///             Policies</a> in the <i>IAM User Guide</i>.</p>
    public let policyArns: [PolicyDescriptorType]?
    /// <p>The Amazon Resource Name (ARN) of the role to assume.</p>
    public let roleArn: String?
    /// <p>An identifier for the assumed role session.</p>
    ///          <p>Use the role session name to uniquely identify a session when the same role is assumed
    ///          by different principals or for different reasons. In cross-account scenarios, the role
    ///          session name is visible to, and can be logged by the account that owns the role. The role
    ///          session name is also used in the ARN of the assumed role principal. This means that
    ///          subsequent cross-account API requests that use the temporary security credentials will
    ///          expose the role session name to the external account in their AWS CloudTrail logs.</p>
    ///          <p>The regex used to validate this parameter is a string of characters
    ///     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    ///     also include underscores or any of the following characters: =,.@-</p>
    public let roleSessionName: String?
    /// <p>The identification number of the MFA device that is associated with the user who is
    ///          making the <code>AssumeRole</code> call. Specify this value if the trust policy of the role
    ///          being assumed includes a condition that requires MFA authentication. The value is either
    ///          the serial number for a hardware device (such as <code>GAHT12345678</code>) or an Amazon
    ///          Resource Name (ARN) for a virtual device (such as
    ///             <code>arn:aws:iam::123456789012:mfa/user</code>).</p>
    ///          <p>The regex used to validate this parameter is a string of characters
    ///     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    ///     also include underscores or any of the following characters: =,.@-</p>
    public let serialNumber: String?
    /// <p>The source identity specified by the principal that is calling the
    ///             <code>AssumeRole</code> operation.</p>
    ///          <p>You can require users to specify a source identity when they assume a role. You do this
    ///          by using the <code>sts:SourceIdentity</code> condition key in a role trust policy. You can
    ///          use source identity information in AWS CloudTrail logs to determine who took actions with a role.
    ///          You can use the <code>aws:SourceIdentity</code> condition key to further control access to
    ///          AWS resources based on the value of source identity. For more information about using
    ///          source identity, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_monitor.html">Monitor and control
    ///             actions taken with assumed roles</a> in the
    ///          <i>IAM User Guide</i>.</p>
    ///          <p>The regex used to validate this parameter is a string of characters consisting of upper-
    ///          and lower-case alphanumeric characters with no spaces. You can also include underscores or
    ///          any of the following characters: =,.@-. You cannot use a value that begins with the text
    ///          <code>aws:</code>. This prefix is reserved for AWS internal
    ///          use.</p>
    public let sourceIdentity: String?
    /// <p>A list of session tags that you want to pass. Each session tag consists of a key name
    ///          and an associated value. For more information about session tags, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Tagging AWS STS
    ///             Sessions</a> in the <i>IAM User Guide</i>.</p>
    ///          <p>This parameter is optional. You can pass up to 50 session tags. The plaintext session
    ///          tag keys can’t exceed 128 characters, and the values can’t exceed 256 characters. For these
    ///          and additional limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-limits.html#reference_iam-limits-entity-length">IAM
    ///             and STS Character Limits</a> in the <i>IAM User Guide</i>.</p>
    ///
    ///          <note>
    ///             <p>An AWS conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///             </p>
    ///          </note>
    ///          <p>You can pass a session tag with the same key as a tag that is already
    ///          attached to the role. When you do, session tags override a role tag with the same key. </p>
    ///          <p>Tag key–value pairs are not case sensitive, but case is preserved. This means that you
    ///          cannot have separate <code>Department</code> and <code>department</code> tag keys. Assume
    ///          that the role has the <code>Department</code>=<code>Marketing</code> tag and you pass the
    ///             <code>department</code>=<code>engineering</code> session tag. <code>Department</code>
    ///          and <code>department</code> are not saved as separate tags, and the session tag passed in
    ///          the request takes precedence over the role tag.</p>
    ///          <p>Additionally, if you used temporary credentials to perform this operation, the new
    ///          session inherits any transitive session tags from the calling session. If you pass a
    ///          session tag with the same key as an inherited tag, the operation fails. To view the
    ///          inherited tags for a session, see the AWS CloudTrail logs. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/session-tags.html#id_session-tags_ctlogs">Viewing Session Tags in CloudTrail</a> in the
    ///          <i>IAM User Guide</i>.</p>
    public let tags: [Tag]?
    /// <p>The value provided by the MFA device, if the trust policy of the role being assumed
    ///          requires MFA. (In other words, if the policy includes a condition that tests for MFA). If
    ///          the role being assumed requires MFA and if the <code>TokenCode</code> value is missing or
    ///          expired, the <code>AssumeRole</code> call returns an "access denied" error.</p>
    ///          <p>The format for this parameter, as described by its regex pattern, is a sequence of six
    ///          numeric digits.</p>
    public let tokenCode: String?
    /// <p>A list of keys for session tags that you want to set as transitive. If you set a tag key
    ///          as transitive, the corresponding key and value passes to subsequent sessions in a role
    ///          chain. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html#id_session-tags_role-chaining">Chaining Roles
    ///             with Session Tags</a> in the <i>IAM User Guide</i>.</p>
    ///          <p>This parameter is optional. When you set session tags as transitive, the session policy
    ///          and session tags packed binary limit is not affected.</p>
    ///          <p>If you choose not to specify a transitive tag key, then no tags are passed from this
    ///          session to any subsequent sessions.</p>
    public let transitiveTagKeys: [String]?

    public init (
        durationSeconds: Int? = nil,
        externalId: String? = nil,
        policy: String? = nil,
        policyArns: [PolicyDescriptorType]? = nil,
        roleArn: String? = nil,
        roleSessionName: String? = nil,
        serialNumber: String? = nil,
        sourceIdentity: String? = nil,
        tags: [Tag]? = nil,
        tokenCode: String? = nil,
        transitiveTagKeys: [String]? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.externalId = externalId
        self.policy = policy
        self.policyArns = policyArns
        self.roleArn = roleArn
        self.roleSessionName = roleSessionName
        self.serialNumber = serialNumber
        self.sourceIdentity = sourceIdentity
        self.tags = tags
        self.tokenCode = tokenCode
        self.transitiveTagKeys = transitiveTagKeys
    }
}

extension AssumeRoleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AssumeRoleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ExpiredTokenException" : self = .expiredTokenException(try ExpiredTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PackedPolicyTooLargeException" : self = .packedPolicyTooLargeException(try PackedPolicyTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegionDisabledException" : self = .regionDisabledException(try RegionDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssumeRoleOutputError: Equatable {
    case expiredTokenException(ExpiredTokenException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case packedPolicyTooLargeException(PackedPolicyTooLargeException)
    case regionDisabledException(RegionDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssumeRoleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssumeRoleOutputResponse(assumedRoleUser: \(String(describing: assumedRoleUser)), credentials: \(String(describing: credentials)), packedPolicySize: \(String(describing: packedPolicySize)), sourceIdentity: \(String(describing: sourceIdentity)))"}
}

extension AssumeRoleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssumeRoleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assumedRoleUser = output.assumedRoleUser
            self.credentials = output.credentials
            self.packedPolicySize = output.packedPolicySize
            self.sourceIdentity = output.sourceIdentity
        } else {
            self.assumedRoleUser = nil
            self.credentials = nil
            self.packedPolicySize = nil
            self.sourceIdentity = nil
        }
    }
}

/// <p>Contains the response to a successful <a>AssumeRole</a> request, including
///       temporary AWS credentials that can be used to make AWS requests. </p>
public struct AssumeRoleOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) and the assumed role ID, which are identifiers that you
    ///          can use to refer to the resulting temporary security credentials. For example, you can
    ///          reference these credentials as a principal in a resource-based policy by using the ARN or
    ///          assumed role ID. The ARN and ID include the <code>RoleSessionName</code> that you specified
    ///          when you called <code>AssumeRole</code>. </p>
    public let assumedRoleUser: AssumedRoleUser?
    /// <p>The temporary security credentials, which include an access key ID, a secret access key,
    ///          and a security (or session) token.</p>
    ///          <note>
    ///             <p>The size of the security token that STS API operations return is not fixed. We
    ///         strongly recommend that you make no assumptions about the maximum size.</p>
    ///          </note>
    public let credentials: Credentials?
    /// <p>A percentage value that indicates the packed size of the session policies and session
    ///       tags combined passed in the request. The request fails if the packed size is greater than 100 percent,
    ///       which means the policies and tags exceeded the allowed space.</p>
    public let packedPolicySize: Int?
    /// <p>The source identity specified by the principal that is calling the
    ///             <code>AssumeRole</code> operation.</p>
    ///          <p>You can require users to specify a source identity when they assume a role. You do this
    ///          by using the <code>sts:SourceIdentity</code> condition key in a role trust policy. You can
    ///          use source identity information in AWS CloudTrail logs to determine who took actions with a role.
    ///          You can use the <code>aws:SourceIdentity</code> condition key to further control access to
    ///          AWS resources based on the value of source identity. For more information about using
    ///          source identity, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_monitor.html">Monitor and control
    ///             actions taken with assumed roles</a> in the
    ///          <i>IAM User Guide</i>.</p>
    ///          <p>The regex used to validate this parameter is a string of characters consisting of upper-
    ///          and lower-case alphanumeric characters with no spaces. You can also include underscores or
    ///          any of the following characters: =,.@-</p>
    public let sourceIdentity: String?

    public init (
        assumedRoleUser: AssumedRoleUser? = nil,
        credentials: Credentials? = nil,
        packedPolicySize: Int? = nil,
        sourceIdentity: String? = nil
    )
    {
        self.assumedRoleUser = assumedRoleUser
        self.credentials = credentials
        self.packedPolicySize = packedPolicySize
        self.sourceIdentity = sourceIdentity
    }
}

struct AssumeRoleOutputResponseBody: Equatable {
    public let credentials: Credentials?
    public let assumedRoleUser: AssumedRoleUser?
    public let packedPolicySize: Int?
    public let sourceIdentity: String?
}

extension AssumeRoleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assumedRoleUser = "AssumedRoleUser"
        case credentials = "Credentials"
        case packedPolicySize = "PackedPolicySize"
        case sourceIdentity = "SourceIdentity"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("AssumeRoleResult"))
        let credentialsDecoded = try containerValues.decodeIfPresent(Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let assumedRoleUserDecoded = try containerValues.decodeIfPresent(AssumedRoleUser.self, forKey: .assumedRoleUser)
        assumedRoleUser = assumedRoleUserDecoded
        let packedPolicySizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .packedPolicySize)
        packedPolicySize = packedPolicySizeDecoded
        let sourceIdentityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceIdentity)
        sourceIdentity = sourceIdentityDecoded
    }
}

public struct AssumeRoleWithSAMLInputBodyMiddleware: Middleware {
    public let id: String = "AssumeRoleWithSAMLInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssumeRoleWithSAMLInput>,
                  next: H) -> Swift.Result<OperationOutput<AssumeRoleWithSAMLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssumeRoleWithSAMLInput>
    public typealias MOutput = OperationOutput<AssumeRoleWithSAMLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssumeRoleWithSAMLOutputError>
}

extension AssumeRoleWithSAMLInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssumeRoleWithSAMLInput(durationSeconds: \(String(describing: durationSeconds)), policy: \(String(describing: policy)), policyArns: \(String(describing: policyArns)), principalArn: \(String(describing: principalArn)), roleArn: \(String(describing: roleArn)), sAMLAssertion: \(String(describing: sAMLAssertion)))"}
}

extension AssumeRoleWithSAMLInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let durationSeconds = durationSeconds {
            try container.encode(durationSeconds, forKey: Key("DurationSeconds"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: Key("Policy"))
        }
        if let policyArns = policyArns {
            var policyArnsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PolicyArns"))
            for (index0, policydescriptortype0) in policyArns.enumerated() {
                try policyArnsContainer.encode(policydescriptortype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let principalArn = principalArn {
            try container.encode(principalArn, forKey: Key("PrincipalArn"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: Key("RoleArn"))
        }
        if let sAMLAssertion = sAMLAssertion {
            try container.encode(sAMLAssertion, forKey: Key("SAMLAssertion"))
        }
        try container.encode("AssumeRoleWithSAML", forKey:Key("Action"))
        try container.encode("2011-06-15", forKey:Key("Version"))
    }
}

public struct AssumeRoleWithSAMLInputHeadersMiddleware: Middleware {
    public let id: String = "AssumeRoleWithSAMLInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssumeRoleWithSAMLInput>,
                  next: H) -> Swift.Result<OperationOutput<AssumeRoleWithSAMLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssumeRoleWithSAMLInput>
    public typealias MOutput = OperationOutput<AssumeRoleWithSAMLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssumeRoleWithSAMLOutputError>
}

public struct AssumeRoleWithSAMLInputQueryItemMiddleware: Middleware {
    public let id: String = "AssumeRoleWithSAMLInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssumeRoleWithSAMLInput>,
                  next: H) -> Swift.Result<OperationOutput<AssumeRoleWithSAMLOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssumeRoleWithSAMLInput>
    public typealias MOutput = OperationOutput<AssumeRoleWithSAMLOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssumeRoleWithSAMLOutputError>
}

public struct AssumeRoleWithSAMLInput: Equatable {
    /// <p>The duration, in seconds, of the role session. Your role session lasts for the duration
    ///          that you specify for the <code>DurationSeconds</code> parameter, or until the time
    ///          specified in the SAML authentication response's <code>SessionNotOnOrAfter</code> value,
    ///          whichever is shorter. You can provide a <code>DurationSeconds</code> value from 900 seconds
    ///          (15 minutes) up to the maximum session duration setting for the role. This setting can have
    ///          a value from 1 hour to 12 hours. If you specify a value higher than this setting, the
    ///          operation fails. For example, if you specify a session duration of 12 hours, but your
    ///          administrator set the maximum session duration to 6 hours, your operation fails. To learn
    ///          how to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html#id_roles_use_view-role-max-session">View the
    ///             Maximum Session Duration Setting for a Role</a> in the
    ///             <i>IAM User Guide</i>.</p>
    ///          <p>By default, the value is set to <code>3600</code> seconds. </p>
    ///          <note>
    ///             <p>The <code>DurationSeconds</code> parameter is separate from the duration of a console
    ///             session that you might request using the returned credentials. The request to the
    ///             federation endpoint for a console sign-in token takes a <code>SessionDuration</code>
    ///             parameter that specifies the maximum length of the console session. For more
    ///             information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-custom-url.html">Creating a URL
    ///                that Enables Federated Users to Access the AWS Management Console</a> in the
    ///                <i>IAM User Guide</i>.</p>
    ///          </note>
    public let durationSeconds: Int?
    /// <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
    ///          <p>This parameter is optional. Passing policies to this operation returns new
    ///          temporary credentials. The resulting session's permissions are the intersection of the
    ///          role's identity-based policy and the session policies. You can use the role's temporary
    ///          credentials in subsequent AWS API calls to access resources in the account that owns
    ///          the role. You cannot use session policies to grant more permissions than those allowed
    ///          by the identity-based policy of the role that is being assumed. For more information, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    ///             Policies</a> in the <i>IAM User Guide</i>. </p>
    ///          <p>The plaintext that you use for both inline and managed session policies can't exceed
    ///          2,048 characters. The JSON policy characters can be any ASCII character from the space
    ///          character to the end of the valid character list (\u0020 through \u00FF). It can also
    ///          include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
    ///          characters.</p>
    ///          <note>
    ///             <p>An AWS conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///             </p>
    ///          </note>
    public let policy: String?
    /// <p>The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as
    ///          managed session policies. The policies must exist in the same account as the role.</p>
    ///          <p>This parameter is optional. You can provide up to 10 managed policy ARNs. However, the
    ///          plaintext that you use for both inline and managed session policies can't exceed 2,048
    ///          characters. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and AWS
    ///             Service Namespaces</a> in the AWS General Reference.</p>
    ///          <note>
    ///             <p>An AWS conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///             </p>
    ///          </note>
    ///
    ///          <p>Passing policies to this operation returns new
    ///          temporary credentials. The resulting session's permissions are the intersection of the
    ///          role's identity-based policy and the session policies. You can use the role's temporary
    ///          credentials in subsequent AWS API calls to access resources in the account that owns
    ///          the role. You cannot use session policies to grant more permissions than those allowed
    ///          by the identity-based policy of the role that is being assumed. For more information, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    ///             Policies</a> in the <i>IAM User Guide</i>.</p>
    public let policyArns: [PolicyDescriptorType]?
    /// <p>The Amazon Resource Name (ARN) of the SAML provider in IAM that describes the
    ///          IdP.</p>
    public let principalArn: String?
    /// <p>The Amazon Resource Name (ARN) of the role that the caller is assuming.</p>
    public let roleArn: String?
    /// <p>The base64 encoded SAML authentication response provided by the IdP.</p>
    ///          <p>For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/create-role-saml-IdP-tasks.html">Configuring a Relying Party and
    ///             Adding Claims</a> in the <i>IAM User Guide</i>. </p>
    public let sAMLAssertion: String?

    public init (
        durationSeconds: Int? = nil,
        policy: String? = nil,
        policyArns: [PolicyDescriptorType]? = nil,
        principalArn: String? = nil,
        roleArn: String? = nil,
        sAMLAssertion: String? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.policy = policy
        self.policyArns = policyArns
        self.principalArn = principalArn
        self.roleArn = roleArn
        self.sAMLAssertion = sAMLAssertion
    }
}

extension AssumeRoleWithSAMLOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AssumeRoleWithSAMLOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ExpiredTokenException" : self = .expiredTokenException(try ExpiredTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IDPRejectedClaimException" : self = .iDPRejectedClaimException(try IDPRejectedClaimException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIdentityTokenException" : self = .invalidIdentityTokenException(try InvalidIdentityTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PackedPolicyTooLargeException" : self = .packedPolicyTooLargeException(try PackedPolicyTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegionDisabledException" : self = .regionDisabledException(try RegionDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssumeRoleWithSAMLOutputError: Equatable {
    case expiredTokenException(ExpiredTokenException)
    case iDPRejectedClaimException(IDPRejectedClaimException)
    case invalidIdentityTokenException(InvalidIdentityTokenException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case packedPolicyTooLargeException(PackedPolicyTooLargeException)
    case regionDisabledException(RegionDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssumeRoleWithSAMLOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssumeRoleWithSAMLOutputResponse(assumedRoleUser: \(String(describing: assumedRoleUser)), audience: \(String(describing: audience)), credentials: \(String(describing: credentials)), issuer: \(String(describing: issuer)), nameQualifier: \(String(describing: nameQualifier)), packedPolicySize: \(String(describing: packedPolicySize)), sourceIdentity: \(String(describing: sourceIdentity)), subject: \(String(describing: subject)), subjectType: \(String(describing: subjectType)))"}
}

extension AssumeRoleWithSAMLOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssumeRoleWithSAMLOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assumedRoleUser = output.assumedRoleUser
            self.audience = output.audience
            self.credentials = output.credentials
            self.issuer = output.issuer
            self.nameQualifier = output.nameQualifier
            self.packedPolicySize = output.packedPolicySize
            self.sourceIdentity = output.sourceIdentity
            self.subject = output.subject
            self.subjectType = output.subjectType
        } else {
            self.assumedRoleUser = nil
            self.audience = nil
            self.credentials = nil
            self.issuer = nil
            self.nameQualifier = nil
            self.packedPolicySize = nil
            self.sourceIdentity = nil
            self.subject = nil
            self.subjectType = nil
        }
    }
}

/// <p>Contains the response to a successful <a>AssumeRoleWithSAML</a> request,
///       including temporary AWS credentials that can be used to make AWS requests. </p>
public struct AssumeRoleWithSAMLOutputResponse: Equatable {
    /// <p>The identifiers for the temporary security credentials that the operation
    ///          returns.</p>
    public let assumedRoleUser: AssumedRoleUser?
    /// <p> The value of the <code>Recipient</code> attribute of the
    ///             <code>SubjectConfirmationData</code> element of the SAML assertion. </p>
    public let audience: String?
    /// <p>The temporary security credentials, which include an access key ID, a secret access key,
    ///          and a security (or session) token.</p>
    ///          <note>
    ///             <p>The size of the security token that STS API operations return is not fixed. We
    ///         strongly recommend that you make no assumptions about the maximum size.</p>
    ///          </note>
    public let credentials: Credentials?
    /// <p>The value of the <code>Issuer</code> element of the SAML assertion.</p>
    public let issuer: String?
    /// <p>A hash value based on the concatenation of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>The <code>Issuer</code> response value.</p>
    ///             </li>
    ///             <li>
    ///                <p>The AWS account ID.</p>
    ///             </li>
    ///             <li>
    ///                <p>The friendly name (the last part of the ARN) of the SAML provider in IAM.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The combination of <code>NameQualifier</code> and <code>Subject</code> can be used to
    ///          uniquely identify a federated user.</p>
    ///          <p>The following pseudocode shows how the hash value is calculated:</p>
    ///          <p>
    ///             <code>BASE64 ( SHA1 ( "https://example.com/saml" + "123456789012" + "/MySAMLIdP" ) )</code>
    ///          </p>
    public let nameQualifier: String?
    /// <p>A percentage value that indicates the packed size of the session policies and session
    ///       tags combined passed in the request. The request fails if the packed size is greater than 100 percent,
    ///       which means the policies and tags exceeded the allowed space.</p>
    public let packedPolicySize: Int?
    /// <p>The value in the <code>SourceIdentity</code> attribute in the SAML assertion. </p>
    ///          <p>You can require users to set a source identity value when they assume a role. You do
    ///          this by using the <code>sts:SourceIdentity</code> condition key in a role trust policy.
    ///          That way, actions that are taken with the role are associated with that user. After the
    ///          source identity is set, the value cannot be changed. It is present in the request for all
    ///          actions that are taken by the role and persists across <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_terms-and-concepts#iam-term-role-chaining">chained
    ///             role</a> sessions. You can configure your SAML identity provider to use an attribute
    ///          associated with your users, like user name or email, as the source identity when calling
    ///             <code>AssumeRoleWithSAML</code>. You do this by adding an attribute to the SAML
    ///          assertion. For more information about using source identity, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_monitor.html">Monitor and control
    ///             actions taken with assumed roles</a> in the
    ///          <i>IAM User Guide</i>.</p>
    ///          <p>The regex used to validate this parameter is a string of characters
    ///     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    ///     also include underscores or any of the following characters: =,.@-</p>
    public let sourceIdentity: String?
    /// <p>The value of the <code>NameID</code> element in the <code>Subject</code> element of the
    ///          SAML assertion.</p>
    public let subject: String?
    /// <p> The format of the name ID, as defined by the <code>Format</code> attribute in the
    ///             <code>NameID</code> element of the SAML assertion. Typical examples of the format are
    ///             <code>transient</code> or <code>persistent</code>. </p>
    ///          <p> If the format includes the prefix
    ///             <code>urn:oasis:names:tc:SAML:2.0:nameid-format</code>, that prefix is removed. For
    ///          example, <code>urn:oasis:names:tc:SAML:2.0:nameid-format:transient</code> is returned as
    ///             <code>transient</code>. If the format includes any other prefix, the format is returned
    ///          with no modifications.</p>
    public let subjectType: String?

    public init (
        assumedRoleUser: AssumedRoleUser? = nil,
        audience: String? = nil,
        credentials: Credentials? = nil,
        issuer: String? = nil,
        nameQualifier: String? = nil,
        packedPolicySize: Int? = nil,
        sourceIdentity: String? = nil,
        subject: String? = nil,
        subjectType: String? = nil
    )
    {
        self.assumedRoleUser = assumedRoleUser
        self.audience = audience
        self.credentials = credentials
        self.issuer = issuer
        self.nameQualifier = nameQualifier
        self.packedPolicySize = packedPolicySize
        self.sourceIdentity = sourceIdentity
        self.subject = subject
        self.subjectType = subjectType
    }
}

struct AssumeRoleWithSAMLOutputResponseBody: Equatable {
    public let credentials: Credentials?
    public let assumedRoleUser: AssumedRoleUser?
    public let packedPolicySize: Int?
    public let subject: String?
    public let subjectType: String?
    public let issuer: String?
    public let audience: String?
    public let nameQualifier: String?
    public let sourceIdentity: String?
}

extension AssumeRoleWithSAMLOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assumedRoleUser = "AssumedRoleUser"
        case audience = "Audience"
        case credentials = "Credentials"
        case issuer = "Issuer"
        case nameQualifier = "NameQualifier"
        case packedPolicySize = "PackedPolicySize"
        case sourceIdentity = "SourceIdentity"
        case subject = "Subject"
        case subjectType = "SubjectType"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("AssumeRoleWithSAMLResult"))
        let credentialsDecoded = try containerValues.decodeIfPresent(Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let assumedRoleUserDecoded = try containerValues.decodeIfPresent(AssumedRoleUser.self, forKey: .assumedRoleUser)
        assumedRoleUser = assumedRoleUserDecoded
        let packedPolicySizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .packedPolicySize)
        packedPolicySize = packedPolicySizeDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let subjectTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subjectType)
        subjectType = subjectTypeDecoded
        let issuerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .issuer)
        issuer = issuerDecoded
        let audienceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .audience)
        audience = audienceDecoded
        let nameQualifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nameQualifier)
        nameQualifier = nameQualifierDecoded
        let sourceIdentityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceIdentity)
        sourceIdentity = sourceIdentityDecoded
    }
}

public struct AssumeRoleWithWebIdentityInputBodyMiddleware: Middleware {
    public let id: String = "AssumeRoleWithWebIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssumeRoleWithWebIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<AssumeRoleWithWebIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssumeRoleWithWebIdentityInput>
    public typealias MOutput = OperationOutput<AssumeRoleWithWebIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssumeRoleWithWebIdentityOutputError>
}

extension AssumeRoleWithWebIdentityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssumeRoleWithWebIdentityInput(durationSeconds: \(String(describing: durationSeconds)), policy: \(String(describing: policy)), policyArns: \(String(describing: policyArns)), providerId: \(String(describing: providerId)), roleArn: \(String(describing: roleArn)), roleSessionName: \(String(describing: roleSessionName)), webIdentityToken: \(String(describing: webIdentityToken)))"}
}

extension AssumeRoleWithWebIdentityInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let durationSeconds = durationSeconds {
            try container.encode(durationSeconds, forKey: Key("DurationSeconds"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: Key("Policy"))
        }
        if let policyArns = policyArns {
            var policyArnsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PolicyArns"))
            for (index0, policydescriptortype0) in policyArns.enumerated() {
                try policyArnsContainer.encode(policydescriptortype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let providerId = providerId {
            try container.encode(providerId, forKey: Key("ProviderId"))
        }
        if let roleArn = roleArn {
            try container.encode(roleArn, forKey: Key("RoleArn"))
        }
        if let roleSessionName = roleSessionName {
            try container.encode(roleSessionName, forKey: Key("RoleSessionName"))
        }
        if let webIdentityToken = webIdentityToken {
            try container.encode(webIdentityToken, forKey: Key("WebIdentityToken"))
        }
        try container.encode("AssumeRoleWithWebIdentity", forKey:Key("Action"))
        try container.encode("2011-06-15", forKey:Key("Version"))
    }
}

public struct AssumeRoleWithWebIdentityInputHeadersMiddleware: Middleware {
    public let id: String = "AssumeRoleWithWebIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssumeRoleWithWebIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<AssumeRoleWithWebIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssumeRoleWithWebIdentityInput>
    public typealias MOutput = OperationOutput<AssumeRoleWithWebIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssumeRoleWithWebIdentityOutputError>
}

public struct AssumeRoleWithWebIdentityInputQueryItemMiddleware: Middleware {
    public let id: String = "AssumeRoleWithWebIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssumeRoleWithWebIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<AssumeRoleWithWebIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssumeRoleWithWebIdentityInput>
    public typealias MOutput = OperationOutput<AssumeRoleWithWebIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssumeRoleWithWebIdentityOutputError>
}

public struct AssumeRoleWithWebIdentityInput: Equatable {
    /// <p>The duration, in seconds, of the role session. The value can range from 900 seconds (15
    ///          minutes) up to the maximum session duration setting for the role. This setting can have a
    ///          value from 1 hour to 12 hours. If you specify a value higher than this setting, the
    ///          operation fails. For example, if you specify a session duration of 12 hours, but your
    ///          administrator set the maximum session duration to 6 hours, your operation fails. To learn
    ///          how to view the maximum value for your role, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html#id_roles_use_view-role-max-session">View the
    ///             Maximum Session Duration Setting for a Role</a> in the
    ///             <i>IAM User Guide</i>.</p>
    ///          <p>By default, the value is set to <code>3600</code> seconds. </p>
    ///          <note>
    ///             <p>The <code>DurationSeconds</code> parameter is separate from the duration of a console
    ///             session that you might request using the returned credentials. The request to the
    ///             federation endpoint for a console sign-in token takes a <code>SessionDuration</code>
    ///             parameter that specifies the maximum length of the console session. For more
    ///             information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers_enable-console-custom-url.html">Creating a URL
    ///                that Enables Federated Users to Access the AWS Management Console</a> in the
    ///                <i>IAM User Guide</i>.</p>
    ///          </note>
    public let durationSeconds: Int?
    /// <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
    ///          <p>This parameter is optional. Passing policies to this operation returns new
    ///          temporary credentials. The resulting session's permissions are the intersection of the
    ///          role's identity-based policy and the session policies. You can use the role's temporary
    ///          credentials in subsequent AWS API calls to access resources in the account that owns
    ///          the role. You cannot use session policies to grant more permissions than those allowed
    ///          by the identity-based policy of the role that is being assumed. For more information, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    ///             Policies</a> in the <i>IAM User Guide</i>.</p>
    ///          <p>The plaintext that you use for both inline and managed session policies can't exceed
    ///          2,048 characters. The JSON policy characters can be any ASCII character from the space
    ///          character to the end of the valid character list (\u0020 through \u00FF). It can also
    ///          include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
    ///          characters.</p>
    ///          <note>
    ///             <p>An AWS conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///             </p>
    ///          </note>
    public let policy: String?
    /// <p>The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as
    ///          managed session policies. The policies must exist in the same account as the role.</p>
    ///          <p>This parameter is optional. You can provide up to 10 managed policy ARNs. However, the
    ///          plaintext that you use for both inline and managed session policies can't exceed 2,048
    ///          characters. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and AWS
    ///             Service Namespaces</a> in the AWS General Reference.</p>
    ///          <note>
    ///             <p>An AWS conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///             </p>
    ///          </note>
    ///
    ///          <p>Passing policies to this operation returns new
    ///          temporary credentials. The resulting session's permissions are the intersection of the
    ///          role's identity-based policy and the session policies. You can use the role's temporary
    ///          credentials in subsequent AWS API calls to access resources in the account that owns
    ///          the role. You cannot use session policies to grant more permissions than those allowed
    ///          by the identity-based policy of the role that is being assumed. For more information, see
    ///             <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session
    ///             Policies</a> in the <i>IAM User Guide</i>.</p>
    public let policyArns: [PolicyDescriptorType]?
    /// <p>The fully qualified host component of the domain name of the identity provider.</p>
    ///          <p>Specify this value only for OAuth 2.0 access tokens. Currently
    ///             <code>www.amazon.com</code> and <code>graph.facebook.com</code> are the only supported
    ///          identity providers for OAuth 2.0 access tokens. Do not include URL schemes and port
    ///          numbers.</p>
    ///          <p>Do not specify this value for OpenID Connect ID tokens.</p>
    public let providerId: String?
    /// <p>The Amazon Resource Name (ARN) of the role that the caller is assuming.</p>
    public let roleArn: String?
    /// <p>An identifier for the assumed role session. Typically, you pass the name or identifier
    ///          that is associated with the user who is using your application. That way, the temporary
    ///          security credentials that your application will use are associated with that user. This
    ///          session name is included as part of the ARN and assumed role ID in the
    ///             <code>AssumedRoleUser</code> response element.</p>
    ///          <p>The regex used to validate this parameter is a string of characters
    ///     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    ///     also include underscores or any of the following characters: =,.@-</p>
    public let roleSessionName: String?
    /// <p>The OAuth 2.0 access token or OpenID Connect ID token that is provided by the identity
    ///          provider. Your application must get this token by authenticating the user who is using your
    ///          application with a web identity provider before the application makes an
    ///             <code>AssumeRoleWithWebIdentity</code> call. </p>
    public let webIdentityToken: String?

    public init (
        durationSeconds: Int? = nil,
        policy: String? = nil,
        policyArns: [PolicyDescriptorType]? = nil,
        providerId: String? = nil,
        roleArn: String? = nil,
        roleSessionName: String? = nil,
        webIdentityToken: String? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.policy = policy
        self.policyArns = policyArns
        self.providerId = providerId
        self.roleArn = roleArn
        self.roleSessionName = roleSessionName
        self.webIdentityToken = webIdentityToken
    }
}

extension AssumeRoleWithWebIdentityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension AssumeRoleWithWebIdentityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ExpiredTokenException" : self = .expiredTokenException(try ExpiredTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IDPCommunicationErrorException" : self = .iDPCommunicationErrorException(try IDPCommunicationErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IDPRejectedClaimException" : self = .iDPRejectedClaimException(try IDPRejectedClaimException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIdentityTokenException" : self = .invalidIdentityTokenException(try InvalidIdentityTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PackedPolicyTooLargeException" : self = .packedPolicyTooLargeException(try PackedPolicyTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegionDisabledException" : self = .regionDisabledException(try RegionDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssumeRoleWithWebIdentityOutputError: Equatable {
    case expiredTokenException(ExpiredTokenException)
    case iDPCommunicationErrorException(IDPCommunicationErrorException)
    case iDPRejectedClaimException(IDPRejectedClaimException)
    case invalidIdentityTokenException(InvalidIdentityTokenException)
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case packedPolicyTooLargeException(PackedPolicyTooLargeException)
    case regionDisabledException(RegionDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssumeRoleWithWebIdentityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssumeRoleWithWebIdentityOutputResponse(assumedRoleUser: \(String(describing: assumedRoleUser)), audience: \(String(describing: audience)), credentials: \(String(describing: credentials)), packedPolicySize: \(String(describing: packedPolicySize)), provider: \(String(describing: provider)), sourceIdentity: \(String(describing: sourceIdentity)), subjectFromWebIdentityToken: \(String(describing: subjectFromWebIdentityToken)))"}
}

extension AssumeRoleWithWebIdentityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssumeRoleWithWebIdentityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assumedRoleUser = output.assumedRoleUser
            self.audience = output.audience
            self.credentials = output.credentials
            self.packedPolicySize = output.packedPolicySize
            self.provider = output.provider
            self.sourceIdentity = output.sourceIdentity
            self.subjectFromWebIdentityToken = output.subjectFromWebIdentityToken
        } else {
            self.assumedRoleUser = nil
            self.audience = nil
            self.credentials = nil
            self.packedPolicySize = nil
            self.provider = nil
            self.sourceIdentity = nil
            self.subjectFromWebIdentityToken = nil
        }
    }
}

/// <p>Contains the response to a successful <a>AssumeRoleWithWebIdentity</a>
///       request, including temporary AWS credentials that can be used to make AWS requests. </p>
public struct AssumeRoleWithWebIdentityOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) and the assumed role ID, which are identifiers that you
    ///          can use to refer to the resulting temporary security credentials. For example, you can
    ///          reference these credentials as a principal in a resource-based policy by using the ARN or
    ///          assumed role ID. The ARN and ID include the <code>RoleSessionName</code> that you specified
    ///          when you called <code>AssumeRole</code>. </p>
    public let assumedRoleUser: AssumedRoleUser?
    /// <p>The intended audience (also known as client ID) of the web identity token. This is
    ///          traditionally the client identifier issued to the application that requested the web
    ///          identity token.</p>
    public let audience: String?
    /// <p>The temporary security credentials, which include an access key ID, a secret access key,
    ///          and a security token.</p>
    ///          <note>
    ///             <p>The size of the security token that STS API operations return is not fixed. We
    ///         strongly recommend that you make no assumptions about the maximum size.</p>
    ///          </note>
    public let credentials: Credentials?
    /// <p>A percentage value that indicates the packed size of the session policies and session
    ///       tags combined passed in the request. The request fails if the packed size is greater than 100 percent,
    ///       which means the policies and tags exceeded the allowed space.</p>
    public let packedPolicySize: Int?
    /// <p> The issuing authority of the web identity token presented. For OpenID Connect ID
    ///          tokens, this contains the value of the <code>iss</code> field. For OAuth 2.0 access tokens,
    ///          this contains the value of the <code>ProviderId</code> parameter that was passed in the
    ///             <code>AssumeRoleWithWebIdentity</code> request.</p>
    public let provider: String?
    /// <p>The value of the source identity that is returned in the JSON web token (JWT) from the
    ///          identity provider.</p>
    ///          <p>You can require users to set a source identity value when they assume a role. You do
    ///          this by using the <code>sts:SourceIdentity</code> condition key in a role trust policy.
    ///          That way, actions that are taken with the role are associated with that user. After the
    ///          source identity is set, the value cannot be changed. It is present in the request for all
    ///          actions that are taken by the role and persists across <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_terms-and-concepts#iam-term-role-chaining">chained
    ///             role</a> sessions. You can configure your identity provider to use an attribute
    ///          associated with your users, like user name or email, as the source identity when calling
    ///             <code>AssumeRoleWithWebIdentity</code>. You do this by adding a claim to the JSON web
    ///          token. To learn more about OIDC tokens and claims, see <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-tokens-with-identity-providers.html">Using Tokens with User Pools</a> in the <i>Amazon Cognito Developer Guide</i>.
    ///          For more information about using source identity, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_control-access_monitor.html">Monitor and control
    ///             actions taken with assumed roles</a> in the
    ///          <i>IAM User Guide</i>.</p>
    ///          <p>The regex used to validate this parameter is a string of characters
    ///     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    ///     also include underscores or any of the following characters: =,.@-</p>
    public let sourceIdentity: String?
    /// <p>The unique user identifier that is returned by the identity provider. This identifier is
    ///          associated with the <code>WebIdentityToken</code> that was submitted with the
    ///             <code>AssumeRoleWithWebIdentity</code> call. The identifier is typically unique to the
    ///          user and the application that acquired the <code>WebIdentityToken</code> (pairwise
    ///          identifier). For OpenID Connect ID tokens, this field contains the value returned by the
    ///          identity provider as the token's <code>sub</code> (Subject) claim. </p>
    public let subjectFromWebIdentityToken: String?

    public init (
        assumedRoleUser: AssumedRoleUser? = nil,
        audience: String? = nil,
        credentials: Credentials? = nil,
        packedPolicySize: Int? = nil,
        provider: String? = nil,
        sourceIdentity: String? = nil,
        subjectFromWebIdentityToken: String? = nil
    )
    {
        self.assumedRoleUser = assumedRoleUser
        self.audience = audience
        self.credentials = credentials
        self.packedPolicySize = packedPolicySize
        self.provider = provider
        self.sourceIdentity = sourceIdentity
        self.subjectFromWebIdentityToken = subjectFromWebIdentityToken
    }
}

struct AssumeRoleWithWebIdentityOutputResponseBody: Equatable {
    public let credentials: Credentials?
    public let subjectFromWebIdentityToken: String?
    public let assumedRoleUser: AssumedRoleUser?
    public let packedPolicySize: Int?
    public let provider: String?
    public let audience: String?
    public let sourceIdentity: String?
}

extension AssumeRoleWithWebIdentityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assumedRoleUser = "AssumedRoleUser"
        case audience = "Audience"
        case credentials = "Credentials"
        case packedPolicySize = "PackedPolicySize"
        case provider = "Provider"
        case sourceIdentity = "SourceIdentity"
        case subjectFromWebIdentityToken = "SubjectFromWebIdentityToken"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("AssumeRoleWithWebIdentityResult"))
        let credentialsDecoded = try containerValues.decodeIfPresent(Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let subjectFromWebIdentityTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subjectFromWebIdentityToken)
        subjectFromWebIdentityToken = subjectFromWebIdentityTokenDecoded
        let assumedRoleUserDecoded = try containerValues.decodeIfPresent(AssumedRoleUser.self, forKey: .assumedRoleUser)
        assumedRoleUser = assumedRoleUserDecoded
        let packedPolicySizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .packedPolicySize)
        packedPolicySize = packedPolicySizeDecoded
        let providerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provider)
        provider = providerDecoded
        let audienceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .audience)
        audience = audienceDecoded
        let sourceIdentityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceIdentity)
        sourceIdentity = sourceIdentityDecoded
    }
}

extension AssumedRoleUser: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case assumedRoleId = "AssumedRoleId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let assumedRoleId = assumedRoleId {
            try container.encode(assumedRoleId, forKey: Key("AssumedRoleId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assumedRoleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assumedRoleId)
        assumedRoleId = assumedRoleIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension AssumedRoleUser: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssumedRoleUser(arn: \(String(describing: arn)), assumedRoleId: \(String(describing: assumedRoleId)))"}
}

/// <p>The identifiers for the temporary security credentials that the operation
///          returns.</p>
public struct AssumedRoleUser: Equatable {
    /// <p>The ARN of the temporary security credentials that are returned from the <a>AssumeRole</a> action. For more information about ARNs and how to use them in
    ///          policies, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM Identifiers</a> in the
    ///             <i>IAM User Guide</i>.</p>
    public let arn: String?
    /// <p>A unique identifier that contains the role ID and the role session name of the role that
    ///          is being assumed. The role ID is generated by AWS when the role is created.</p>
    public let assumedRoleId: String?

    public init (
        arn: String? = nil,
        assumedRoleId: String? = nil
    )
    {
        self.arn = arn
        self.assumedRoleId = assumedRoleId
    }
}

extension Credentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessKeyId = "AccessKeyId"
        case expiration = "Expiration"
        case secretAccessKey = "SecretAccessKey"
        case sessionToken = "SessionToken"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: Key("AccessKeyId"))
        }
        if let expiration = expiration {
            try container.encode(TimestampWrapper(expiration, format: .dateTime), forKey: Key("expiration"))
        }
        if let secretAccessKey = secretAccessKey {
            try container.encode(secretAccessKey, forKey: Key("SecretAccessKey"))
        }
        if let sessionToken = sessionToken {
            try container.encode(sessionToken, forKey: Key("SessionToken"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expiration)
        var expirationBuffer:Date? = nil
        if let expirationDecoded = expirationDecoded {
            expirationBuffer = try TimestampWrapperDecoder.parseDateStringValue(expirationDecoded, format: .dateTime)
        }
        expiration = expirationBuffer
    }
}

extension Credentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Credentials(accessKeyId: \(String(describing: accessKeyId)), expiration: \(String(describing: expiration)), secretAccessKey: \(String(describing: secretAccessKey)), sessionToken: \(String(describing: sessionToken)))"}
}

/// <p>AWS credentials for API authentication.</p>
public struct Credentials: Equatable {
    /// <p>The access key ID that identifies the temporary security credentials.</p>
    public let accessKeyId: String?
    /// <p>The date on which the current credentials expire.</p>
    public let expiration: Date?
    /// <p>The secret access key that can be used to sign requests.</p>
    public let secretAccessKey: String?
    /// <p>The token that users must pass to the service API to use the temporary
    ///          credentials.</p>
    public let sessionToken: String?

    public init (
        accessKeyId: String? = nil,
        expiration: Date? = nil,
        secretAccessKey: String? = nil,
        sessionToken: String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.expiration = expiration
        self.secretAccessKey = secretAccessKey
        self.sessionToken = sessionToken
    }
}

public struct DecodeAuthorizationMessageInputBodyMiddleware: Middleware {
    public let id: String = "DecodeAuthorizationMessageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DecodeAuthorizationMessageInput>,
                  next: H) -> Swift.Result<OperationOutput<DecodeAuthorizationMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DecodeAuthorizationMessageInput>
    public typealias MOutput = OperationOutput<DecodeAuthorizationMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DecodeAuthorizationMessageOutputError>
}

extension DecodeAuthorizationMessageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DecodeAuthorizationMessageInput(encodedMessage: \(String(describing: encodedMessage)))"}
}

extension DecodeAuthorizationMessageInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let encodedMessage = encodedMessage {
            try container.encode(encodedMessage, forKey: Key("EncodedMessage"))
        }
        try container.encode("DecodeAuthorizationMessage", forKey:Key("Action"))
        try container.encode("2011-06-15", forKey:Key("Version"))
    }
}

public struct DecodeAuthorizationMessageInputHeadersMiddleware: Middleware {
    public let id: String = "DecodeAuthorizationMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DecodeAuthorizationMessageInput>,
                  next: H) -> Swift.Result<OperationOutput<DecodeAuthorizationMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DecodeAuthorizationMessageInput>
    public typealias MOutput = OperationOutput<DecodeAuthorizationMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DecodeAuthorizationMessageOutputError>
}

public struct DecodeAuthorizationMessageInputQueryItemMiddleware: Middleware {
    public let id: String = "DecodeAuthorizationMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DecodeAuthorizationMessageInput>,
                  next: H) -> Swift.Result<OperationOutput<DecodeAuthorizationMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DecodeAuthorizationMessageInput>
    public typealias MOutput = OperationOutput<DecodeAuthorizationMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DecodeAuthorizationMessageOutputError>
}

public struct DecodeAuthorizationMessageInput: Equatable {
    /// <p>The encoded message that was returned with the response.</p>
    public let encodedMessage: String?

    public init (
        encodedMessage: String? = nil
    )
    {
        self.encodedMessage = encodedMessage
    }
}

extension DecodeAuthorizationMessageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension DecodeAuthorizationMessageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidAuthorizationMessageException" : self = .invalidAuthorizationMessageException(try InvalidAuthorizationMessageException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DecodeAuthorizationMessageOutputError: Equatable {
    case invalidAuthorizationMessageException(InvalidAuthorizationMessageException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DecodeAuthorizationMessageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DecodeAuthorizationMessageOutputResponse(decodedMessage: \(String(describing: decodedMessage)))"}
}

extension DecodeAuthorizationMessageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DecodeAuthorizationMessageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.decodedMessage = output.decodedMessage
        } else {
            self.decodedMessage = nil
        }
    }
}

/// <p>A document that contains additional information about the authorization status of a
///       request from an encoded message that is returned in response to an AWS request.</p>
public struct DecodeAuthorizationMessageOutputResponse: Equatable {
    /// <p>An XML document that contains the decoded message.</p>
    public let decodedMessage: String?

    public init (
        decodedMessage: String? = nil
    )
    {
        self.decodedMessage = decodedMessage
    }
}

struct DecodeAuthorizationMessageOutputResponseBody: Equatable {
    public let decodedMessage: String?
}

extension DecodeAuthorizationMessageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case decodedMessage = "DecodedMessage"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("DecodeAuthorizationMessageResult"))
        let decodedMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .decodedMessage)
        decodedMessage = decodedMessageDecoded
    }
}

extension ExpiredTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExpiredTokenException(message: \(String(describing: message)))"}
}

extension ExpiredTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<ExpiredTokenExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The web identity token that was passed is expired or is not valid. Get a new identity
///             token from the identity provider and then retry the request.</p>
public struct ExpiredTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ExpiredTokenExceptionBody: Equatable {
    public let message: String?
}

extension ExpiredTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FederatedUser: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case federatedUserId = "FederatedUserId"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("Arn"))
        }
        if let federatedUserId = federatedUserId {
            try container.encode(federatedUserId, forKey: Key("FederatedUserId"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let federatedUserIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .federatedUserId)
        federatedUserId = federatedUserIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension FederatedUser: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FederatedUser(arn: \(String(describing: arn)), federatedUserId: \(String(describing: federatedUserId)))"}
}

/// <p>Identifiers for the federated user that is associated with the credentials.</p>
public struct FederatedUser: Equatable {
    /// <p>The ARN that specifies the federated user that is associated with the credentials. For
    ///          more information about ARNs and how to use them in policies, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM
    ///             Identifiers</a> in the <i>IAM User Guide</i>. </p>
    public let arn: String?
    /// <p>The string that identifies the federated user associated with the credentials, similar
    ///          to the unique ID of an IAM user.</p>
    public let federatedUserId: String?

    public init (
        arn: String? = nil,
        federatedUserId: String? = nil
    )
    {
        self.arn = arn
        self.federatedUserId = federatedUserId
    }
}

public struct GetAccessKeyInfoInputBodyMiddleware: Middleware {
    public let id: String = "GetAccessKeyInfoInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessKeyInfoInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessKeyInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessKeyInfoInput>
    public typealias MOutput = OperationOutput<GetAccessKeyInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessKeyInfoOutputError>
}

extension GetAccessKeyInfoInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessKeyInfoInput(accessKeyId: \(String(describing: accessKeyId)))"}
}

extension GetAccessKeyInfoInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let accessKeyId = accessKeyId {
            try container.encode(accessKeyId, forKey: Key("AccessKeyId"))
        }
        try container.encode("GetAccessKeyInfo", forKey:Key("Action"))
        try container.encode("2011-06-15", forKey:Key("Version"))
    }
}

public struct GetAccessKeyInfoInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccessKeyInfoInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessKeyInfoInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessKeyInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessKeyInfoInput>
    public typealias MOutput = OperationOutput<GetAccessKeyInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessKeyInfoOutputError>
}

public struct GetAccessKeyInfoInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccessKeyInfoInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccessKeyInfoInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccessKeyInfoOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccessKeyInfoInput>
    public typealias MOutput = OperationOutput<GetAccessKeyInfoOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccessKeyInfoOutputError>
}

public struct GetAccessKeyInfoInput: Equatable {
    /// <p>The identifier of an access key.</p>
    ///         <p>This parameter allows (through its regex pattern) a string of characters that can
    ///             consist of any upper- or lowercase letter or digit.</p>
    public let accessKeyId: String?

    public init (
        accessKeyId: String? = nil
    )
    {
        self.accessKeyId = accessKeyId
    }
}

extension GetAccessKeyInfoOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetAccessKeyInfoOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccessKeyInfoOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccessKeyInfoOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccessKeyInfoOutputResponse(account: \(String(describing: account)))"}
}

extension GetAccessKeyInfoOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccessKeyInfoOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.account = output.account
        } else {
            self.account = nil
        }
    }
}

public struct GetAccessKeyInfoOutputResponse: Equatable {
    /// <p>The number used to identify the AWS account.</p>
    public let account: String?

    public init (
        account: String? = nil
    )
    {
        self.account = account
    }
}

struct GetAccessKeyInfoOutputResponseBody: Equatable {
    public let account: String?
}

extension GetAccessKeyInfoOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case account = "Account"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetAccessKeyInfoResult"))
        let accountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .account)
        account = accountDecoded
    }
}

public struct GetCallerIdentityInputBodyMiddleware: Middleware {
    public let id: String = "GetCallerIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCallerIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCallerIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCallerIdentityInput>
    public typealias MOutput = OperationOutput<GetCallerIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCallerIdentityOutputError>
}

extension GetCallerIdentityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCallerIdentityInput()"}
}

extension GetCallerIdentityInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        try container.encode("GetCallerIdentity", forKey:Key("Action"))
        try container.encode("2011-06-15", forKey:Key("Version"))
    }
}

public struct GetCallerIdentityInputHeadersMiddleware: Middleware {
    public let id: String = "GetCallerIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCallerIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCallerIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCallerIdentityInput>
    public typealias MOutput = OperationOutput<GetCallerIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCallerIdentityOutputError>
}

public struct GetCallerIdentityInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCallerIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCallerIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCallerIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCallerIdentityInput>
    public typealias MOutput = OperationOutput<GetCallerIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCallerIdentityOutputError>
}

public struct GetCallerIdentityInput: Equatable {

    public init() {}
}

extension GetCallerIdentityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetCallerIdentityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCallerIdentityOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCallerIdentityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCallerIdentityOutputResponse(account: \(String(describing: account)), arn: \(String(describing: arn)), userId: \(String(describing: userId)))"}
}

extension GetCallerIdentityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCallerIdentityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.account = output.account
            self.arn = output.arn
            self.userId = output.userId
        } else {
            self.account = nil
            self.arn = nil
            self.userId = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetCallerIdentity</a> request,
///          including information about the entity making the request.</p>
public struct GetCallerIdentityOutputResponse: Equatable {
    /// <p>The AWS account ID number of the account that owns or contains the calling
    ///          entity.</p>
    public let account: String?
    /// <p>The AWS ARN associated with the calling entity.</p>
    public let arn: String?
    /// <p>The unique identifier of the calling entity. The exact value depends on the type of
    ///          entity that is making the call. The values returned are those listed in the <b>aws:userid</b> column in the <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_variables.html#principaltable">Principal
    ///             table</a> found on the <b>Policy Variables</b> reference
    ///          page in the <i>IAM User Guide</i>.</p>
    public let userId: String?

    public init (
        account: String? = nil,
        arn: String? = nil,
        userId: String? = nil
    )
    {
        self.account = account
        self.arn = arn
        self.userId = userId
    }
}

struct GetCallerIdentityOutputResponseBody: Equatable {
    public let userId: String?
    public let account: String?
    public let arn: String?
}

extension GetCallerIdentityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case account = "Account"
        case arn = "Arn"
        case userId = "UserId"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetCallerIdentityResult"))
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
        let accountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .account)
        account = accountDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct GetFederationTokenInputBodyMiddleware: Middleware {
    public let id: String = "GetFederationTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFederationTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFederationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFederationTokenInput>
    public typealias MOutput = OperationOutput<GetFederationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFederationTokenOutputError>
}

extension GetFederationTokenInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFederationTokenInput(durationSeconds: \(String(describing: durationSeconds)), name: \(String(describing: name)), policy: \(String(describing: policy)), policyArns: \(String(describing: policyArns)), tags: \(String(describing: tags)))"}
}

extension GetFederationTokenInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let durationSeconds = durationSeconds {
            try container.encode(durationSeconds, forKey: Key("DurationSeconds"))
        }
        if let name = name {
            try container.encode(name, forKey: Key("Name"))
        }
        if let policy = policy {
            try container.encode(policy, forKey: Key("Policy"))
        }
        if let policyArns = policyArns {
            var policyArnsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("PolicyArns"))
            for (index0, policydescriptortype0) in policyArns.enumerated() {
                try policyArnsContainer.encode(policydescriptortype0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        if let tags = tags {
            var tagsContainer = container.nestedContainer(keyedBy: Key.self, forKey: Key("Tags"))
            for (index0, tag0) in tags.enumerated() {
                try tagsContainer.encode(tag0, forKey: Key("member.\(index0.advanced(by: 1))"))
            }
        }
        try container.encode("GetFederationToken", forKey:Key("Action"))
        try container.encode("2011-06-15", forKey:Key("Version"))
    }
}

public struct GetFederationTokenInputHeadersMiddleware: Middleware {
    public let id: String = "GetFederationTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFederationTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFederationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFederationTokenInput>
    public typealias MOutput = OperationOutput<GetFederationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFederationTokenOutputError>
}

public struct GetFederationTokenInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFederationTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFederationTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFederationTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFederationTokenInput>
    public typealias MOutput = OperationOutput<GetFederationTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFederationTokenOutputError>
}

public struct GetFederationTokenInput: Equatable {
    /// <p>The duration, in seconds, that the session should last. Acceptable durations for
    ///          federation sessions range from 900 seconds (15 minutes) to 129,600 seconds (36 hours), with
    ///          43,200 seconds (12 hours) as the default. Sessions obtained using AWS account root user
    ///          credentials are restricted to a maximum of 3,600 seconds (one hour). If the specified
    ///          duration is longer than one hour, the session obtained by using root user credentials
    ///          defaults to one hour.</p>
    public let durationSeconds: Int?
    /// <p>The name of the federated user. The name is used as an identifier for the temporary
    ///          security credentials (such as <code>Bob</code>). For example, you can reference the
    ///          federated user name in a resource-based policy, such as in an Amazon S3 bucket policy.</p>
    ///          <p>The regex used to validate this parameter is a string of characters
    ///     consisting of upper- and lower-case alphanumeric characters with no spaces. You can
    ///     also include underscores or any of the following characters: =,.@-</p>
    public let name: String?
    /// <p>An IAM policy in JSON format that you want to use as an inline session policy.</p>
    ///          <p>You must pass an inline or managed <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">session policy</a> to
    ///          this operation. You can pass a single JSON policy document to use as an inline session
    ///          policy. You can also specify up to 10 managed policies to use as managed session
    ///          policies.</p>
    ///          <p>This parameter is optional. However, if you do not pass any session policies, then the
    ///          resulting federated user session has no permissions.</p>
    ///          <p>When you pass session policies, the session permissions are the intersection of the
    ///          IAM user policies and the session policies that you pass. This gives you a way to further
    ///          restrict the permissions for a federated user. You cannot use session policies to grant
    ///          more permissions than those that are defined in the permissions policy of the IAM user.
    ///          For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session Policies</a> in
    ///          the <i>IAM User Guide</i>.</p>
    ///          <p>The resulting credentials can be used to access a resource that has a resource-based
    ///          policy. If that policy specifically references the federated user session in the
    ///             <code>Principal</code> element of the policy, the session has the permissions allowed by
    ///          the policy. These permissions are granted in addition to the permissions that are granted
    ///          by the session policies.</p>
    ///          <p>The plaintext that you use for both inline and managed session policies can't exceed
    ///          2,048 characters. The JSON policy characters can be any ASCII character from the space
    ///          character to the end of the valid character list (\u0020 through \u00FF). It can also
    ///          include the tab (\u0009), linefeed (\u000A), and carriage return (\u000D)
    ///          characters.</p>
    ///          <note>
    ///             <p>An AWS conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///             </p>
    ///          </note>
    public let policy: String?
    /// <p>The Amazon Resource Names (ARNs) of the IAM managed policies that you want to use as a
    ///          managed session policy. The policies must exist in the same account as the IAM user that
    ///          is requesting federated access.</p>
    ///          <p>You must pass an inline or managed <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">session policy</a> to
    ///          this operation. You can pass a single JSON policy document to use as an inline session
    ///          policy. You can also specify up to 10 managed policies to use as managed session policies.
    ///          The plaintext that you use for both inline and managed session policies can't exceed 2,048
    ///          characters. You can provide up to 10 managed policy ARNs. For more information about ARNs,
    ///          see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon
    ///             Resource Names (ARNs) and AWS Service Namespaces</a> in the AWS General Reference.</p>
    ///          <p>This parameter is optional. However, if you do not pass any session policies, then the
    ///          resulting federated user session has no permissions.</p>
    ///          <p>When you pass session policies, the session permissions are the intersection of the
    ///          IAM user policies and the session policies that you pass. This gives you a way to further
    ///          restrict the permissions for a federated user. You cannot use session policies to grant
    ///          more permissions than those that are defined in the permissions policy of the IAM user.
    ///          For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html#policies_session">Session Policies</a> in
    ///          the <i>IAM User Guide</i>.</p>
    ///          <p>The resulting credentials can be used to access a resource that has a resource-based
    ///          policy. If that policy specifically references the federated user session in the
    ///             <code>Principal</code> element of the policy, the session has the permissions allowed by
    ///          the policy. These permissions are granted in addition to the permissions that are granted
    ///          by the session policies.</p>
    ///          <note>
    ///             <p>An AWS conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///             </p>
    ///          </note>
    public let policyArns: [PolicyDescriptorType]?
    /// <p>A list of session tags. Each session tag consists of a key name and an associated value.
    ///          For more information about session tags, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Passing Session Tags in STS</a> in the
    ///             <i>IAM User Guide</i>.</p>
    ///          <p>This parameter is optional. You can pass up to 50 session tags. The plaintext session
    ///          tag keys can’t exceed 128 characters and the values can’t exceed 256 characters. For these
    ///          and additional limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-limits.html#reference_iam-limits-entity-length">IAM
    ///             and STS Character Limits</a> in the <i>IAM User Guide</i>.</p>
    ///
    ///          <note>
    ///             <p>An AWS conversion compresses the passed session policies and session tags into a
    ///             packed binary format that has a separate limit. Your request can fail for this limit
    ///             even if your plaintext meets the other requirements. The <code>PackedPolicySize</code>
    ///             response element indicates by percentage how close the policies and tags for your
    ///             request are to the upper size limit.
    ///             </p>
    ///          </note>
    ///          <p>You can pass a session tag with the same key as a tag that is already
    ///          attached to the user you are federating. When you do, session tags override a user tag with
    ///          the same key. </p>
    ///          <p>Tag key–value pairs are not case sensitive, but case is preserved. This means that you
    ///          cannot have separate <code>Department</code> and <code>department</code> tag keys. Assume
    ///          that the role has the <code>Department</code>=<code>Marketing</code> tag and you pass the
    ///             <code>department</code>=<code>engineering</code> session tag. <code>Department</code>
    ///          and <code>department</code> are not saved as separate tags, and the session tag passed in
    ///          the request takes precedence over the role tag.</p>
    public let tags: [Tag]?

    public init (
        durationSeconds: Int? = nil,
        name: String? = nil,
        policy: String? = nil,
        policyArns: [PolicyDescriptorType]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.name = name
        self.policy = policy
        self.policyArns = policyArns
        self.tags = tags
    }
}

extension GetFederationTokenOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetFederationTokenOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "MalformedPolicyDocumentException" : self = .malformedPolicyDocumentException(try MalformedPolicyDocumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PackedPolicyTooLargeException" : self = .packedPolicyTooLargeException(try PackedPolicyTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RegionDisabledException" : self = .regionDisabledException(try RegionDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFederationTokenOutputError: Equatable {
    case malformedPolicyDocumentException(MalformedPolicyDocumentException)
    case packedPolicyTooLargeException(PackedPolicyTooLargeException)
    case regionDisabledException(RegionDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFederationTokenOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFederationTokenOutputResponse(credentials: \(String(describing: credentials)), federatedUser: \(String(describing: federatedUser)), packedPolicySize: \(String(describing: packedPolicySize)))"}
}

extension GetFederationTokenOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFederationTokenOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.credentials = output.credentials
            self.federatedUser = output.federatedUser
            self.packedPolicySize = output.packedPolicySize
        } else {
            self.credentials = nil
            self.federatedUser = nil
            self.packedPolicySize = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetFederationToken</a> request,
///       including temporary AWS credentials that can be used to make AWS requests. </p>
public struct GetFederationTokenOutputResponse: Equatable {
    /// <p>The temporary security credentials, which include an access key ID, a secret access key,
    ///          and a security (or session) token.</p>
    ///          <note>
    ///             <p>The size of the security token that STS API operations return is not fixed. We
    ///         strongly recommend that you make no assumptions about the maximum size.</p>
    ///          </note>
    public let credentials: Credentials?
    /// <p>Identifiers for the federated user associated with the credentials (such as
    ///             <code>arn:aws:sts::123456789012:federated-user/Bob</code> or
    ///             <code>123456789012:Bob</code>). You can use the federated user's ARN in your
    ///          resource-based policies, such as an Amazon S3 bucket policy. </p>
    public let federatedUser: FederatedUser?
    /// <p>A percentage value that indicates the packed size of the session policies and session
    ///       tags combined passed in the request. The request fails if the packed size is greater than 100 percent,
    ///       which means the policies and tags exceeded the allowed space.</p>
    public let packedPolicySize: Int?

    public init (
        credentials: Credentials? = nil,
        federatedUser: FederatedUser? = nil,
        packedPolicySize: Int? = nil
    )
    {
        self.credentials = credentials
        self.federatedUser = federatedUser
        self.packedPolicySize = packedPolicySize
    }
}

struct GetFederationTokenOutputResponseBody: Equatable {
    public let credentials: Credentials?
    public let federatedUser: FederatedUser?
    public let packedPolicySize: Int?
}

extension GetFederationTokenOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case credentials = "Credentials"
        case federatedUser = "FederatedUser"
        case packedPolicySize = "PackedPolicySize"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetFederationTokenResult"))
        let credentialsDecoded = try containerValues.decodeIfPresent(Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let federatedUserDecoded = try containerValues.decodeIfPresent(FederatedUser.self, forKey: .federatedUser)
        federatedUser = federatedUserDecoded
        let packedPolicySizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .packedPolicySize)
        packedPolicySize = packedPolicySizeDecoded
    }
}

public struct GetSessionTokenInputBodyMiddleware: Middleware {
    public let id: String = "GetSessionTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSessionTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSessionTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            let encoder = context.getEncoder()
            let data = try encoder.encode(input.operationInput)
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSessionTokenInput>
    public typealias MOutput = OperationOutput<GetSessionTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSessionTokenOutputError>
}

extension GetSessionTokenInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSessionTokenInput(durationSeconds: \(String(describing: durationSeconds)), serialNumber: \(String(describing: serialNumber)), tokenCode: \(String(describing: tokenCode)))"}
}

extension GetSessionTokenInput: Encodable, Reflection {
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let durationSeconds = durationSeconds {
            try container.encode(durationSeconds, forKey: Key("DurationSeconds"))
        }
        if let serialNumber = serialNumber {
            try container.encode(serialNumber, forKey: Key("SerialNumber"))
        }
        if let tokenCode = tokenCode {
            try container.encode(tokenCode, forKey: Key("TokenCode"))
        }
        try container.encode("GetSessionToken", forKey:Key("Action"))
        try container.encode("2011-06-15", forKey:Key("Version"))
    }
}

public struct GetSessionTokenInputHeadersMiddleware: Middleware {
    public let id: String = "GetSessionTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSessionTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSessionTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSessionTokenInput>
    public typealias MOutput = OperationOutput<GetSessionTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSessionTokenOutputError>
}

public struct GetSessionTokenInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSessionTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSessionTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSessionTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSessionTokenInput>
    public typealias MOutput = OperationOutput<GetSessionTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSessionTokenOutputError>
}

public struct GetSessionTokenInput: Equatable {
    /// <p>The duration, in seconds, that the credentials should remain valid. Acceptable
    ///             durations for IAM user sessions range from 900 seconds (15 minutes) to 129,600 seconds
    ///             (36 hours), with 43,200 seconds (12 hours) as the default. Sessions for AWS account
    ///             owners are restricted to a maximum of 3,600 seconds (one hour). If the duration is
    ///             longer than one hour, the session for AWS account owners defaults to one hour.</p>
    public let durationSeconds: Int?
    /// <p>The identification number of the MFA device that is associated with the IAM user who
    ///             is making the <code>GetSessionToken</code> call. Specify this value if the IAM user
    ///             has a policy that requires MFA authentication. The value is either the serial number for
    ///             a hardware device (such as <code>GAHT12345678</code>) or an Amazon Resource Name (ARN)
    ///             for a virtual device (such as <code>arn:aws:iam::123456789012:mfa/user</code>). You can
    ///             find the device for an IAM user by going to the AWS Management Console and viewing the user's
    ///             security credentials. </p>
    ///         <p>The regex used to validate this parameter is a string of
    ///     characters consisting of upper- and lower-case alphanumeric characters with no spaces.
    ///     You can also include underscores or any of the following characters: =,.@:/-</p>
    public let serialNumber: String?
    /// <p>The value provided by the MFA device, if MFA is required. If any policy requires the
    ///             IAM user to submit an MFA code, specify this value. If MFA authentication is required,
    ///             the user must provide a code when requesting a set of temporary security credentials. A
    ///             user who fails to provide the code receives an "access denied" response when requesting
    ///             resources that require MFA authentication.</p>
    ///         <p>The format for this parameter, as described by its regex pattern, is a sequence of six
    ///             numeric digits.</p>
    public let tokenCode: String?

    public init (
        durationSeconds: Int? = nil,
        serialNumber: String? = nil,
        tokenCode: String? = nil
    )
    {
        self.durationSeconds = durationSeconds
        self.serialNumber = serialNumber
        self.tokenCode = tokenCode
    }
}

extension GetSessionTokenOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestXMLError(httpResponse: httpResponse)
        try self.init(errorType: errorDetails.errorCode, httpResponse: httpResponse, decoder: decoder, message: errorDetails.message, requestID: errorDetails.requestId)
    }
}

extension GetSessionTokenOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "RegionDisabledException" : self = .regionDisabledException(try RegionDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSessionTokenOutputError: Equatable {
    case regionDisabledException(RegionDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSessionTokenOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSessionTokenOutputResponse(credentials: \(String(describing: credentials)))"}
}

extension GetSessionTokenOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSessionTokenOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.credentials = output.credentials
        } else {
            self.credentials = nil
        }
    }
}

/// <p>Contains the response to a successful <a>GetSessionToken</a> request,
///       including temporary AWS credentials that can be used to make AWS requests. </p>
public struct GetSessionTokenOutputResponse: Equatable {
    /// <p>The temporary security credentials, which include an access key ID, a secret access
    ///             key, and a security (or session) token.</p>
    ///
    ///          <note>
    ///             <p>The size of the security token that STS API operations return is not fixed. We
    ///         strongly recommend that you make no assumptions about the maximum size.</p>
    ///          </note>
    public let credentials: Credentials?

    public init (
        credentials: Credentials? = nil
    )
    {
        self.credentials = credentials
    }
}

struct GetSessionTokenOutputResponseBody: Equatable {
    public let credentials: Credentials?
}

extension GetSessionTokenOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case credentials = "Credentials"
    }

    public init (from decoder: Decoder) throws {
        let topLevelContainer = try decoder.container(keyedBy: Key.self)
        let containerValues = try topLevelContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: Key("GetSessionTokenResult"))
        let credentialsDecoded = try containerValues.decodeIfPresent(Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
    }
}

extension IDPCommunicationErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IDPCommunicationErrorException(message: \(String(describing: message)))"}
}

extension IDPCommunicationErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<IDPCommunicationErrorExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request could not be fulfilled because the identity provider (IDP) that
///             was asked to verify the incoming identity token could not be reached. This is often a
///             transient error caused by network conditions. Retry the request a limited number of
///             times so that you don't exceed the request rate. If the error persists, the
///             identity provider might be down or not responding.</p>
public struct IDPCommunicationErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IDPCommunicationErrorExceptionBody: Equatable {
    public let message: String?
}

extension IDPCommunicationErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IDPRejectedClaimException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IDPRejectedClaimException(message: \(String(describing: message)))"}
}

extension IDPRejectedClaimException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<IDPRejectedClaimExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The identity provider (IdP) reported that authentication failed. This might be because
///             the claim is invalid.</p>
///         <p>If this error is returned for the <code>AssumeRoleWithWebIdentity</code> operation, it
///             can also mean that the claim has expired or has been explicitly revoked. </p>
public struct IDPRejectedClaimException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IDPRejectedClaimExceptionBody: Equatable {
    public let message: String?
}

extension IDPRejectedClaimExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidAuthorizationMessageException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidAuthorizationMessageException(message: \(String(describing: message)))"}
}

extension InvalidAuthorizationMessageException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidAuthorizationMessageExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The error returned if the message passed to <code>DecodeAuthorizationMessage</code>
///             was invalid. This can happen if the token contains invalid characters, such as
///             linebreaks. </p>
public struct InvalidAuthorizationMessageException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidAuthorizationMessageExceptionBody: Equatable {
    public let message: String?
}

extension InvalidAuthorizationMessageExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidIdentityTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidIdentityTokenException(message: \(String(describing: message)))"}
}

extension InvalidIdentityTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<InvalidIdentityTokenExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The web identity token that was passed could not be validated by AWS. Get a new
///             identity token from the identity provider and then retry the request.</p>
public struct InvalidIdentityTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidIdentityTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidIdentityTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MalformedPolicyDocumentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MalformedPolicyDocumentException(message: \(String(describing: message)))"}
}

extension MalformedPolicyDocumentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<MalformedPolicyDocumentExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the policy document was malformed. The error message
///             describes the specific error.</p>
public struct MalformedPolicyDocumentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct MalformedPolicyDocumentExceptionBody: Equatable {
    public let message: String?
}

extension MalformedPolicyDocumentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PackedPolicyTooLargeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PackedPolicyTooLargeException(message: \(String(describing: message)))"}
}

extension PackedPolicyTooLargeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<PackedPolicyTooLargeExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because the total packed size of the session policies and
///             session tags combined was too large. An AWS conversion compresses the session policy
///             document, session policy ARNs, and session tags into a packed binary format that has a
///             separate limit. The error message indicates by percentage how close the policies and
///             tags are to the upper size limit. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Passing Session Tags in STS</a> in
///             the <i>IAM User Guide</i>.</p>
///         <p>You could receive this error even though you meet other defined session policy and
///             session tag limits. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">IAM and STS Entity
///                 Character Limits</a> in the <i>IAM User Guide</i>.</p>
public struct PackedPolicyTooLargeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PackedPolicyTooLargeExceptionBody: Equatable {
    public let message: String?
}

extension PackedPolicyTooLargeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PolicyDescriptorType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let arn = arn {
            try container.encode(arn, forKey: Key("arn"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension PolicyDescriptorType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyDescriptorType(arn: \(String(describing: arn)))"}
}

/// <p>A reference to the IAM managed policy that is passed as a session policy for a role
///          session or a federated user session.</p>
public struct PolicyDescriptorType: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the IAM managed policy to use as a session policy
    ///          for the role. For more information about ARNs, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">Amazon Resource Names (ARNs) and AWS
    ///             Service Namespaces</a> in the <i>AWS General Reference</i>.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

extension RegionDisabledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegionDisabledException(message: \(String(describing: message)))"}
}

extension RegionDisabledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ErrorResponseContainer<RegionDisabledExceptionBody> = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.error.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>STS is not activated in the requested region for the account that is being asked to
///             generate credentials. The account administrator must use the IAM console to activate STS
///             in that region. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_enable-regions.html">Activating and
///                 Deactivating AWS STS in an AWS Region</a> in the <i>IAM User
///                     Guide</i>.</p>
public struct RegionDisabledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RegionDisabledExceptionBody: Equatable {
    public let message: String?
}

extension RegionDisabledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: Key.self)
        if let key = key {
            try container.encode(key, forKey: Key("Key"))
        }
        if let value = value {
            try container.encode(value, forKey: Key("Value"))
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>You can pass custom key-value pair attributes when you assume a role or federate a user.
///          These are called session tags. You can then use the session tags to control access to
///          resources. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_session-tags.html">Tagging AWS STS Sessions</a> in the
///             <i>IAM User Guide</i>.</p>
public struct Tag: Equatable {
    /// <p>The key for a session tag.</p>
    ///          <p>You can pass up to 50 session tags. The plain text session tag keys can’t exceed 128
    ///          characters. For these and additional limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-limits.html#reference_iam-limits-entity-length">IAM
    ///             and STS Character Limits</a> in the <i>IAM User Guide</i>.</p>
    public let key: String?
    /// <p>The value for a session tag.</p>
    ///          <p>You can pass up to 50 session tags. The plain text session tag values can’t exceed 256
    ///          characters. For these and additional limits, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-limits.html#reference_iam-limits-entity-length">IAM
    ///             and STS Character Limits</a> in the <i>IAM User Guide</i>.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}
