// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct ActivateEventSourceInputBodyMiddleware: Middleware {
    public let id: String = "ActivateEventSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ActivateEventSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ActivateEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ActivateEventSourceInput>
    public typealias MOutput = OperationOutput<ActivateEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ActivateEventSourceOutputError>
}

extension ActivateEventSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivateEventSourceInput(name: \(String(describing: name)))"}
}

extension ActivateEventSourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct ActivateEventSourceInputHeadersMiddleware: Middleware {
    public let id: String = "ActivateEventSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ActivateEventSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ActivateEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ActivateEventSourceInput>
    public typealias MOutput = OperationOutput<ActivateEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ActivateEventSourceOutputError>
}

public struct ActivateEventSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ActivateEventSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ActivateEventSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ActivateEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ActivateEventSourceInput>
    public typealias MOutput = OperationOutput<ActivateEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ActivateEventSourceOutputError>
}

public struct ActivateEventSourceInput: Equatable {
    /// <p>The name of the partner event source to activate.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct ActivateEventSourceInputBody: Equatable {
    public let name: String?
}

extension ActivateEventSourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ActivateEventSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ActivateEventSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ActivateEventSourceOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case invalidStateException(InvalidStateException)
    case operationDisabledException(OperationDisabledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ActivateEventSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivateEventSourceOutputResponse()"}
}

extension ActivateEventSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ActivateEventSourceOutputResponse: Equatable {

    public init() {}
}

struct ActivateEventSourceOutputResponseBody: Equatable {
}

extension ActivateEventSourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ApiDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiDestinationArn = "ApiDestinationArn"
        case apiDestinationState = "ApiDestinationState"
        case connectionArn = "ConnectionArn"
        case creationTime = "CreationTime"
        case httpMethod = "HttpMethod"
        case invocationEndpoint = "InvocationEndpoint"
        case invocationRateLimitPerSecond = "InvocationRateLimitPerSecond"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiDestinationArn = apiDestinationArn {
            try encodeContainer.encode(apiDestinationArn, forKey: .apiDestinationArn)
        }
        if let apiDestinationState = apiDestinationState {
            try encodeContainer.encode(apiDestinationState.rawValue, forKey: .apiDestinationState)
        }
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let httpMethod = httpMethod {
            try encodeContainer.encode(httpMethod.rawValue, forKey: .httpMethod)
        }
        if let invocationEndpoint = invocationEndpoint {
            try encodeContainer.encode(invocationEndpoint, forKey: .invocationEndpoint)
        }
        if let invocationRateLimitPerSecond = invocationRateLimitPerSecond {
            try encodeContainer.encode(invocationRateLimitPerSecond, forKey: .invocationRateLimitPerSecond)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDestinationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiDestinationArn)
        apiDestinationArn = apiDestinationArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let apiDestinationStateDecoded = try containerValues.decodeIfPresent(ApiDestinationState.self, forKey: .apiDestinationState)
        apiDestinationState = apiDestinationStateDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let invocationEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invocationEndpoint)
        invocationEndpoint = invocationEndpointDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(ApiDestinationHttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let invocationRateLimitPerSecondDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .invocationRateLimitPerSecond)
        invocationRateLimitPerSecond = invocationRateLimitPerSecondDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension ApiDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApiDestination(apiDestinationArn: \(String(describing: apiDestinationArn)), apiDestinationState: \(String(describing: apiDestinationState)), connectionArn: \(String(describing: connectionArn)), creationTime: \(String(describing: creationTime)), httpMethod: \(String(describing: httpMethod)), invocationEndpoint: \(String(describing: invocationEndpoint)), invocationRateLimitPerSecond: \(String(describing: invocationRateLimitPerSecond)), lastModifiedTime: \(String(describing: lastModifiedTime)), name: \(String(describing: name)))"}
}

/// <p>Contains details about an API destination.</p>
public struct ApiDestination: Equatable {
    /// <p>The ARN of the API destination.</p>
    public let apiDestinationArn: String?
    /// <p>The state of the API destination.</p>
    public let apiDestinationState: ApiDestinationState?
    /// <p>The ARN of the connection specified for the API destination.</p>
    public let connectionArn: String?
    /// <p>A time stamp for the time that the API destination was created.</p>
    public let creationTime: Date?
    /// <p>The method to use to connect to the HTTP endpoint.</p>
    public let httpMethod: ApiDestinationHttpMethod?
    /// <p>The URL to the endpoint for the API destination.</p>
    public let invocationEndpoint: String?
    /// <p>The maximum number of invocations per second to send to the HTTP endpoint.</p>
    public let invocationRateLimitPerSecond: Int?
    /// <p>A time stamp for the time that the API destination was last modified.</p>
    public let lastModifiedTime: Date?
    /// <p>The name of the API destination.</p>
    public let name: String?

    public init (
        apiDestinationArn: String? = nil,
        apiDestinationState: ApiDestinationState? = nil,
        connectionArn: String? = nil,
        creationTime: Date? = nil,
        httpMethod: ApiDestinationHttpMethod? = nil,
        invocationEndpoint: String? = nil,
        invocationRateLimitPerSecond: Int? = nil,
        lastModifiedTime: Date? = nil,
        name: String? = nil
    )
    {
        self.apiDestinationArn = apiDestinationArn
        self.apiDestinationState = apiDestinationState
        self.connectionArn = connectionArn
        self.creationTime = creationTime
        self.httpMethod = httpMethod
        self.invocationEndpoint = invocationEndpoint
        self.invocationRateLimitPerSecond = invocationRateLimitPerSecond
        self.lastModifiedTime = lastModifiedTime
        self.name = name
    }
}

public enum ApiDestinationHttpMethod {
    case delete
    case `get`
    case head
    case options
    case patch
    case post
    case put
    case sdkUnknown(String)
}

extension ApiDestinationHttpMethod : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ApiDestinationHttpMethod] {
        return [
            .delete,
            .get,
            .head,
            .options,
            .patch,
            .post,
            .put,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .delete: return "DELETE"
        case .get: return "GET"
        case .head: return "HEAD"
        case .options: return "OPTIONS"
        case .patch: return "PATCH"
        case .post: return "POST"
        case .put: return "PUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ApiDestinationHttpMethod(rawValue: rawValue) ?? ApiDestinationHttpMethod.sdkUnknown(rawValue)
    }
}

public enum ApiDestinationState {
    case active
    case inactive
    case sdkUnknown(String)
}

extension ApiDestinationState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ApiDestinationState] {
        return [
            .active,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ApiDestinationState(rawValue: rawValue) ?? ApiDestinationState.sdkUnknown(rawValue)
    }
}

extension Archive: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case archiveName = "ArchiveName"
        case creationTime = "CreationTime"
        case eventCount = "EventCount"
        case eventSourceArn = "EventSourceArn"
        case retentionDays = "RetentionDays"
        case sizeBytes = "SizeBytes"
        case state = "State"
        case stateReason = "StateReason"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveName = archiveName {
            try encodeContainer.encode(archiveName, forKey: .archiveName)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if eventCount != 0 {
            try encodeContainer.encode(eventCount, forKey: .eventCount)
        }
        if let eventSourceArn = eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let retentionDays = retentionDays {
            try encodeContainer.encode(retentionDays, forKey: .retentionDays)
        }
        if sizeBytes != 0 {
            try encodeContainer.encode(sizeBytes, forKey: .sizeBytes)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .archiveName)
        archiveName = archiveNameDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ArchiveState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let retentionDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .retentionDays)
        retentionDays = retentionDaysDecoded
        let sizeBytesDecoded = try containerValues.decode(Int.self, forKey: .sizeBytes)
        sizeBytes = sizeBytesDecoded
        let eventCountDecoded = try containerValues.decode(Int.self, forKey: .eventCount)
        eventCount = eventCountDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension Archive: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Archive(archiveName: \(String(describing: archiveName)), creationTime: \(String(describing: creationTime)), eventCount: \(String(describing: eventCount)), eventSourceArn: \(String(describing: eventSourceArn)), retentionDays: \(String(describing: retentionDays)), sizeBytes: \(String(describing: sizeBytes)), state: \(String(describing: state)), stateReason: \(String(describing: stateReason)))"}
}

/// <p>An <code>Archive</code> object that contains details about an archive.</p>
public struct Archive: Equatable {
    /// <p>The name of the archive.</p>
    public let archiveName: String?
    /// <p>The time stamp for the time that the archive was created.</p>
    public let creationTime: Date?
    /// <p>The number of events in the archive.</p>
    public let eventCount: Int
    /// <p>The ARN of the event bus associated with the archive. Only events from this event bus are
    ///       sent to the archive.</p>
    public let eventSourceArn: String?
    /// <p>The number of days to retain events in the archive before they are deleted.</p>
    public let retentionDays: Int?
    /// <p>The size of the archive, in bytes.</p>
    public let sizeBytes: Int
    /// <p>The current state of the archive.</p>
    public let state: ArchiveState?
    /// <p>A description for the reason that the archive is in the current state.</p>
    public let stateReason: String?

    public init (
        archiveName: String? = nil,
        creationTime: Date? = nil,
        eventCount: Int = 0,
        eventSourceArn: String? = nil,
        retentionDays: Int? = nil,
        sizeBytes: Int = 0,
        state: ArchiveState? = nil,
        stateReason: String? = nil
    )
    {
        self.archiveName = archiveName
        self.creationTime = creationTime
        self.eventCount = eventCount
        self.eventSourceArn = eventSourceArn
        self.retentionDays = retentionDays
        self.sizeBytes = sizeBytes
        self.state = state
        self.stateReason = stateReason
    }
}

public enum ArchiveState {
    case createFailed
    case creating
    case disabled
    case enabled
    case updateFailed
    case updating
    case sdkUnknown(String)
}

extension ArchiveState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ArchiveState] {
        return [
            .createFailed,
            .creating,
            .disabled,
            .enabled,
            .updateFailed,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .createFailed: return "CREATE_FAILED"
        case .creating: return "CREATING"
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case .updateFailed: return "UPDATE_FAILED"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ArchiveState(rawValue: rawValue) ?? ArchiveState.sdkUnknown(rawValue)
    }
}

public enum AssignPublicIp {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension AssignPublicIp : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssignPublicIp] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssignPublicIp(rawValue: rawValue) ?? AssignPublicIp.sdkUnknown(rawValue)
    }
}

extension AwsVpcConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assignPublicIp = "AssignPublicIp"
        case securityGroups = "SecurityGroups"
        case subnets = "Subnets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assignPublicIp = assignPublicIp {
            try encodeContainer.encode(assignPublicIp.rawValue, forKey: .assignPublicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for stringlist0 in securityGroups {
                try securityGroupsContainer.encode(stringlist0)
            }
        }
        if let subnets = subnets {
            var subnetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnets)
            for stringlist0 in subnets {
                try subnetsContainer.encode(stringlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnets)
        var subnetsDecoded0:[String]? = nil
        if let subnetsContainer = subnetsContainer {
            subnetsDecoded0 = [String]()
            for string0 in subnetsContainer {
                if let string0 = string0 {
                    subnetsDecoded0?.append(string0)
                }
            }
        }
        subnets = subnetsDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[String]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [String]()
            for string0 in securityGroupsContainer {
                if let string0 = string0 {
                    securityGroupsDecoded0?.append(string0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let assignPublicIpDecoded = try containerValues.decodeIfPresent(AssignPublicIp.self, forKey: .assignPublicIp)
        assignPublicIp = assignPublicIpDecoded
    }
}

extension AwsVpcConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsVpcConfiguration(assignPublicIp: \(String(describing: assignPublicIp)), securityGroups: \(String(describing: securityGroups)), subnets: \(String(describing: subnets)))"}
}

/// <p>This structure specifies the VPC subnets and security groups for the task, and whether a
///       public IP address is to be used. This structure is relevant only for ECS tasks that use the
///         <code>awsvpc</code> network mode.</p>
public struct AwsVpcConfiguration: Equatable {
    /// <p>Specifies whether the task's elastic network interface receives a public IP address. You
    ///       can specify <code>ENABLED</code> only when <code>LaunchType</code> in
    ///         <code>EcsParameters</code> is set to <code>FARGATE</code>.</p>
    public let assignPublicIp: AssignPublicIp?
    /// <p>Specifies the security groups associated with the task. These security groups must all be
    ///       in the same VPC. You can specify as many as five security groups. If you do not specify a
    ///       security group, the default security group for the VPC is used.</p>
    public let securityGroups: [String]?
    /// <p>Specifies the subnets associated with the task. These subnets must all be in the same VPC.
    ///       You can specify as many as 16 subnets.</p>
    public let subnets: [String]?

    public init (
        assignPublicIp: AssignPublicIp? = nil,
        securityGroups: [String]? = nil,
        subnets: [String]? = nil
    )
    {
        self.assignPublicIp = assignPublicIp
        self.securityGroups = securityGroups
        self.subnets = subnets
    }
}

extension BatchArrayProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case size = "Size"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sizeDecoded = try containerValues.decode(Int.self, forKey: .size)
        size = sizeDecoded
    }
}

extension BatchArrayProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchArrayProperties(size: \(String(describing: size)))"}
}

/// <p>The array properties for the submitted job, such as the size of the array. The array size
///       can be between 2 and 10,000. If you specify array properties for a job, it becomes an array
///       job. This parameter is used only if the target is an AWS Batch job.</p>
public struct BatchArrayProperties: Equatable {
    /// <p>The size of the array, if this is an array batch job. Valid values are integers between 2
    ///       and 10,000.</p>
    public let size: Int

    public init (
        size: Int = 0
    )
    {
        self.size = size
    }
}

extension BatchParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arrayProperties = "ArrayProperties"
        case jobDefinition = "JobDefinition"
        case jobName = "JobName"
        case retryStrategy = "RetryStrategy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arrayProperties = arrayProperties {
            try encodeContainer.encode(arrayProperties, forKey: .arrayProperties)
        }
        if let jobDefinition = jobDefinition {
            try encodeContainer.encode(jobDefinition, forKey: .jobDefinition)
        }
        if let jobName = jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let retryStrategy = retryStrategy {
            try encodeContainer.encode(retryStrategy, forKey: .retryStrategy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDefinitionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobDefinition)
        jobDefinition = jobDefinitionDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let arrayPropertiesDecoded = try containerValues.decodeIfPresent(BatchArrayProperties.self, forKey: .arrayProperties)
        arrayProperties = arrayPropertiesDecoded
        let retryStrategyDecoded = try containerValues.decodeIfPresent(BatchRetryStrategy.self, forKey: .retryStrategy)
        retryStrategy = retryStrategyDecoded
    }
}

extension BatchParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchParameters(arrayProperties: \(String(describing: arrayProperties)), jobDefinition: \(String(describing: jobDefinition)), jobName: \(String(describing: jobName)), retryStrategy: \(String(describing: retryStrategy)))"}
}

/// <p>The custom parameters to be used when the target is an AWS Batch job.</p>
public struct BatchParameters: Equatable {
    /// <p>The array properties for the submitted job, such as the size of the array. The array size
    ///       can be between 2 and 10,000. If you specify array properties for a job, it becomes an array
    ///       job. This parameter is used only if the target is an AWS Batch job.</p>
    public let arrayProperties: BatchArrayProperties?
    /// <p>The ARN or name of the job definition to use if the event target is an AWS Batch job. This
    ///       job definition must already exist.</p>
    public let jobDefinition: String?
    /// <p>The name to use for this execution of the job, if the target is an AWS Batch job.</p>
    public let jobName: String?
    /// <p>The retry strategy to use for failed jobs, if the target is an AWS Batch job. The retry
    ///       strategy is the number of times to retry the failed job execution. Valid values are 1–10. When
    ///       you specify a retry strategy here, it overrides the retry strategy defined in the job
    ///       definition.</p>
    public let retryStrategy: BatchRetryStrategy?

    public init (
        arrayProperties: BatchArrayProperties? = nil,
        jobDefinition: String? = nil,
        jobName: String? = nil,
        retryStrategy: BatchRetryStrategy? = nil
    )
    {
        self.arrayProperties = arrayProperties
        self.jobDefinition = jobDefinition
        self.jobName = jobName
        self.retryStrategy = retryStrategy
    }
}

extension BatchRetryStrategy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attempts = "Attempts"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if attempts != 0 {
            try encodeContainer.encode(attempts, forKey: .attempts)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attemptsDecoded = try containerValues.decode(Int.self, forKey: .attempts)
        attempts = attemptsDecoded
    }
}

extension BatchRetryStrategy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchRetryStrategy(attempts: \(String(describing: attempts)))"}
}

/// <p>The retry strategy to use for failed jobs, if the target is an AWS Batch job. If you
///       specify a retry strategy here, it overrides the retry strategy defined in the job
///       definition.</p>
public struct BatchRetryStrategy: Equatable {
    /// <p>The number of times to attempt to retry, if the job fails. Valid values are 1–10.</p>
    public let attempts: Int

    public init (
        attempts: Int = 0
    )
    {
        self.attempts = attempts
    }
}

public struct CancelReplayInputBodyMiddleware: Middleware {
    public let id: String = "CancelReplayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelReplayInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelReplayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelReplayInput>
    public typealias MOutput = OperationOutput<CancelReplayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelReplayOutputError>
}

extension CancelReplayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelReplayInput(replayName: \(String(describing: replayName)))"}
}

extension CancelReplayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replayName = "ReplayName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replayName = replayName {
            try encodeContainer.encode(replayName, forKey: .replayName)
        }
    }
}

public struct CancelReplayInputHeadersMiddleware: Middleware {
    public let id: String = "CancelReplayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelReplayInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelReplayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelReplayInput>
    public typealias MOutput = OperationOutput<CancelReplayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelReplayOutputError>
}

public struct CancelReplayInputQueryItemMiddleware: Middleware {
    public let id: String = "CancelReplayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CancelReplayInput>,
                  next: H) -> Swift.Result<OperationOutput<CancelReplayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CancelReplayInput>
    public typealias MOutput = OperationOutput<CancelReplayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CancelReplayOutputError>
}

public struct CancelReplayInput: Equatable {
    /// <p>The name of the replay to cancel.</p>
    public let replayName: String?

    public init (
        replayName: String? = nil
    )
    {
        self.replayName = replayName
    }
}

struct CancelReplayInputBody: Equatable {
    public let replayName: String?
}

extension CancelReplayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replayName = "ReplayName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replayName)
        replayName = replayNameDecoded
    }
}

extension CancelReplayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CancelReplayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "IllegalStatusException" : self = .illegalStatusException(try IllegalStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CancelReplayOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case illegalStatusException(IllegalStatusException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CancelReplayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CancelReplayOutputResponse(replayArn: \(String(describing: replayArn)), state: \(String(describing: state)), stateReason: \(String(describing: stateReason)))"}
}

extension CancelReplayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CancelReplayOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replayArn = output.replayArn
            self.state = output.state
            self.stateReason = output.stateReason
        } else {
            self.replayArn = nil
            self.state = nil
            self.stateReason = nil
        }
    }
}

public struct CancelReplayOutputResponse: Equatable {
    /// <p>The ARN of the replay to cancel.</p>
    public let replayArn: String?
    /// <p>The current state of the replay.</p>
    public let state: ReplayState?
    /// <p>The reason that the replay is in the current state.</p>
    public let stateReason: String?

    public init (
        replayArn: String? = nil,
        state: ReplayState? = nil,
        stateReason: String? = nil
    )
    {
        self.replayArn = replayArn
        self.state = state
        self.stateReason = stateReason
    }
}

struct CancelReplayOutputResponseBody: Equatable {
    public let replayArn: String?
    public let state: ReplayState?
    public let stateReason: String?
}

extension CancelReplayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replayArn = "ReplayArn"
        case state = "State"
        case stateReason = "StateReason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replayArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replayArn)
        replayArn = replayArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ReplayState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There is concurrent modification on a rule, target, archive, or replay.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Condition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Condition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Condition(key: \(String(describing: key)), type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <p>A JSON string which you can use to limit the event bus permissions you are granting to
///       only accounts that fulfill the condition. Currently, the only supported condition is
///       membership in a certain AWS organization. The string must contain <code>Type</code>,
///         <code>Key</code>, and <code>Value</code> fields. The <code>Value</code> field specifies the
///       ID of the AWS organization. Following is an example value for <code>Condition</code>:</p>
///          <p>
///             <code>'{"Type" : "StringEquals", "Key": "aws:PrincipalOrgID", "Value":
///         "o-1234567890"}'</code>
///          </p>
public struct Condition: Equatable {
    /// <p>Specifies the key for the condition. Currently the only supported key is
    ///         <code>aws:PrincipalOrgID</code>.</p>
    public let key: String?
    /// <p>Specifies the type of condition. Currently the only supported value is
    ///         <code>StringEquals</code>.</p>
    public let type: String?
    /// <p>Specifies the value for the key. Currently, this must be the ID of the
    ///       organization.</p>
    public let value: String?

    public init (
        key: String? = nil,
        type: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.type = type
        self.value = value
    }
}

extension Connection: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizationType = "AuthorizationType"
        case connectionArn = "ConnectionArn"
        case connectionState = "ConnectionState"
        case creationTime = "CreationTime"
        case lastAuthorizedTime = "LastAuthorizedTime"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case stateReason = "StateReason"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationType = authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let connectionState = connectionState {
            try encodeContainer.encode(connectionState.rawValue, forKey: .connectionState)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let lastAuthorizedTime = lastAuthorizedTime {
            try encodeContainer.encode(lastAuthorizedTime.timeIntervalSince1970, forKey: .lastAuthorizedTime)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let stateReason = stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(ConnectionAuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastAuthorizedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAuthorizedTime)
        lastAuthorizedTime = lastAuthorizedTimeDecoded
    }
}

extension Connection: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Connection(authorizationType: \(String(describing: authorizationType)), connectionArn: \(String(describing: connectionArn)), connectionState: \(String(describing: connectionState)), creationTime: \(String(describing: creationTime)), lastAuthorizedTime: \(String(describing: lastAuthorizedTime)), lastModifiedTime: \(String(describing: lastModifiedTime)), name: \(String(describing: name)), stateReason: \(String(describing: stateReason)))"}
}

/// <p>Contains information about a connection.</p>
public struct Connection: Equatable {
    /// <p>The authorization type specified for the connection.</p>
    public let authorizationType: ConnectionAuthorizationType?
    /// <p>The ARN of the connection.</p>
    public let connectionArn: String?
    /// <p>The state of the connection.</p>
    public let connectionState: ConnectionState?
    /// <p>A time stamp for the time that the connection was created.</p>
    public let creationTime: Date?
    /// <p>A time stamp for the time that the connection was last authorized.</p>
    public let lastAuthorizedTime: Date?
    /// <p>A time stamp for the time that the connection was last modified.</p>
    public let lastModifiedTime: Date?
    /// <p>The name of the connection.</p>
    public let name: String?
    /// <p>The reason that the connection is in the connection state.</p>
    public let stateReason: String?

    public init (
        authorizationType: ConnectionAuthorizationType? = nil,
        connectionArn: String? = nil,
        connectionState: ConnectionState? = nil,
        creationTime: Date? = nil,
        lastAuthorizedTime: Date? = nil,
        lastModifiedTime: Date? = nil,
        name: String? = nil,
        stateReason: String? = nil
    )
    {
        self.authorizationType = authorizationType
        self.connectionArn = connectionArn
        self.connectionState = connectionState
        self.creationTime = creationTime
        self.lastAuthorizedTime = lastAuthorizedTime
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.stateReason = stateReason
    }
}

extension ConnectionApiKeyAuthResponseParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiKeyName = "ApiKeyName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyName = apiKeyName {
            try encodeContainer.encode(apiKeyName, forKey: .apiKeyName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKeyName)
        apiKeyName = apiKeyNameDecoded
    }
}

extension ConnectionApiKeyAuthResponseParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionApiKeyAuthResponseParameters(apiKeyName: \(String(describing: apiKeyName)))"}
}

/// <p>Contains the authorization parameters for the connection if API Key is specified as the
///       authorization type.</p>
public struct ConnectionApiKeyAuthResponseParameters: Equatable {
    /// <p>The name of the header to use for the <code>APIKeyValue</code> used for authorization.</p>
    public let apiKeyName: String?

    public init (
        apiKeyName: String? = nil
    )
    {
        self.apiKeyName = apiKeyName
    }
}

extension ConnectionAuthResponseParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiKeyAuthParameters = "ApiKeyAuthParameters"
        case basicAuthParameters = "BasicAuthParameters"
        case invocationHttpParameters = "InvocationHttpParameters"
        case oAuthParameters = "OAuthParameters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyAuthParameters = apiKeyAuthParameters {
            try encodeContainer.encode(apiKeyAuthParameters, forKey: .apiKeyAuthParameters)
        }
        if let basicAuthParameters = basicAuthParameters {
            try encodeContainer.encode(basicAuthParameters, forKey: .basicAuthParameters)
        }
        if let invocationHttpParameters = invocationHttpParameters {
            try encodeContainer.encode(invocationHttpParameters, forKey: .invocationHttpParameters)
        }
        if let oAuthParameters = oAuthParameters {
            try encodeContainer.encode(oAuthParameters, forKey: .oAuthParameters)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basicAuthParametersDecoded = try containerValues.decodeIfPresent(ConnectionBasicAuthResponseParameters.self, forKey: .basicAuthParameters)
        basicAuthParameters = basicAuthParametersDecoded
        let oAuthParametersDecoded = try containerValues.decodeIfPresent(ConnectionOAuthResponseParameters.self, forKey: .oAuthParameters)
        oAuthParameters = oAuthParametersDecoded
        let apiKeyAuthParametersDecoded = try containerValues.decodeIfPresent(ConnectionApiKeyAuthResponseParameters.self, forKey: .apiKeyAuthParameters)
        apiKeyAuthParameters = apiKeyAuthParametersDecoded
        let invocationHttpParametersDecoded = try containerValues.decodeIfPresent(ConnectionHttpParameters.self, forKey: .invocationHttpParameters)
        invocationHttpParameters = invocationHttpParametersDecoded
    }
}

extension ConnectionAuthResponseParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionAuthResponseParameters(apiKeyAuthParameters: \(String(describing: apiKeyAuthParameters)), basicAuthParameters: \(String(describing: basicAuthParameters)), invocationHttpParameters: \(String(describing: invocationHttpParameters)), oAuthParameters: \(String(describing: oAuthParameters)))"}
}

/// <p>Contains the authorization parameters to use for the connection.</p>
public struct ConnectionAuthResponseParameters: Equatable {
    /// <p>The API Key parameters to use for authorization.</p>
    public let apiKeyAuthParameters: ConnectionApiKeyAuthResponseParameters?
    /// <p>The authorization parameters for Basic authorization.</p>
    public let basicAuthParameters: ConnectionBasicAuthResponseParameters?
    /// <p>Additional parameters for the connection that are passed through with every invocation to
    ///       the HTTP endpoint.</p>
    public let invocationHttpParameters: ConnectionHttpParameters?
    /// <p>The OAuth parameters to use for authorization.</p>
    public let oAuthParameters: ConnectionOAuthResponseParameters?

    public init (
        apiKeyAuthParameters: ConnectionApiKeyAuthResponseParameters? = nil,
        basicAuthParameters: ConnectionBasicAuthResponseParameters? = nil,
        invocationHttpParameters: ConnectionHttpParameters? = nil,
        oAuthParameters: ConnectionOAuthResponseParameters? = nil
    )
    {
        self.apiKeyAuthParameters = apiKeyAuthParameters
        self.basicAuthParameters = basicAuthParameters
        self.invocationHttpParameters = invocationHttpParameters
        self.oAuthParameters = oAuthParameters
    }
}

public enum ConnectionAuthorizationType {
    case apiKey
    case basic
    case oauthClientCredentials
    case sdkUnknown(String)
}

extension ConnectionAuthorizationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionAuthorizationType] {
        return [
            .apiKey,
            .basic,
            .oauthClientCredentials,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .apiKey: return "API_KEY"
        case .basic: return "BASIC"
        case .oauthClientCredentials: return "OAUTH_CLIENT_CREDENTIALS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionAuthorizationType(rawValue: rawValue) ?? ConnectionAuthorizationType.sdkUnknown(rawValue)
    }
}

extension ConnectionBasicAuthResponseParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
    }
}

extension ConnectionBasicAuthResponseParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionBasicAuthResponseParameters(username: \(String(describing: username)))"}
}

/// <p>Contains the authorization parameters for the connection if Basic is specified as the
///       authorization type.</p>
public struct ConnectionBasicAuthResponseParameters: Equatable {
    /// <p>The user name to use for Basic authorization.</p>
    public let username: String?

    public init (
        username: String? = nil
    )
    {
        self.username = username
    }
}

extension ConnectionBodyParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isValueSecret = "IsValueSecret"
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isValueSecret != false {
            try encodeContainer.encode(isValueSecret, forKey: .isValueSecret)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let isValueSecretDecoded = try containerValues.decode(Bool.self, forKey: .isValueSecret)
        isValueSecret = isValueSecretDecoded
    }
}

extension ConnectionBodyParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionBodyParameter(isValueSecret: \(String(describing: isValueSecret)), key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Additional parameter included in the body. You can include up to 100 additional body
///       parameters per request. An event payload cannot exceed 64 KB.</p>
public struct ConnectionBodyParameter: Equatable {
    /// <p>Specified whether the value is secret.</p>
    public let isValueSecret: Bool
    /// <p>The key for the parameter.</p>
    public let key: String?
    /// <p>The value associated with the key.</p>
    public let value: String?

    public init (
        isValueSecret: Bool = false,
        key: String? = nil,
        value: String? = nil
    )
    {
        self.isValueSecret = isValueSecret
        self.key = key
        self.value = value
    }
}

extension ConnectionHeaderParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isValueSecret = "IsValueSecret"
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isValueSecret != false {
            try encodeContainer.encode(isValueSecret, forKey: .isValueSecret)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let isValueSecretDecoded = try containerValues.decode(Bool.self, forKey: .isValueSecret)
        isValueSecret = isValueSecretDecoded
    }
}

extension ConnectionHeaderParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionHeaderParameter(isValueSecret: \(String(describing: isValueSecret)), key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Additional parameter included in the header. You can include up to 100 additional header
///       parameters per request. An event payload cannot exceed 64 KB.</p>
public struct ConnectionHeaderParameter: Equatable {
    /// <p>Specified whether the value is a secret.</p>
    public let isValueSecret: Bool
    /// <p>The key for the parameter.</p>
    public let key: String?
    /// <p>The value associated with the key.</p>
    public let value: String?

    public init (
        isValueSecret: Bool = false,
        key: String? = nil,
        value: String? = nil
    )
    {
        self.isValueSecret = isValueSecret
        self.key = key
        self.value = value
    }
}

extension ConnectionHttpParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bodyParameters = "BodyParameters"
        case headerParameters = "HeaderParameters"
        case queryStringParameters = "QueryStringParameters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bodyParameters = bodyParameters {
            var bodyParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bodyParameters)
            for connectionbodyparameterslist0 in bodyParameters {
                try bodyParametersContainer.encode(connectionbodyparameterslist0)
            }
        }
        if let headerParameters = headerParameters {
            var headerParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .headerParameters)
            for connectionheaderparameterslist0 in headerParameters {
                try headerParametersContainer.encode(connectionheaderparameterslist0)
            }
        }
        if let queryStringParameters = queryStringParameters {
            var queryStringParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queryStringParameters)
            for connectionquerystringparameterslist0 in queryStringParameters {
                try queryStringParametersContainer.encode(connectionquerystringparameterslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headerParametersContainer = try containerValues.decodeIfPresent([ConnectionHeaderParameter?].self, forKey: .headerParameters)
        var headerParametersDecoded0:[ConnectionHeaderParameter]? = nil
        if let headerParametersContainer = headerParametersContainer {
            headerParametersDecoded0 = [ConnectionHeaderParameter]()
            for structure0 in headerParametersContainer {
                if let structure0 = structure0 {
                    headerParametersDecoded0?.append(structure0)
                }
            }
        }
        headerParameters = headerParametersDecoded0
        let queryStringParametersContainer = try containerValues.decodeIfPresent([ConnectionQueryStringParameter?].self, forKey: .queryStringParameters)
        var queryStringParametersDecoded0:[ConnectionQueryStringParameter]? = nil
        if let queryStringParametersContainer = queryStringParametersContainer {
            queryStringParametersDecoded0 = [ConnectionQueryStringParameter]()
            for structure0 in queryStringParametersContainer {
                if let structure0 = structure0 {
                    queryStringParametersDecoded0?.append(structure0)
                }
            }
        }
        queryStringParameters = queryStringParametersDecoded0
        let bodyParametersContainer = try containerValues.decodeIfPresent([ConnectionBodyParameter?].self, forKey: .bodyParameters)
        var bodyParametersDecoded0:[ConnectionBodyParameter]? = nil
        if let bodyParametersContainer = bodyParametersContainer {
            bodyParametersDecoded0 = [ConnectionBodyParameter]()
            for structure0 in bodyParametersContainer {
                if let structure0 = structure0 {
                    bodyParametersDecoded0?.append(structure0)
                }
            }
        }
        bodyParameters = bodyParametersDecoded0
    }
}

extension ConnectionHttpParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionHttpParameters(bodyParameters: \(String(describing: bodyParameters)), headerParameters: \(String(describing: headerParameters)), queryStringParameters: \(String(describing: queryStringParameters)))"}
}

/// <p>Contains additional parameters for the connection.</p>
public struct ConnectionHttpParameters: Equatable {
    /// <p>Contains additional body string parameters for the connection.</p>
    public let bodyParameters: [ConnectionBodyParameter]?
    /// <p>Contains additional header parameters for the connection.</p>
    public let headerParameters: [ConnectionHeaderParameter]?
    /// <p>Contains additional query string parameters for the connection.</p>
    public let queryStringParameters: [ConnectionQueryStringParameter]?

    public init (
        bodyParameters: [ConnectionBodyParameter]? = nil,
        headerParameters: [ConnectionHeaderParameter]? = nil,
        queryStringParameters: [ConnectionQueryStringParameter]? = nil
    )
    {
        self.bodyParameters = bodyParameters
        self.headerParameters = headerParameters
        self.queryStringParameters = queryStringParameters
    }
}

extension ConnectionOAuthClientResponseParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientID = "ClientID"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientID = clientID {
            try encodeContainer.encode(clientID, forKey: .clientID)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientID)
        clientID = clientIDDecoded
    }
}

extension ConnectionOAuthClientResponseParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionOAuthClientResponseParameters(clientID: \(String(describing: clientID)))"}
}

/// <p>Contains the client response parameters for the connection when OAuth is specified as the
///       authorization type.</p>
public struct ConnectionOAuthClientResponseParameters: Equatable {
    /// <p>The client ID associated with the response to the connection request.</p>
    public let clientID: String?

    public init (
        clientID: String? = nil
    )
    {
        self.clientID = clientID
    }
}

public enum ConnectionOAuthHttpMethod {
    case `get`
    case post
    case put
    case sdkUnknown(String)
}

extension ConnectionOAuthHttpMethod : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionOAuthHttpMethod] {
        return [
            .get,
            .post,
            .put,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .get: return "GET"
        case .post: return "POST"
        case .put: return "PUT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionOAuthHttpMethod(rawValue: rawValue) ?? ConnectionOAuthHttpMethod.sdkUnknown(rawValue)
    }
}

extension ConnectionOAuthResponseParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizationEndpoint = "AuthorizationEndpoint"
        case clientParameters = "ClientParameters"
        case httpMethod = "HttpMethod"
        case oAuthHttpParameters = "OAuthHttpParameters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationEndpoint = authorizationEndpoint {
            try encodeContainer.encode(authorizationEndpoint, forKey: .authorizationEndpoint)
        }
        if let clientParameters = clientParameters {
            try encodeContainer.encode(clientParameters, forKey: .clientParameters)
        }
        if let httpMethod = httpMethod {
            try encodeContainer.encode(httpMethod.rawValue, forKey: .httpMethod)
        }
        if let oAuthHttpParameters = oAuthHttpParameters {
            try encodeContainer.encode(oAuthHttpParameters, forKey: .oAuthHttpParameters)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientParametersDecoded = try containerValues.decodeIfPresent(ConnectionOAuthClientResponseParameters.self, forKey: .clientParameters)
        clientParameters = clientParametersDecoded
        let authorizationEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizationEndpoint)
        authorizationEndpoint = authorizationEndpointDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(ConnectionOAuthHttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let oAuthHttpParametersDecoded = try containerValues.decodeIfPresent(ConnectionHttpParameters.self, forKey: .oAuthHttpParameters)
        oAuthHttpParameters = oAuthHttpParametersDecoded
    }
}

extension ConnectionOAuthResponseParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionOAuthResponseParameters(authorizationEndpoint: \(String(describing: authorizationEndpoint)), clientParameters: \(String(describing: clientParameters)), httpMethod: \(String(describing: httpMethod)), oAuthHttpParameters: \(String(describing: oAuthHttpParameters)))"}
}

/// <p>Contains the response parameters when OAuth is specified as the authorization type.</p>
public struct ConnectionOAuthResponseParameters: Equatable {
    /// <p>The URL to the HTTP endpoint that authorized the request.</p>
    public let authorizationEndpoint: String?
    /// <p>A <code>ConnectionOAuthClientResponseParameters</code> object that contains details about
    ///       the client parameters returned when OAuth is specified as the authorization type.</p>
    public let clientParameters: ConnectionOAuthClientResponseParameters?
    /// <p>The method used to connect to the HTTP endpoint.</p>
    public let httpMethod: ConnectionOAuthHttpMethod?
    /// <p>The additional HTTP parameters used for the OAuth authorization request.</p>
    public let oAuthHttpParameters: ConnectionHttpParameters?

    public init (
        authorizationEndpoint: String? = nil,
        clientParameters: ConnectionOAuthClientResponseParameters? = nil,
        httpMethod: ConnectionOAuthHttpMethod? = nil,
        oAuthHttpParameters: ConnectionHttpParameters? = nil
    )
    {
        self.authorizationEndpoint = authorizationEndpoint
        self.clientParameters = clientParameters
        self.httpMethod = httpMethod
        self.oAuthHttpParameters = oAuthHttpParameters
    }
}

extension ConnectionQueryStringParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isValueSecret = "IsValueSecret"
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if isValueSecret != false {
            try encodeContainer.encode(isValueSecret, forKey: .isValueSecret)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let isValueSecretDecoded = try containerValues.decode(Bool.self, forKey: .isValueSecret)
        isValueSecret = isValueSecretDecoded
    }
}

extension ConnectionQueryStringParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConnectionQueryStringParameter(isValueSecret: \(String(describing: isValueSecret)), key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Additional query string parameter for the connection. You can include up to 100 additional
///       query string parameters per request. Each additional parameter counts towards the event
///       payload size, which cannot exceed 64 KB.</p>
public struct ConnectionQueryStringParameter: Equatable {
    /// <p>Specifies whether the value is secret.</p>
    public let isValueSecret: Bool
    /// <p>The key for a query string parameter.</p>
    public let key: String?
    /// <p>The value associated with the key for the query string parameter.</p>
    public let value: String?

    public init (
        isValueSecret: Bool = false,
        key: String? = nil,
        value: String? = nil
    )
    {
        self.isValueSecret = isValueSecret
        self.key = key
        self.value = value
    }
}

public enum ConnectionState {
    case authorized
    case authorizing
    case creating
    case deauthorized
    case deauthorizing
    case deleting
    case updating
    case sdkUnknown(String)
}

extension ConnectionState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionState] {
        return [
            .authorized,
            .authorizing,
            .creating,
            .deauthorized,
            .deauthorizing,
            .deleting,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .authorized: return "AUTHORIZED"
        case .authorizing: return "AUTHORIZING"
        case .creating: return "CREATING"
        case .deauthorized: return "DEAUTHORIZED"
        case .deauthorizing: return "DEAUTHORIZING"
        case .deleting: return "DELETING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionState(rawValue: rawValue) ?? ConnectionState.sdkUnknown(rawValue)
    }
}

public struct CreateApiDestinationInputBodyMiddleware: Middleware {
    public let id: String = "CreateApiDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApiDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApiDestinationInput>
    public typealias MOutput = OperationOutput<CreateApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApiDestinationOutputError>
}

extension CreateApiDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApiDestinationInput(connectionArn: \(String(describing: connectionArn)), description: \(String(describing: description)), httpMethod: \(String(describing: httpMethod)), invocationEndpoint: \(String(describing: invocationEndpoint)), invocationRateLimitPerSecond: \(String(describing: invocationRateLimitPerSecond)), name: \(String(describing: name)))"}
}

extension CreateApiDestinationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionArn = "ConnectionArn"
        case description = "Description"
        case httpMethod = "HttpMethod"
        case invocationEndpoint = "InvocationEndpoint"
        case invocationRateLimitPerSecond = "InvocationRateLimitPerSecond"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let httpMethod = httpMethod {
            try encodeContainer.encode(httpMethod.rawValue, forKey: .httpMethod)
        }
        if let invocationEndpoint = invocationEndpoint {
            try encodeContainer.encode(invocationEndpoint, forKey: .invocationEndpoint)
        }
        if let invocationRateLimitPerSecond = invocationRateLimitPerSecond {
            try encodeContainer.encode(invocationRateLimitPerSecond, forKey: .invocationRateLimitPerSecond)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateApiDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateApiDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApiDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApiDestinationInput>
    public typealias MOutput = OperationOutput<CreateApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApiDestinationOutputError>
}

public struct CreateApiDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateApiDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApiDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApiDestinationInput>
    public typealias MOutput = OperationOutput<CreateApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApiDestinationOutputError>
}

public struct CreateApiDestinationInput: Equatable {
    /// <p>The ARN of the connection to use for the API destination. The destination endpoint must
    ///       support the authorization type specified for the connection.</p>
    public let connectionArn: String?
    /// <p>A description for the API destination to create.</p>
    public let description: String?
    /// <p>The method to use for the request to the HTTP invocation endpoint.</p>
    public let httpMethod: ApiDestinationHttpMethod?
    /// <p>The URL to the HTTP invocation endpoint for the API destination.</p>
    public let invocationEndpoint: String?
    /// <p>The maximum number of requests per second to send to the HTTP invocation endpoint.</p>
    public let invocationRateLimitPerSecond: Int?
    /// <p>The name for the API destination to create.</p>
    public let name: String?

    public init (
        connectionArn: String? = nil,
        description: String? = nil,
        httpMethod: ApiDestinationHttpMethod? = nil,
        invocationEndpoint: String? = nil,
        invocationRateLimitPerSecond: Int? = nil,
        name: String? = nil
    )
    {
        self.connectionArn = connectionArn
        self.description = description
        self.httpMethod = httpMethod
        self.invocationEndpoint = invocationEndpoint
        self.invocationRateLimitPerSecond = invocationRateLimitPerSecond
        self.name = name
    }
}

struct CreateApiDestinationInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let connectionArn: String?
    public let invocationEndpoint: String?
    public let httpMethod: ApiDestinationHttpMethod?
    public let invocationRateLimitPerSecond: Int?
}

extension CreateApiDestinationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionArn = "ConnectionArn"
        case description = "Description"
        case httpMethod = "HttpMethod"
        case invocationEndpoint = "InvocationEndpoint"
        case invocationRateLimitPerSecond = "InvocationRateLimitPerSecond"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let invocationEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invocationEndpoint)
        invocationEndpoint = invocationEndpointDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(ApiDestinationHttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let invocationRateLimitPerSecondDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .invocationRateLimitPerSecond)
        invocationRateLimitPerSecond = invocationRateLimitPerSecondDecoded
    }
}

extension CreateApiDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApiDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApiDestinationOutputError: Equatable {
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApiDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApiDestinationOutputResponse(apiDestinationArn: \(String(describing: apiDestinationArn)), apiDestinationState: \(String(describing: apiDestinationState)), creationTime: \(String(describing: creationTime)), lastModifiedTime: \(String(describing: lastModifiedTime)))"}
}

extension CreateApiDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateApiDestinationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiDestinationArn = output.apiDestinationArn
            self.apiDestinationState = output.apiDestinationState
            self.creationTime = output.creationTime
            self.lastModifiedTime = output.lastModifiedTime
        } else {
            self.apiDestinationArn = nil
            self.apiDestinationState = nil
            self.creationTime = nil
            self.lastModifiedTime = nil
        }
    }
}

public struct CreateApiDestinationOutputResponse: Equatable {
    /// <p>The ARN of the API destination that was created by the request.</p>
    public let apiDestinationArn: String?
    /// <p>The state of the API destination that was created by the request.</p>
    public let apiDestinationState: ApiDestinationState?
    /// <p>A time stamp indicating the time that the API destination was created.</p>
    public let creationTime: Date?
    /// <p>A time stamp indicating the time that the API destination was last modified.</p>
    public let lastModifiedTime: Date?

    public init (
        apiDestinationArn: String? = nil,
        apiDestinationState: ApiDestinationState? = nil,
        creationTime: Date? = nil,
        lastModifiedTime: Date? = nil
    )
    {
        self.apiDestinationArn = apiDestinationArn
        self.apiDestinationState = apiDestinationState
        self.creationTime = creationTime
        self.lastModifiedTime = lastModifiedTime
    }
}

struct CreateApiDestinationOutputResponseBody: Equatable {
    public let apiDestinationArn: String?
    public let apiDestinationState: ApiDestinationState?
    public let creationTime: Date?
    public let lastModifiedTime: Date?
}

extension CreateApiDestinationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiDestinationArn = "ApiDestinationArn"
        case apiDestinationState = "ApiDestinationState"
        case creationTime = "CreationTime"
        case lastModifiedTime = "LastModifiedTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDestinationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiDestinationArn)
        apiDestinationArn = apiDestinationArnDecoded
        let apiDestinationStateDecoded = try containerValues.decodeIfPresent(ApiDestinationState.self, forKey: .apiDestinationState)
        apiDestinationState = apiDestinationStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

public struct CreateArchiveInputBodyMiddleware: Middleware {
    public let id: String = "CreateArchiveInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateArchiveInput>
    public typealias MOutput = OperationOutput<CreateArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateArchiveOutputError>
}

extension CreateArchiveInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateArchiveInput(archiveName: \(String(describing: archiveName)), description: \(String(describing: description)), eventPattern: \(String(describing: eventPattern)), eventSourceArn: \(String(describing: eventSourceArn)), retentionDays: \(String(describing: retentionDays)))"}
}

extension CreateArchiveInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case archiveName = "ArchiveName"
        case description = "Description"
        case eventPattern = "EventPattern"
        case eventSourceArn = "EventSourceArn"
        case retentionDays = "RetentionDays"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveName = archiveName {
            try encodeContainer.encode(archiveName, forKey: .archiveName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventPattern = eventPattern {
            try encodeContainer.encode(eventPattern, forKey: .eventPattern)
        }
        if let eventSourceArn = eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let retentionDays = retentionDays {
            try encodeContainer.encode(retentionDays, forKey: .retentionDays)
        }
    }
}

public struct CreateArchiveInputHeadersMiddleware: Middleware {
    public let id: String = "CreateArchiveInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateArchiveInput>
    public typealias MOutput = OperationOutput<CreateArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateArchiveOutputError>
}

public struct CreateArchiveInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateArchiveInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateArchiveInput>
    public typealias MOutput = OperationOutput<CreateArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateArchiveOutputError>
}

public struct CreateArchiveInput: Equatable {
    /// <p>The name for the archive to create.</p>
    public let archiveName: String?
    /// <p>A description for the archive.</p>
    public let description: String?
    /// <p>An event pattern to use to filter events sent to the archive.</p>
    public let eventPattern: String?
    /// <p>The ARN of the event source associated with the archive.</p>
    public let eventSourceArn: String?
    /// <p>The number of days to retain events for. Default value is 0. If set to 0, events are
    ///       retained indefinitely</p>
    public let retentionDays: Int?

    public init (
        archiveName: String? = nil,
        description: String? = nil,
        eventPattern: String? = nil,
        eventSourceArn: String? = nil,
        retentionDays: Int? = nil
    )
    {
        self.archiveName = archiveName
        self.description = description
        self.eventPattern = eventPattern
        self.eventSourceArn = eventSourceArn
        self.retentionDays = retentionDays
    }
}

struct CreateArchiveInputBody: Equatable {
    public let archiveName: String?
    public let eventSourceArn: String?
    public let description: String?
    public let eventPattern: String?
    public let retentionDays: Int?
}

extension CreateArchiveInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case archiveName = "ArchiveName"
        case description = "Description"
        case eventPattern = "EventPattern"
        case eventSourceArn = "EventSourceArn"
        case retentionDays = "RetentionDays"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .archiveName)
        archiveName = archiveNameDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let retentionDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .retentionDays)
        retentionDays = retentionDaysDecoded
    }
}

extension CreateArchiveOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateArchiveOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventPatternException" : self = .invalidEventPatternException(try InvalidEventPatternException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateArchiveOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case invalidEventPatternException(InvalidEventPatternException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateArchiveOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateArchiveOutputResponse(archiveArn: \(String(describing: archiveArn)), creationTime: \(String(describing: creationTime)), state: \(String(describing: state)), stateReason: \(String(describing: stateReason)))"}
}

extension CreateArchiveOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateArchiveOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.archiveArn = output.archiveArn
            self.creationTime = output.creationTime
            self.state = output.state
            self.stateReason = output.stateReason
        } else {
            self.archiveArn = nil
            self.creationTime = nil
            self.state = nil
            self.stateReason = nil
        }
    }
}

public struct CreateArchiveOutputResponse: Equatable {
    /// <p>The ARN of the archive that was created.</p>
    public let archiveArn: String?
    /// <p>The time at which the archive was created.</p>
    public let creationTime: Date?
    /// <p>The state of the archive that was created.</p>
    public let state: ArchiveState?
    /// <p>The reason that the archive is in the state.</p>
    public let stateReason: String?

    public init (
        archiveArn: String? = nil,
        creationTime: Date? = nil,
        state: ArchiveState? = nil,
        stateReason: String? = nil
    )
    {
        self.archiveArn = archiveArn
        self.creationTime = creationTime
        self.state = state
        self.stateReason = stateReason
    }
}

struct CreateArchiveOutputResponseBody: Equatable {
    public let archiveArn: String?
    public let state: ArchiveState?
    public let stateReason: String?
    public let creationTime: Date?
}

extension CreateArchiveOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case archiveArn = "ArchiveArn"
        case creationTime = "CreationTime"
        case state = "State"
        case stateReason = "StateReason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .archiveArn)
        archiveArn = archiveArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ArchiveState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension CreateConnectionApiKeyAuthRequestParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiKeyName = "ApiKeyName"
        case apiKeyValue = "ApiKeyValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyName = apiKeyName {
            try encodeContainer.encode(apiKeyName, forKey: .apiKeyName)
        }
        if let apiKeyValue = apiKeyValue {
            try encodeContainer.encode(apiKeyValue, forKey: .apiKeyValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKeyName)
        apiKeyName = apiKeyNameDecoded
        let apiKeyValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKeyValue)
        apiKeyValue = apiKeyValueDecoded
    }
}

extension CreateConnectionApiKeyAuthRequestParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectionApiKeyAuthRequestParameters(apiKeyName: \(String(describing: apiKeyName)), apiKeyValue: \(String(describing: apiKeyValue)))"}
}

/// <p>Contains the API key authorization parameters for the connection.</p>
public struct CreateConnectionApiKeyAuthRequestParameters: Equatable {
    /// <p>The name of the API key to use for authorization.</p>
    public let apiKeyName: String?
    /// <p>The value for the API key to use for authorization.</p>
    public let apiKeyValue: String?

    public init (
        apiKeyName: String? = nil,
        apiKeyValue: String? = nil
    )
    {
        self.apiKeyName = apiKeyName
        self.apiKeyValue = apiKeyValue
    }
}

extension CreateConnectionAuthRequestParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiKeyAuthParameters = "ApiKeyAuthParameters"
        case basicAuthParameters = "BasicAuthParameters"
        case invocationHttpParameters = "InvocationHttpParameters"
        case oAuthParameters = "OAuthParameters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyAuthParameters = apiKeyAuthParameters {
            try encodeContainer.encode(apiKeyAuthParameters, forKey: .apiKeyAuthParameters)
        }
        if let basicAuthParameters = basicAuthParameters {
            try encodeContainer.encode(basicAuthParameters, forKey: .basicAuthParameters)
        }
        if let invocationHttpParameters = invocationHttpParameters {
            try encodeContainer.encode(invocationHttpParameters, forKey: .invocationHttpParameters)
        }
        if let oAuthParameters = oAuthParameters {
            try encodeContainer.encode(oAuthParameters, forKey: .oAuthParameters)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basicAuthParametersDecoded = try containerValues.decodeIfPresent(CreateConnectionBasicAuthRequestParameters.self, forKey: .basicAuthParameters)
        basicAuthParameters = basicAuthParametersDecoded
        let oAuthParametersDecoded = try containerValues.decodeIfPresent(CreateConnectionOAuthRequestParameters.self, forKey: .oAuthParameters)
        oAuthParameters = oAuthParametersDecoded
        let apiKeyAuthParametersDecoded = try containerValues.decodeIfPresent(CreateConnectionApiKeyAuthRequestParameters.self, forKey: .apiKeyAuthParameters)
        apiKeyAuthParameters = apiKeyAuthParametersDecoded
        let invocationHttpParametersDecoded = try containerValues.decodeIfPresent(ConnectionHttpParameters.self, forKey: .invocationHttpParameters)
        invocationHttpParameters = invocationHttpParametersDecoded
    }
}

extension CreateConnectionAuthRequestParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectionAuthRequestParameters(apiKeyAuthParameters: \(String(describing: apiKeyAuthParameters)), basicAuthParameters: \(String(describing: basicAuthParameters)), invocationHttpParameters: \(String(describing: invocationHttpParameters)), oAuthParameters: \(String(describing: oAuthParameters)))"}
}

/// <p>Contains the authorization parameters for the connection.</p>
public struct CreateConnectionAuthRequestParameters: Equatable {
    /// <p>A <code>CreateConnectionApiKeyAuthRequestParameters</code> object that contains the API
    ///       key authorization parameters to use for the connection.</p>
    public let apiKeyAuthParameters: CreateConnectionApiKeyAuthRequestParameters?
    /// <p>A <code>CreateConnectionBasicAuthRequestParameters</code> object that contains the Basic
    ///       authorization parameters to use for the connection.</p>
    public let basicAuthParameters: CreateConnectionBasicAuthRequestParameters?
    /// <p>A <code>ConnectionHttpParameters</code> object that contains the API key authorization
    ///       parameters to use for the connection. Note that if you include additional parameters for
    ///       the target of a rule via <code>HttpParameters</code>, including query strings, the parameters
    ///       added for the connection take precedence.</p>
    public let invocationHttpParameters: ConnectionHttpParameters?
    /// <p>A <code>CreateConnectionOAuthRequestParameters</code> object that contains the OAuth
    ///       authorization parameters to use for the connection.</p>
    public let oAuthParameters: CreateConnectionOAuthRequestParameters?

    public init (
        apiKeyAuthParameters: CreateConnectionApiKeyAuthRequestParameters? = nil,
        basicAuthParameters: CreateConnectionBasicAuthRequestParameters? = nil,
        invocationHttpParameters: ConnectionHttpParameters? = nil,
        oAuthParameters: CreateConnectionOAuthRequestParameters? = nil
    )
    {
        self.apiKeyAuthParameters = apiKeyAuthParameters
        self.basicAuthParameters = basicAuthParameters
        self.invocationHttpParameters = invocationHttpParameters
        self.oAuthParameters = oAuthParameters
    }
}

extension CreateConnectionBasicAuthRequestParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case password = "Password"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension CreateConnectionBasicAuthRequestParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectionBasicAuthRequestParameters(password: \(String(describing: password)), username: \(String(describing: username)))"}
}

/// <p>Contains the Basic authorization parameters to use for the connection.</p>
public struct CreateConnectionBasicAuthRequestParameters: Equatable {
    /// <p>The password associated with the user name to use for Basic authorization.</p>
    public let password: String?
    /// <p>The user name to use for Basic authorization.</p>
    public let username: String?

    public init (
        password: String? = nil,
        username: String? = nil
    )
    {
        self.password = password
        self.username = username
    }
}

public struct CreateConnectionInputBodyMiddleware: Middleware {
    public let id: String = "CreateConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectionOutputError>
}

extension CreateConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectionInput(authParameters: \(String(describing: authParameters)), authorizationType: \(String(describing: authorizationType)), description: \(String(describing: description)), name: \(String(describing: name)))"}
}

extension CreateConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authParameters = "AuthParameters"
        case authorizationType = "AuthorizationType"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authParameters = authParameters {
            try encodeContainer.encode(authParameters, forKey: .authParameters)
        }
        if let authorizationType = authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInput: Equatable {
    /// <p>A <code>CreateConnectionAuthRequestParameters</code> object that contains the
    ///       authorization parameters to use to authorize with the endpoint. </p>
    public let authParameters: CreateConnectionAuthRequestParameters?
    /// <p>The type of authorization to use for the connection.</p>
    public let authorizationType: ConnectionAuthorizationType?
    /// <p>A description for the connection to create.</p>
    public let description: String?
    /// <p>The name for the connection to create.</p>
    public let name: String?

    public init (
        authParameters: CreateConnectionAuthRequestParameters? = nil,
        authorizationType: ConnectionAuthorizationType? = nil,
        description: String? = nil,
        name: String? = nil
    )
    {
        self.authParameters = authParameters
        self.authorizationType = authorizationType
        self.description = description
        self.name = name
    }
}

struct CreateConnectionInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let authorizationType: ConnectionAuthorizationType?
    public let authParameters: CreateConnectionAuthRequestParameters?
}

extension CreateConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authParameters = "AuthParameters"
        case authorizationType = "AuthorizationType"
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(ConnectionAuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authParametersDecoded = try containerValues.decodeIfPresent(CreateConnectionAuthRequestParameters.self, forKey: .authParameters)
        authParameters = authParametersDecoded
    }
}

extension CreateConnectionOAuthClientRequestParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientID = "ClientID"
        case clientSecret = "ClientSecret"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientID = clientID {
            try encodeContainer.encode(clientID, forKey: .clientID)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientID)
        clientID = clientIDDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
    }
}

extension CreateConnectionOAuthClientRequestParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectionOAuthClientRequestParameters(clientID: \(String(describing: clientID)), clientSecret: \(String(describing: clientSecret)))"}
}

/// <p>Contains the Basic authorization parameters to use for the connection.</p>
public struct CreateConnectionOAuthClientRequestParameters: Equatable {
    /// <p>The client ID to use for OAuth authorization for the connection.</p>
    public let clientID: String?
    /// <p>The client secret associated with the client ID to use for OAuth authorization for the
    ///       connection.</p>
    public let clientSecret: String?

    public init (
        clientID: String? = nil,
        clientSecret: String? = nil
    )
    {
        self.clientID = clientID
        self.clientSecret = clientSecret
    }
}

extension CreateConnectionOAuthRequestParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizationEndpoint = "AuthorizationEndpoint"
        case clientParameters = "ClientParameters"
        case httpMethod = "HttpMethod"
        case oAuthHttpParameters = "OAuthHttpParameters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationEndpoint = authorizationEndpoint {
            try encodeContainer.encode(authorizationEndpoint, forKey: .authorizationEndpoint)
        }
        if let clientParameters = clientParameters {
            try encodeContainer.encode(clientParameters, forKey: .clientParameters)
        }
        if let httpMethod = httpMethod {
            try encodeContainer.encode(httpMethod.rawValue, forKey: .httpMethod)
        }
        if let oAuthHttpParameters = oAuthHttpParameters {
            try encodeContainer.encode(oAuthHttpParameters, forKey: .oAuthHttpParameters)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientParametersDecoded = try containerValues.decodeIfPresent(CreateConnectionOAuthClientRequestParameters.self, forKey: .clientParameters)
        clientParameters = clientParametersDecoded
        let authorizationEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizationEndpoint)
        authorizationEndpoint = authorizationEndpointDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(ConnectionOAuthHttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let oAuthHttpParametersDecoded = try containerValues.decodeIfPresent(ConnectionHttpParameters.self, forKey: .oAuthHttpParameters)
        oAuthHttpParameters = oAuthHttpParametersDecoded
    }
}

extension CreateConnectionOAuthRequestParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectionOAuthRequestParameters(authorizationEndpoint: \(String(describing: authorizationEndpoint)), clientParameters: \(String(describing: clientParameters)), httpMethod: \(String(describing: httpMethod)), oAuthHttpParameters: \(String(describing: oAuthHttpParameters)))"}
}

/// <p>Contains the OAuth authorization parameters to use for the connection.</p>
public struct CreateConnectionOAuthRequestParameters: Equatable {
    /// <p>The URL to the authorization endpoint when OAuth is specified as the authorization
    ///       type.</p>
    public let authorizationEndpoint: String?
    /// <p>A <code>CreateConnectionOAuthClientRequestParameters</code> object that contains the
    ///       client parameters for OAuth authorization.</p>
    public let clientParameters: CreateConnectionOAuthClientRequestParameters?
    /// <p>The method to use for the authorization request.</p>
    public let httpMethod: ConnectionOAuthHttpMethod?
    /// <p>A <code>ConnectionHttpParameters</code> object that contains details about the additional
    ///       parameters to use for the connection.</p>
    public let oAuthHttpParameters: ConnectionHttpParameters?

    public init (
        authorizationEndpoint: String? = nil,
        clientParameters: CreateConnectionOAuthClientRequestParameters? = nil,
        httpMethod: ConnectionOAuthHttpMethod? = nil,
        oAuthHttpParameters: ConnectionHttpParameters? = nil
    )
    {
        self.authorizationEndpoint = authorizationEndpoint
        self.clientParameters = clientParameters
        self.httpMethod = httpMethod
        self.oAuthHttpParameters = oAuthHttpParameters
    }
}

extension CreateConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConnectionOutputError: Equatable {
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectionOutputResponse(connectionArn: \(String(describing: connectionArn)), connectionState: \(String(describing: connectionState)), creationTime: \(String(describing: creationTime)), lastModifiedTime: \(String(describing: lastModifiedTime)))"}
}

extension CreateConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connectionArn = output.connectionArn
            self.connectionState = output.connectionState
            self.creationTime = output.creationTime
            self.lastModifiedTime = output.lastModifiedTime
        } else {
            self.connectionArn = nil
            self.connectionState = nil
            self.creationTime = nil
            self.lastModifiedTime = nil
        }
    }
}

public struct CreateConnectionOutputResponse: Equatable {
    /// <p>The ARN of the connection that was created by the request.</p>
    public let connectionArn: String?
    /// <p>The state of the connection that was created by the request.</p>
    public let connectionState: ConnectionState?
    /// <p>A time stamp for the time that the connection was created.</p>
    public let creationTime: Date?
    /// <p>A time stamp for the time that the connection was last updated.</p>
    public let lastModifiedTime: Date?

    public init (
        connectionArn: String? = nil,
        connectionState: ConnectionState? = nil,
        creationTime: Date? = nil,
        lastModifiedTime: Date? = nil
    )
    {
        self.connectionArn = connectionArn
        self.connectionState = connectionState
        self.creationTime = creationTime
        self.lastModifiedTime = lastModifiedTime
    }
}

struct CreateConnectionOutputResponseBody: Equatable {
    public let connectionArn: String?
    public let connectionState: ConnectionState?
    public let creationTime: Date?
    public let lastModifiedTime: Date?
}

extension CreateConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionArn = "ConnectionArn"
        case connectionState = "ConnectionState"
        case creationTime = "CreationTime"
        case lastModifiedTime = "LastModifiedTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

public struct CreateEventBusInputBodyMiddleware: Middleware {
    public let id: String = "CreateEventBusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventBusInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventBusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventBusInput>
    public typealias MOutput = OperationOutput<CreateEventBusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventBusOutputError>
}

extension CreateEventBusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEventBusInput(eventSourceName: \(String(describing: eventSourceName)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateEventBusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventSourceName = "EventSourceName"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventSourceName = eventSourceName {
            try encodeContainer.encode(eventSourceName, forKey: .eventSourceName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateEventBusInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEventBusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventBusInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventBusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventBusInput>
    public typealias MOutput = OperationOutput<CreateEventBusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventBusOutputError>
}

public struct CreateEventBusInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEventBusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventBusInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventBusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventBusInput>
    public typealias MOutput = OperationOutput<CreateEventBusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventBusOutputError>
}

public struct CreateEventBusInput: Equatable {
    /// <p>If you are creating a partner event bus, this specifies the partner event source that the
    ///       new event bus will be matched with.</p>
    public let eventSourceName: String?
    /// <p>The name of the new event bus. </p>
    ///          <p>Event bus names cannot contain the / character. You can't use the name
    ///         <code>default</code> for a custom event bus, as this name is already used for your account's
    ///       default event bus.</p>
    ///          <p>If this is a partner event bus, the name must exactly match the name of the partner event
    ///       source that this event bus is matched to.</p>
    public let name: String?
    /// <p>Tags to associate with the event bus.</p>
    public let tags: [Tag]?

    public init (
        eventSourceName: String? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.eventSourceName = eventSourceName
        self.name = name
        self.tags = tags
    }
}

struct CreateEventBusInputBody: Equatable {
    public let name: String?
    public let eventSourceName: String?
    public let tags: [Tag]?
}

extension CreateEventBusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSourceName = "EventSourceName"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let eventSourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSourceName)
        eventSourceName = eventSourceNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEventBusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEventBusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEventBusOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case invalidStateException(InvalidStateException)
    case limitExceededException(LimitExceededException)
    case operationDisabledException(OperationDisabledException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventBusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEventBusOutputResponse(eventBusArn: \(String(describing: eventBusArn)))"}
}

extension CreateEventBusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateEventBusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventBusArn = output.eventBusArn
        } else {
            self.eventBusArn = nil
        }
    }
}

public struct CreateEventBusOutputResponse: Equatable {
    /// <p>The ARN of the new event bus.</p>
    public let eventBusArn: String?

    public init (
        eventBusArn: String? = nil
    )
    {
        self.eventBusArn = eventBusArn
    }
}

struct CreateEventBusOutputResponseBody: Equatable {
    public let eventBusArn: String?
}

extension CreateEventBusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventBusArn = "EventBusArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventBusArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventBusArn)
        eventBusArn = eventBusArnDecoded
    }
}

public struct CreatePartnerEventSourceInputBodyMiddleware: Middleware {
    public let id: String = "CreatePartnerEventSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePartnerEventSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePartnerEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePartnerEventSourceInput>
    public typealias MOutput = OperationOutput<CreatePartnerEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePartnerEventSourceOutputError>
}

extension CreatePartnerEventSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePartnerEventSourceInput(account: \(String(describing: account)), name: \(String(describing: name)))"}
}

extension CreatePartnerEventSourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case account = "Account"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let account = account {
            try encodeContainer.encode(account, forKey: .account)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreatePartnerEventSourceInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePartnerEventSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePartnerEventSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePartnerEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePartnerEventSourceInput>
    public typealias MOutput = OperationOutput<CreatePartnerEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePartnerEventSourceOutputError>
}

public struct CreatePartnerEventSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePartnerEventSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePartnerEventSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePartnerEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePartnerEventSourceInput>
    public typealias MOutput = OperationOutput<CreatePartnerEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePartnerEventSourceOutputError>
}

public struct CreatePartnerEventSourceInput: Equatable {
    /// <p>The AWS account ID that is permitted to create a matching partner event bus for this
    ///       partner event source.</p>
    public let account: String?
    /// <p>The name of the partner event source. This name must be unique and must be in the format
    ///           <code>
    ///                <i>partner_name</i>/<i>event_namespace</i>/<i>event_name</i>
    ///             </code>.
    ///       The AWS account that wants to use this partner event source must create a partner event bus
    ///       with a name that matches the name of the partner event source.</p>
    public let name: String?

    public init (
        account: String? = nil,
        name: String? = nil
    )
    {
        self.account = account
        self.name = name
    }
}

struct CreatePartnerEventSourceInputBody: Equatable {
    public let name: String?
    public let account: String?
}

extension CreatePartnerEventSourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case account = "Account"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let accountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .account)
        account = accountDecoded
    }
}

extension CreatePartnerEventSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePartnerEventSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePartnerEventSourceOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case operationDisabledException(OperationDisabledException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePartnerEventSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePartnerEventSourceOutputResponse(eventSourceArn: \(String(describing: eventSourceArn)))"}
}

extension CreatePartnerEventSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreatePartnerEventSourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSourceArn = output.eventSourceArn
        } else {
            self.eventSourceArn = nil
        }
    }
}

public struct CreatePartnerEventSourceOutputResponse: Equatable {
    /// <p>The ARN of the partner event source.</p>
    public let eventSourceArn: String?

    public init (
        eventSourceArn: String? = nil
    )
    {
        self.eventSourceArn = eventSourceArn
    }
}

struct CreatePartnerEventSourceOutputResponseBody: Equatable {
    public let eventSourceArn: String?
}

extension CreatePartnerEventSourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSourceArn = "EventSourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
    }
}

public struct DeactivateEventSourceInputBodyMiddleware: Middleware {
    public let id: String = "DeactivateEventSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeactivateEventSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeactivateEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeactivateEventSourceInput>
    public typealias MOutput = OperationOutput<DeactivateEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeactivateEventSourceOutputError>
}

extension DeactivateEventSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeactivateEventSourceInput(name: \(String(describing: name)))"}
}

extension DeactivateEventSourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeactivateEventSourceInputHeadersMiddleware: Middleware {
    public let id: String = "DeactivateEventSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeactivateEventSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeactivateEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeactivateEventSourceInput>
    public typealias MOutput = OperationOutput<DeactivateEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeactivateEventSourceOutputError>
}

public struct DeactivateEventSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeactivateEventSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeactivateEventSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeactivateEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeactivateEventSourceInput>
    public typealias MOutput = OperationOutput<DeactivateEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeactivateEventSourceOutputError>
}

public struct DeactivateEventSourceInput: Equatable {
    /// <p>The name of the partner event source to deactivate.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeactivateEventSourceInputBody: Equatable {
    public let name: String?
}

extension DeactivateEventSourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeactivateEventSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeactivateEventSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeactivateEventSourceOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case invalidStateException(InvalidStateException)
    case operationDisabledException(OperationDisabledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeactivateEventSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeactivateEventSourceOutputResponse()"}
}

extension DeactivateEventSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeactivateEventSourceOutputResponse: Equatable {

    public init() {}
}

struct DeactivateEventSourceOutputResponseBody: Equatable {
}

extension DeactivateEventSourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeadLetterConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeadLetterConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeadLetterConfig(arn: \(String(describing: arn)))"}
}

/// <p>A <code>DeadLetterConfig</code> object that contains information about a dead-letter queue
///       configuration.</p>
public struct DeadLetterConfig: Equatable {
    /// <p>The ARN of the SQS queue specified as the target for the dead-letter queue.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

public struct DeauthorizeConnectionInputBodyMiddleware: Middleware {
    public let id: String = "DeauthorizeConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeauthorizeConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeauthorizeConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeauthorizeConnectionInput>
    public typealias MOutput = OperationOutput<DeauthorizeConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeauthorizeConnectionOutputError>
}

extension DeauthorizeConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeauthorizeConnectionInput(name: \(String(describing: name)))"}
}

extension DeauthorizeConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeauthorizeConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "DeauthorizeConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeauthorizeConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeauthorizeConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeauthorizeConnectionInput>
    public typealias MOutput = OperationOutput<DeauthorizeConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeauthorizeConnectionOutputError>
}

public struct DeauthorizeConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeauthorizeConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeauthorizeConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeauthorizeConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeauthorizeConnectionInput>
    public typealias MOutput = OperationOutput<DeauthorizeConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeauthorizeConnectionOutputError>
}

public struct DeauthorizeConnectionInput: Equatable {
    /// <p>The name of the connection to remove authorization from.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeauthorizeConnectionInputBody: Equatable {
    public let name: String?
}

extension DeauthorizeConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeauthorizeConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeauthorizeConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeauthorizeConnectionOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeauthorizeConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeauthorizeConnectionOutputResponse(connectionArn: \(String(describing: connectionArn)), connectionState: \(String(describing: connectionState)), creationTime: \(String(describing: creationTime)), lastAuthorizedTime: \(String(describing: lastAuthorizedTime)), lastModifiedTime: \(String(describing: lastModifiedTime)))"}
}

extension DeauthorizeConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeauthorizeConnectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connectionArn = output.connectionArn
            self.connectionState = output.connectionState
            self.creationTime = output.creationTime
            self.lastAuthorizedTime = output.lastAuthorizedTime
            self.lastModifiedTime = output.lastModifiedTime
        } else {
            self.connectionArn = nil
            self.connectionState = nil
            self.creationTime = nil
            self.lastAuthorizedTime = nil
            self.lastModifiedTime = nil
        }
    }
}

public struct DeauthorizeConnectionOutputResponse: Equatable {
    /// <p>The ARN of the connection that authorization was removed from.</p>
    public let connectionArn: String?
    /// <p>The state of the connection.</p>
    public let connectionState: ConnectionState?
    /// <p>A time stamp for the time that the connection was created.</p>
    public let creationTime: Date?
    /// <p>A time stamp for the time that the connection was last authorized.</p>
    public let lastAuthorizedTime: Date?
    /// <p>A time stamp for the time that the connection was last updated.</p>
    public let lastModifiedTime: Date?

    public init (
        connectionArn: String? = nil,
        connectionState: ConnectionState? = nil,
        creationTime: Date? = nil,
        lastAuthorizedTime: Date? = nil,
        lastModifiedTime: Date? = nil
    )
    {
        self.connectionArn = connectionArn
        self.connectionState = connectionState
        self.creationTime = creationTime
        self.lastAuthorizedTime = lastAuthorizedTime
        self.lastModifiedTime = lastModifiedTime
    }
}

struct DeauthorizeConnectionOutputResponseBody: Equatable {
    public let connectionArn: String?
    public let connectionState: ConnectionState?
    public let creationTime: Date?
    public let lastModifiedTime: Date?
    public let lastAuthorizedTime: Date?
}

extension DeauthorizeConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionArn = "ConnectionArn"
        case connectionState = "ConnectionState"
        case creationTime = "CreationTime"
        case lastAuthorizedTime = "LastAuthorizedTime"
        case lastModifiedTime = "LastModifiedTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastAuthorizedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAuthorizedTime)
        lastAuthorizedTime = lastAuthorizedTimeDecoded
    }
}

public struct DeleteApiDestinationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteApiDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApiDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApiDestinationInput>
    public typealias MOutput = OperationOutput<DeleteApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApiDestinationOutputError>
}

extension DeleteApiDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApiDestinationInput(name: \(String(describing: name)))"}
}

extension DeleteApiDestinationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteApiDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApiDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApiDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApiDestinationInput>
    public typealias MOutput = OperationOutput<DeleteApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApiDestinationOutputError>
}

public struct DeleteApiDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApiDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApiDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApiDestinationInput>
    public typealias MOutput = OperationOutput<DeleteApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApiDestinationOutputError>
}

public struct DeleteApiDestinationInput: Equatable {
    /// <p>The name of the destination to delete.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteApiDestinationInputBody: Equatable {
    public let name: String?
}

extension DeleteApiDestinationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteApiDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApiDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApiDestinationOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApiDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApiDestinationOutputResponse()"}
}

extension DeleteApiDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApiDestinationOutputResponse: Equatable {

    public init() {}
}

struct DeleteApiDestinationOutputResponseBody: Equatable {
}

extension DeleteApiDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteArchiveInputBodyMiddleware: Middleware {
    public let id: String = "DeleteArchiveInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteArchiveInput>
    public typealias MOutput = OperationOutput<DeleteArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteArchiveOutputError>
}

extension DeleteArchiveInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteArchiveInput(archiveName: \(String(describing: archiveName)))"}
}

extension DeleteArchiveInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case archiveName = "ArchiveName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveName = archiveName {
            try encodeContainer.encode(archiveName, forKey: .archiveName)
        }
    }
}

public struct DeleteArchiveInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteArchiveInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteArchiveInput>
    public typealias MOutput = OperationOutput<DeleteArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteArchiveOutputError>
}

public struct DeleteArchiveInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteArchiveInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteArchiveInput>
    public typealias MOutput = OperationOutput<DeleteArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteArchiveOutputError>
}

public struct DeleteArchiveInput: Equatable {
    /// <p>The name of the archive to delete.</p>
    public let archiveName: String?

    public init (
        archiveName: String? = nil
    )
    {
        self.archiveName = archiveName
    }
}

struct DeleteArchiveInputBody: Equatable {
    public let archiveName: String?
}

extension DeleteArchiveInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case archiveName = "ArchiveName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .archiveName)
        archiveName = archiveNameDecoded
    }
}

extension DeleteArchiveOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteArchiveOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteArchiveOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteArchiveOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteArchiveOutputResponse()"}
}

extension DeleteArchiveOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteArchiveOutputResponse: Equatable {

    public init() {}
}

struct DeleteArchiveOutputResponseBody: Equatable {
}

extension DeleteArchiveOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteConnectionInputBodyMiddleware: Middleware {
    public let id: String = "DeleteConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionOutputError>
}

extension DeleteConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConnectionInput(name: \(String(describing: name)))"}
}

extension DeleteConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInput: Equatable {
    /// <p>The name of the connection to delete.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteConnectionInputBody: Equatable {
    public let name: String?
}

extension DeleteConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConnectionOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConnectionOutputResponse(connectionArn: \(String(describing: connectionArn)), connectionState: \(String(describing: connectionState)), creationTime: \(String(describing: creationTime)), lastAuthorizedTime: \(String(describing: lastAuthorizedTime)), lastModifiedTime: \(String(describing: lastModifiedTime)))"}
}

extension DeleteConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteConnectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connectionArn = output.connectionArn
            self.connectionState = output.connectionState
            self.creationTime = output.creationTime
            self.lastAuthorizedTime = output.lastAuthorizedTime
            self.lastModifiedTime = output.lastModifiedTime
        } else {
            self.connectionArn = nil
            self.connectionState = nil
            self.creationTime = nil
            self.lastAuthorizedTime = nil
            self.lastModifiedTime = nil
        }
    }
}

public struct DeleteConnectionOutputResponse: Equatable {
    /// <p>The ARN of the connection that was deleted.</p>
    public let connectionArn: String?
    /// <p>The state of the connection before it was deleted.</p>
    public let connectionState: ConnectionState?
    /// <p>A time stamp for the time that the connection was created.</p>
    public let creationTime: Date?
    /// <p>A time stamp for the time that the connection was last authorized before it wa
    ///       deleted.</p>
    public let lastAuthorizedTime: Date?
    /// <p>A time stamp for the time that the connection was last modified before it was
    ///       deleted.</p>
    public let lastModifiedTime: Date?

    public init (
        connectionArn: String? = nil,
        connectionState: ConnectionState? = nil,
        creationTime: Date? = nil,
        lastAuthorizedTime: Date? = nil,
        lastModifiedTime: Date? = nil
    )
    {
        self.connectionArn = connectionArn
        self.connectionState = connectionState
        self.creationTime = creationTime
        self.lastAuthorizedTime = lastAuthorizedTime
        self.lastModifiedTime = lastModifiedTime
    }
}

struct DeleteConnectionOutputResponseBody: Equatable {
    public let connectionArn: String?
    public let connectionState: ConnectionState?
    public let creationTime: Date?
    public let lastModifiedTime: Date?
    public let lastAuthorizedTime: Date?
}

extension DeleteConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionArn = "ConnectionArn"
        case connectionState = "ConnectionState"
        case creationTime = "CreationTime"
        case lastAuthorizedTime = "LastAuthorizedTime"
        case lastModifiedTime = "LastModifiedTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastAuthorizedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAuthorizedTime)
        lastAuthorizedTime = lastAuthorizedTimeDecoded
    }
}

public struct DeleteEventBusInputBodyMiddleware: Middleware {
    public let id: String = "DeleteEventBusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventBusInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventBusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventBusInput>
    public typealias MOutput = OperationOutput<DeleteEventBusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventBusOutputError>
}

extension DeleteEventBusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventBusInput(name: \(String(describing: name)))"}
}

extension DeleteEventBusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteEventBusInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEventBusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventBusInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventBusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventBusInput>
    public typealias MOutput = OperationOutput<DeleteEventBusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventBusOutputError>
}

public struct DeleteEventBusInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEventBusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventBusInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventBusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventBusInput>
    public typealias MOutput = OperationOutput<DeleteEventBusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventBusOutputError>
}

public struct DeleteEventBusInput: Equatable {
    /// <p>The name of the event bus to delete.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteEventBusInputBody: Equatable {
    public let name: String?
}

extension DeleteEventBusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DeleteEventBusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEventBusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventBusOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventBusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventBusOutputResponse()"}
}

extension DeleteEventBusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEventBusOutputResponse: Equatable {

    public init() {}
}

struct DeleteEventBusOutputResponseBody: Equatable {
}

extension DeleteEventBusOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeletePartnerEventSourceInputBodyMiddleware: Middleware {
    public let id: String = "DeletePartnerEventSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePartnerEventSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePartnerEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePartnerEventSourceInput>
    public typealias MOutput = OperationOutput<DeletePartnerEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePartnerEventSourceOutputError>
}

extension DeletePartnerEventSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePartnerEventSourceInput(account: \(String(describing: account)), name: \(String(describing: name)))"}
}

extension DeletePartnerEventSourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case account = "Account"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let account = account {
            try encodeContainer.encode(account, forKey: .account)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeletePartnerEventSourceInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePartnerEventSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePartnerEventSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePartnerEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePartnerEventSourceInput>
    public typealias MOutput = OperationOutput<DeletePartnerEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePartnerEventSourceOutputError>
}

public struct DeletePartnerEventSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePartnerEventSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePartnerEventSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePartnerEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePartnerEventSourceInput>
    public typealias MOutput = OperationOutput<DeletePartnerEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePartnerEventSourceOutputError>
}

public struct DeletePartnerEventSourceInput: Equatable {
    /// <p>The AWS account ID of the AWS customer that the event source was created for.</p>
    public let account: String?
    /// <p>The name of the event source to delete.</p>
    public let name: String?

    public init (
        account: String? = nil,
        name: String? = nil
    )
    {
        self.account = account
        self.name = name
    }
}

struct DeletePartnerEventSourceInputBody: Equatable {
    public let name: String?
    public let account: String?
}

extension DeletePartnerEventSourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case account = "Account"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let accountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .account)
        account = accountDecoded
    }
}

extension DeletePartnerEventSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePartnerEventSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePartnerEventSourceOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePartnerEventSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePartnerEventSourceOutputResponse()"}
}

extension DeletePartnerEventSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeletePartnerEventSourceOutputResponse: Equatable {

    public init() {}
}

struct DeletePartnerEventSourceOutputResponseBody: Equatable {
}

extension DeletePartnerEventSourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteRuleInputBodyMiddleware: Middleware {
    public let id: String = "DeleteRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRuleInput>
    public typealias MOutput = OperationOutput<DeleteRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRuleOutputError>
}

extension DeleteRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRuleInput(eventBusName: \(String(describing: eventBusName)), force: \(String(describing: force)), name: \(String(describing: name)))"}
}

extension DeleteRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventBusName = "EventBusName"
        case force = "Force"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if force != false {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DeleteRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRuleInput>
    public typealias MOutput = OperationOutput<DeleteRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRuleOutputError>
}

public struct DeleteRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRuleInput>
    public typealias MOutput = OperationOutput<DeleteRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRuleOutputError>
}

public struct DeleteRuleInput: Equatable {
    /// <p>The name or ARN of the event bus associated with the rule. If you omit this, the default
    ///       event bus is used.</p>
    public let eventBusName: String?
    /// <p>If this is a managed rule, created by an AWS service on your behalf, you must specify
    ///         <code>Force</code> as <code>True</code> to delete the rule. This parameter is ignored for
    ///       rules that are not managed rules. You can check whether a rule is a managed rule by using
    ///         <code>DescribeRule</code> or <code>ListRules</code> and checking the <code>ManagedBy</code>
    ///       field of the response.</p>
    public let force: Bool
    /// <p>The name of the rule.</p>
    public let name: String?

    public init (
        eventBusName: String? = nil,
        force: Bool = false,
        name: String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.force = force
        self.name = name
    }
}

struct DeleteRuleInputBody: Equatable {
    public let name: String?
    public let eventBusName: String?
    public let force: Bool
}

extension DeleteRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventBusName = "EventBusName"
        case force = "Force"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let forceDecoded = try containerValues.decode(Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension DeleteRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRuleOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRuleOutputResponse()"}
}

extension DeleteRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRuleOutputResponse: Equatable {

    public init() {}
}

struct DeleteRuleOutputResponseBody: Equatable {
}

extension DeleteRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeApiDestinationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeApiDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApiDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApiDestinationInput>
    public typealias MOutput = OperationOutput<DescribeApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApiDestinationOutputError>
}

extension DescribeApiDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApiDestinationInput(name: \(String(describing: name)))"}
}

extension DescribeApiDestinationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DescribeApiDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeApiDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApiDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApiDestinationInput>
    public typealias MOutput = OperationOutput<DescribeApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApiDestinationOutputError>
}

public struct DescribeApiDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeApiDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApiDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApiDestinationInput>
    public typealias MOutput = OperationOutput<DescribeApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApiDestinationOutputError>
}

public struct DescribeApiDestinationInput: Equatable {
    /// <p>The name of the API destination to retrieve.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeApiDestinationInputBody: Equatable {
    public let name: String?
}

extension DescribeApiDestinationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribeApiDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApiDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeApiDestinationOutputError: Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApiDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApiDestinationOutputResponse(apiDestinationArn: \(String(describing: apiDestinationArn)), apiDestinationState: \(String(describing: apiDestinationState)), connectionArn: \(String(describing: connectionArn)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), httpMethod: \(String(describing: httpMethod)), invocationEndpoint: \(String(describing: invocationEndpoint)), invocationRateLimitPerSecond: \(String(describing: invocationRateLimitPerSecond)), lastModifiedTime: \(String(describing: lastModifiedTime)), name: \(String(describing: name)))"}
}

extension DescribeApiDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeApiDestinationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiDestinationArn = output.apiDestinationArn
            self.apiDestinationState = output.apiDestinationState
            self.connectionArn = output.connectionArn
            self.creationTime = output.creationTime
            self.description = output.description
            self.httpMethod = output.httpMethod
            self.invocationEndpoint = output.invocationEndpoint
            self.invocationRateLimitPerSecond = output.invocationRateLimitPerSecond
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
        } else {
            self.apiDestinationArn = nil
            self.apiDestinationState = nil
            self.connectionArn = nil
            self.creationTime = nil
            self.description = nil
            self.httpMethod = nil
            self.invocationEndpoint = nil
            self.invocationRateLimitPerSecond = nil
            self.lastModifiedTime = nil
            self.name = nil
        }
    }
}

public struct DescribeApiDestinationOutputResponse: Equatable {
    /// <p>The ARN of the API destination retrieved.</p>
    public let apiDestinationArn: String?
    /// <p>The state of the API destination retrieved.</p>
    public let apiDestinationState: ApiDestinationState?
    /// <p>The ARN of the connection specified for the API destination retrieved.</p>
    public let connectionArn: String?
    /// <p>A time stamp for the time that the API destination was created.</p>
    public let creationTime: Date?
    /// <p>The description for the API destination retrieved.</p>
    public let description: String?
    /// <p>The method to use to connect to the HTTP endpoint.</p>
    public let httpMethod: ApiDestinationHttpMethod?
    /// <p>The URL to use to connect to the HTTP endpoint.</p>
    public let invocationEndpoint: String?
    /// <p>The maximum number of invocations per second to specified for the API destination. Note
    ///       that if you set the invocation rate maximum to a value lower the rate necessary to send all
    ///       events received on to the destination HTTP endpoint, some events may not be delivered within
    ///       the 24-hour retry window. If you plan to set the rate lower than the rate necessary to deliver
    ///       all events, consider using a dead-letter queue to catch events that are not delivered within
    ///       24 hours.</p>
    public let invocationRateLimitPerSecond: Int?
    /// <p>A time stamp for the time that the API destination was last modified.</p>
    public let lastModifiedTime: Date?
    /// <p>The name of the API destination retrieved.</p>
    public let name: String?

    public init (
        apiDestinationArn: String? = nil,
        apiDestinationState: ApiDestinationState? = nil,
        connectionArn: String? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        httpMethod: ApiDestinationHttpMethod? = nil,
        invocationEndpoint: String? = nil,
        invocationRateLimitPerSecond: Int? = nil,
        lastModifiedTime: Date? = nil,
        name: String? = nil
    )
    {
        self.apiDestinationArn = apiDestinationArn
        self.apiDestinationState = apiDestinationState
        self.connectionArn = connectionArn
        self.creationTime = creationTime
        self.description = description
        self.httpMethod = httpMethod
        self.invocationEndpoint = invocationEndpoint
        self.invocationRateLimitPerSecond = invocationRateLimitPerSecond
        self.lastModifiedTime = lastModifiedTime
        self.name = name
    }
}

struct DescribeApiDestinationOutputResponseBody: Equatable {
    public let apiDestinationArn: String?
    public let name: String?
    public let description: String?
    public let apiDestinationState: ApiDestinationState?
    public let connectionArn: String?
    public let invocationEndpoint: String?
    public let httpMethod: ApiDestinationHttpMethod?
    public let invocationRateLimitPerSecond: Int?
    public let creationTime: Date?
    public let lastModifiedTime: Date?
}

extension DescribeApiDestinationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiDestinationArn = "ApiDestinationArn"
        case apiDestinationState = "ApiDestinationState"
        case connectionArn = "ConnectionArn"
        case creationTime = "CreationTime"
        case description = "Description"
        case httpMethod = "HttpMethod"
        case invocationEndpoint = "InvocationEndpoint"
        case invocationRateLimitPerSecond = "InvocationRateLimitPerSecond"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDestinationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiDestinationArn)
        apiDestinationArn = apiDestinationArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let apiDestinationStateDecoded = try containerValues.decodeIfPresent(ApiDestinationState.self, forKey: .apiDestinationState)
        apiDestinationState = apiDestinationStateDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let invocationEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invocationEndpoint)
        invocationEndpoint = invocationEndpointDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(ApiDestinationHttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let invocationRateLimitPerSecondDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .invocationRateLimitPerSecond)
        invocationRateLimitPerSecond = invocationRateLimitPerSecondDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

public struct DescribeArchiveInputBodyMiddleware: Middleware {
    public let id: String = "DescribeArchiveInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeArchiveInput>
    public typealias MOutput = OperationOutput<DescribeArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeArchiveOutputError>
}

extension DescribeArchiveInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeArchiveInput(archiveName: \(String(describing: archiveName)))"}
}

extension DescribeArchiveInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case archiveName = "ArchiveName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveName = archiveName {
            try encodeContainer.encode(archiveName, forKey: .archiveName)
        }
    }
}

public struct DescribeArchiveInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeArchiveInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeArchiveInput>
    public typealias MOutput = OperationOutput<DescribeArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeArchiveOutputError>
}

public struct DescribeArchiveInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeArchiveInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeArchiveInput>
    public typealias MOutput = OperationOutput<DescribeArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeArchiveOutputError>
}

public struct DescribeArchiveInput: Equatable {
    /// <p>The name of the archive to retrieve.</p>
    public let archiveName: String?

    public init (
        archiveName: String? = nil
    )
    {
        self.archiveName = archiveName
    }
}

struct DescribeArchiveInputBody: Equatable {
    public let archiveName: String?
}

extension DescribeArchiveInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case archiveName = "ArchiveName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .archiveName)
        archiveName = archiveNameDecoded
    }
}

extension DescribeArchiveOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeArchiveOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeArchiveOutputError: Equatable {
    case internalException(InternalException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeArchiveOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeArchiveOutputResponse(archiveArn: \(String(describing: archiveArn)), archiveName: \(String(describing: archiveName)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), eventCount: \(String(describing: eventCount)), eventPattern: \(String(describing: eventPattern)), eventSourceArn: \(String(describing: eventSourceArn)), retentionDays: \(String(describing: retentionDays)), sizeBytes: \(String(describing: sizeBytes)), state: \(String(describing: state)), stateReason: \(String(describing: stateReason)))"}
}

extension DescribeArchiveOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeArchiveOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.archiveArn = output.archiveArn
            self.archiveName = output.archiveName
            self.creationTime = output.creationTime
            self.description = output.description
            self.eventCount = output.eventCount
            self.eventPattern = output.eventPattern
            self.eventSourceArn = output.eventSourceArn
            self.retentionDays = output.retentionDays
            self.sizeBytes = output.sizeBytes
            self.state = output.state
            self.stateReason = output.stateReason
        } else {
            self.archiveArn = nil
            self.archiveName = nil
            self.creationTime = nil
            self.description = nil
            self.eventCount = 0
            self.eventPattern = nil
            self.eventSourceArn = nil
            self.retentionDays = nil
            self.sizeBytes = 0
            self.state = nil
            self.stateReason = nil
        }
    }
}

public struct DescribeArchiveOutputResponse: Equatable {
    /// <p>The ARN of the archive.</p>
    public let archiveArn: String?
    /// <p>The name of the archive.</p>
    public let archiveName: String?
    /// <p>The time at which the archive was created.</p>
    public let creationTime: Date?
    /// <p>The description of the archive.</p>
    public let description: String?
    /// <p>The number of events in the archive.</p>
    public let eventCount: Int
    /// <p>The event pattern used to filter events sent to the archive.</p>
    public let eventPattern: String?
    /// <p>The ARN of the event source associated with the archive.</p>
    public let eventSourceArn: String?
    /// <p>The number of days to retain events for in the archive.</p>
    public let retentionDays: Int?
    /// <p>The size of the archive in bytes.</p>
    public let sizeBytes: Int
    /// <p>The state of the archive.</p>
    public let state: ArchiveState?
    /// <p>The reason that the archive is in the state.</p>
    public let stateReason: String?

    public init (
        archiveArn: String? = nil,
        archiveName: String? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        eventCount: Int = 0,
        eventPattern: String? = nil,
        eventSourceArn: String? = nil,
        retentionDays: Int? = nil,
        sizeBytes: Int = 0,
        state: ArchiveState? = nil,
        stateReason: String? = nil
    )
    {
        self.archiveArn = archiveArn
        self.archiveName = archiveName
        self.creationTime = creationTime
        self.description = description
        self.eventCount = eventCount
        self.eventPattern = eventPattern
        self.eventSourceArn = eventSourceArn
        self.retentionDays = retentionDays
        self.sizeBytes = sizeBytes
        self.state = state
        self.stateReason = stateReason
    }
}

struct DescribeArchiveOutputResponseBody: Equatable {
    public let archiveArn: String?
    public let archiveName: String?
    public let eventSourceArn: String?
    public let description: String?
    public let eventPattern: String?
    public let state: ArchiveState?
    public let stateReason: String?
    public let retentionDays: Int?
    public let sizeBytes: Int
    public let eventCount: Int
    public let creationTime: Date?
}

extension DescribeArchiveOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case archiveArn = "ArchiveArn"
        case archiveName = "ArchiveName"
        case creationTime = "CreationTime"
        case description = "Description"
        case eventCount = "EventCount"
        case eventPattern = "EventPattern"
        case eventSourceArn = "EventSourceArn"
        case retentionDays = "RetentionDays"
        case sizeBytes = "SizeBytes"
        case state = "State"
        case stateReason = "StateReason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .archiveArn)
        archiveArn = archiveArnDecoded
        let archiveNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .archiveName)
        archiveName = archiveNameDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ArchiveState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let retentionDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .retentionDays)
        retentionDays = retentionDaysDecoded
        let sizeBytesDecoded = try containerValues.decode(Int.self, forKey: .sizeBytes)
        sizeBytes = sizeBytesDecoded
        let eventCountDecoded = try containerValues.decode(Int.self, forKey: .eventCount)
        eventCount = eventCountDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

public struct DescribeConnectionInputBodyMiddleware: Middleware {
    public let id: String = "DescribeConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectionInput>
    public typealias MOutput = OperationOutput<DescribeConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectionOutputError>
}

extension DescribeConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConnectionInput(name: \(String(describing: name)))"}
}

extension DescribeConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DescribeConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectionInput>
    public typealias MOutput = OperationOutput<DescribeConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectionOutputError>
}

public struct DescribeConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeConnectionInput>
    public typealias MOutput = OperationOutput<DescribeConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeConnectionOutputError>
}

public struct DescribeConnectionInput: Equatable {
    /// <p>The name of the connection to retrieve.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeConnectionInputBody: Equatable {
    public let name: String?
}

extension DescribeConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribeConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConnectionOutputError: Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeConnectionOutputResponse(authParameters: \(String(describing: authParameters)), authorizationType: \(String(describing: authorizationType)), connectionArn: \(String(describing: connectionArn)), connectionState: \(String(describing: connectionState)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), lastAuthorizedTime: \(String(describing: lastAuthorizedTime)), lastModifiedTime: \(String(describing: lastModifiedTime)), name: \(String(describing: name)), secretArn: \(String(describing: secretArn)), stateReason: \(String(describing: stateReason)))"}
}

extension DescribeConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeConnectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.authParameters = output.authParameters
            self.authorizationType = output.authorizationType
            self.connectionArn = output.connectionArn
            self.connectionState = output.connectionState
            self.creationTime = output.creationTime
            self.description = output.description
            self.lastAuthorizedTime = output.lastAuthorizedTime
            self.lastModifiedTime = output.lastModifiedTime
            self.name = output.name
            self.secretArn = output.secretArn
            self.stateReason = output.stateReason
        } else {
            self.authParameters = nil
            self.authorizationType = nil
            self.connectionArn = nil
            self.connectionState = nil
            self.creationTime = nil
            self.description = nil
            self.lastAuthorizedTime = nil
            self.lastModifiedTime = nil
            self.name = nil
            self.secretArn = nil
            self.stateReason = nil
        }
    }
}

public struct DescribeConnectionOutputResponse: Equatable {
    /// <p>The parameters to use for authorization for the connection.</p>
    public let authParameters: ConnectionAuthResponseParameters?
    /// <p>The type of authorization specified for the connection.</p>
    public let authorizationType: ConnectionAuthorizationType?
    /// <p>The ARN of the connection retrieved.</p>
    public let connectionArn: String?
    /// <p>The state of the connection retrieved.</p>
    public let connectionState: ConnectionState?
    /// <p>A time stamp for the time that the connection was created.</p>
    public let creationTime: Date?
    /// <p>The description for the connection retrieved.</p>
    public let description: String?
    /// <p>A time stamp for the time that the connection was last authorized.</p>
    public let lastAuthorizedTime: Date?
    /// <p>A time stamp for the time that the connection was last modified.</p>
    public let lastModifiedTime: Date?
    /// <p>The name of the connection retrieved.</p>
    public let name: String?
    /// <p>The ARN of the secret created from the authorization parameters specified for the
    ///       connection.</p>
    public let secretArn: String?
    /// <p>The reason that the connection is in the current connection state.</p>
    public let stateReason: String?

    public init (
        authParameters: ConnectionAuthResponseParameters? = nil,
        authorizationType: ConnectionAuthorizationType? = nil,
        connectionArn: String? = nil,
        connectionState: ConnectionState? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        lastAuthorizedTime: Date? = nil,
        lastModifiedTime: Date? = nil,
        name: String? = nil,
        secretArn: String? = nil,
        stateReason: String? = nil
    )
    {
        self.authParameters = authParameters
        self.authorizationType = authorizationType
        self.connectionArn = connectionArn
        self.connectionState = connectionState
        self.creationTime = creationTime
        self.description = description
        self.lastAuthorizedTime = lastAuthorizedTime
        self.lastModifiedTime = lastModifiedTime
        self.name = name
        self.secretArn = secretArn
        self.stateReason = stateReason
    }
}

struct DescribeConnectionOutputResponseBody: Equatable {
    public let connectionArn: String?
    public let name: String?
    public let description: String?
    public let connectionState: ConnectionState?
    public let stateReason: String?
    public let authorizationType: ConnectionAuthorizationType?
    public let secretArn: String?
    public let authParameters: ConnectionAuthResponseParameters?
    public let creationTime: Date?
    public let lastModifiedTime: Date?
    public let lastAuthorizedTime: Date?
}

extension DescribeConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authParameters = "AuthParameters"
        case authorizationType = "AuthorizationType"
        case connectionArn = "ConnectionArn"
        case connectionState = "ConnectionState"
        case creationTime = "CreationTime"
        case description = "Description"
        case lastAuthorizedTime = "LastAuthorizedTime"
        case lastModifiedTime = "LastModifiedTime"
        case name = "Name"
        case secretArn = "SecretArn"
        case stateReason = "StateReason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(ConnectionAuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let secretArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretArn)
        secretArn = secretArnDecoded
        let authParametersDecoded = try containerValues.decodeIfPresent(ConnectionAuthResponseParameters.self, forKey: .authParameters)
        authParameters = authParametersDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastAuthorizedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAuthorizedTime)
        lastAuthorizedTime = lastAuthorizedTimeDecoded
    }
}

public struct DescribeEventBusInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventBusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventBusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventBusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventBusInput>
    public typealias MOutput = OperationOutput<DescribeEventBusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventBusOutputError>
}

extension DescribeEventBusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventBusInput(name: \(String(describing: name)))"}
}

extension DescribeEventBusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DescribeEventBusInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventBusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventBusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventBusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventBusInput>
    public typealias MOutput = OperationOutput<DescribeEventBusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventBusOutputError>
}

public struct DescribeEventBusInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventBusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventBusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventBusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventBusInput>
    public typealias MOutput = OperationOutput<DescribeEventBusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventBusOutputError>
}

public struct DescribeEventBusInput: Equatable {
    /// <p>The name or ARN of the event bus to show details for. If you omit this, the default event
    ///       bus is displayed.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeEventBusInputBody: Equatable {
    public let name: String?
}

extension DescribeEventBusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribeEventBusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventBusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventBusOutputError: Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventBusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventBusOutputResponse(arn: \(String(describing: arn)), name: \(String(describing: name)), policy: \(String(describing: policy)))"}
}

extension DescribeEventBusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventBusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.name = output.name
            self.policy = output.policy
        } else {
            self.arn = nil
            self.name = nil
            self.policy = nil
        }
    }
}

public struct DescribeEventBusOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the account permitted to write events to the current
    ///       account.</p>
    public let arn: String?
    /// <p>The name of the event bus. Currently, this is always <code>default</code>.</p>
    public let name: String?
    /// <p>The policy that enables the external account to send events to your account.</p>
    public let policy: String?

    public init (
        arn: String? = nil,
        name: String? = nil,
        policy: String? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.policy = policy
    }
}

struct DescribeEventBusOutputResponseBody: Equatable {
    public let name: String?
    public let arn: String?
    public let policy: String?
}

extension DescribeEventBusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case name = "Name"
        case policy = "Policy"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

public struct DescribeEventSourceInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventSourceInput>
    public typealias MOutput = OperationOutput<DescribeEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventSourceOutputError>
}

extension DescribeEventSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventSourceInput(name: \(String(describing: name)))"}
}

extension DescribeEventSourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DescribeEventSourceInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventSourceInput>
    public typealias MOutput = OperationOutput<DescribeEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventSourceOutputError>
}

public struct DescribeEventSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventSourceInput>
    public typealias MOutput = OperationOutput<DescribeEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventSourceOutputError>
}

public struct DescribeEventSourceInput: Equatable {
    /// <p>The name of the partner event source to display the details of.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeEventSourceInputBody: Equatable {
    public let name: String?
}

extension DescribeEventSourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribeEventSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventSourceOutputError: Equatable {
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventSourceOutputResponse(arn: \(String(describing: arn)), createdBy: \(String(describing: createdBy)), creationTime: \(String(describing: creationTime)), expirationTime: \(String(describing: expirationTime)), name: \(String(describing: name)), state: \(String(describing: state)))"}
}

extension DescribeEventSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventSourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.createdBy = output.createdBy
            self.creationTime = output.creationTime
            self.expirationTime = output.expirationTime
            self.name = output.name
            self.state = output.state
        } else {
            self.arn = nil
            self.createdBy = nil
            self.creationTime = nil
            self.expirationTime = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct DescribeEventSourceOutputResponse: Equatable {
    /// <p>The ARN of the partner event source.</p>
    public let arn: String?
    /// <p>The name of the SaaS partner that created the event source.</p>
    public let createdBy: String?
    /// <p>The date and time that the event source was created.</p>
    public let creationTime: Date?
    /// <p>The date and time that the event source will expire if you do not create a matching event
    ///       bus.</p>
    public let expirationTime: Date?
    /// <p>The name of the partner event source.</p>
    public let name: String?
    /// <p>The state of the event source. If it is ACTIVE, you have already created a matching event
    ///       bus for this event source, and that event bus is active. If it is PENDING, either you haven't
    ///       yet created a matching event bus, or that event bus is deactivated. If it is DELETED, you have
    ///       created a matching event bus, but the event source has since been deleted.</p>
    public let state: EventSourceState?

    public init (
        arn: String? = nil,
        createdBy: String? = nil,
        creationTime: Date? = nil,
        expirationTime: Date? = nil,
        name: String? = nil,
        state: EventSourceState? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.creationTime = creationTime
        self.expirationTime = expirationTime
        self.name = name
        self.state = state
    }
}

struct DescribeEventSourceOutputResponseBody: Equatable {
    public let arn: String?
    public let createdBy: String?
    public let creationTime: Date?
    public let expirationTime: Date?
    public let name: String?
    public let state: EventSourceState?
}

extension DescribeEventSourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdBy = "CreatedBy"
        case creationTime = "CreationTime"
        case expirationTime = "ExpirationTime"
        case name = "Name"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventSourceState.self, forKey: .state)
        state = stateDecoded
    }
}

public struct DescribePartnerEventSourceInputBodyMiddleware: Middleware {
    public let id: String = "DescribePartnerEventSourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePartnerEventSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePartnerEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePartnerEventSourceInput>
    public typealias MOutput = OperationOutput<DescribePartnerEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePartnerEventSourceOutputError>
}

extension DescribePartnerEventSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePartnerEventSourceInput(name: \(String(describing: name)))"}
}

extension DescribePartnerEventSourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DescribePartnerEventSourceInputHeadersMiddleware: Middleware {
    public let id: String = "DescribePartnerEventSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePartnerEventSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePartnerEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePartnerEventSourceInput>
    public typealias MOutput = OperationOutput<DescribePartnerEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePartnerEventSourceOutputError>
}

public struct DescribePartnerEventSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribePartnerEventSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribePartnerEventSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribePartnerEventSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribePartnerEventSourceInput>
    public typealias MOutput = OperationOutput<DescribePartnerEventSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribePartnerEventSourceOutputError>
}

public struct DescribePartnerEventSourceInput: Equatable {
    /// <p>The name of the event source to display.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DescribePartnerEventSourceInputBody: Equatable {
    public let name: String?
}

extension DescribePartnerEventSourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribePartnerEventSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePartnerEventSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePartnerEventSourceOutputError: Equatable {
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePartnerEventSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribePartnerEventSourceOutputResponse(arn: \(String(describing: arn)), name: \(String(describing: name)))"}
}

extension DescribePartnerEventSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribePartnerEventSourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct DescribePartnerEventSourceOutputResponse: Equatable {
    /// <p>The ARN of the event source.</p>
    public let arn: String?
    /// <p>The name of the event source.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct DescribePartnerEventSourceOutputResponseBody: Equatable {
    public let arn: String?
    public let name: String?
}

extension DescribePartnerEventSourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct DescribeReplayInputBodyMiddleware: Middleware {
    public let id: String = "DescribeReplayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplayInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplayInput>
    public typealias MOutput = OperationOutput<DescribeReplayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplayOutputError>
}

extension DescribeReplayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReplayInput(replayName: \(String(describing: replayName)))"}
}

extension DescribeReplayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case replayName = "ReplayName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replayName = replayName {
            try encodeContainer.encode(replayName, forKey: .replayName)
        }
    }
}

public struct DescribeReplayInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeReplayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplayInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplayInput>
    public typealias MOutput = OperationOutput<DescribeReplayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplayOutputError>
}

public struct DescribeReplayInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeReplayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeReplayInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeReplayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeReplayInput>
    public typealias MOutput = OperationOutput<DescribeReplayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeReplayOutputError>
}

public struct DescribeReplayInput: Equatable {
    /// <p>The name of the replay to retrieve.</p>
    public let replayName: String?

    public init (
        replayName: String? = nil
    )
    {
        self.replayName = replayName
    }
}

struct DescribeReplayInputBody: Equatable {
    public let replayName: String?
}

extension DescribeReplayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replayName = "ReplayName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replayName)
        replayName = replayNameDecoded
    }
}

extension DescribeReplayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReplayOutputError: Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeReplayOutputResponse(description: \(String(describing: description)), destination: \(String(describing: destination)), eventEndTime: \(String(describing: eventEndTime)), eventLastReplayedTime: \(String(describing: eventLastReplayedTime)), eventSourceArn: \(String(describing: eventSourceArn)), eventStartTime: \(String(describing: eventStartTime)), replayArn: \(String(describing: replayArn)), replayEndTime: \(String(describing: replayEndTime)), replayName: \(String(describing: replayName)), replayStartTime: \(String(describing: replayStartTime)), state: \(String(describing: state)), stateReason: \(String(describing: stateReason)))"}
}

extension DescribeReplayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeReplayOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.description = output.description
            self.destination = output.destination
            self.eventEndTime = output.eventEndTime
            self.eventLastReplayedTime = output.eventLastReplayedTime
            self.eventSourceArn = output.eventSourceArn
            self.eventStartTime = output.eventStartTime
            self.replayArn = output.replayArn
            self.replayEndTime = output.replayEndTime
            self.replayName = output.replayName
            self.replayStartTime = output.replayStartTime
            self.state = output.state
            self.stateReason = output.stateReason
        } else {
            self.description = nil
            self.destination = nil
            self.eventEndTime = nil
            self.eventLastReplayedTime = nil
            self.eventSourceArn = nil
            self.eventStartTime = nil
            self.replayArn = nil
            self.replayEndTime = nil
            self.replayName = nil
            self.replayStartTime = nil
            self.state = nil
            self.stateReason = nil
        }
    }
}

public struct DescribeReplayOutputResponse: Equatable {
    /// <p>The description of the replay.</p>
    public let description: String?
    /// <p>A <code>ReplayDestination</code> object that contains details about the replay.</p>
    public let destination: ReplayDestination?
    /// <p>The time stamp for the last event that was replayed from the archive.</p>
    public let eventEndTime: Date?
    /// <p>The time that the event was last replayed.</p>
    public let eventLastReplayedTime: Date?
    /// <p>The ARN of the archive events were replayed from.</p>
    public let eventSourceArn: String?
    /// <p>The time stamp of the first event that was last replayed from the archive.</p>
    public let eventStartTime: Date?
    /// <p>The ARN of the replay.</p>
    public let replayArn: String?
    /// <p>A time stamp for the time that the replay stopped.</p>
    public let replayEndTime: Date?
    /// <p>The name of the replay.</p>
    public let replayName: String?
    /// <p>A time stamp for the time that the replay started.</p>
    public let replayStartTime: Date?
    /// <p>The current state of the replay.</p>
    public let state: ReplayState?
    /// <p>The reason that the replay is in the current state.</p>
    public let stateReason: String?

    public init (
        description: String? = nil,
        destination: ReplayDestination? = nil,
        eventEndTime: Date? = nil,
        eventLastReplayedTime: Date? = nil,
        eventSourceArn: String? = nil,
        eventStartTime: Date? = nil,
        replayArn: String? = nil,
        replayEndTime: Date? = nil,
        replayName: String? = nil,
        replayStartTime: Date? = nil,
        state: ReplayState? = nil,
        stateReason: String? = nil
    )
    {
        self.description = description
        self.destination = destination
        self.eventEndTime = eventEndTime
        self.eventLastReplayedTime = eventLastReplayedTime
        self.eventSourceArn = eventSourceArn
        self.eventStartTime = eventStartTime
        self.replayArn = replayArn
        self.replayEndTime = replayEndTime
        self.replayName = replayName
        self.replayStartTime = replayStartTime
        self.state = state
        self.stateReason = stateReason
    }
}

struct DescribeReplayOutputResponseBody: Equatable {
    public let replayName: String?
    public let replayArn: String?
    public let description: String?
    public let state: ReplayState?
    public let stateReason: String?
    public let eventSourceArn: String?
    public let destination: ReplayDestination?
    public let eventStartTime: Date?
    public let eventEndTime: Date?
    public let eventLastReplayedTime: Date?
    public let replayStartTime: Date?
    public let replayEndTime: Date?
}

extension DescribeReplayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case destination = "Destination"
        case eventEndTime = "EventEndTime"
        case eventLastReplayedTime = "EventLastReplayedTime"
        case eventSourceArn = "EventSourceArn"
        case eventStartTime = "EventStartTime"
        case replayArn = "ReplayArn"
        case replayEndTime = "ReplayEndTime"
        case replayName = "ReplayName"
        case replayStartTime = "ReplayStartTime"
        case state = "State"
        case stateReason = "StateReason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replayName)
        replayName = replayNameDecoded
        let replayArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replayArn)
        replayArn = replayArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ReplayState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ReplayDestination.self, forKey: .destination)
        destination = destinationDecoded
        let eventStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .eventStartTime)
        eventStartTime = eventStartTimeDecoded
        let eventEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .eventEndTime)
        eventEndTime = eventEndTimeDecoded
        let eventLastReplayedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .eventLastReplayedTime)
        eventLastReplayedTime = eventLastReplayedTimeDecoded
        let replayStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .replayStartTime)
        replayStartTime = replayStartTimeDecoded
        let replayEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .replayEndTime)
        replayEndTime = replayEndTimeDecoded
    }
}

public struct DescribeRuleInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRuleInput>
    public typealias MOutput = OperationOutput<DescribeRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRuleOutputError>
}

extension DescribeRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRuleInput(eventBusName: \(String(describing: eventBusName)), name: \(String(describing: name)))"}
}

extension DescribeRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventBusName = "EventBusName"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DescribeRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRuleInput>
    public typealias MOutput = OperationOutput<DescribeRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRuleOutputError>
}

public struct DescribeRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRuleInput>
    public typealias MOutput = OperationOutput<DescribeRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRuleOutputError>
}

public struct DescribeRuleInput: Equatable {
    /// <p>The name or ARN of the event bus associated with the rule. If you omit this, the default
    ///       event bus is used.</p>
    public let eventBusName: String?
    /// <p>The name of the rule.</p>
    public let name: String?

    public init (
        eventBusName: String? = nil,
        name: String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.name = name
    }
}

struct DescribeRuleInputBody: Equatable {
    public let name: String?
    public let eventBusName: String?
}

extension DescribeRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventBusName = "EventBusName"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
    }
}

extension DescribeRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRuleOutputError: Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRuleOutputResponse(arn: \(String(describing: arn)), createdBy: \(String(describing: createdBy)), description: \(String(describing: description)), eventBusName: \(String(describing: eventBusName)), eventPattern: \(String(describing: eventPattern)), managedBy: \(String(describing: managedBy)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), scheduleExpression: \(String(describing: scheduleExpression)), state: \(String(describing: state)))"}
}

extension DescribeRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.createdBy = output.createdBy
            self.description = output.description
            self.eventBusName = output.eventBusName
            self.eventPattern = output.eventPattern
            self.managedBy = output.managedBy
            self.name = output.name
            self.roleArn = output.roleArn
            self.scheduleExpression = output.scheduleExpression
            self.state = output.state
        } else {
            self.arn = nil
            self.createdBy = nil
            self.description = nil
            self.eventBusName = nil
            self.eventPattern = nil
            self.managedBy = nil
            self.name = nil
            self.roleArn = nil
            self.scheduleExpression = nil
            self.state = nil
        }
    }
}

public struct DescribeRuleOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the rule.</p>
    public let arn: String?
    /// <p>The account ID of the user that created the rule. If you use <code>PutRule</code> to put a
    ///       rule on an event bus in another account, the other account is the owner of the rule, and the
    ///       rule ARN includes the account ID for that account. However, the value for
    ///         <code>CreatedBy</code> is the account ID as the account that created the rule in the other
    ///       account.</p>
    public let createdBy: String?
    /// <p>The description of the rule.</p>
    public let description: String?
    /// <p>The name of the event bus associated with the rule.</p>
    public let eventBusName: String?
    /// <p>The event pattern. For more information, see <a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-and-event-patterns.html">Events and Event
    ///         Patterns</a> in the <i>Amazon EventBridge User Guide</i>.</p>
    public let eventPattern: String?
    /// <p>If this is a managed rule, created by an AWS service on your behalf, this field displays
    ///       the principal name of the AWS service that created the rule.</p>
    public let managedBy: String?
    /// <p>The name of the rule.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role associated with the rule.</p>
    public let roleArn: String?
    /// <p>The scheduling expression. For example, "cron(0 20 * * ? *)", "rate(5 minutes)".</p>
    public let scheduleExpression: String?
    /// <p>Specifies whether the rule is enabled or disabled.</p>
    public let state: RuleState?

    public init (
        arn: String? = nil,
        createdBy: String? = nil,
        description: String? = nil,
        eventBusName: String? = nil,
        eventPattern: String? = nil,
        managedBy: String? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        scheduleExpression: String? = nil,
        state: RuleState? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.description = description
        self.eventBusName = eventBusName
        self.eventPattern = eventPattern
        self.managedBy = managedBy
        self.name = name
        self.roleArn = roleArn
        self.scheduleExpression = scheduleExpression
        self.state = state
    }
}

struct DescribeRuleOutputResponseBody: Equatable {
    public let name: String?
    public let arn: String?
    public let eventPattern: String?
    public let scheduleExpression: String?
    public let state: RuleState?
    public let description: String?
    public let roleArn: String?
    public let managedBy: String?
    public let eventBusName: String?
    public let createdBy: String?
}

extension DescribeRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdBy = "CreatedBy"
        case description = "Description"
        case eventBusName = "EventBusName"
        case eventPattern = "EventPattern"
        case managedBy = "ManagedBy"
        case name = "Name"
        case roleArn = "RoleArn"
        case scheduleExpression = "ScheduleExpression"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(RuleState.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let managedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .managedBy)
        managedBy = managedByDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

public struct DisableRuleInputBodyMiddleware: Middleware {
    public let id: String = "DisableRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableRuleInput>
    public typealias MOutput = OperationOutput<DisableRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableRuleOutputError>
}

extension DisableRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableRuleInput(eventBusName: \(String(describing: eventBusName)), name: \(String(describing: name)))"}
}

extension DisableRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventBusName = "EventBusName"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DisableRuleInputHeadersMiddleware: Middleware {
    public let id: String = "DisableRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableRuleInput>
    public typealias MOutput = OperationOutput<DisableRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableRuleOutputError>
}

public struct DisableRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "DisableRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisableRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<DisableRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisableRuleInput>
    public typealias MOutput = OperationOutput<DisableRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisableRuleOutputError>
}

public struct DisableRuleInput: Equatable {
    /// <p>The name or ARN of the event bus associated with the rule. If you omit this, the default
    ///       event bus is used.</p>
    public let eventBusName: String?
    /// <p>The name of the rule.</p>
    public let name: String?

    public init (
        eventBusName: String? = nil,
        name: String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.name = name
    }
}

struct DisableRuleInputBody: Equatable {
    public let name: String?
    public let eventBusName: String?
}

extension DisableRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventBusName = "EventBusName"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
    }
}

extension DisableRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableRuleOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisableRuleOutputResponse()"}
}

extension DisableRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisableRuleOutputResponse: Equatable {

    public init() {}
}

struct DisableRuleOutputResponseBody: Equatable {
}

extension DisableRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension EcsParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case group = "Group"
        case launchType = "LaunchType"
        case networkConfiguration = "NetworkConfiguration"
        case platformVersion = "PlatformVersion"
        case taskCount = "TaskCount"
        case taskDefinitionArn = "TaskDefinitionArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let group = group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let launchType = launchType {
            try encodeContainer.encode(launchType.rawValue, forKey: .launchType)
        }
        if let networkConfiguration = networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let platformVersion = platformVersion {
            try encodeContainer.encode(platformVersion, forKey: .platformVersion)
        }
        if let taskCount = taskCount {
            try encodeContainer.encode(taskCount, forKey: .taskCount)
        }
        if let taskDefinitionArn = taskDefinitionArn {
            try encodeContainer.encode(taskDefinitionArn, forKey: .taskDefinitionArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskDefinitionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskDefinitionArn)
        taskDefinitionArn = taskDefinitionArnDecoded
        let taskCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .taskCount)
        taskCount = taskCountDecoded
        let launchTypeDecoded = try containerValues.decodeIfPresent(LaunchType.self, forKey: .launchType)
        launchType = launchTypeDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let platformVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformVersion)
        platformVersion = platformVersionDecoded
        let groupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .group)
        group = groupDecoded
    }
}

extension EcsParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EcsParameters(group: \(String(describing: group)), launchType: \(String(describing: launchType)), networkConfiguration: \(String(describing: networkConfiguration)), platformVersion: \(String(describing: platformVersion)), taskCount: \(String(describing: taskCount)), taskDefinitionArn: \(String(describing: taskDefinitionArn)))"}
}

/// <p>The custom parameters to be used when the target is an Amazon ECS task.</p>
public struct EcsParameters: Equatable {
    /// <p>Specifies an ECS task group for the task. The maximum length is 255 characters.</p>
    public let group: String?
    /// <p>Specifies the launch type on which your task is running. The launch type that you specify
    ///       here must match one of the launch type (compatibilities) of the target task. The
    ///         <code>FARGATE</code> value is supported only in the Regions where AWS Fargate with Amazon
    ///       ECS is supported. For more information, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/AWS-Fargate.html">AWS Fargate on Amazon ECS</a> in
    ///       the <i>Amazon Elastic Container Service Developer Guide</i>.</p>
    public let launchType: LaunchType?
    /// <p>Use this structure if the ECS task uses the <code>awsvpc</code> network mode. This
    ///       structure specifies the VPC subnets and security groups associated with the task, and whether
    ///       a public IP address is to be used. This structure is required if <code>LaunchType</code> is
    ///         <code>FARGATE</code> because the <code>awsvpc</code> mode is required for Fargate
    ///       tasks.</p>
    ///          <p>If you specify <code>NetworkConfiguration</code> when the target ECS task does not use the
    ///         <code>awsvpc</code> network mode, the task fails.</p>
    public let networkConfiguration: NetworkConfiguration?
    /// <p>Specifies the platform version for the task. Specify only the numeric portion of the
    ///       platform version, such as <code>1.1.0</code>.</p>
    ///          <p>This structure is used only if <code>LaunchType</code> is <code>FARGATE</code>. For more
    ///       information about valid platform versions, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html">AWS Fargate Platform
    ///         Versions</a> in the <i>Amazon Elastic Container Service Developer
    ///         Guide</i>.</p>
    public let platformVersion: String?
    /// <p>The number of tasks to create based on <code>TaskDefinition</code>. The default is
    ///       1.</p>
    public let taskCount: Int?
    /// <p>The ARN of the task definition to use if the event target is an Amazon ECS task. </p>
    public let taskDefinitionArn: String?

    public init (
        group: String? = nil,
        launchType: LaunchType? = nil,
        networkConfiguration: NetworkConfiguration? = nil,
        platformVersion: String? = nil,
        taskCount: Int? = nil,
        taskDefinitionArn: String? = nil
    )
    {
        self.group = group
        self.launchType = launchType
        self.networkConfiguration = networkConfiguration
        self.platformVersion = platformVersion
        self.taskCount = taskCount
        self.taskDefinitionArn = taskDefinitionArn
    }
}

public struct EnableRuleInputBodyMiddleware: Middleware {
    public let id: String = "EnableRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableRuleInput>
    public typealias MOutput = OperationOutput<EnableRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableRuleOutputError>
}

extension EnableRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableRuleInput(eventBusName: \(String(describing: eventBusName)), name: \(String(describing: name)))"}
}

extension EnableRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventBusName = "EventBusName"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct EnableRuleInputHeadersMiddleware: Middleware {
    public let id: String = "EnableRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableRuleInput>
    public typealias MOutput = OperationOutput<EnableRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableRuleOutputError>
}

public struct EnableRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "EnableRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<EnableRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<EnableRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<EnableRuleInput>
    public typealias MOutput = OperationOutput<EnableRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<EnableRuleOutputError>
}

public struct EnableRuleInput: Equatable {
    /// <p>The name or ARN of the event bus associated with the rule. If you omit this, the default
    ///       event bus is used.</p>
    public let eventBusName: String?
    /// <p>The name of the rule.</p>
    public let name: String?

    public init (
        eventBusName: String? = nil,
        name: String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.name = name
    }
}

struct EnableRuleInputBody: Equatable {
    public let name: String?
    public let eventBusName: String?
}

extension EnableRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventBusName = "EventBusName"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
    }
}

extension EnableRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableRuleOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnableRuleOutputResponse()"}
}

extension EnableRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct EnableRuleOutputResponse: Equatable {

    public init() {}
}

struct EnableRuleOutputResponseBody: Equatable {
}

extension EnableRuleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension EventBus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case name = "Name"
        case policy = "Policy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension EventBus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventBus(arn: \(String(describing: arn)), name: \(String(describing: name)), policy: \(String(describing: policy)))"}
}

/// <p>An event bus receives events from a source and routes them to rules associated with that
///       event bus. Your account's default event bus receives rules from AWS services. A custom event
///       bus can receive rules from AWS services as well as your custom applications and services. A
///       partner event bus receives events from an event source created by an SaaS partner. These
///       events come from the partners services or applications.</p>
public struct EventBus: Equatable {
    /// <p>The ARN of the event bus.</p>
    public let arn: String?
    /// <p>The name of the event bus.</p>
    public let name: String?
    /// <p>The permissions policy of the event bus, describing which other AWS accounts can write
    ///       events to this event bus.</p>
    public let policy: String?

    public init (
        arn: String? = nil,
        name: String? = nil,
        policy: String? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.policy = policy
    }
}

extension EventSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case createdBy = "CreatedBy"
        case creationTime = "CreationTime"
        case expirationTime = "ExpirationTime"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let expirationTime = expirationTime {
            try encodeContainer.encode(expirationTime.timeIntervalSince1970, forKey: .expirationTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventSourceState.self, forKey: .state)
        state = stateDecoded
    }
}

extension EventSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventSource(arn: \(String(describing: arn)), createdBy: \(String(describing: createdBy)), creationTime: \(String(describing: creationTime)), expirationTime: \(String(describing: expirationTime)), name: \(String(describing: name)), state: \(String(describing: state)))"}
}

/// <p>A partner event source is created by an SaaS partner. If a customer creates a partner
///       event bus that matches this event source, that AWS account can receive events from the
///       partner's applications or services.</p>
public struct EventSource: Equatable {
    /// <p>The ARN of the event source.</p>
    public let arn: String?
    /// <p>The name of the partner that created the event source.</p>
    public let createdBy: String?
    /// <p>The date and time the event source was created.</p>
    public let creationTime: Date?
    /// <p>The date and time that the event source will expire, if the AWS account doesn't create a
    ///       matching event bus for it.</p>
    public let expirationTime: Date?
    /// <p>The name of the event source.</p>
    public let name: String?
    /// <p>The state of the event source. If it is ACTIVE, you have already created a matching event
    ///       bus for this event source, and that event bus is active. If it is PENDING, either you haven't
    ///       yet created a matching event bus, or that event bus is deactivated. If it is DELETED, you have
    ///       created a matching event bus, but the event source has since been deleted.</p>
    public let state: EventSourceState?

    public init (
        arn: String? = nil,
        createdBy: String? = nil,
        creationTime: Date? = nil,
        expirationTime: Date? = nil,
        name: String? = nil,
        state: EventSourceState? = nil
    )
    {
        self.arn = arn
        self.createdBy = createdBy
        self.creationTime = creationTime
        self.expirationTime = expirationTime
        self.name = name
        self.state = state
    }
}

public enum EventSourceState {
    case active
    case deleted
    case pending
    case sdkUnknown(String)
}

extension EventSourceState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventSourceState] {
        return [
            .active,
            .deleted,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deleted: return "DELETED"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventSourceState(rawValue: rawValue) ?? EventSourceState.sdkUnknown(rawValue)
    }
}

extension HttpParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case headerParameters = "HeaderParameters"
        case pathParameterValues = "PathParameterValues"
        case queryStringParameters = "QueryStringParameters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headerParameters = headerParameters {
            var headerParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .headerParameters)
            for (dictKey0, headerparametersmap0) in headerParameters {
                try headerParametersContainer.encode(headerparametersmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let pathParameterValues = pathParameterValues {
            var pathParameterValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pathParameterValues)
            for pathparameterlist0 in pathParameterValues {
                try pathParameterValuesContainer.encode(pathparameterlist0)
            }
        }
        if let queryStringParameters = queryStringParameters {
            var queryStringParametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .queryStringParameters)
            for (dictKey0, querystringparametersmap0) in queryStringParameters {
                try queryStringParametersContainer.encode(querystringparametersmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathParameterValuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .pathParameterValues)
        var pathParameterValuesDecoded0:[String]? = nil
        if let pathParameterValuesContainer = pathParameterValuesContainer {
            pathParameterValuesDecoded0 = [String]()
            for string0 in pathParameterValuesContainer {
                if let string0 = string0 {
                    pathParameterValuesDecoded0?.append(string0)
                }
            }
        }
        pathParameterValues = pathParameterValuesDecoded0
        let headerParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .headerParameters)
        var headerParametersDecoded0: [String:String]? = nil
        if let headerParametersContainer = headerParametersContainer {
            headerParametersDecoded0 = [String:String]()
            for (key0, headervalue0) in headerParametersContainer {
                if let headervalue0 = headervalue0 {
                    headerParametersDecoded0?[key0] = headervalue0
                }
            }
        }
        headerParameters = headerParametersDecoded0
        let queryStringParametersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .queryStringParameters)
        var queryStringParametersDecoded0: [String:String]? = nil
        if let queryStringParametersContainer = queryStringParametersContainer {
            queryStringParametersDecoded0 = [String:String]()
            for (key0, querystringvalue0) in queryStringParametersContainer {
                if let querystringvalue0 = querystringvalue0 {
                    queryStringParametersDecoded0?[key0] = querystringvalue0
                }
            }
        }
        queryStringParameters = queryStringParametersDecoded0
    }
}

extension HttpParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpParameters(headerParameters: \(String(describing: headerParameters)), pathParameterValues: \(String(describing: pathParameterValues)), queryStringParameters: \(String(describing: queryStringParameters)))"}
}

/// <p>These are custom parameter to be used when the target is an API Gateway REST APIs
///       or EventBridge ApiDestinations. In the latter case, these are merged with any InvocationParameters
///       specified on the Connection, with any values from the Connection taking precedence.</p>
public struct HttpParameters: Equatable {
    /// <p>The headers that need to be sent as part of request invoking the API Gateway REST
    ///       API or EventBridge ApiDestination.</p>
    public let headerParameters: [String:String]?
    /// <p>The path parameter values to be used to populate API Gateway REST API or
    ///       EventBridge ApiDestination path wildcards ("*").</p>
    public let pathParameterValues: [String]?
    /// <p>The query string keys/values that need to be sent as part of request invoking the API
    ///       Gateway REST API or EventBridge ApiDestination.</p>
    public let queryStringParameters: [String:String]?

    public init (
        headerParameters: [String:String]? = nil,
        pathParameterValues: [String]? = nil,
        queryStringParameters: [String:String]? = nil
    )
    {
        self.headerParameters = headerParameters
        self.pathParameterValues = pathParameterValues
        self.queryStringParameters = queryStringParameters
    }
}

extension IllegalStatusException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IllegalStatusException(message: \(String(describing: message)))"}
}

extension IllegalStatusException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: IllegalStatusExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error occurred because a replay can be canceled only when the state is Running or
///       Starting.</p>
public struct IllegalStatusException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct IllegalStatusExceptionBody: Equatable {
    public let message: String?
}

extension IllegalStatusExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InputTransformer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case inputPathsMap = "InputPathsMap"
        case inputTemplate = "InputTemplate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputPathsMap = inputPathsMap {
            var inputPathsMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .inputPathsMap)
            for (dictKey0, transformerpaths0) in inputPathsMap {
                try inputPathsMapContainer.encode(transformerpaths0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let inputTemplate = inputTemplate {
            try encodeContainer.encode(inputTemplate, forKey: .inputTemplate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputPathsMapContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .inputPathsMap)
        var inputPathsMapDecoded0: [String:String]? = nil
        if let inputPathsMapContainer = inputPathsMapContainer {
            inputPathsMapDecoded0 = [String:String]()
            for (key0, targetinputpath0) in inputPathsMapContainer {
                if let targetinputpath0 = targetinputpath0 {
                    inputPathsMapDecoded0?[key0] = targetinputpath0
                }
            }
        }
        inputPathsMap = inputPathsMapDecoded0
        let inputTemplateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputTemplate)
        inputTemplate = inputTemplateDecoded
    }
}

extension InputTransformer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InputTransformer(inputPathsMap: \(String(describing: inputPathsMap)), inputTemplate: \(String(describing: inputTemplate)))"}
}

/// <p>Contains the parameters needed for you to provide custom input to a target based on one or
///       more pieces of data extracted from the event.</p>
public struct InputTransformer: Equatable {
    /// <p>Map of JSON paths to be extracted from the event. You can then insert these in the
    ///       template in <code>InputTemplate</code> to produce the output you want to be sent to the
    ///       target.</p>
    ///          <p>
    ///             <code>InputPathsMap</code> is an array key-value pairs, where each value is a valid JSON
    ///       path. You can have as many as 100 key-value pairs. You must use JSON dot notation, not bracket
    ///       notation.</p>
    ///          <p>The keys cannot start with "AWS." </p>
    public let inputPathsMap: [String:String]?
    /// <p>Input template where you specify placeholders that will be filled with the values of the
    ///       keys from <code>InputPathsMap</code> to customize the data sent to the target. Enclose each
    ///         <code>InputPathsMaps</code> value in brackets: <<i>value</i>> The
    ///       InputTemplate must be valid JSON.</p>
    ///
    ///          <p>If <code>InputTemplate</code> is a JSON object (surrounded by curly braces), the following
    ///       restrictions apply:</p>
    ///          <ul>
    ///             <li>
    ///                <p>The placeholder cannot be used as an object key.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The following example shows the syntax for using <code>InputPathsMap</code> and
    ///         <code>InputTemplate</code>.</p>
    ///          <p>
    ///             <code> "InputTransformer":</code>
    ///          </p>
    ///          <p>
    ///             <code>{</code>
    ///          </p>
    ///          <p>
    ///             <code>"InputPathsMap": {"instance": "$.detail.instance","status":
    ///         "$.detail.status"},</code>
    ///          </p>
    ///          <p>
    ///             <code>"InputTemplate": "<instance> is in state <status>"</code>
    ///          </p>
    ///          <p>
    ///             <code>}</code>
    ///          </p>
    ///          <p>To have the <code>InputTemplate</code> include quote marks within a JSON string, escape
    ///       each quote marks with a slash, as in the following example:</p>
    ///          <p>
    ///             <code> "InputTransformer":</code>
    ///          </p>
    ///          <p>
    ///             <code>{</code>
    ///          </p>
    ///          <p>
    ///             <code>"InputPathsMap": {"instance": "$.detail.instance","status":
    ///         "$.detail.status"},</code>
    ///          </p>
    ///          <p>
    ///             <code>"InputTemplate": "<instance> is in state \"<status>\""</code>
    ///          </p>
    ///          <p>
    ///             <code>}</code>
    ///          </p>
    ///          <p>The <code>InputTemplate</code> can also be valid JSON with varibles in quotes or out,
    ///       as in the following example:</p>
    ///          <p>
    ///             <code> "InputTransformer":</code>
    ///          </p>
    ///          <p>
    ///             <code>{</code>
    ///          </p>
    ///          <p>
    ///             <code>"InputPathsMap": {"instance": "$.detail.instance","status":
    ///         "$.detail.status"},</code>
    ///          </p>
    ///          <p>
    ///             <code>"InputTemplate": '{"myInstance": <instance>,"myStatus":
    ///         "<instance> is in state \"<status>\""}'</code>
    ///          </p>
    ///          <p>
    ///             <code>}</code>
    ///          </p>
    public let inputTemplate: String?

    public init (
        inputPathsMap: [String:String]? = nil,
        inputTemplate: String? = nil
    )
    {
        self.inputPathsMap = inputPathsMap
        self.inputTemplate = inputTemplate
    }
}

extension InternalException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalException(message: \(String(describing: message)))"}
}

extension InternalException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This exception occurs due to unexpected causes.</p>
public struct InternalException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalExceptionBody: Equatable {
    public let message: String?
}

extension InternalExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidEventPatternException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidEventPatternException(message: \(String(describing: message)))"}
}

extension InvalidEventPatternException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidEventPatternExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The event pattern is not valid.</p>
public struct InvalidEventPatternException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidEventPatternExceptionBody: Equatable {
    public let message: String?
}

extension InvalidEventPatternExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidStateException(message: \(String(describing: message)))"}
}

extension InvalidStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified state is not a valid state for an event source.</p>
public struct InvalidStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStateExceptionBody: Equatable {
    public let message: String?
}

extension InvalidStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case partitionKeyPath = "PartitionKeyPath"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let partitionKeyPath = partitionKeyPath {
            try encodeContainer.encode(partitionKeyPath, forKey: .partitionKeyPath)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partitionKeyPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .partitionKeyPath)
        partitionKeyPath = partitionKeyPathDecoded
    }
}

extension KinesisParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisParameters(partitionKeyPath: \(String(describing: partitionKeyPath)))"}
}

/// <p>This object enables you to specify a JSON path to extract from the event and use as the
///       partition key for the Amazon Kinesis data stream, so that you can control the shard to which
///       the event goes. If you do not include this parameter, the default is to use the
///         <code>eventId</code> as the partition key.</p>
public struct KinesisParameters: Equatable {
    /// <p>The JSON path to be extracted from the event and used as the partition key. For more
    ///       information, see <a href="https://docs.aws.amazon.com/streams/latest/dev/key-concepts.html#partition-key">Amazon Kinesis Streams Key
    ///         Concepts</a> in the <i>Amazon Kinesis Streams Developer Guide</i>.</p>
    public let partitionKeyPath: String?

    public init (
        partitionKeyPath: String? = nil
    )
    {
        self.partitionKeyPath = partitionKeyPath
    }
}

public enum LaunchType {
    case ec2
    case fargate
    case sdkUnknown(String)
}

extension LaunchType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LaunchType] {
        return [
            .ec2,
            .fargate,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ec2: return "EC2"
        case .fargate: return "FARGATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LaunchType(rawValue: rawValue) ?? LaunchType.sdkUnknown(rawValue)
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request failed because it attempted to create resource beyond the allowed service
///       quota.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListApiDestinationsInputBodyMiddleware: Middleware {
    public let id: String = "ListApiDestinationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApiDestinationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApiDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApiDestinationsInput>
    public typealias MOutput = OperationOutput<ListApiDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApiDestinationsOutputError>
}

extension ListApiDestinationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApiDestinationsInput(connectionArn: \(String(describing: connectionArn)), limit: \(String(describing: limit)), namePrefix: \(String(describing: namePrefix)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApiDestinationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionArn = "ConnectionArn"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListApiDestinationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListApiDestinationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApiDestinationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApiDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApiDestinationsInput>
    public typealias MOutput = OperationOutput<ListApiDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApiDestinationsOutputError>
}

public struct ListApiDestinationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListApiDestinationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApiDestinationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApiDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApiDestinationsInput>
    public typealias MOutput = OperationOutput<ListApiDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApiDestinationsOutputError>
}

public struct ListApiDestinationsInput: Equatable {
    /// <p>The ARN of the connection specified for the API destination.</p>
    public let connectionArn: String?
    /// <p>The maximum number of API destinations to include in the response.</p>
    public let limit: Int?
    /// <p>A name prefix to filter results returned. Only API destinations with a name that starts
    ///       with the prefix are returned.</p>
    public let namePrefix: String?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        connectionArn: String? = nil,
        limit: Int? = nil,
        namePrefix: String? = nil,
        nextToken: String? = nil
    )
    {
        self.connectionArn = connectionArn
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

struct ListApiDestinationsInputBody: Equatable {
    public let namePrefix: String?
    public let connectionArn: String?
    public let nextToken: String?
    public let limit: Int?
}

extension ListApiDestinationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionArn = "ConnectionArn"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListApiDestinationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApiDestinationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApiDestinationsOutputError: Equatable {
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApiDestinationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApiDestinationsOutputResponse(apiDestinations: \(String(describing: apiDestinations)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApiDestinationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListApiDestinationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiDestinations = output.apiDestinations
            self.nextToken = output.nextToken
        } else {
            self.apiDestinations = nil
            self.nextToken = nil
        }
    }
}

public struct ListApiDestinationsOutputResponse: Equatable {
    /// <p>An array of <code>ApiDestination</code> objects that include information about an API
    ///       destination.</p>
    public let apiDestinations: [ApiDestination]?
    /// <p>A token you can use in a subsequent request to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        apiDestinations: [ApiDestination]? = nil,
        nextToken: String? = nil
    )
    {
        self.apiDestinations = apiDestinations
        self.nextToken = nextToken
    }
}

struct ListApiDestinationsOutputResponseBody: Equatable {
    public let apiDestinations: [ApiDestination]?
    public let nextToken: String?
}

extension ListApiDestinationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiDestinations = "ApiDestinations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDestinationsContainer = try containerValues.decodeIfPresent([ApiDestination?].self, forKey: .apiDestinations)
        var apiDestinationsDecoded0:[ApiDestination]? = nil
        if let apiDestinationsContainer = apiDestinationsContainer {
            apiDestinationsDecoded0 = [ApiDestination]()
            for structure0 in apiDestinationsContainer {
                if let structure0 = structure0 {
                    apiDestinationsDecoded0?.append(structure0)
                }
            }
        }
        apiDestinations = apiDestinationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListArchivesInputBodyMiddleware: Middleware {
    public let id: String = "ListArchivesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListArchivesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListArchivesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListArchivesInput>
    public typealias MOutput = OperationOutput<ListArchivesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListArchivesOutputError>
}

extension ListArchivesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListArchivesInput(eventSourceArn: \(String(describing: eventSourceArn)), limit: \(String(describing: limit)), namePrefix: \(String(describing: namePrefix)), nextToken: \(String(describing: nextToken)), state: \(String(describing: state)))"}
}

extension ListArchivesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventSourceArn = "EventSourceArn"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventSourceArn = eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

public struct ListArchivesInputHeadersMiddleware: Middleware {
    public let id: String = "ListArchivesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListArchivesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListArchivesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListArchivesInput>
    public typealias MOutput = OperationOutput<ListArchivesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListArchivesOutputError>
}

public struct ListArchivesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListArchivesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListArchivesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListArchivesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListArchivesInput>
    public typealias MOutput = OperationOutput<ListArchivesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListArchivesOutputError>
}

public struct ListArchivesInput: Equatable {
    /// <p>The ARN of the event source associated with the archive.</p>
    public let eventSourceArn: String?
    /// <p>The maximum number of results to return.</p>
    public let limit: Int?
    /// <p>A name prefix to filter the archives returned. Only archives with name that match the
    ///       prefix are returned.</p>
    public let namePrefix: String?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The state of the archive.</p>
    public let state: ArchiveState?

    public init (
        eventSourceArn: String? = nil,
        limit: Int? = nil,
        namePrefix: String? = nil,
        nextToken: String? = nil,
        state: ArchiveState? = nil
    )
    {
        self.eventSourceArn = eventSourceArn
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
        self.state = state
    }
}

struct ListArchivesInputBody: Equatable {
    public let namePrefix: String?
    public let eventSourceArn: String?
    public let state: ArchiveState?
    public let nextToken: String?
    public let limit: Int?
}

extension ListArchivesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSourceArn = "EventSourceArn"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ArchiveState.self, forKey: .state)
        state = stateDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListArchivesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListArchivesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListArchivesOutputError: Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListArchivesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListArchivesOutputResponse(archives: \(String(describing: archives)), nextToken: \(String(describing: nextToken)))"}
}

extension ListArchivesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListArchivesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.archives = output.archives
            self.nextToken = output.nextToken
        } else {
            self.archives = nil
            self.nextToken = nil
        }
    }
}

public struct ListArchivesOutputResponse: Equatable {
    /// <p>An array of <code>Archive</code> objects that include details about an archive.</p>
    public let archives: [Archive]?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        archives: [Archive]? = nil,
        nextToken: String? = nil
    )
    {
        self.archives = archives
        self.nextToken = nextToken
    }
}

struct ListArchivesOutputResponseBody: Equatable {
    public let archives: [Archive]?
    public let nextToken: String?
}

extension ListArchivesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case archives = "Archives"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archivesContainer = try containerValues.decodeIfPresent([Archive?].self, forKey: .archives)
        var archivesDecoded0:[Archive]? = nil
        if let archivesContainer = archivesContainer {
            archivesDecoded0 = [Archive]()
            for structure0 in archivesContainer {
                if let structure0 = structure0 {
                    archivesDecoded0?.append(structure0)
                }
            }
        }
        archives = archivesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListConnectionsInputBodyMiddleware: Middleware {
    public let id: String = "ListConnectionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConnectionsInput>
    public typealias MOutput = OperationOutput<ListConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConnectionsOutputError>
}

extension ListConnectionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConnectionsInput(connectionState: \(String(describing: connectionState)), limit: \(String(describing: limit)), namePrefix: \(String(describing: namePrefix)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConnectionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionState = "ConnectionState"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionState = connectionState {
            try encodeContainer.encode(connectionState.rawValue, forKey: .connectionState)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListConnectionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListConnectionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConnectionsInput>
    public typealias MOutput = OperationOutput<ListConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConnectionsOutputError>
}

public struct ListConnectionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListConnectionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConnectionsInput>
    public typealias MOutput = OperationOutput<ListConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConnectionsOutputError>
}

public struct ListConnectionsInput: Equatable {
    /// <p>The state of the connection.</p>
    public let connectionState: ConnectionState?
    /// <p>The maximum number of connections to return.</p>
    public let limit: Int?
    /// <p>A name prefix to filter results returned. Only connections with a name that starts with
    ///       the prefix are returned.</p>
    public let namePrefix: String?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        connectionState: ConnectionState? = nil,
        limit: Int? = nil,
        namePrefix: String? = nil,
        nextToken: String? = nil
    )
    {
        self.connectionState = connectionState
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

struct ListConnectionsInputBody: Equatable {
    public let namePrefix: String?
    public let connectionState: ConnectionState?
    public let nextToken: String?
    public let limit: Int?
}

extension ListConnectionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionState = "ConnectionState"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListConnectionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConnectionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConnectionsOutputError: Equatable {
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConnectionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConnectionsOutputResponse(connections: \(String(describing: connections)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConnectionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connections = output.connections
            self.nextToken = output.nextToken
        } else {
            self.connections = nil
            self.nextToken = nil
        }
    }
}

public struct ListConnectionsOutputResponse: Equatable {
    /// <p>An array of connections objects that include details about the connections.</p>
    public let connections: [Connection]?
    /// <p>A token you can use in a subsequent request to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        connections: [Connection]? = nil,
        nextToken: String? = nil
    )
    {
        self.connections = connections
        self.nextToken = nextToken
    }
}

struct ListConnectionsOutputResponseBody: Equatable {
    public let connections: [Connection]?
    public let nextToken: String?
}

extension ListConnectionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connections = "Connections"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsContainer = try containerValues.decodeIfPresent([Connection?].self, forKey: .connections)
        var connectionsDecoded0:[Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListEventBusesInputBodyMiddleware: Middleware {
    public let id: String = "ListEventBusesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventBusesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventBusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventBusesInput>
    public typealias MOutput = OperationOutput<ListEventBusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventBusesOutputError>
}

extension ListEventBusesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventBusesInput(limit: \(String(describing: limit)), namePrefix: \(String(describing: namePrefix)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEventBusesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEventBusesInputHeadersMiddleware: Middleware {
    public let id: String = "ListEventBusesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventBusesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventBusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventBusesInput>
    public typealias MOutput = OperationOutput<ListEventBusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventBusesOutputError>
}

public struct ListEventBusesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEventBusesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventBusesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventBusesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventBusesInput>
    public typealias MOutput = OperationOutput<ListEventBusesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventBusesOutputError>
}

public struct ListEventBusesInput: Equatable {
    /// <p>Specifying this limits the number of results returned by this operation. The operation
    ///       also returns a NextToken which you can use in a subsequent operation to retrieve the next set
    ///       of results.</p>
    public let limit: Int?
    /// <p>Specifying this limits the results to only those event buses with names that start with
    ///       the specified prefix.</p>
    public let namePrefix: String?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        limit: Int? = nil,
        namePrefix: String? = nil,
        nextToken: String? = nil
    )
    {
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

struct ListEventBusesInputBody: Equatable {
    public let namePrefix: String?
    public let nextToken: String?
    public let limit: Int?
}

extension ListEventBusesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListEventBusesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventBusesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEventBusesOutputError: Equatable {
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventBusesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventBusesOutputResponse(eventBuses: \(String(describing: eventBuses)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEventBusesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEventBusesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventBuses = output.eventBuses
            self.nextToken = output.nextToken
        } else {
            self.eventBuses = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventBusesOutputResponse: Equatable {
    /// <p>This list of event buses.</p>
    public let eventBuses: [EventBus]?
    /// <p>A token you can use in a subsequent operation to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        eventBuses: [EventBus]? = nil,
        nextToken: String? = nil
    )
    {
        self.eventBuses = eventBuses
        self.nextToken = nextToken
    }
}

struct ListEventBusesOutputResponseBody: Equatable {
    public let eventBuses: [EventBus]?
    public let nextToken: String?
}

extension ListEventBusesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventBuses = "EventBuses"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventBusesContainer = try containerValues.decodeIfPresent([EventBus?].self, forKey: .eventBuses)
        var eventBusesDecoded0:[EventBus]? = nil
        if let eventBusesContainer = eventBusesContainer {
            eventBusesDecoded0 = [EventBus]()
            for structure0 in eventBusesContainer {
                if let structure0 = structure0 {
                    eventBusesDecoded0?.append(structure0)
                }
            }
        }
        eventBuses = eventBusesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListEventSourcesInputBodyMiddleware: Middleware {
    public let id: String = "ListEventSourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventSourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventSourcesInput>
    public typealias MOutput = OperationOutput<ListEventSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventSourcesOutputError>
}

extension ListEventSourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventSourcesInput(limit: \(String(describing: limit)), namePrefix: \(String(describing: namePrefix)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEventSourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListEventSourcesInputHeadersMiddleware: Middleware {
    public let id: String = "ListEventSourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventSourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventSourcesInput>
    public typealias MOutput = OperationOutput<ListEventSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventSourcesOutputError>
}

public struct ListEventSourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEventSourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventSourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventSourcesInput>
    public typealias MOutput = OperationOutput<ListEventSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventSourcesOutputError>
}

public struct ListEventSourcesInput: Equatable {
    /// <p>Specifying this limits the number of results returned by this operation. The operation
    ///       also returns a NextToken which you can use in a subsequent operation to retrieve the next set
    ///       of results.</p>
    public let limit: Int?
    /// <p>Specifying this limits the results to only those partner event sources with names that
    ///       start with the specified prefix.</p>
    public let namePrefix: String?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        limit: Int? = nil,
        namePrefix: String? = nil,
        nextToken: String? = nil
    )
    {
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

struct ListEventSourcesInputBody: Equatable {
    public let namePrefix: String?
    public let nextToken: String?
    public let limit: Int?
}

extension ListEventSourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListEventSourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventSourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEventSourcesOutputError: Equatable {
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventSourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventSourcesOutputResponse(eventSources: \(String(describing: eventSources)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEventSourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEventSourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSources = output.eventSources
            self.nextToken = output.nextToken
        } else {
            self.eventSources = nil
            self.nextToken = nil
        }
    }
}

public struct ListEventSourcesOutputResponse: Equatable {
    /// <p>The list of event sources.</p>
    public let eventSources: [EventSource]?
    /// <p>A token you can use in a subsequent operation to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        eventSources: [EventSource]? = nil,
        nextToken: String? = nil
    )
    {
        self.eventSources = eventSources
        self.nextToken = nextToken
    }
}

struct ListEventSourcesOutputResponseBody: Equatable {
    public let eventSources: [EventSource]?
    public let nextToken: String?
}

extension ListEventSourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSources = "EventSources"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourcesContainer = try containerValues.decodeIfPresent([EventSource?].self, forKey: .eventSources)
        var eventSourcesDecoded0:[EventSource]? = nil
        if let eventSourcesContainer = eventSourcesContainer {
            eventSourcesDecoded0 = [EventSource]()
            for structure0 in eventSourcesContainer {
                if let structure0 = structure0 {
                    eventSourcesDecoded0?.append(structure0)
                }
            }
        }
        eventSources = eventSourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPartnerEventSourceAccountsInputBodyMiddleware: Middleware {
    public let id: String = "ListPartnerEventSourceAccountsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPartnerEventSourceAccountsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPartnerEventSourceAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPartnerEventSourceAccountsInput>
    public typealias MOutput = OperationOutput<ListPartnerEventSourceAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPartnerEventSourceAccountsOutputError>
}

extension ListPartnerEventSourceAccountsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPartnerEventSourceAccountsInput(eventSourceName: \(String(describing: eventSourceName)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPartnerEventSourceAccountsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventSourceName = "EventSourceName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventSourceName = eventSourceName {
            try encodeContainer.encode(eventSourceName, forKey: .eventSourceName)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPartnerEventSourceAccountsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPartnerEventSourceAccountsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPartnerEventSourceAccountsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPartnerEventSourceAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPartnerEventSourceAccountsInput>
    public typealias MOutput = OperationOutput<ListPartnerEventSourceAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPartnerEventSourceAccountsOutputError>
}

public struct ListPartnerEventSourceAccountsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPartnerEventSourceAccountsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPartnerEventSourceAccountsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPartnerEventSourceAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPartnerEventSourceAccountsInput>
    public typealias MOutput = OperationOutput<ListPartnerEventSourceAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPartnerEventSourceAccountsOutputError>
}

public struct ListPartnerEventSourceAccountsInput: Equatable {
    /// <p>The name of the partner event source to display account information about.</p>
    public let eventSourceName: String?
    /// <p>Specifying this limits the number of results returned by this operation. The operation
    ///       also returns a NextToken which you can use in a subsequent operation to retrieve the next set
    ///       of results.</p>
    public let limit: Int?
    /// <p>The token returned by a previous call to this operation. Specifying this retrieves the
    ///       next set of results.</p>
    public let nextToken: String?

    public init (
        eventSourceName: String? = nil,
        limit: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.eventSourceName = eventSourceName
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct ListPartnerEventSourceAccountsInputBody: Equatable {
    public let eventSourceName: String?
    public let nextToken: String?
    public let limit: Int?
}

extension ListPartnerEventSourceAccountsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSourceName = "EventSourceName"
        case limit = "Limit"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSourceName)
        eventSourceName = eventSourceNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListPartnerEventSourceAccountsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPartnerEventSourceAccountsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPartnerEventSourceAccountsOutputError: Equatable {
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPartnerEventSourceAccountsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPartnerEventSourceAccountsOutputResponse(nextToken: \(String(describing: nextToken)), partnerEventSourceAccounts: \(String(describing: partnerEventSourceAccounts)))"}
}

extension ListPartnerEventSourceAccountsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPartnerEventSourceAccountsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.partnerEventSourceAccounts = output.partnerEventSourceAccounts
        } else {
            self.nextToken = nil
            self.partnerEventSourceAccounts = nil
        }
    }
}

public struct ListPartnerEventSourceAccountsOutputResponse: Equatable {
    /// <p>A token you can use in a subsequent operation to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The list of partner event sources returned by the operation.</p>
    public let partnerEventSourceAccounts: [PartnerEventSourceAccount]?

    public init (
        nextToken: String? = nil,
        partnerEventSourceAccounts: [PartnerEventSourceAccount]? = nil
    )
    {
        self.nextToken = nextToken
        self.partnerEventSourceAccounts = partnerEventSourceAccounts
    }
}

struct ListPartnerEventSourceAccountsOutputResponseBody: Equatable {
    public let partnerEventSourceAccounts: [PartnerEventSourceAccount]?
    public let nextToken: String?
}

extension ListPartnerEventSourceAccountsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case partnerEventSourceAccounts = "PartnerEventSourceAccounts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partnerEventSourceAccountsContainer = try containerValues.decodeIfPresent([PartnerEventSourceAccount?].self, forKey: .partnerEventSourceAccounts)
        var partnerEventSourceAccountsDecoded0:[PartnerEventSourceAccount]? = nil
        if let partnerEventSourceAccountsContainer = partnerEventSourceAccountsContainer {
            partnerEventSourceAccountsDecoded0 = [PartnerEventSourceAccount]()
            for structure0 in partnerEventSourceAccountsContainer {
                if let structure0 = structure0 {
                    partnerEventSourceAccountsDecoded0?.append(structure0)
                }
            }
        }
        partnerEventSourceAccounts = partnerEventSourceAccountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListPartnerEventSourcesInputBodyMiddleware: Middleware {
    public let id: String = "ListPartnerEventSourcesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPartnerEventSourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPartnerEventSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPartnerEventSourcesInput>
    public typealias MOutput = OperationOutput<ListPartnerEventSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPartnerEventSourcesOutputError>
}

extension ListPartnerEventSourcesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPartnerEventSourcesInput(limit: \(String(describing: limit)), namePrefix: \(String(describing: namePrefix)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPartnerEventSourcesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListPartnerEventSourcesInputHeadersMiddleware: Middleware {
    public let id: String = "ListPartnerEventSourcesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPartnerEventSourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPartnerEventSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPartnerEventSourcesInput>
    public typealias MOutput = OperationOutput<ListPartnerEventSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPartnerEventSourcesOutputError>
}

public struct ListPartnerEventSourcesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPartnerEventSourcesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPartnerEventSourcesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPartnerEventSourcesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPartnerEventSourcesInput>
    public typealias MOutput = OperationOutput<ListPartnerEventSourcesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPartnerEventSourcesOutputError>
}

public struct ListPartnerEventSourcesInput: Equatable {
    /// <p>pecifying this limits the number of results returned by this operation. The operation also
    ///       returns a NextToken which you can use in a subsequent operation to retrieve the next set of
    ///       results.</p>
    public let limit: Int?
    /// <p>If you specify this, the results are limited to only those partner event sources that
    ///       start with the string you specify.</p>
    public let namePrefix: String?
    /// <p>The token returned by a previous call to this operation. Specifying this retrieves the
    ///       next set of results.</p>
    public let nextToken: String?

    public init (
        limit: Int? = nil,
        namePrefix: String? = nil,
        nextToken: String? = nil
    )
    {
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

struct ListPartnerEventSourcesInputBody: Equatable {
    public let namePrefix: String?
    public let nextToken: String?
    public let limit: Int?
}

extension ListPartnerEventSourcesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListPartnerEventSourcesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPartnerEventSourcesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPartnerEventSourcesOutputError: Equatable {
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPartnerEventSourcesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPartnerEventSourcesOutputResponse(nextToken: \(String(describing: nextToken)), partnerEventSources: \(String(describing: partnerEventSources)))"}
}

extension ListPartnerEventSourcesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPartnerEventSourcesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.partnerEventSources = output.partnerEventSources
        } else {
            self.nextToken = nil
            self.partnerEventSources = nil
        }
    }
}

public struct ListPartnerEventSourcesOutputResponse: Equatable {
    /// <p>A token you can use in a subsequent operation to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The list of partner event sources returned by the operation.</p>
    public let partnerEventSources: [PartnerEventSource]?

    public init (
        nextToken: String? = nil,
        partnerEventSources: [PartnerEventSource]? = nil
    )
    {
        self.nextToken = nextToken
        self.partnerEventSources = partnerEventSources
    }
}

struct ListPartnerEventSourcesOutputResponseBody: Equatable {
    public let partnerEventSources: [PartnerEventSource]?
    public let nextToken: String?
}

extension ListPartnerEventSourcesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case partnerEventSources = "PartnerEventSources"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let partnerEventSourcesContainer = try containerValues.decodeIfPresent([PartnerEventSource?].self, forKey: .partnerEventSources)
        var partnerEventSourcesDecoded0:[PartnerEventSource]? = nil
        if let partnerEventSourcesContainer = partnerEventSourcesContainer {
            partnerEventSourcesDecoded0 = [PartnerEventSource]()
            for structure0 in partnerEventSourcesContainer {
                if let structure0 = structure0 {
                    partnerEventSourcesDecoded0?.append(structure0)
                }
            }
        }
        partnerEventSources = partnerEventSourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListReplaysInputBodyMiddleware: Middleware {
    public let id: String = "ListReplaysInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReplaysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReplaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReplaysInput>
    public typealias MOutput = OperationOutput<ListReplaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReplaysOutputError>
}

extension ListReplaysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReplaysInput(eventSourceArn: \(String(describing: eventSourceArn)), limit: \(String(describing: limit)), namePrefix: \(String(describing: namePrefix)), nextToken: \(String(describing: nextToken)), state: \(String(describing: state)))"}
}

extension ListReplaysInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventSourceArn = "EventSourceArn"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventSourceArn = eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }
}

public struct ListReplaysInputHeadersMiddleware: Middleware {
    public let id: String = "ListReplaysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReplaysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReplaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReplaysInput>
    public typealias MOutput = OperationOutput<ListReplaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReplaysOutputError>
}

public struct ListReplaysInputQueryItemMiddleware: Middleware {
    public let id: String = "ListReplaysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReplaysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReplaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReplaysInput>
    public typealias MOutput = OperationOutput<ListReplaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReplaysOutputError>
}

public struct ListReplaysInput: Equatable {
    /// <p>The ARN of the event source associated with the replay.</p>
    public let eventSourceArn: String?
    /// <p>The maximum number of replays to retrieve.</p>
    public let limit: Int?
    /// <p>A name prefix to filter the replays returned. Only replays with name that match the prefix
    ///       are returned.</p>
    public let namePrefix: String?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The state of the replay.</p>
    public let state: ReplayState?

    public init (
        eventSourceArn: String? = nil,
        limit: Int? = nil,
        namePrefix: String? = nil,
        nextToken: String? = nil,
        state: ReplayState? = nil
    )
    {
        self.eventSourceArn = eventSourceArn
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
        self.state = state
    }
}

struct ListReplaysInputBody: Equatable {
    public let namePrefix: String?
    public let state: ReplayState?
    public let eventSourceArn: String?
    public let nextToken: String?
    public let limit: Int?
}

extension ListReplaysInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSourceArn = "EventSourceArn"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
        case state = "State"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ReplayState.self, forKey: .state)
        state = stateDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListReplaysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReplaysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReplaysOutputError: Equatable {
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReplaysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReplaysOutputResponse(nextToken: \(String(describing: nextToken)), replays: \(String(describing: replays)))"}
}

extension ListReplaysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListReplaysOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.replays = output.replays
        } else {
            self.nextToken = nil
            self.replays = nil
        }
    }
}

public struct ListReplaysOutputResponse: Equatable {
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>An array of <code>Replay</code> objects that contain information about the replay.</p>
    public let replays: [Replay]?

    public init (
        nextToken: String? = nil,
        replays: [Replay]? = nil
    )
    {
        self.nextToken = nextToken
        self.replays = replays
    }
}

struct ListReplaysOutputResponseBody: Equatable {
    public let replays: [Replay]?
    public let nextToken: String?
}

extension ListReplaysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case replays = "Replays"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replaysContainer = try containerValues.decodeIfPresent([Replay?].self, forKey: .replays)
        var replaysDecoded0:[Replay]? = nil
        if let replaysContainer = replaysContainer {
            replaysDecoded0 = [Replay]()
            for structure0 in replaysContainer {
                if let structure0 = structure0 {
                    replaysDecoded0?.append(structure0)
                }
            }
        }
        replays = replaysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRuleNamesByTargetInputBodyMiddleware: Middleware {
    public let id: String = "ListRuleNamesByTargetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRuleNamesByTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRuleNamesByTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRuleNamesByTargetInput>
    public typealias MOutput = OperationOutput<ListRuleNamesByTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRuleNamesByTargetOutputError>
}

extension ListRuleNamesByTargetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRuleNamesByTargetInput(eventBusName: \(String(describing: eventBusName)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), targetArn: \(String(describing: targetArn)))"}
}

extension ListRuleNamesByTargetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventBusName = "EventBusName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case targetArn = "TargetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let targetArn = targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }
}

public struct ListRuleNamesByTargetInputHeadersMiddleware: Middleware {
    public let id: String = "ListRuleNamesByTargetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRuleNamesByTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRuleNamesByTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRuleNamesByTargetInput>
    public typealias MOutput = OperationOutput<ListRuleNamesByTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRuleNamesByTargetOutputError>
}

public struct ListRuleNamesByTargetInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRuleNamesByTargetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRuleNamesByTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRuleNamesByTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRuleNamesByTargetInput>
    public typealias MOutput = OperationOutput<ListRuleNamesByTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRuleNamesByTargetOutputError>
}

public struct ListRuleNamesByTargetInput: Equatable {
    /// <p>The name or ARN of the event bus to list rules for. If you omit this, the default event
    ///       bus is used.</p>
    public let eventBusName: String?
    /// <p>The maximum number of results to return.</p>
    public let limit: Int?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the target resource.</p>
    public let targetArn: String?

    public init (
        eventBusName: String? = nil,
        limit: Int? = nil,
        nextToken: String? = nil,
        targetArn: String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.limit = limit
        self.nextToken = nextToken
        self.targetArn = targetArn
    }
}

struct ListRuleNamesByTargetInputBody: Equatable {
    public let targetArn: String?
    public let eventBusName: String?
    public let nextToken: String?
    public let limit: Int?
}

extension ListRuleNamesByTargetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventBusName = "EventBusName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case targetArn = "TargetArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListRuleNamesByTargetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRuleNamesByTargetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRuleNamesByTargetOutputError: Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRuleNamesByTargetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRuleNamesByTargetOutputResponse(nextToken: \(String(describing: nextToken)), ruleNames: \(String(describing: ruleNames)))"}
}

extension ListRuleNamesByTargetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRuleNamesByTargetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.ruleNames = output.ruleNames
        } else {
            self.nextToken = nil
            self.ruleNames = nil
        }
    }
}

public struct ListRuleNamesByTargetOutputResponse: Equatable {
    /// <p>Indicates whether there are additional results to retrieve. If there are no more results,
    ///       the value is null.</p>
    public let nextToken: String?
    /// <p>The names of the rules that can invoke the given target.</p>
    public let ruleNames: [String]?

    public init (
        nextToken: String? = nil,
        ruleNames: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.ruleNames = ruleNames
    }
}

struct ListRuleNamesByTargetOutputResponseBody: Equatable {
    public let ruleNames: [String]?
    public let nextToken: String?
}

extension ListRuleNamesByTargetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case ruleNames = "RuleNames"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ruleNames)
        var ruleNamesDecoded0:[String]? = nil
        if let ruleNamesContainer = ruleNamesContainer {
            ruleNamesDecoded0 = [String]()
            for string0 in ruleNamesContainer {
                if let string0 = string0 {
                    ruleNamesDecoded0?.append(string0)
                }
            }
        }
        ruleNames = ruleNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRulesInputBodyMiddleware: Middleware {
    public let id: String = "ListRulesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRulesInput>
    public typealias MOutput = OperationOutput<ListRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRulesOutputError>
}

extension ListRulesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRulesInput(eventBusName: \(String(describing: eventBusName)), limit: \(String(describing: limit)), namePrefix: \(String(describing: namePrefix)), nextToken: \(String(describing: nextToken)))"}
}

extension ListRulesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventBusName = "EventBusName"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let namePrefix = namePrefix {
            try encodeContainer.encode(namePrefix, forKey: .namePrefix)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRulesInputHeadersMiddleware: Middleware {
    public let id: String = "ListRulesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRulesInput>
    public typealias MOutput = OperationOutput<ListRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRulesOutputError>
}

public struct ListRulesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRulesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRulesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRulesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRulesInput>
    public typealias MOutput = OperationOutput<ListRulesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRulesOutputError>
}

public struct ListRulesInput: Equatable {
    /// <p>The name or ARN of the event bus to list the rules for. If you omit this, the default
    ///       event bus is used.</p>
    public let eventBusName: String?
    /// <p>The maximum number of results to return.</p>
    public let limit: Int?
    /// <p>The prefix matching the rule name.</p>
    public let namePrefix: String?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: String?

    public init (
        eventBusName: String? = nil,
        limit: Int? = nil,
        namePrefix: String? = nil,
        nextToken: String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.limit = limit
        self.namePrefix = namePrefix
        self.nextToken = nextToken
    }
}

struct ListRulesInputBody: Equatable {
    public let namePrefix: String?
    public let eventBusName: String?
    public let nextToken: String?
    public let limit: Int?
}

extension ListRulesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventBusName = "EventBusName"
        case limit = "Limit"
        case namePrefix = "NamePrefix"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namePrefix)
        namePrefix = namePrefixDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListRulesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRulesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRulesOutputError: Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRulesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRulesOutputResponse(nextToken: \(String(describing: nextToken)), rules: \(String(describing: rules)))"}
}

extension ListRulesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRulesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.rules = output.rules
        } else {
            self.nextToken = nil
            self.rules = nil
        }
    }
}

public struct ListRulesOutputResponse: Equatable {
    /// <p>Indicates whether there are additional results to retrieve. If there are no more results,
    ///       the value is null.</p>
    public let nextToken: String?
    /// <p>The rules that match the specified criteria.</p>
    public let rules: [Rule]?

    public init (
        nextToken: String? = nil,
        rules: [Rule]? = nil
    )
    {
        self.nextToken = nextToken
        self.rules = rules
    }
}

struct ListRulesOutputResponseBody: Equatable {
    public let rules: [Rule]?
    public let nextToken: String?
}

extension ListRulesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case rules = "Rules"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([Rule?].self, forKey: .rules)
        var rulesDecoded0:[Rule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [Rule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The ARN of the EventBridge resource for which you want to view tags.</p>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceARN: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The list of tag keys and values associated with the resource you specified</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListTargetsByRuleInputBodyMiddleware: Middleware {
    public let id: String = "ListTargetsByRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTargetsByRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTargetsByRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTargetsByRuleInput>
    public typealias MOutput = OperationOutput<ListTargetsByRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTargetsByRuleOutputError>
}

extension ListTargetsByRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTargetsByRuleInput(eventBusName: \(String(describing: eventBusName)), limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), rule: \(String(describing: rule)))"}
}

extension ListTargetsByRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventBusName = "EventBusName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case rule = "Rule"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let limit = limit {
            try encodeContainer.encode(limit, forKey: .limit)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let rule = rule {
            try encodeContainer.encode(rule, forKey: .rule)
        }
    }
}

public struct ListTargetsByRuleInputHeadersMiddleware: Middleware {
    public let id: String = "ListTargetsByRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTargetsByRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTargetsByRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTargetsByRuleInput>
    public typealias MOutput = OperationOutput<ListTargetsByRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTargetsByRuleOutputError>
}

public struct ListTargetsByRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTargetsByRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTargetsByRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTargetsByRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTargetsByRuleInput>
    public typealias MOutput = OperationOutput<ListTargetsByRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTargetsByRuleOutputError>
}

public struct ListTargetsByRuleInput: Equatable {
    /// <p>The name or ARN of the event bus associated with the rule. If you omit this, the default
    ///       event bus is used.</p>
    public let eventBusName: String?
    /// <p>The maximum number of results to return.</p>
    public let limit: Int?
    /// <p>The token returned by a previous call to retrieve the next set of results.</p>
    public let nextToken: String?
    /// <p>The name of the rule.</p>
    public let rule: String?

    public init (
        eventBusName: String? = nil,
        limit: Int? = nil,
        nextToken: String? = nil,
        rule: String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.limit = limit
        self.nextToken = nextToken
        self.rule = rule
    }
}

struct ListTargetsByRuleInputBody: Equatable {
    public let rule: String?
    public let eventBusName: String?
    public let nextToken: String?
    public let limit: Int?
}

extension ListTargetsByRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventBusName = "EventBusName"
        case limit = "Limit"
        case nextToken = "NextToken"
        case rule = "Rule"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rule)
        rule = ruleDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let limitDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .limit)
        limit = limitDecoded
    }
}

extension ListTargetsByRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTargetsByRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTargetsByRuleOutputError: Equatable {
    case internalException(InternalException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTargetsByRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTargetsByRuleOutputResponse(nextToken: \(String(describing: nextToken)), targets: \(String(describing: targets)))"}
}

extension ListTargetsByRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTargetsByRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.targets = output.targets
        } else {
            self.nextToken = nil
            self.targets = nil
        }
    }
}

public struct ListTargetsByRuleOutputResponse: Equatable {
    /// <p>Indicates whether there are additional results to retrieve. If there are no more results,
    ///       the value is null.</p>
    public let nextToken: String?
    /// <p>The targets assigned to the rule.</p>
    public let targets: [Target]?

    public init (
        nextToken: String? = nil,
        targets: [Target]? = nil
    )
    {
        self.nextToken = nextToken
        self.targets = targets
    }
}

struct ListTargetsByRuleOutputResponseBody: Equatable {
    public let targets: [Target]?
    public let nextToken: String?
}

extension ListTargetsByRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case targets = "Targets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ManagedRuleException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ManagedRuleException(message: \(String(describing: message)))"}
}

extension ManagedRuleException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ManagedRuleExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This rule was created by an AWS service on behalf of your account. It is managed by that
///       service. If you see this error in response to <code>DeleteRule</code> or
///         <code>RemoveTargets</code>, you can use the <code>Force</code> parameter in those calls to
///       delete the rule or remove targets from the rule. You cannot modify these managed rules by
///       using <code>DisableRule</code>, <code>EnableRule</code>, <code>PutTargets</code>,
///         <code>PutRule</code>, <code>TagResource</code>, or <code>UntagResource</code>. </p>
public struct ManagedRuleException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ManagedRuleExceptionBody: Equatable {
    public let message: String?
}

extension ManagedRuleExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NetworkConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsvpcConfiguration
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsvpcConfiguration = awsvpcConfiguration {
            try encodeContainer.encode(awsvpcConfiguration, forKey: .awsvpcConfiguration)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsvpcConfigurationDecoded = try containerValues.decodeIfPresent(AwsVpcConfiguration.self, forKey: .awsvpcConfiguration)
        awsvpcConfiguration = awsvpcConfigurationDecoded
    }
}

extension NetworkConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkConfiguration(awsvpcConfiguration: \(String(describing: awsvpcConfiguration)))"}
}

/// <p>This structure specifies the network configuration for an ECS task.</p>
public struct NetworkConfiguration: Equatable {
    /// <p>Use this structure to specify the VPC subnets and security groups for the task, and
    ///       whether a public IP address is to be used. This structure is relevant only for ECS tasks that
    ///       use the <code>awsvpc</code> network mode.</p>
    public let awsvpcConfiguration: AwsVpcConfiguration?

    public init (
        awsvpcConfiguration: AwsVpcConfiguration? = nil
    )
    {
        self.awsvpcConfiguration = awsvpcConfiguration
    }
}

extension OperationDisabledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OperationDisabledException(message: \(String(describing: message)))"}
}

extension OperationDisabledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: OperationDisabledExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation you are attempting is not available in this region.</p>
public struct OperationDisabledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct OperationDisabledExceptionBody: Equatable {
    public let message: String?
}

extension OperationDisabledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PartnerEventSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension PartnerEventSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PartnerEventSource(arn: \(String(describing: arn)), name: \(String(describing: name)))"}
}

/// <p>A partner event source is created by an SaaS partner. If a customer creates a partner
///       event bus that matches this event source, that AWS account can receive events from the
///       partner's applications or services.</p>
public struct PartnerEventSource: Equatable {
    /// <p>The ARN of the partner event source.</p>
    public let arn: String?
    /// <p>The name of the partner event source.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

extension PartnerEventSourceAccount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case account = "Account"
        case creationTime = "CreationTime"
        case expirationTime = "ExpirationTime"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let account = account {
            try encodeContainer.encode(account, forKey: .account)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let expirationTime = expirationTime {
            try encodeContainer.encode(expirationTime.timeIntervalSince1970, forKey: .expirationTime)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .account)
        account = accountDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let expirationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expirationTime)
        expirationTime = expirationTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(EventSourceState.self, forKey: .state)
        state = stateDecoded
    }
}

extension PartnerEventSourceAccount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PartnerEventSourceAccount(account: \(String(describing: account)), creationTime: \(String(describing: creationTime)), expirationTime: \(String(describing: expirationTime)), state: \(String(describing: state)))"}
}

/// <p>The AWS account that a partner event source has been offered to.</p>
public struct PartnerEventSourceAccount: Equatable {
    /// <p>The AWS account ID that the partner event source was offered to.</p>
    public let account: String?
    /// <p>The date and time the event source was created.</p>
    public let creationTime: Date?
    /// <p>The date and time that the event source will expire, if the AWS account doesn't create a
    ///       matching event bus for it.</p>
    public let expirationTime: Date?
    /// <p>The state of the event source. If it is ACTIVE, you have already created a matching event
    ///       bus for this event source, and that event bus is active. If it is PENDING, either you haven't
    ///       yet created a matching event bus, or that event bus is deactivated. If it is DELETED, you have
    ///       created a matching event bus, but the event source has since been deleted.</p>
    public let state: EventSourceState?

    public init (
        account: String? = nil,
        creationTime: Date? = nil,
        expirationTime: Date? = nil,
        state: EventSourceState? = nil
    )
    {
        self.account = account
        self.creationTime = creationTime
        self.expirationTime = expirationTime
        self.state = state
    }
}

extension PolicyLengthExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyLengthExceededException(message: \(String(describing: message)))"}
}

extension PolicyLengthExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PolicyLengthExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The event bus policy is too long. For more information, see the limits.</p>
public struct PolicyLengthExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PolicyLengthExceededExceptionBody: Equatable {
    public let message: String?
}

extension PolicyLengthExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PutEventsInputBodyMiddleware: Middleware {
    public let id: String = "PutEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEventsInput>
    public typealias MOutput = OperationOutput<PutEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEventsOutputError>
}

extension PutEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEventsInput(entries: \(String(describing: entries)))"}
}

extension PutEventsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entries = "Entries"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for puteventsrequestentrylist0 in entries {
                try entriesContainer.encode(puteventsrequestentrylist0)
            }
        }
    }
}

public struct PutEventsInputHeadersMiddleware: Middleware {
    public let id: String = "PutEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEventsInput>
    public typealias MOutput = OperationOutput<PutEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEventsOutputError>
}

public struct PutEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEventsInput>
    public typealias MOutput = OperationOutput<PutEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEventsOutputError>
}

public struct PutEventsInput: Equatable {
    /// <p>The entry that defines an event in your system. You can specify several parameters for the
    ///       entry such as the source and type of the event, resources associated with the event, and so
    ///       on.</p>
    public let entries: [PutEventsRequestEntry]?

    public init (
        entries: [PutEventsRequestEntry]? = nil
    )
    {
        self.entries = entries
    }
}

struct PutEventsInputBody: Equatable {
    public let entries: [PutEventsRequestEntry]?
}

extension PutEventsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entries = "Entries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([PutEventsRequestEntry?].self, forKey: .entries)
        var entriesDecoded0:[PutEventsRequestEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [PutEventsRequestEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension PutEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEventsOutputError: Equatable {
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEventsOutputResponse(entries: \(String(describing: entries)), failedEntryCount: \(String(describing: failedEntryCount)))"}
}

extension PutEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutEventsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entries = output.entries
            self.failedEntryCount = output.failedEntryCount
        } else {
            self.entries = nil
            self.failedEntryCount = 0
        }
    }
}

public struct PutEventsOutputResponse: Equatable {
    /// <p>The successfully and unsuccessfully ingested events results. If the ingestion was
    ///       successful, the entry has the event ID in it. Otherwise, you can use the error code and error
    ///       message to identify the problem with the entry.</p>
    public let entries: [PutEventsResultEntry]?
    /// <p>The number of failed entries.</p>
    public let failedEntryCount: Int

    public init (
        entries: [PutEventsResultEntry]? = nil,
        failedEntryCount: Int = 0
    )
    {
        self.entries = entries
        self.failedEntryCount = failedEntryCount
    }
}

struct PutEventsOutputResponseBody: Equatable {
    public let failedEntryCount: Int
    public let entries: [PutEventsResultEntry]?
}

extension PutEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entries = "Entries"
        case failedEntryCount = "FailedEntryCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedEntryCountDecoded = try containerValues.decode(Int.self, forKey: .failedEntryCount)
        failedEntryCount = failedEntryCountDecoded
        let entriesContainer = try containerValues.decodeIfPresent([PutEventsResultEntry?].self, forKey: .entries)
        var entriesDecoded0:[PutEventsResultEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [PutEventsResultEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension PutEventsRequestEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detail = "Detail"
        case detailType = "DetailType"
        case eventBusName = "EventBusName"
        case resources = "Resources"
        case source = "Source"
        case time = "Time"
        case traceHeader = "TraceHeader"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detail = detail {
            try encodeContainer.encode(detail, forKey: .detail)
        }
        if let detailType = detailType {
            try encodeContainer.encode(detailType, forKey: .detailType)
        }
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for eventresourcelist0 in resources {
                try resourcesContainer.encode(eventresourcelist0)
            }
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let time = time {
            try encodeContainer.encode(time.timeIntervalSince1970, forKey: .time)
        }
        if let traceHeader = traceHeader {
            try encodeContainer.encode(traceHeader, forKey: .traceHeader)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .time)
        time = timeDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resources)
        var resourcesDecoded0:[String]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [String]()
            for string0 in resourcesContainer {
                if let string0 = string0 {
                    resourcesDecoded0?.append(string0)
                }
            }
        }
        resources = resourcesDecoded0
        let detailTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detailType)
        detailType = detailTypeDecoded
        let detailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detail)
        detail = detailDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let traceHeaderDecoded = try containerValues.decodeIfPresent(String.self, forKey: .traceHeader)
        traceHeader = traceHeaderDecoded
    }
}

extension PutEventsRequestEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEventsRequestEntry(detail: \(String(describing: detail)), detailType: \(String(describing: detailType)), eventBusName: \(String(describing: eventBusName)), resources: \(String(describing: resources)), source: \(String(describing: source)), time: \(String(describing: time)), traceHeader: \(String(describing: traceHeader)))"}
}

/// <p>Represents an event to be submitted.</p>
public struct PutEventsRequestEntry: Equatable {
    /// <p>A valid JSON string. There is no other schema imposed. The JSON string may contain fields
    ///       and nested subobjects.</p>
    public let detail: String?
    /// <p>Free-form string used to decide what fields to expect in the event detail.</p>
    public let detailType: String?
    /// <p>The name or ARN of the event bus to receive the event. Only the rules that are associated
    ///       with this event bus are used to match the event. If you omit this, the default event bus is
    ///       used.</p>
    public let eventBusName: String?
    /// <p>AWS resources, identified by Amazon Resource Name (ARN), which the event primarily
    ///       concerns. Any number, including zero, may be present.</p>
    public let resources: [String]?
    /// <p>The source of the event.</p>
    public let source: String?
    /// <p>The time stamp of the event, per <a href="https://www.rfc-editor.org/rfc/rfc3339.txt">RFC3339</a>. If no time stamp is provided, the time stamp of the <a>PutEvents</a> call is used.</p>
    public let time: Date?
    /// <p>An AWS X-Ray trade header, which is an http header (X-Amzn-Trace-Id) that contains the trace-id associated with the event.</p>
    ///          <p>To learn more about X-Ray trace headers, see <a href="https://docs.aws.amazon.com/xray/latest/devguide/xray-concepts.html#xray-concepts-tracingheader">Tracing header</a> in the AWS X-Ray Developer Guide.</p>
    public let traceHeader: String?

    public init (
        detail: String? = nil,
        detailType: String? = nil,
        eventBusName: String? = nil,
        resources: [String]? = nil,
        source: String? = nil,
        time: Date? = nil,
        traceHeader: String? = nil
    )
    {
        self.detail = detail
        self.detailType = detailType
        self.eventBusName = eventBusName
        self.resources = resources
        self.source = source
        self.time = time
        self.traceHeader = traceHeader
    }
}

extension PutEventsResultEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case eventId = "EventId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension PutEventsResultEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEventsResultEntry(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), eventId: \(String(describing: eventId)))"}
}

/// <p>Represents an event that failed to be submitted.</p>
public struct PutEventsResultEntry: Equatable {
    /// <p>The error code that indicates why the event submission failed.</p>
    public let errorCode: String?
    /// <p>The error message that explains why the event submission failed.</p>
    public let errorMessage: String?
    /// <p>The ID of the event.</p>
    public let eventId: String?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        eventId: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.eventId = eventId
    }
}

public struct PutPartnerEventsInputBodyMiddleware: Middleware {
    public let id: String = "PutPartnerEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPartnerEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPartnerEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPartnerEventsInput>
    public typealias MOutput = OperationOutput<PutPartnerEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPartnerEventsOutputError>
}

extension PutPartnerEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPartnerEventsInput(entries: \(String(describing: entries)))"}
}

extension PutPartnerEventsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entries = "Entries"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for putpartnereventsrequestentrylist0 in entries {
                try entriesContainer.encode(putpartnereventsrequestentrylist0)
            }
        }
    }
}

public struct PutPartnerEventsInputHeadersMiddleware: Middleware {
    public let id: String = "PutPartnerEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPartnerEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPartnerEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPartnerEventsInput>
    public typealias MOutput = OperationOutput<PutPartnerEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPartnerEventsOutputError>
}

public struct PutPartnerEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutPartnerEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPartnerEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPartnerEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPartnerEventsInput>
    public typealias MOutput = OperationOutput<PutPartnerEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPartnerEventsOutputError>
}

public struct PutPartnerEventsInput: Equatable {
    /// <p>The list of events to write to the event bus.</p>
    public let entries: [PutPartnerEventsRequestEntry]?

    public init (
        entries: [PutPartnerEventsRequestEntry]? = nil
    )
    {
        self.entries = entries
    }
}

struct PutPartnerEventsInputBody: Equatable {
    public let entries: [PutPartnerEventsRequestEntry]?
}

extension PutPartnerEventsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entries = "Entries"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([PutPartnerEventsRequestEntry?].self, forKey: .entries)
        var entriesDecoded0:[PutPartnerEventsRequestEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [PutPartnerEventsRequestEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension PutPartnerEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutPartnerEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutPartnerEventsOutputError: Equatable {
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPartnerEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPartnerEventsOutputResponse(entries: \(String(describing: entries)), failedEntryCount: \(String(describing: failedEntryCount)))"}
}

extension PutPartnerEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutPartnerEventsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.entries = output.entries
            self.failedEntryCount = output.failedEntryCount
        } else {
            self.entries = nil
            self.failedEntryCount = 0
        }
    }
}

public struct PutPartnerEventsOutputResponse: Equatable {
    /// <p>The list of events from this operation that were successfully written to the partner event
    ///       bus.</p>
    public let entries: [PutPartnerEventsResultEntry]?
    /// <p>The number of events from this operation that could not be written to the partner event
    ///       bus.</p>
    public let failedEntryCount: Int

    public init (
        entries: [PutPartnerEventsResultEntry]? = nil,
        failedEntryCount: Int = 0
    )
    {
        self.entries = entries
        self.failedEntryCount = failedEntryCount
    }
}

struct PutPartnerEventsOutputResponseBody: Equatable {
    public let failedEntryCount: Int
    public let entries: [PutPartnerEventsResultEntry]?
}

extension PutPartnerEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case entries = "Entries"
        case failedEntryCount = "FailedEntryCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedEntryCountDecoded = try containerValues.decode(Int.self, forKey: .failedEntryCount)
        failedEntryCount = failedEntryCountDecoded
        let entriesContainer = try containerValues.decodeIfPresent([PutPartnerEventsResultEntry?].self, forKey: .entries)
        var entriesDecoded0:[PutPartnerEventsResultEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [PutPartnerEventsResultEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension PutPartnerEventsRequestEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case detail = "Detail"
        case detailType = "DetailType"
        case resources = "Resources"
        case source = "Source"
        case time = "Time"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detail = detail {
            try encodeContainer.encode(detail, forKey: .detail)
        }
        if let detailType = detailType {
            try encodeContainer.encode(detailType, forKey: .detailType)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for eventresourcelist0 in resources {
                try resourcesContainer.encode(eventresourcelist0)
            }
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let time = time {
            try encodeContainer.encode(time.timeIntervalSince1970, forKey: .time)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .time)
        time = timeDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resources)
        var resourcesDecoded0:[String]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [String]()
            for string0 in resourcesContainer {
                if let string0 = string0 {
                    resourcesDecoded0?.append(string0)
                }
            }
        }
        resources = resourcesDecoded0
        let detailTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detailType)
        detailType = detailTypeDecoded
        let detailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .detail)
        detail = detailDecoded
    }
}

extension PutPartnerEventsRequestEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPartnerEventsRequestEntry(detail: \(String(describing: detail)), detailType: \(String(describing: detailType)), resources: \(String(describing: resources)), source: \(String(describing: source)), time: \(String(describing: time)))"}
}

/// <p>The details about an event generated by an SaaS partner.</p>
public struct PutPartnerEventsRequestEntry: Equatable {
    /// <p>A valid JSON string. There is no other schema imposed. The JSON string may contain fields
    ///       and nested subobjects.</p>
    public let detail: String?
    /// <p>A free-form string used to decide what fields to expect in the event detail.</p>
    public let detailType: String?
    /// <p>AWS resources, identified by Amazon Resource Name (ARN), which the event primarily
    ///       concerns. Any number, including zero, may be present.</p>
    public let resources: [String]?
    /// <p>The event source that is generating the evntry.</p>
    public let source: String?
    /// <p>The date and time of the event.</p>
    public let time: Date?

    public init (
        detail: String? = nil,
        detailType: String? = nil,
        resources: [String]? = nil,
        source: String? = nil,
        time: Date? = nil
    )
    {
        self.detail = detail
        self.detailType = detailType
        self.resources = resources
        self.source = source
        self.time = time
    }
}

extension PutPartnerEventsResultEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case eventId = "EventId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension PutPartnerEventsResultEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPartnerEventsResultEntry(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), eventId: \(String(describing: eventId)))"}
}

/// <p>Represents an event that a partner tried to generate, but failed.</p>
public struct PutPartnerEventsResultEntry: Equatable {
    /// <p>The error code that indicates why the event submission failed.</p>
    public let errorCode: String?
    /// <p>The error message that explains why the event submission failed.</p>
    public let errorMessage: String?
    /// <p>The ID of the event.</p>
    public let eventId: String?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        eventId: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.eventId = eventId
    }
}

public struct PutPermissionInputBodyMiddleware: Middleware {
    public let id: String = "PutPermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPermissionInput>
    public typealias MOutput = OperationOutput<PutPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPermissionOutputError>
}

extension PutPermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPermissionInput(action: \(String(describing: action)), condition: \(String(describing: condition)), eventBusName: \(String(describing: eventBusName)), policy: \(String(describing: policy)), principal: \(String(describing: principal)), statementId: \(String(describing: statementId)))"}
}

extension PutPermissionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case condition = "Condition"
        case eventBusName = "EventBusName"
        case policy = "Policy"
        case principal = "Principal"
        case statementId = "StatementId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let condition = condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let statementId = statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }
}

public struct PutPermissionInputHeadersMiddleware: Middleware {
    public let id: String = "PutPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPermissionInput>
    public typealias MOutput = OperationOutput<PutPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPermissionOutputError>
}

public struct PutPermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "PutPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<PutPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutPermissionInput>
    public typealias MOutput = OperationOutput<PutPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutPermissionOutputError>
}

public struct PutPermissionInput: Equatable {
    /// <p>The action that you are enabling the other account to perform. Currently, this must be
    ///         <code>events:PutEvents</code>.</p>
    public let action: String?
    /// <p>This parameter enables you to limit the permission to accounts that fulfill a certain
    ///       condition, such as being a member of a certain AWS organization. For more information about
    ///       AWS Organizations, see <a href="https://docs.aws.amazon.com/organizations/latest/userguide/orgs_introduction.html">What Is AWS
    ///         Organizations</a> in the <i>AWS Organizations User Guide</i>.</p>
    ///          <p>If you specify <code>Condition</code> with an AWS organization ID, and specify "*" as the
    ///       value for <code>Principal</code>, you grant permission to all the accounts in the named
    ///       organization.</p>
    ///
    ///          <p>The <code>Condition</code> is a JSON string which must contain <code>Type</code>,
    ///         <code>Key</code>, and <code>Value</code> fields.</p>
    public let condition: Condition?
    /// <p>The name of the event bus associated with the rule. If you omit this, the default event
    ///       bus is used.</p>
    public let eventBusName: String?
    /// <p>A JSON string that describes the permission policy statement. You can include a
    ///         <code>Policy</code> parameter in the request instead of using the <code>StatementId</code>,
    ///         <code>Action</code>, <code>Principal</code>, or <code>Condition</code> parameters.</p>
    public let policy: String?
    /// <p>The 12-digit AWS account ID that you are permitting to put events to your default event
    ///       bus. Specify "*" to permit any account to put events to your default event bus.</p>
    ///
    ///          <p>If you specify "*" without specifying <code>Condition</code>, avoid creating rules that
    ///       may match undesirable events. To create more secure rules, make sure that the event pattern
    ///       for each rule contains an <code>account</code> field with a specific account ID from which to
    ///       receive events. Rules with an account field do not match any events sent from other
    ///       accounts.</p>
    public let principal: String?
    /// <p>An identifier string for the external account that you are granting permissions to. If you
    ///       later want to revoke the permission for this external account, specify this
    ///         <code>StatementId</code> when you run <a>RemovePermission</a>.</p>
    public let statementId: String?

    public init (
        action: String? = nil,
        condition: Condition? = nil,
        eventBusName: String? = nil,
        policy: String? = nil,
        principal: String? = nil,
        statementId: String? = nil
    )
    {
        self.action = action
        self.condition = condition
        self.eventBusName = eventBusName
        self.policy = policy
        self.principal = principal
        self.statementId = statementId
    }
}

struct PutPermissionInputBody: Equatable {
    public let eventBusName: String?
    public let action: String?
    public let principal: String?
    public let statementId: String?
    public let condition: Condition?
    public let policy: String?
}

extension PutPermissionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case condition = "Condition"
        case eventBusName = "EventBusName"
        case policy = "Policy"
        case principal = "Principal"
        case statementId = "StatementId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventBusNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .action)
        action = actionDecoded
        let principalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principal)
        principal = principalDecoded
        let statementIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statementId)
        statementId = statementIdDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(Condition.self, forKey: .condition)
        condition = conditionDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutPermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutPermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyLengthExceededException" : self = .policyLengthExceededException(try PolicyLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutPermissionOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case policyLengthExceededException(PolicyLengthExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutPermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutPermissionOutputResponse()"}
}

extension PutPermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutPermissionOutputResponse: Equatable {

    public init() {}
}

struct PutPermissionOutputResponseBody: Equatable {
}

extension PutPermissionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct PutRuleInputBodyMiddleware: Middleware {
    public let id: String = "PutRuleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRuleInput>
    public typealias MOutput = OperationOutput<PutRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRuleOutputError>
}

extension PutRuleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRuleInput(description: \(String(describing: description)), eventBusName: \(String(describing: eventBusName)), eventPattern: \(String(describing: eventPattern)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), scheduleExpression: \(String(describing: scheduleExpression)), state: \(String(describing: state)), tags: \(String(describing: tags)))"}
}

extension PutRuleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case eventBusName = "EventBusName"
        case eventPattern = "EventPattern"
        case name = "Name"
        case roleArn = "RoleArn"
        case scheduleExpression = "ScheduleExpression"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let eventPattern = eventPattern {
            try encodeContainer.encode(eventPattern, forKey: .eventPattern)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct PutRuleInputHeadersMiddleware: Middleware {
    public let id: String = "PutRuleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRuleInput>
    public typealias MOutput = OperationOutput<PutRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRuleOutputError>
}

public struct PutRuleInputQueryItemMiddleware: Middleware {
    public let id: String = "PutRuleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutRuleInput>,
                  next: H) -> Swift.Result<OperationOutput<PutRuleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutRuleInput>
    public typealias MOutput = OperationOutput<PutRuleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutRuleOutputError>
}

public struct PutRuleInput: Equatable {
    /// <p>A description of the rule.</p>
    public let description: String?
    /// <p>The name or ARN of the event bus to associate with this rule. If you omit this, the
    ///       default event bus is used.</p>
    public let eventBusName: String?
    /// <p>The event pattern. For more information, see <a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-and-event-patterns.html">Events and Event
    ///         Patterns</a> in the <i>Amazon EventBridge User Guide</i>.</p>
    public let eventPattern: String?
    /// <p>The name of the rule that you are creating or updating.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the IAM role associated with the rule.</p>
    public let roleArn: String?
    /// <p>The scheduling expression. For example, "cron(0 20 * * ? *)" or "rate(5 minutes)".</p>
    public let scheduleExpression: String?
    /// <p>Indicates whether the rule is enabled or disabled.</p>
    public let state: RuleState?
    /// <p>The list of key-value pairs to associate with the rule.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        eventBusName: String? = nil,
        eventPattern: String? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        scheduleExpression: String? = nil,
        state: RuleState? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.eventBusName = eventBusName
        self.eventPattern = eventPattern
        self.name = name
        self.roleArn = roleArn
        self.scheduleExpression = scheduleExpression
        self.state = state
        self.tags = tags
    }
}

struct PutRuleInputBody: Equatable {
    public let name: String?
    public let scheduleExpression: String?
    public let eventPattern: String?
    public let state: RuleState?
    public let description: String?
    public let roleArn: String?
    public let tags: [Tag]?
    public let eventBusName: String?
}

extension PutRuleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case eventBusName = "EventBusName"
        case eventPattern = "EventPattern"
        case name = "Name"
        case roleArn = "RoleArn"
        case scheduleExpression = "ScheduleExpression"
        case state = "State"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let stateDecoded = try containerValues.decodeIfPresent(RuleState.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let eventBusNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
    }
}

extension PutRuleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRuleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventPatternException" : self = .invalidEventPatternException(try InvalidEventPatternException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRuleOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case invalidEventPatternException(InvalidEventPatternException)
    case limitExceededException(LimitExceededException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRuleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutRuleOutputResponse(ruleArn: \(String(describing: ruleArn)))"}
}

extension PutRuleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutRuleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.ruleArn = output.ruleArn
        } else {
            self.ruleArn = nil
        }
    }
}

public struct PutRuleOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the rule.</p>
    public let ruleArn: String?

    public init (
        ruleArn: String? = nil
    )
    {
        self.ruleArn = ruleArn
    }
}

struct PutRuleOutputResponseBody: Equatable {
    public let ruleArn: String?
}

extension PutRuleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case ruleArn = "RuleArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ruleArn)
        ruleArn = ruleArnDecoded
    }
}

public struct PutTargetsInputBodyMiddleware: Middleware {
    public let id: String = "PutTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutTargetsInput>
    public typealias MOutput = OperationOutput<PutTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutTargetsOutputError>
}

extension PutTargetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutTargetsInput(eventBusName: \(String(describing: eventBusName)), rule: \(String(describing: rule)), targets: \(String(describing: targets)))"}
}

extension PutTargetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventBusName = "EventBusName"
        case rule = "Rule"
        case targets = "Targets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let rule = rule {
            try encodeContainer.encode(rule, forKey: .rule)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for targetlist0 in targets {
                try targetsContainer.encode(targetlist0)
            }
        }
    }
}

public struct PutTargetsInputHeadersMiddleware: Middleware {
    public let id: String = "PutTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutTargetsInput>
    public typealias MOutput = OperationOutput<PutTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutTargetsOutputError>
}

public struct PutTargetsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutTargetsInput>
    public typealias MOutput = OperationOutput<PutTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutTargetsOutputError>
}

public struct PutTargetsInput: Equatable {
    /// <p>The name or ARN of the event bus associated with the rule. If you omit this, the default
    ///       event bus is used.</p>
    public let eventBusName: String?
    /// <p>The name of the rule.</p>
    public let rule: String?
    /// <p>The targets to update or add to the rule.</p>
    public let targets: [Target]?

    public init (
        eventBusName: String? = nil,
        rule: String? = nil,
        targets: [Target]? = nil
    )
    {
        self.eventBusName = eventBusName
        self.rule = rule
        self.targets = targets
    }
}

struct PutTargetsInputBody: Equatable {
    public let rule: String?
    public let eventBusName: String?
    public let targets: [Target]?
}

extension PutTargetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventBusName = "EventBusName"
        case rule = "Rule"
        case targets = "Targets"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rule)
        rule = ruleDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let targetsContainer = try containerValues.decodeIfPresent([Target?].self, forKey: .targets)
        var targetsDecoded0:[Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
    }
}

extension PutTargetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutTargetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutTargetsOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutTargetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutTargetsOutputResponse(failedEntries: \(String(describing: failedEntries)), failedEntryCount: \(String(describing: failedEntryCount)))"}
}

extension PutTargetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutTargetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedEntries = output.failedEntries
            self.failedEntryCount = output.failedEntryCount
        } else {
            self.failedEntries = nil
            self.failedEntryCount = 0
        }
    }
}

public struct PutTargetsOutputResponse: Equatable {
    /// <p>The failed target entries.</p>
    public let failedEntries: [PutTargetsResultEntry]?
    /// <p>The number of failed entries.</p>
    public let failedEntryCount: Int

    public init (
        failedEntries: [PutTargetsResultEntry]? = nil,
        failedEntryCount: Int = 0
    )
    {
        self.failedEntries = failedEntries
        self.failedEntryCount = failedEntryCount
    }
}

struct PutTargetsOutputResponseBody: Equatable {
    public let failedEntryCount: Int
    public let failedEntries: [PutTargetsResultEntry]?
}

extension PutTargetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedEntries = "FailedEntries"
        case failedEntryCount = "FailedEntryCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedEntryCountDecoded = try containerValues.decode(Int.self, forKey: .failedEntryCount)
        failedEntryCount = failedEntryCountDecoded
        let failedEntriesContainer = try containerValues.decodeIfPresent([PutTargetsResultEntry?].self, forKey: .failedEntries)
        var failedEntriesDecoded0:[PutTargetsResultEntry]? = nil
        if let failedEntriesContainer = failedEntriesContainer {
            failedEntriesDecoded0 = [PutTargetsResultEntry]()
            for structure0 in failedEntriesContainer {
                if let structure0 = structure0 {
                    failedEntriesDecoded0?.append(structure0)
                }
            }
        }
        failedEntries = failedEntriesDecoded0
    }
}

extension PutTargetsResultEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case targetId = "TargetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let targetId = targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension PutTargetsResultEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutTargetsResultEntry(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), targetId: \(String(describing: targetId)))"}
}

/// <p>Represents a target that failed to be added to a rule.</p>
public struct PutTargetsResultEntry: Equatable {
    /// <p>The error code that indicates why the target addition failed. If the value is
    ///         <code>ConcurrentModificationException</code>, too many requests were made at the same
    ///       time.</p>
    public let errorCode: String?
    /// <p>The error message that explains why the target addition failed.</p>
    public let errorMessage: String?
    /// <p>The ID of the target.</p>
    public let targetId: String?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        targetId: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.targetId = targetId
    }
}

extension RedshiftDataParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case database = "Database"
        case dbUser = "DbUser"
        case secretManagerArn = "SecretManagerArn"
        case sql = "Sql"
        case statementName = "StatementName"
        case withEvent = "WithEvent"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let database = database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let dbUser = dbUser {
            try encodeContainer.encode(dbUser, forKey: .dbUser)
        }
        if let secretManagerArn = secretManagerArn {
            try encodeContainer.encode(secretManagerArn, forKey: .secretManagerArn)
        }
        if let sql = sql {
            try encodeContainer.encode(sql, forKey: .sql)
        }
        if let statementName = statementName {
            try encodeContainer.encode(statementName, forKey: .statementName)
        }
        if withEvent != false {
            try encodeContainer.encode(withEvent, forKey: .withEvent)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretManagerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretManagerArn)
        secretManagerArn = secretManagerArnDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .database)
        database = databaseDecoded
        let dbUserDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dbUser)
        dbUser = dbUserDecoded
        let sqlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sql)
        sql = sqlDecoded
        let statementNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statementName)
        statementName = statementNameDecoded
        let withEventDecoded = try containerValues.decode(Bool.self, forKey: .withEvent)
        withEvent = withEventDecoded
    }
}

extension RedshiftDataParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RedshiftDataParameters(database: \(String(describing: database)), dbUser: \(String(describing: dbUser)), secretManagerArn: \(String(describing: secretManagerArn)), sql: \(String(describing: sql)), statementName: \(String(describing: statementName)), withEvent: \(String(describing: withEvent)))"}
}

/// <p>These are custom parameters to be used when the target is a Redshift cluster to invoke the
///       Redshift Data API ExecuteStatement based on EventBridge events.</p>
public struct RedshiftDataParameters: Equatable {
    /// <p>The name of the database. Required when authenticating using temporary credentials.</p>
    public let database: String?
    /// <p>The database user name. Required when authenticating using temporary credentials.</p>
    public let dbUser: String?
    /// <p>The name or ARN of the secret that enables access to the database. Required when
    ///       authenticating using AWS Secrets Manager.</p>
    public let secretManagerArn: String?
    /// <p>The SQL statement text to run.</p>
    public let sql: String?
    /// <p>The name of the SQL statement. You can name the SQL statement when you create it to
    ///       identify the query.</p>
    public let statementName: String?
    /// <p>Indicates whether to send an event back to EventBridge after the SQL statement
    ///       runs.</p>
    public let withEvent: Bool

    public init (
        database: String? = nil,
        dbUser: String? = nil,
        secretManagerArn: String? = nil,
        sql: String? = nil,
        statementName: String? = nil,
        withEvent: Bool = false
    )
    {
        self.database = database
        self.dbUser = dbUser
        self.secretManagerArn = secretManagerArn
        self.sql = sql
        self.statementName = statementName
        self.withEvent = withEvent
    }
}

public struct RemovePermissionInputBodyMiddleware: Middleware {
    public let id: String = "RemovePermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemovePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemovePermissionInput>
    public typealias MOutput = OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemovePermissionOutputError>
}

extension RemovePermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemovePermissionInput(eventBusName: \(String(describing: eventBusName)), removeAllPermissions: \(String(describing: removeAllPermissions)), statementId: \(String(describing: statementId)))"}
}

extension RemovePermissionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventBusName = "EventBusName"
        case removeAllPermissions = "RemoveAllPermissions"
        case statementId = "StatementId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if removeAllPermissions != false {
            try encodeContainer.encode(removeAllPermissions, forKey: .removeAllPermissions)
        }
        if let statementId = statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }
}

public struct RemovePermissionInputHeadersMiddleware: Middleware {
    public let id: String = "RemovePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemovePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemovePermissionInput>
    public typealias MOutput = OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemovePermissionOutputError>
}

public struct RemovePermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "RemovePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemovePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemovePermissionInput>
    public typealias MOutput = OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemovePermissionOutputError>
}

public struct RemovePermissionInput: Equatable {
    /// <p>The name of the event bus to revoke permissions for. If you omit this, the default event
    ///       bus is used.</p>
    public let eventBusName: String?
    /// <p>Specifies whether to remove all permissions.</p>
    public let removeAllPermissions: Bool
    /// <p>The statement ID corresponding to the account that is no longer allowed to put events to
    ///       the default event bus.</p>
    public let statementId: String?

    public init (
        eventBusName: String? = nil,
        removeAllPermissions: Bool = false,
        statementId: String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.removeAllPermissions = removeAllPermissions
        self.statementId = statementId
    }
}

struct RemovePermissionInputBody: Equatable {
    public let statementId: String?
    public let removeAllPermissions: Bool
    public let eventBusName: String?
}

extension RemovePermissionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventBusName = "EventBusName"
        case removeAllPermissions = "RemoveAllPermissions"
        case statementId = "StatementId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statementId)
        statementId = statementIdDecoded
        let removeAllPermissionsDecoded = try containerValues.decode(Bool.self, forKey: .removeAllPermissions)
        removeAllPermissions = removeAllPermissionsDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
    }
}

extension RemovePermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemovePermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationDisabledException" : self = .operationDisabledException(try OperationDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemovePermissionOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case operationDisabledException(OperationDisabledException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemovePermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemovePermissionOutputResponse()"}
}

extension RemovePermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemovePermissionOutputResponse: Equatable {

    public init() {}
}

struct RemovePermissionOutputResponseBody: Equatable {
}

extension RemovePermissionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RemoveTargetsInputBodyMiddleware: Middleware {
    public let id: String = "RemoveTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTargetsInput>
    public typealias MOutput = OperationOutput<RemoveTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTargetsOutputError>
}

extension RemoveTargetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTargetsInput(eventBusName: \(String(describing: eventBusName)), force: \(String(describing: force)), ids: \(String(describing: ids)), rule: \(String(describing: rule)))"}
}

extension RemoveTargetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventBusName = "EventBusName"
        case force = "Force"
        case ids = "Ids"
        case rule = "Rule"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if force != false {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let ids = ids {
            var idsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ids)
            for targetidlist0 in ids {
                try idsContainer.encode(targetidlist0)
            }
        }
        if let rule = rule {
            try encodeContainer.encode(rule, forKey: .rule)
        }
    }
}

public struct RemoveTargetsInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTargetsInput>
    public typealias MOutput = OperationOutput<RemoveTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTargetsOutputError>
}

public struct RemoveTargetsInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveTargetsInput>
    public typealias MOutput = OperationOutput<RemoveTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveTargetsOutputError>
}

public struct RemoveTargetsInput: Equatable {
    /// <p>The name or ARN of the event bus associated with the rule. If you omit this, the default
    ///       event bus is used.</p>
    public let eventBusName: String?
    /// <p>If this is a managed rule, created by an AWS service on your behalf, you must specify
    ///         <code>Force</code> as <code>True</code> to remove targets. This parameter is ignored for
    ///       rules that are not managed rules. You can check whether a rule is a managed rule by using
    ///         <code>DescribeRule</code> or <code>ListRules</code> and checking the <code>ManagedBy</code>
    ///       field of the response.</p>
    public let force: Bool
    /// <p>The IDs of the targets to remove from the rule.</p>
    public let ids: [String]?
    /// <p>The name of the rule.</p>
    public let rule: String?

    public init (
        eventBusName: String? = nil,
        force: Bool = false,
        ids: [String]? = nil,
        rule: String? = nil
    )
    {
        self.eventBusName = eventBusName
        self.force = force
        self.ids = ids
        self.rule = rule
    }
}

struct RemoveTargetsInputBody: Equatable {
    public let rule: String?
    public let eventBusName: String?
    public let ids: [String]?
    public let force: Bool
}

extension RemoveTargetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventBusName = "EventBusName"
        case force = "Force"
        case ids = "Ids"
        case rule = "Rule"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rule)
        rule = ruleDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
        let idsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ids)
        var idsDecoded0:[String]? = nil
        if let idsContainer = idsContainer {
            idsDecoded0 = [String]()
            for string0 in idsContainer {
                if let string0 = string0 {
                    idsDecoded0?.append(string0)
                }
            }
        }
        ids = idsDecoded0
        let forceDecoded = try containerValues.decode(Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension RemoveTargetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTargetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveTargetsOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTargetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTargetsOutputResponse(failedEntries: \(String(describing: failedEntries)), failedEntryCount: \(String(describing: failedEntryCount)))"}
}

extension RemoveTargetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RemoveTargetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedEntries = output.failedEntries
            self.failedEntryCount = output.failedEntryCount
        } else {
            self.failedEntries = nil
            self.failedEntryCount = 0
        }
    }
}

public struct RemoveTargetsOutputResponse: Equatable {
    /// <p>The failed target entries.</p>
    public let failedEntries: [RemoveTargetsResultEntry]?
    /// <p>The number of failed entries.</p>
    public let failedEntryCount: Int

    public init (
        failedEntries: [RemoveTargetsResultEntry]? = nil,
        failedEntryCount: Int = 0
    )
    {
        self.failedEntries = failedEntries
        self.failedEntryCount = failedEntryCount
    }
}

struct RemoveTargetsOutputResponseBody: Equatable {
    public let failedEntryCount: Int
    public let failedEntries: [RemoveTargetsResultEntry]?
}

extension RemoveTargetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedEntries = "FailedEntries"
        case failedEntryCount = "FailedEntryCount"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedEntryCountDecoded = try containerValues.decode(Int.self, forKey: .failedEntryCount)
        failedEntryCount = failedEntryCountDecoded
        let failedEntriesContainer = try containerValues.decodeIfPresent([RemoveTargetsResultEntry?].self, forKey: .failedEntries)
        var failedEntriesDecoded0:[RemoveTargetsResultEntry]? = nil
        if let failedEntriesContainer = failedEntriesContainer {
            failedEntriesDecoded0 = [RemoveTargetsResultEntry]()
            for structure0 in failedEntriesContainer {
                if let structure0 = structure0 {
                    failedEntriesDecoded0?.append(structure0)
                }
            }
        }
        failedEntries = failedEntriesDecoded0
    }
}

extension RemoveTargetsResultEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case targetId = "TargetId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let targetId = targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension RemoveTargetsResultEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveTargetsResultEntry(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), targetId: \(String(describing: targetId)))"}
}

/// <p>Represents a target that failed to be removed from a rule.</p>
public struct RemoveTargetsResultEntry: Equatable {
    /// <p>The error code that indicates why the target removal failed. If the value is
    ///         <code>ConcurrentModificationException</code>, too many requests were made at the same
    ///       time.</p>
    public let errorCode: String?
    /// <p>The error message that explains why the target removal failed.</p>
    public let errorMessage: String?
    /// <p>The ID of the target.</p>
    public let targetId: String?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        targetId: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.targetId = targetId
    }
}

extension Replay: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventEndTime = "EventEndTime"
        case eventLastReplayedTime = "EventLastReplayedTime"
        case eventSourceArn = "EventSourceArn"
        case eventStartTime = "EventStartTime"
        case replayEndTime = "ReplayEndTime"
        case replayName = "ReplayName"
        case replayStartTime = "ReplayStartTime"
        case state = "State"
        case stateReason = "StateReason"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventEndTime = eventEndTime {
            try encodeContainer.encode(eventEndTime.timeIntervalSince1970, forKey: .eventEndTime)
        }
        if let eventLastReplayedTime = eventLastReplayedTime {
            try encodeContainer.encode(eventLastReplayedTime.timeIntervalSince1970, forKey: .eventLastReplayedTime)
        }
        if let eventSourceArn = eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let eventStartTime = eventStartTime {
            try encodeContainer.encode(eventStartTime.timeIntervalSince1970, forKey: .eventStartTime)
        }
        if let replayEndTime = replayEndTime {
            try encodeContainer.encode(replayEndTime.timeIntervalSince1970, forKey: .replayEndTime)
        }
        if let replayName = replayName {
            try encodeContainer.encode(replayName, forKey: .replayName)
        }
        if let replayStartTime = replayStartTime {
            try encodeContainer.encode(replayStartTime.timeIntervalSince1970, forKey: .replayStartTime)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replayName)
        replayName = replayNameDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ReplayState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let eventStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .eventStartTime)
        eventStartTime = eventStartTimeDecoded
        let eventEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .eventEndTime)
        eventEndTime = eventEndTimeDecoded
        let eventLastReplayedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .eventLastReplayedTime)
        eventLastReplayedTime = eventLastReplayedTimeDecoded
        let replayStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .replayStartTime)
        replayStartTime = replayStartTimeDecoded
        let replayEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .replayEndTime)
        replayEndTime = replayEndTimeDecoded
    }
}

extension Replay: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Replay(eventEndTime: \(String(describing: eventEndTime)), eventLastReplayedTime: \(String(describing: eventLastReplayedTime)), eventSourceArn: \(String(describing: eventSourceArn)), eventStartTime: \(String(describing: eventStartTime)), replayEndTime: \(String(describing: replayEndTime)), replayName: \(String(describing: replayName)), replayStartTime: \(String(describing: replayStartTime)), state: \(String(describing: state)), stateReason: \(String(describing: stateReason)))"}
}

/// <p>A <code>Replay</code> object that contains details about a replay.</p>
public struct Replay: Equatable {
    /// <p>A time stamp for the time to start replaying events. Any event with a creation time prior
    ///       to the <code>EventEndTime</code> specified is replayed.</p>
    public let eventEndTime: Date?
    /// <p>A time stamp for the time that the last event was replayed.</p>
    public let eventLastReplayedTime: Date?
    /// <p>The ARN of the archive to replay event from.</p>
    public let eventSourceArn: String?
    /// <p>A time stamp for the time to start replaying events. This is determined by the time in the
    ///       event as described in <a href="https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEventsRequestEntry.html#eventbridge-Type-PutEventsRequestEntry-Time">Time</a>.</p>
    public let eventStartTime: Date?
    /// <p>A time stamp for the time that the replay completed.</p>
    public let replayEndTime: Date?
    /// <p>The name of the replay.</p>
    public let replayName: String?
    /// <p>A time stamp for the time that the replay started.</p>
    public let replayStartTime: Date?
    /// <p>The current state of the replay.</p>
    public let state: ReplayState?
    /// <p>A description of why the replay is in the current state.</p>
    public let stateReason: String?

    public init (
        eventEndTime: Date? = nil,
        eventLastReplayedTime: Date? = nil,
        eventSourceArn: String? = nil,
        eventStartTime: Date? = nil,
        replayEndTime: Date? = nil,
        replayName: String? = nil,
        replayStartTime: Date? = nil,
        state: ReplayState? = nil,
        stateReason: String? = nil
    )
    {
        self.eventEndTime = eventEndTime
        self.eventLastReplayedTime = eventLastReplayedTime
        self.eventSourceArn = eventSourceArn
        self.eventStartTime = eventStartTime
        self.replayEndTime = replayEndTime
        self.replayName = replayName
        self.replayStartTime = replayStartTime
        self.state = state
        self.stateReason = stateReason
    }
}

extension ReplayDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case filterArns = "FilterArns"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let filterArns = filterArns {
            var filterArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterArns)
            for replaydestinationfilters0 in filterArns {
                try filterArnsContainer.encode(replaydestinationfilters0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let filterArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .filterArns)
        var filterArnsDecoded0:[String]? = nil
        if let filterArnsContainer = filterArnsContainer {
            filterArnsDecoded0 = [String]()
            for string0 in filterArnsContainer {
                if let string0 = string0 {
                    filterArnsDecoded0?.append(string0)
                }
            }
        }
        filterArns = filterArnsDecoded0
    }
}

extension ReplayDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplayDestination(arn: \(String(describing: arn)), filterArns: \(String(describing: filterArns)))"}
}

/// <p>A <code>ReplayDestination</code> object that contains details about a replay.</p>
public struct ReplayDestination: Equatable {
    /// <p>The ARN of the event bus to replay event to. You can replay events only to the event bus
    ///       specified to create the archive.</p>
    public let arn: String?
    /// <p>A list of ARNs for rules to replay events to.</p>
    public let filterArns: [String]?

    public init (
        arn: String? = nil,
        filterArns: [String]? = nil
    )
    {
        self.arn = arn
        self.filterArns = filterArns
    }
}

public enum ReplayState {
    case cancelled
    case cancelling
    case completed
    case failed
    case running
    case starting
    case sdkUnknown(String)
}

extension ReplayState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReplayState] {
        return [
            .cancelled,
            .cancelling,
            .completed,
            .failed,
            .running,
            .starting,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "CANCELLED"
        case .cancelling: return "CANCELLING"
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .running: return "RUNNING"
        case .starting: return "STARTING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReplayState(rawValue: rawValue) ?? ReplayState.sdkUnknown(rawValue)
    }
}

extension ResourceAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ResourceAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource you are trying to create already exists.</p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ResourceAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An entity that you specified does not exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RetryPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximumEventAgeInSeconds = maximumEventAgeInSeconds {
            try encodeContainer.encode(maximumEventAgeInSeconds, forKey: .maximumEventAgeInSeconds)
        }
        if let maximumRetryAttempts = maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
    }
}

extension RetryPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RetryPolicy(maximumEventAgeInSeconds: \(String(describing: maximumEventAgeInSeconds)), maximumRetryAttempts: \(String(describing: maximumRetryAttempts)))"}
}

/// <p>A <code>RetryPolicy</code> object that includes information about the retry policy
///       settings.</p>
public struct RetryPolicy: Equatable {
    /// <p>The maximum amount of time, in seconds, to continue to make retry attempts.</p>
    public let maximumEventAgeInSeconds: Int?
    /// <p>The maximum number of retry attempts to make before the request fails. Retry attempts
    ///       continue until either the maximum number of attempts is made or until the duration of the
    ///         <code>MaximumEventAgeInSeconds</code> is met.</p>
    public let maximumRetryAttempts: Int?

    public init (
        maximumEventAgeInSeconds: Int? = nil,
        maximumRetryAttempts: Int? = nil
    )
    {
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
    }
}

extension Rule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case description = "Description"
        case eventBusName = "EventBusName"
        case eventPattern = "EventPattern"
        case managedBy = "ManagedBy"
        case name = "Name"
        case roleArn = "RoleArn"
        case scheduleExpression = "ScheduleExpression"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventBusName = eventBusName {
            try encodeContainer.encode(eventBusName, forKey: .eventBusName)
        }
        if let eventPattern = eventPattern {
            try encodeContainer.encode(eventPattern, forKey: .eventPattern)
        }
        if let managedBy = managedBy {
            try encodeContainer.encode(managedBy, forKey: .managedBy)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let scheduleExpression = scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let stateDecoded = try containerValues.decodeIfPresent(RuleState.self, forKey: .state)
        state = stateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let managedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .managedBy)
        managedBy = managedByDecoded
        let eventBusNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventBusName)
        eventBusName = eventBusNameDecoded
    }
}

extension Rule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Rule(arn: \(String(describing: arn)), description: \(String(describing: description)), eventBusName: \(String(describing: eventBusName)), eventPattern: \(String(describing: eventPattern)), managedBy: \(String(describing: managedBy)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), scheduleExpression: \(String(describing: scheduleExpression)), state: \(String(describing: state)))"}
}

/// <p>Contains information about a rule in Amazon EventBridge.</p>
public struct Rule: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the rule.</p>
    public let arn: String?
    /// <p>The description of the rule.</p>
    public let description: String?
    /// <p>The name or ARN of the event bus associated with the rule. If you omit this, the default
    ///       event bus is used.</p>
    public let eventBusName: String?
    /// <p>The event pattern of the rule. For more information, see <a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-and-event-patterns.html">Events and Event
    ///         Patterns</a> in the <i>Amazon EventBridge User Guide</i>.</p>
    public let eventPattern: String?
    /// <p>If the rule was created on behalf of your account by an AWS service, this field displays
    ///       the principal name of the service that created the rule.</p>
    public let managedBy: String?
    /// <p>The name of the rule.</p>
    public let name: String?
    /// <p>The Amazon Resource Name (ARN) of the role that is used for target invocation.</p>
    public let roleArn: String?
    /// <p>The scheduling expression. For example, "cron(0 20 * * ? *)", "rate(5 minutes)".</p>
    public let scheduleExpression: String?
    /// <p>The state of the rule.</p>
    public let state: RuleState?

    public init (
        arn: String? = nil,
        description: String? = nil,
        eventBusName: String? = nil,
        eventPattern: String? = nil,
        managedBy: String? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        scheduleExpression: String? = nil,
        state: RuleState? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.eventBusName = eventBusName
        self.eventPattern = eventPattern
        self.managedBy = managedBy
        self.name = name
        self.roleArn = roleArn
        self.scheduleExpression = scheduleExpression
        self.state = state
    }
}

public enum RuleState {
    case disabled
    case enabled
    case sdkUnknown(String)
}

extension RuleState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RuleState] {
        return [
            .disabled,
            .enabled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .enabled: return "ENABLED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RuleState(rawValue: rawValue) ?? RuleState.sdkUnknown(rawValue)
    }
}

extension RunCommandParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case runCommandTargets = "RunCommandTargets"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let runCommandTargets = runCommandTargets {
            var runCommandTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .runCommandTargets)
            for runcommandtargets0 in runCommandTargets {
                try runCommandTargetsContainer.encode(runcommandtargets0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runCommandTargetsContainer = try containerValues.decodeIfPresent([RunCommandTarget?].self, forKey: .runCommandTargets)
        var runCommandTargetsDecoded0:[RunCommandTarget]? = nil
        if let runCommandTargetsContainer = runCommandTargetsContainer {
            runCommandTargetsDecoded0 = [RunCommandTarget]()
            for structure0 in runCommandTargetsContainer {
                if let structure0 = structure0 {
                    runCommandTargetsDecoded0?.append(structure0)
                }
            }
        }
        runCommandTargets = runCommandTargetsDecoded0
    }
}

extension RunCommandParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RunCommandParameters(runCommandTargets: \(String(describing: runCommandTargets)))"}
}

/// <p>This parameter contains the criteria (either InstanceIds or a tag) used to specify which
///       EC2 instances are to be sent the command. </p>
public struct RunCommandParameters: Equatable {
    /// <p>Currently, we support including only one RunCommandTarget block, which specifies either an
    ///       array of InstanceIds or a tag.</p>
    public let runCommandTargets: [RunCommandTarget]?

    public init (
        runCommandTargets: [RunCommandTarget]? = nil
    )
    {
        self.runCommandTargets = runCommandTargets
    }
}

extension RunCommandTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for runcommandtargetvalues0 in values {
                try valuesContainer.encode(runcommandtargetvalues0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension RunCommandTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RunCommandTarget(key: \(String(describing: key)), values: \(String(describing: values)))"}
}

/// <p>Information about the EC2 instances that are to be sent the command, specified as
///       key-value pairs. Each <code>RunCommandTarget</code> block can include only one key, but this
///       key may specify multiple values.</p>
public struct RunCommandTarget: Equatable {
    /// <p>Can be either <code>tag:</code>
    ///             <i>tag-key</i> or
    ///       <code>InstanceIds</code>.</p>
    public let key: String?
    /// <p>If <code>Key</code> is <code>tag:</code>
    ///             <i>tag-key</i>, <code>Values</code>
    ///       is a list of tag values. If <code>Key</code> is <code>InstanceIds</code>, <code>Values</code>
    ///       is a list of Amazon EC2 instance IDs.</p>
    public let values: [String]?

    public init (
        key: String? = nil,
        values: [String]? = nil
    )
    {
        self.key = key
        self.values = values
    }
}

extension SageMakerPipelineParameter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SageMakerPipelineParameter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SageMakerPipelineParameter(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Name/Value pair of a parameter to start execution of a SageMaker Model Building
///       Pipeline.</p>
public struct SageMakerPipelineParameter: Equatable {
    /// <p>Name of parameter to start execution of a SageMaker Model Building Pipeline.</p>
    public let name: String?
    /// <p>Value of parameter to start execution of a SageMaker Model Building Pipeline.</p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

extension SageMakerPipelineParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pipelineParameterList = "PipelineParameterList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineParameterList = pipelineParameterList {
            var pipelineParameterListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pipelineParameterList)
            for sagemakerpipelineparameterlist0 in pipelineParameterList {
                try pipelineParameterListContainer.encode(sagemakerpipelineparameterlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineParameterListContainer = try containerValues.decodeIfPresent([SageMakerPipelineParameter?].self, forKey: .pipelineParameterList)
        var pipelineParameterListDecoded0:[SageMakerPipelineParameter]? = nil
        if let pipelineParameterListContainer = pipelineParameterListContainer {
            pipelineParameterListDecoded0 = [SageMakerPipelineParameter]()
            for structure0 in pipelineParameterListContainer {
                if let structure0 = structure0 {
                    pipelineParameterListDecoded0?.append(structure0)
                }
            }
        }
        pipelineParameterList = pipelineParameterListDecoded0
    }
}

extension SageMakerPipelineParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SageMakerPipelineParameters(pipelineParameterList: \(String(describing: pipelineParameterList)))"}
}

/// <p>These are custom parameters to use when the target is a SageMaker Model Building Pipeline
///       that starts based on EventBridge events.</p>
public struct SageMakerPipelineParameters: Equatable {
    /// <p>List of Parameter names and values for SageMaker Model Building Pipeline execution.</p>
    public let pipelineParameterList: [SageMakerPipelineParameter]?

    public init (
        pipelineParameterList: [SageMakerPipelineParameter]? = nil
    )
    {
        self.pipelineParameterList = pipelineParameterList
    }
}

extension SqsParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case messageGroupId = "MessageGroupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageGroupId = messageGroupId {
            try encodeContainer.encode(messageGroupId, forKey: .messageGroupId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageGroupId)
        messageGroupId = messageGroupIdDecoded
    }
}

extension SqsParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SqsParameters(messageGroupId: \(String(describing: messageGroupId)))"}
}

/// <p>This structure includes the custom parameter to be used when the target is an SQS FIFO
///       queue.</p>
public struct SqsParameters: Equatable {
    /// <p>The FIFO message group ID to use as the target.</p>
    public let messageGroupId: String?

    public init (
        messageGroupId: String? = nil
    )
    {
        self.messageGroupId = messageGroupId
    }
}

public struct StartReplayInputBodyMiddleware: Middleware {
    public let id: String = "StartReplayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartReplayInput>,
                  next: H) -> Swift.Result<OperationOutput<StartReplayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartReplayInput>
    public typealias MOutput = OperationOutput<StartReplayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartReplayOutputError>
}

extension StartReplayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartReplayInput(description: \(String(describing: description)), destination: \(String(describing: destination)), eventEndTime: \(String(describing: eventEndTime)), eventSourceArn: \(String(describing: eventSourceArn)), eventStartTime: \(String(describing: eventStartTime)), replayName: \(String(describing: replayName)))"}
}

extension StartReplayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case destination = "Destination"
        case eventEndTime = "EventEndTime"
        case eventSourceArn = "EventSourceArn"
        case eventStartTime = "EventStartTime"
        case replayName = "ReplayName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let eventEndTime = eventEndTime {
            try encodeContainer.encode(eventEndTime.timeIntervalSince1970, forKey: .eventEndTime)
        }
        if let eventSourceArn = eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let eventStartTime = eventStartTime {
            try encodeContainer.encode(eventStartTime.timeIntervalSince1970, forKey: .eventStartTime)
        }
        if let replayName = replayName {
            try encodeContainer.encode(replayName, forKey: .replayName)
        }
    }
}

public struct StartReplayInputHeadersMiddleware: Middleware {
    public let id: String = "StartReplayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartReplayInput>,
                  next: H) -> Swift.Result<OperationOutput<StartReplayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartReplayInput>
    public typealias MOutput = OperationOutput<StartReplayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartReplayOutputError>
}

public struct StartReplayInputQueryItemMiddleware: Middleware {
    public let id: String = "StartReplayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartReplayInput>,
                  next: H) -> Swift.Result<OperationOutput<StartReplayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartReplayInput>
    public typealias MOutput = OperationOutput<StartReplayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartReplayOutputError>
}

public struct StartReplayInput: Equatable {
    /// <p>A description for the replay to start.</p>
    public let description: String?
    /// <p>A <code>ReplayDestination</code> object that includes details about the destination for
    ///       the replay.</p>
    public let destination: ReplayDestination?
    /// <p>A time stamp for the time to stop replaying events. Only events that occurred between the
    ///         <code>EventStartTime</code> and <code>EventEndTime</code> are replayed.</p>
    public let eventEndTime: Date?
    /// <p>The ARN of the archive to replay events from.</p>
    public let eventSourceArn: String?
    /// <p>A time stamp for the time to start replaying events. Only events that occurred between the
    ///         <code>EventStartTime</code> and <code>EventEndTime</code> are replayed.</p>
    public let eventStartTime: Date?
    /// <p>The name of the replay to start.</p>
    public let replayName: String?

    public init (
        description: String? = nil,
        destination: ReplayDestination? = nil,
        eventEndTime: Date? = nil,
        eventSourceArn: String? = nil,
        eventStartTime: Date? = nil,
        replayName: String? = nil
    )
    {
        self.description = description
        self.destination = destination
        self.eventEndTime = eventEndTime
        self.eventSourceArn = eventSourceArn
        self.eventStartTime = eventStartTime
        self.replayName = replayName
    }
}

struct StartReplayInputBody: Equatable {
    public let replayName: String?
    public let description: String?
    public let eventSourceArn: String?
    public let eventStartTime: Date?
    public let eventEndTime: Date?
    public let destination: ReplayDestination?
}

extension StartReplayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case destination = "Destination"
        case eventEndTime = "EventEndTime"
        case eventSourceArn = "EventSourceArn"
        case eventStartTime = "EventStartTime"
        case replayName = "ReplayName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replayName)
        replayName = replayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let eventStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .eventStartTime)
        eventStartTime = eventStartTimeDecoded
        let eventEndTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .eventEndTime)
        eventEndTime = eventEndTimeDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(ReplayDestination.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension StartReplayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartReplayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventPatternException" : self = .invalidEventPatternException(try InvalidEventPatternException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartReplayOutputError: Equatable {
    case internalException(InternalException)
    case invalidEventPatternException(InvalidEventPatternException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartReplayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartReplayOutputResponse(replayArn: \(String(describing: replayArn)), replayStartTime: \(String(describing: replayStartTime)), state: \(String(describing: state)), stateReason: \(String(describing: stateReason)))"}
}

extension StartReplayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartReplayOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replayArn = output.replayArn
            self.replayStartTime = output.replayStartTime
            self.state = output.state
            self.stateReason = output.stateReason
        } else {
            self.replayArn = nil
            self.replayStartTime = nil
            self.state = nil
            self.stateReason = nil
        }
    }
}

public struct StartReplayOutputResponse: Equatable {
    /// <p>The ARN of the replay.</p>
    public let replayArn: String?
    /// <p>The time at which the replay started.</p>
    public let replayStartTime: Date?
    /// <p>The state of the replay.</p>
    public let state: ReplayState?
    /// <p>The reason that the replay is in the state.</p>
    public let stateReason: String?

    public init (
        replayArn: String? = nil,
        replayStartTime: Date? = nil,
        state: ReplayState? = nil,
        stateReason: String? = nil
    )
    {
        self.replayArn = replayArn
        self.replayStartTime = replayStartTime
        self.state = state
        self.stateReason = stateReason
    }
}

struct StartReplayOutputResponseBody: Equatable {
    public let replayArn: String?
    public let state: ReplayState?
    public let stateReason: String?
    public let replayStartTime: Date?
}

extension StartReplayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replayArn = "ReplayArn"
        case replayStartTime = "ReplayStartTime"
        case state = "State"
        case stateReason = "StateReason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replayArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .replayArn)
        replayArn = replayArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ReplayState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let replayStartTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .replayStartTime)
        replayStartTime = replayStartTimeDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A key-value pair associated with an AWS resource. In EventBridge, rules and event buses
///       support tagging.</p>
public struct Tag: Equatable {
    /// <p>A string you can use to assign a value. The combination of tag keys and values can help
    ///       you organize and categorize your resources.</p>
    public let key: String?
    /// <p>The value for the specified tag key.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The ARN of the EventBridge resource that you're adding tags to.</p>
    public let resourceARN: String?
    /// <p>The list of key-value pairs to associate with the resource.</p>
    public let tags: [Tag]?

    public init (
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Target: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case batchParameters = "BatchParameters"
        case deadLetterConfig = "DeadLetterConfig"
        case ecsParameters = "EcsParameters"
        case httpParameters = "HttpParameters"
        case id = "Id"
        case input = "Input"
        case inputPath = "InputPath"
        case inputTransformer = "InputTransformer"
        case kinesisParameters = "KinesisParameters"
        case redshiftDataParameters = "RedshiftDataParameters"
        case retryPolicy = "RetryPolicy"
        case roleArn = "RoleArn"
        case runCommandParameters = "RunCommandParameters"
        case sageMakerPipelineParameters = "SageMakerPipelineParameters"
        case sqsParameters = "SqsParameters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let batchParameters = batchParameters {
            try encodeContainer.encode(batchParameters, forKey: .batchParameters)
        }
        if let deadLetterConfig = deadLetterConfig {
            try encodeContainer.encode(deadLetterConfig, forKey: .deadLetterConfig)
        }
        if let ecsParameters = ecsParameters {
            try encodeContainer.encode(ecsParameters, forKey: .ecsParameters)
        }
        if let httpParameters = httpParameters {
            try encodeContainer.encode(httpParameters, forKey: .httpParameters)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let input = input {
            try encodeContainer.encode(input, forKey: .input)
        }
        if let inputPath = inputPath {
            try encodeContainer.encode(inputPath, forKey: .inputPath)
        }
        if let inputTransformer = inputTransformer {
            try encodeContainer.encode(inputTransformer, forKey: .inputTransformer)
        }
        if let kinesisParameters = kinesisParameters {
            try encodeContainer.encode(kinesisParameters, forKey: .kinesisParameters)
        }
        if let redshiftDataParameters = redshiftDataParameters {
            try encodeContainer.encode(redshiftDataParameters, forKey: .redshiftDataParameters)
        }
        if let retryPolicy = retryPolicy {
            try encodeContainer.encode(retryPolicy, forKey: .retryPolicy)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let runCommandParameters = runCommandParameters {
            try encodeContainer.encode(runCommandParameters, forKey: .runCommandParameters)
        }
        if let sageMakerPipelineParameters = sageMakerPipelineParameters {
            try encodeContainer.encode(sageMakerPipelineParameters, forKey: .sageMakerPipelineParameters)
        }
        if let sqsParameters = sqsParameters {
            try encodeContainer.encode(sqsParameters, forKey: .sqsParameters)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let inputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .input)
        input = inputDecoded
        let inputPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inputPath)
        inputPath = inputPathDecoded
        let inputTransformerDecoded = try containerValues.decodeIfPresent(InputTransformer.self, forKey: .inputTransformer)
        inputTransformer = inputTransformerDecoded
        let kinesisParametersDecoded = try containerValues.decodeIfPresent(KinesisParameters.self, forKey: .kinesisParameters)
        kinesisParameters = kinesisParametersDecoded
        let runCommandParametersDecoded = try containerValues.decodeIfPresent(RunCommandParameters.self, forKey: .runCommandParameters)
        runCommandParameters = runCommandParametersDecoded
        let ecsParametersDecoded = try containerValues.decodeIfPresent(EcsParameters.self, forKey: .ecsParameters)
        ecsParameters = ecsParametersDecoded
        let batchParametersDecoded = try containerValues.decodeIfPresent(BatchParameters.self, forKey: .batchParameters)
        batchParameters = batchParametersDecoded
        let sqsParametersDecoded = try containerValues.decodeIfPresent(SqsParameters.self, forKey: .sqsParameters)
        sqsParameters = sqsParametersDecoded
        let httpParametersDecoded = try containerValues.decodeIfPresent(HttpParameters.self, forKey: .httpParameters)
        httpParameters = httpParametersDecoded
        let redshiftDataParametersDecoded = try containerValues.decodeIfPresent(RedshiftDataParameters.self, forKey: .redshiftDataParameters)
        redshiftDataParameters = redshiftDataParametersDecoded
        let sageMakerPipelineParametersDecoded = try containerValues.decodeIfPresent(SageMakerPipelineParameters.self, forKey: .sageMakerPipelineParameters)
        sageMakerPipelineParameters = sageMakerPipelineParametersDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let retryPolicyDecoded = try containerValues.decodeIfPresent(RetryPolicy.self, forKey: .retryPolicy)
        retryPolicy = retryPolicyDecoded
    }
}

extension Target: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Target(arn: \(String(describing: arn)), batchParameters: \(String(describing: batchParameters)), deadLetterConfig: \(String(describing: deadLetterConfig)), ecsParameters: \(String(describing: ecsParameters)), httpParameters: \(String(describing: httpParameters)), id: \(String(describing: id)), input: \(String(describing: input)), inputPath: \(String(describing: inputPath)), inputTransformer: \(String(describing: inputTransformer)), kinesisParameters: \(String(describing: kinesisParameters)), redshiftDataParameters: \(String(describing: redshiftDataParameters)), retryPolicy: \(String(describing: retryPolicy)), roleArn: \(String(describing: roleArn)), runCommandParameters: \(String(describing: runCommandParameters)), sageMakerPipelineParameters: \(String(describing: sageMakerPipelineParameters)), sqsParameters: \(String(describing: sqsParameters)))"}
}

/// <p>Targets are the resources to be invoked when a rule is triggered. For a complete list of
///       services and resources that can be set as a target, see <a>PutTargets</a>.</p>
///
///          <p>If you are setting the event bus of another account as the target, and that account
///       granted permission to your account through an organization instead of directly by the account
///       ID, then you must specify a <code>RoleArn</code> with proper permissions in the
///         <code>Target</code> structure. For more information, see <a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-cross-account-event-delivery.html">Sending and
///         Receiving Events Between AWS Accounts</a> in the <i>Amazon EventBridge User
///         Guide</i>.</p>
public struct Target: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the target.</p>
    public let arn: String?
    /// <p>If the event target is an AWS Batch job, this contains the job definition, job name, and
    ///       other parameters. For more information, see <a href="https://docs.aws.amazon.com/batch/latest/userguide/jobs.html">Jobs</a> in the <i>AWS Batch User
    ///         Guide</i>.</p>
    public let batchParameters: BatchParameters?
    /// <p>The <code>DeadLetterConfig</code> that defines the target queue to send dead-letter queue
    ///       events to.</p>
    public let deadLetterConfig: DeadLetterConfig?
    /// <p>Contains the Amazon ECS task definition and task count to be used, if the event target is
    ///       an Amazon ECS task. For more information about Amazon ECS tasks, see <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_defintions.html">Task
    ///         Definitions </a> in the <i>Amazon EC2 Container Service Developer
    ///         Guide</i>.</p>
    public let ecsParameters: EcsParameters?
    /// <p>Contains the HTTP parameters to use when the target is a API Gateway REST endpoint
    ///       or EventBridge ApiDestination.</p>
    ///          <p>If you specify an API Gateway REST API or EventBridge ApiDestination as a target, you
    ///       can use this parameter to specify headers, path parameters, and query string keys/values
    ///       as part of your target invoking request. If you're using ApiDestinations, the corresponding
    ///       Connection can also have these values configured. In case of any conflicting keys, values
    ///       from the Connection take precedence.</p>
    public let httpParameters: HttpParameters?
    /// <p>The ID of the target.</p>
    public let id: String?
    /// <p>Valid JSON text passed to the target. In this case, nothing from the event itself is
    ///       passed to the target. For more information, see <a href="http://www.rfc-editor.org/rfc/rfc7159.txt">The JavaScript Object Notation (JSON) Data
    ///         Interchange Format</a>.</p>
    public let input: String?
    /// <p>The value of the JSONPath that is used for extracting part of the matched event when
    ///       passing it to the target. You must use JSON dot notation, not bracket notation. For more
    ///       information about JSON paths, see <a href="http://goessner.net/articles/JsonPath/">JSONPath</a>.</p>
    public let inputPath: String?
    /// <p>Settings to enable you to provide custom input to a target based on certain event data.
    ///       You can extract one or more key-value pairs from the event and then use that data to send
    ///       customized input to the target.</p>
    public let inputTransformer: InputTransformer?
    /// <p>The custom parameter you can use to control the shard assignment, when the target is a
    ///       Kinesis data stream. If you do not include this parameter, the default is to use the
    ///         <code>eventId</code> as the partition key.</p>
    public let kinesisParameters: KinesisParameters?
    /// <p>Contains the Redshift Data API parameters to use when the target is a Redshift
    ///       cluster.</p>
    ///          <p>If you specify a Redshift Cluster as a Target, you can use this to specify parameters to
    ///       invoke the Redshift Data API ExecuteStatement based on EventBridge events.</p>
    public let redshiftDataParameters: RedshiftDataParameters?
    /// <p>The <code>RetryPolicy</code> object that contains the retry policy configuration to use
    ///       for the dead-letter queue.</p>
    public let retryPolicy: RetryPolicy?
    /// <p>The Amazon Resource Name (ARN) of the IAM role to be used for this target when the rule is
    ///       triggered. If one rule triggers multiple targets, you can use a different IAM role for each
    ///       target.</p>
    public let roleArn: String?
    /// <p>Parameters used when you are using the rule to invoke Amazon EC2 Run Command.</p>
    public let runCommandParameters: RunCommandParameters?
    /// <p>Contains the SageMaker Model Building Pipeline parameters to start execution of a
    ///       SageMaker Model Building Pipeline.</p>
    ///          <p>If you specify a SageMaker Model Building Pipeline as a target, you can use this to
    ///       specify parameters to start a pipeline execution based on EventBridge events.</p>
    public let sageMakerPipelineParameters: SageMakerPipelineParameters?
    /// <p>Contains the message group ID to use when the target is a FIFO queue.</p>
    ///          <p>If you specify an SQS FIFO queue as a target, the queue must have content-based
    ///       deduplication enabled.</p>
    public let sqsParameters: SqsParameters?

    public init (
        arn: String? = nil,
        batchParameters: BatchParameters? = nil,
        deadLetterConfig: DeadLetterConfig? = nil,
        ecsParameters: EcsParameters? = nil,
        httpParameters: HttpParameters? = nil,
        id: String? = nil,
        input: String? = nil,
        inputPath: String? = nil,
        inputTransformer: InputTransformer? = nil,
        kinesisParameters: KinesisParameters? = nil,
        redshiftDataParameters: RedshiftDataParameters? = nil,
        retryPolicy: RetryPolicy? = nil,
        roleArn: String? = nil,
        runCommandParameters: RunCommandParameters? = nil,
        sageMakerPipelineParameters: SageMakerPipelineParameters? = nil,
        sqsParameters: SqsParameters? = nil
    )
    {
        self.arn = arn
        self.batchParameters = batchParameters
        self.deadLetterConfig = deadLetterConfig
        self.ecsParameters = ecsParameters
        self.httpParameters = httpParameters
        self.id = id
        self.input = input
        self.inputPath = inputPath
        self.inputTransformer = inputTransformer
        self.kinesisParameters = kinesisParameters
        self.redshiftDataParameters = redshiftDataParameters
        self.retryPolicy = retryPolicy
        self.roleArn = roleArn
        self.runCommandParameters = runCommandParameters
        self.sageMakerPipelineParameters = sageMakerPipelineParameters
        self.sqsParameters = sqsParameters
    }
}

public struct TestEventPatternInputBodyMiddleware: Middleware {
    public let id: String = "TestEventPatternInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestEventPatternInput>,
                  next: H) -> Swift.Result<OperationOutput<TestEventPatternOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestEventPatternInput>
    public typealias MOutput = OperationOutput<TestEventPatternOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestEventPatternOutputError>
}

extension TestEventPatternInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestEventPatternInput(event: \(String(describing: event)), eventPattern: \(String(describing: eventPattern)))"}
}

extension TestEventPatternInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case event = "Event"
        case eventPattern = "EventPattern"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let eventPattern = eventPattern {
            try encodeContainer.encode(eventPattern, forKey: .eventPattern)
        }
    }
}

public struct TestEventPatternInputHeadersMiddleware: Middleware {
    public let id: String = "TestEventPatternInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestEventPatternInput>,
                  next: H) -> Swift.Result<OperationOutput<TestEventPatternOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestEventPatternInput>
    public typealias MOutput = OperationOutput<TestEventPatternOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestEventPatternOutputError>
}

public struct TestEventPatternInputQueryItemMiddleware: Middleware {
    public let id: String = "TestEventPatternInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestEventPatternInput>,
                  next: H) -> Swift.Result<OperationOutput<TestEventPatternOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestEventPatternInput>
    public typealias MOutput = OperationOutput<TestEventPatternOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestEventPatternOutputError>
}

public struct TestEventPatternInput: Equatable {
    /// <p>The event, in JSON format, to test against the event pattern. The JSON must follow the
    ///       format specified in <a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/aws-events.html">AWS Events</a>, and the following
    ///       fields are mandatory:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>id</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>account</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>source</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>time</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>region</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>resources</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>detail-type</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let event: String?
    /// <p>The event pattern. For more information, see <a href="https://docs.aws.amazon.com/eventbridge/latest/userguide/eventbridge-and-event-patterns.html">Events and Event
    ///         Patterns</a> in the <i>Amazon EventBridge User Guide</i>.</p>
    public let eventPattern: String?

    public init (
        event: String? = nil,
        eventPattern: String? = nil
    )
    {
        self.event = event
        self.eventPattern = eventPattern
    }
}

struct TestEventPatternInputBody: Equatable {
    public let eventPattern: String?
    public let event: String?
}

extension TestEventPatternInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case event = "Event"
        case eventPattern = "EventPattern"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let eventDecoded = try containerValues.decodeIfPresent(String.self, forKey: .event)
        event = eventDecoded
    }
}

extension TestEventPatternOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestEventPatternOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventPatternException" : self = .invalidEventPatternException(try InvalidEventPatternException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestEventPatternOutputError: Equatable {
    case internalException(InternalException)
    case invalidEventPatternException(InvalidEventPatternException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestEventPatternOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestEventPatternOutputResponse(result: \(String(describing: result)))"}
}

extension TestEventPatternOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TestEventPatternOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.result = output.result
        } else {
            self.result = false
        }
    }
}

public struct TestEventPatternOutputResponse: Equatable {
    /// <p>Indicates whether the event matches the event pattern.</p>
    public let result: Bool

    public init (
        result: Bool = false
    )
    {
        self.result = result
    }
}

struct TestEventPatternOutputResponseBody: Equatable {
    public let result: Bool
}

extension TestEventPatternOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case result = "Result"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultDecoded = try containerValues.decode(Bool.self, forKey: .result)
        result = resultDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the EventBridge resource from which you are removing tags.</p>
    public let resourceARN: String?
    /// <p>The list of tag keys to remove from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ManagedRuleException" : self = .managedRuleException(try ManagedRuleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case managedRuleException(ManagedRuleException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateApiDestinationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApiDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApiDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApiDestinationInput>
    public typealias MOutput = OperationOutput<UpdateApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApiDestinationOutputError>
}

extension UpdateApiDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApiDestinationInput(connectionArn: \(String(describing: connectionArn)), description: \(String(describing: description)), httpMethod: \(String(describing: httpMethod)), invocationEndpoint: \(String(describing: invocationEndpoint)), invocationRateLimitPerSecond: \(String(describing: invocationRateLimitPerSecond)), name: \(String(describing: name)))"}
}

extension UpdateApiDestinationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionArn = "ConnectionArn"
        case description = "Description"
        case httpMethod = "HttpMethod"
        case invocationEndpoint = "InvocationEndpoint"
        case invocationRateLimitPerSecond = "InvocationRateLimitPerSecond"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let httpMethod = httpMethod {
            try encodeContainer.encode(httpMethod.rawValue, forKey: .httpMethod)
        }
        if let invocationEndpoint = invocationEndpoint {
            try encodeContainer.encode(invocationEndpoint, forKey: .invocationEndpoint)
        }
        if let invocationRateLimitPerSecond = invocationRateLimitPerSecond {
            try encodeContainer.encode(invocationRateLimitPerSecond, forKey: .invocationRateLimitPerSecond)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateApiDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApiDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApiDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApiDestinationInput>
    public typealias MOutput = OperationOutput<UpdateApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApiDestinationOutputError>
}

public struct UpdateApiDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApiDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApiDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApiDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApiDestinationInput>
    public typealias MOutput = OperationOutput<UpdateApiDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApiDestinationOutputError>
}

public struct UpdateApiDestinationInput: Equatable {
    /// <p>The ARN of the connection to use for the API destination.</p>
    public let connectionArn: String?
    /// <p>The name of the API destination to update.</p>
    public let description: String?
    /// <p>The method to use for the API destination.</p>
    public let httpMethod: ApiDestinationHttpMethod?
    /// <p>The URL to the endpoint to use for the API destination.</p>
    public let invocationEndpoint: String?
    /// <p>The maximum number of invocations per second to send to the API destination.</p>
    public let invocationRateLimitPerSecond: Int?
    /// <p>The name of the API destination to update.</p>
    public let name: String?

    public init (
        connectionArn: String? = nil,
        description: String? = nil,
        httpMethod: ApiDestinationHttpMethod? = nil,
        invocationEndpoint: String? = nil,
        invocationRateLimitPerSecond: Int? = nil,
        name: String? = nil
    )
    {
        self.connectionArn = connectionArn
        self.description = description
        self.httpMethod = httpMethod
        self.invocationEndpoint = invocationEndpoint
        self.invocationRateLimitPerSecond = invocationRateLimitPerSecond
        self.name = name
    }
}

struct UpdateApiDestinationInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let connectionArn: String?
    public let invocationEndpoint: String?
    public let httpMethod: ApiDestinationHttpMethod?
    public let invocationRateLimitPerSecond: Int?
}

extension UpdateApiDestinationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionArn = "ConnectionArn"
        case description = "Description"
        case httpMethod = "HttpMethod"
        case invocationEndpoint = "InvocationEndpoint"
        case invocationRateLimitPerSecond = "InvocationRateLimitPerSecond"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let invocationEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invocationEndpoint)
        invocationEndpoint = invocationEndpointDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(ApiDestinationHttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let invocationRateLimitPerSecondDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .invocationRateLimitPerSecond)
        invocationRateLimitPerSecond = invocationRateLimitPerSecondDecoded
    }
}

extension UpdateApiDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApiDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApiDestinationOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApiDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApiDestinationOutputResponse(apiDestinationArn: \(String(describing: apiDestinationArn)), apiDestinationState: \(String(describing: apiDestinationState)), creationTime: \(String(describing: creationTime)), lastModifiedTime: \(String(describing: lastModifiedTime)))"}
}

extension UpdateApiDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateApiDestinationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.apiDestinationArn = output.apiDestinationArn
            self.apiDestinationState = output.apiDestinationState
            self.creationTime = output.creationTime
            self.lastModifiedTime = output.lastModifiedTime
        } else {
            self.apiDestinationArn = nil
            self.apiDestinationState = nil
            self.creationTime = nil
            self.lastModifiedTime = nil
        }
    }
}

public struct UpdateApiDestinationOutputResponse: Equatable {
    /// <p>The ARN of the API destination that was updated.</p>
    public let apiDestinationArn: String?
    /// <p>The state of the API destination that was updated.</p>
    public let apiDestinationState: ApiDestinationState?
    /// <p>A time stamp for the time that the API destination was created.</p>
    public let creationTime: Date?
    /// <p>A time stamp for the time that the API destination was last modified.</p>
    public let lastModifiedTime: Date?

    public init (
        apiDestinationArn: String? = nil,
        apiDestinationState: ApiDestinationState? = nil,
        creationTime: Date? = nil,
        lastModifiedTime: Date? = nil
    )
    {
        self.apiDestinationArn = apiDestinationArn
        self.apiDestinationState = apiDestinationState
        self.creationTime = creationTime
        self.lastModifiedTime = lastModifiedTime
    }
}

struct UpdateApiDestinationOutputResponseBody: Equatable {
    public let apiDestinationArn: String?
    public let apiDestinationState: ApiDestinationState?
    public let creationTime: Date?
    public let lastModifiedTime: Date?
}

extension UpdateApiDestinationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case apiDestinationArn = "ApiDestinationArn"
        case apiDestinationState = "ApiDestinationState"
        case creationTime = "CreationTime"
        case lastModifiedTime = "LastModifiedTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDestinationArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiDestinationArn)
        apiDestinationArn = apiDestinationArnDecoded
        let apiDestinationStateDecoded = try containerValues.decodeIfPresent(ApiDestinationState.self, forKey: .apiDestinationState)
        apiDestinationState = apiDestinationStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

public struct UpdateArchiveInputBodyMiddleware: Middleware {
    public let id: String = "UpdateArchiveInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateArchiveInput>
    public typealias MOutput = OperationOutput<UpdateArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateArchiveOutputError>
}

extension UpdateArchiveInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateArchiveInput(archiveName: \(String(describing: archiveName)), description: \(String(describing: description)), eventPattern: \(String(describing: eventPattern)), retentionDays: \(String(describing: retentionDays)))"}
}

extension UpdateArchiveInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case archiveName = "ArchiveName"
        case description = "Description"
        case eventPattern = "EventPattern"
        case retentionDays = "RetentionDays"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let archiveName = archiveName {
            try encodeContainer.encode(archiveName, forKey: .archiveName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventPattern = eventPattern {
            try encodeContainer.encode(eventPattern, forKey: .eventPattern)
        }
        if let retentionDays = retentionDays {
            try encodeContainer.encode(retentionDays, forKey: .retentionDays)
        }
    }
}

public struct UpdateArchiveInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateArchiveInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateArchiveInput>
    public typealias MOutput = OperationOutput<UpdateArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateArchiveOutputError>
}

public struct UpdateArchiveInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateArchiveInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateArchiveInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateArchiveOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateArchiveInput>
    public typealias MOutput = OperationOutput<UpdateArchiveOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateArchiveOutputError>
}

public struct UpdateArchiveInput: Equatable {
    /// <p>The name of the archive to update.</p>
    public let archiveName: String?
    /// <p>The description for the archive.</p>
    public let description: String?
    /// <p>The event pattern to use to filter events sent to the archive.</p>
    public let eventPattern: String?
    /// <p>The number of days to retain events in the archive.</p>
    public let retentionDays: Int?

    public init (
        archiveName: String? = nil,
        description: String? = nil,
        eventPattern: String? = nil,
        retentionDays: Int? = nil
    )
    {
        self.archiveName = archiveName
        self.description = description
        self.eventPattern = eventPattern
        self.retentionDays = retentionDays
    }
}

struct UpdateArchiveInputBody: Equatable {
    public let archiveName: String?
    public let description: String?
    public let eventPattern: String?
    public let retentionDays: Int?
}

extension UpdateArchiveInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case archiveName = "ArchiveName"
        case description = "Description"
        case eventPattern = "EventPattern"
        case retentionDays = "RetentionDays"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .archiveName)
        archiveName = archiveNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let eventPatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventPattern)
        eventPattern = eventPatternDecoded
        let retentionDaysDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .retentionDays)
        retentionDays = retentionDaysDecoded
    }
}

extension UpdateArchiveOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateArchiveOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidEventPatternException" : self = .invalidEventPatternException(try InvalidEventPatternException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateArchiveOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case invalidEventPatternException(InvalidEventPatternException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateArchiveOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateArchiveOutputResponse(archiveArn: \(String(describing: archiveArn)), creationTime: \(String(describing: creationTime)), state: \(String(describing: state)), stateReason: \(String(describing: stateReason)))"}
}

extension UpdateArchiveOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateArchiveOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.archiveArn = output.archiveArn
            self.creationTime = output.creationTime
            self.state = output.state
            self.stateReason = output.stateReason
        } else {
            self.archiveArn = nil
            self.creationTime = nil
            self.state = nil
            self.stateReason = nil
        }
    }
}

public struct UpdateArchiveOutputResponse: Equatable {
    /// <p>The ARN of the archive.</p>
    public let archiveArn: String?
    /// <p>The time at which the archive was updated.</p>
    public let creationTime: Date?
    /// <p>The state of the archive.</p>
    public let state: ArchiveState?
    /// <p>The reason that the archive is in the current state.</p>
    public let stateReason: String?

    public init (
        archiveArn: String? = nil,
        creationTime: Date? = nil,
        state: ArchiveState? = nil,
        stateReason: String? = nil
    )
    {
        self.archiveArn = archiveArn
        self.creationTime = creationTime
        self.state = state
        self.stateReason = stateReason
    }
}

struct UpdateArchiveOutputResponseBody: Equatable {
    public let archiveArn: String?
    public let state: ArchiveState?
    public let stateReason: String?
    public let creationTime: Date?
}

extension UpdateArchiveOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case archiveArn = "ArchiveArn"
        case creationTime = "CreationTime"
        case state = "State"
        case stateReason = "StateReason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archiveArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .archiveArn)
        archiveArn = archiveArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ArchiveState.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension UpdateConnectionApiKeyAuthRequestParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiKeyName = "ApiKeyName"
        case apiKeyValue = "ApiKeyValue"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyName = apiKeyName {
            try encodeContainer.encode(apiKeyName, forKey: .apiKeyName)
        }
        if let apiKeyValue = apiKeyValue {
            try encodeContainer.encode(apiKeyValue, forKey: .apiKeyValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKeyName)
        apiKeyName = apiKeyNameDecoded
        let apiKeyValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKeyValue)
        apiKeyValue = apiKeyValueDecoded
    }
}

extension UpdateConnectionApiKeyAuthRequestParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConnectionApiKeyAuthRequestParameters(apiKeyName: \(String(describing: apiKeyName)), apiKeyValue: \(String(describing: apiKeyValue)))"}
}

/// <p>Contains the API key authorization parameters to use to update the connection.</p>
public struct UpdateConnectionApiKeyAuthRequestParameters: Equatable {
    /// <p>The name of the API key to use for authorization.</p>
    public let apiKeyName: String?
    /// <p>The value associated with teh API key to use for authorization.</p>
    public let apiKeyValue: String?

    public init (
        apiKeyName: String? = nil,
        apiKeyValue: String? = nil
    )
    {
        self.apiKeyName = apiKeyName
        self.apiKeyValue = apiKeyValue
    }
}

extension UpdateConnectionAuthRequestParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiKeyAuthParameters = "ApiKeyAuthParameters"
        case basicAuthParameters = "BasicAuthParameters"
        case invocationHttpParameters = "InvocationHttpParameters"
        case oAuthParameters = "OAuthParameters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKeyAuthParameters = apiKeyAuthParameters {
            try encodeContainer.encode(apiKeyAuthParameters, forKey: .apiKeyAuthParameters)
        }
        if let basicAuthParameters = basicAuthParameters {
            try encodeContainer.encode(basicAuthParameters, forKey: .basicAuthParameters)
        }
        if let invocationHttpParameters = invocationHttpParameters {
            try encodeContainer.encode(invocationHttpParameters, forKey: .invocationHttpParameters)
        }
        if let oAuthParameters = oAuthParameters {
            try encodeContainer.encode(oAuthParameters, forKey: .oAuthParameters)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let basicAuthParametersDecoded = try containerValues.decodeIfPresent(UpdateConnectionBasicAuthRequestParameters.self, forKey: .basicAuthParameters)
        basicAuthParameters = basicAuthParametersDecoded
        let oAuthParametersDecoded = try containerValues.decodeIfPresent(UpdateConnectionOAuthRequestParameters.self, forKey: .oAuthParameters)
        oAuthParameters = oAuthParametersDecoded
        let apiKeyAuthParametersDecoded = try containerValues.decodeIfPresent(UpdateConnectionApiKeyAuthRequestParameters.self, forKey: .apiKeyAuthParameters)
        apiKeyAuthParameters = apiKeyAuthParametersDecoded
        let invocationHttpParametersDecoded = try containerValues.decodeIfPresent(ConnectionHttpParameters.self, forKey: .invocationHttpParameters)
        invocationHttpParameters = invocationHttpParametersDecoded
    }
}

extension UpdateConnectionAuthRequestParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConnectionAuthRequestParameters(apiKeyAuthParameters: \(String(describing: apiKeyAuthParameters)), basicAuthParameters: \(String(describing: basicAuthParameters)), invocationHttpParameters: \(String(describing: invocationHttpParameters)), oAuthParameters: \(String(describing: oAuthParameters)))"}
}

/// <p>Contains the additional parameters to use for the connection.</p>
public struct UpdateConnectionAuthRequestParameters: Equatable {
    /// <p>A <code>UpdateConnectionApiKeyAuthRequestParameters</code> object that contains the
    ///       authorization parameters for API key authorization.</p>
    public let apiKeyAuthParameters: UpdateConnectionApiKeyAuthRequestParameters?
    /// <p>A <code>UpdateConnectionBasicAuthRequestParameters</code> object that contains the
    ///       authorization parameters for Basic authorization.</p>
    public let basicAuthParameters: UpdateConnectionBasicAuthRequestParameters?
    /// <p>A <code>ConnectionHttpParameters</code> object that contains the additional parameters to
    ///       use for the connection.</p>
    public let invocationHttpParameters: ConnectionHttpParameters?
    /// <p>A <code>UpdateConnectionOAuthRequestParameters</code> object that contains the
    ///       authorization parameters for OAuth authorization.</p>
    public let oAuthParameters: UpdateConnectionOAuthRequestParameters?

    public init (
        apiKeyAuthParameters: UpdateConnectionApiKeyAuthRequestParameters? = nil,
        basicAuthParameters: UpdateConnectionBasicAuthRequestParameters? = nil,
        invocationHttpParameters: ConnectionHttpParameters? = nil,
        oAuthParameters: UpdateConnectionOAuthRequestParameters? = nil
    )
    {
        self.apiKeyAuthParameters = apiKeyAuthParameters
        self.basicAuthParameters = basicAuthParameters
        self.invocationHttpParameters = invocationHttpParameters
        self.oAuthParameters = oAuthParameters
    }
}

extension UpdateConnectionBasicAuthRequestParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case password = "Password"
        case username = "Username"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let password = password {
            try encodeContainer.encode(password, forKey: .password)
        }
        if let username = username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .username)
        username = usernameDecoded
        let passwordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .password)
        password = passwordDecoded
    }
}

extension UpdateConnectionBasicAuthRequestParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConnectionBasicAuthRequestParameters(password: \(String(describing: password)), username: \(String(describing: username)))"}
}

/// <p>Contains the Basic authorization parameters for the connection.</p>
public struct UpdateConnectionBasicAuthRequestParameters: Equatable {
    /// <p>The password associated with the user name to use for Basic authorization.</p>
    public let password: String?
    /// <p>The user name to use for Basic authorization.</p>
    public let username: String?

    public init (
        password: String? = nil,
        username: String? = nil
    )
    {
        self.password = password
        self.username = username
    }
}

public struct UpdateConnectionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectionInput>
    public typealias MOutput = OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectionOutputError>
}

extension UpdateConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConnectionInput(authParameters: \(String(describing: authParameters)), authorizationType: \(String(describing: authorizationType)), description: \(String(describing: description)), name: \(String(describing: name)))"}
}

extension UpdateConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authParameters = "AuthParameters"
        case authorizationType = "AuthorizationType"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authParameters = authParameters {
            try encodeContainer.encode(authParameters, forKey: .authParameters)
        }
        if let authorizationType = authorizationType {
            try encodeContainer.encode(authorizationType.rawValue, forKey: .authorizationType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectionInput>
    public typealias MOutput = OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectionOutputError>
}

public struct UpdateConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectionInput>
    public typealias MOutput = OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectionOutputError>
}

public struct UpdateConnectionInput: Equatable {
    /// <p>The authorization parameters to use for the connection.</p>
    public let authParameters: UpdateConnectionAuthRequestParameters?
    /// <p>The type of authorization to use for the connection.</p>
    public let authorizationType: ConnectionAuthorizationType?
    /// <p>A description for the connection.</p>
    public let description: String?
    /// <p>The name of the connection to update.</p>
    public let name: String?

    public init (
        authParameters: UpdateConnectionAuthRequestParameters? = nil,
        authorizationType: ConnectionAuthorizationType? = nil,
        description: String? = nil,
        name: String? = nil
    )
    {
        self.authParameters = authParameters
        self.authorizationType = authorizationType
        self.description = description
        self.name = name
    }
}

struct UpdateConnectionInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let authorizationType: ConnectionAuthorizationType?
    public let authParameters: UpdateConnectionAuthRequestParameters?
}

extension UpdateConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case authParameters = "AuthParameters"
        case authorizationType = "AuthorizationType"
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let authorizationTypeDecoded = try containerValues.decodeIfPresent(ConnectionAuthorizationType.self, forKey: .authorizationType)
        authorizationType = authorizationTypeDecoded
        let authParametersDecoded = try containerValues.decodeIfPresent(UpdateConnectionAuthRequestParameters.self, forKey: .authParameters)
        authParameters = authParametersDecoded
    }
}

extension UpdateConnectionOAuthClientRequestParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientID = "ClientID"
        case clientSecret = "ClientSecret"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientID = clientID {
            try encodeContainer.encode(clientID, forKey: .clientID)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientID)
        clientID = clientIDDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
    }
}

extension UpdateConnectionOAuthClientRequestParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConnectionOAuthClientRequestParameters(clientID: \(String(describing: clientID)), clientSecret: \(String(describing: clientSecret)))"}
}

/// <p>Contains the OAuth authorization parameters to use for the connection.</p>
public struct UpdateConnectionOAuthClientRequestParameters: Equatable {
    /// <p>The client ID to use for OAuth authorization.</p>
    public let clientID: String?
    /// <p>The client secret assciated with the client ID to use for OAuth authorization.</p>
    public let clientSecret: String?

    public init (
        clientID: String? = nil,
        clientSecret: String? = nil
    )
    {
        self.clientID = clientID
        self.clientSecret = clientSecret
    }
}

extension UpdateConnectionOAuthRequestParameters: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorizationEndpoint = "AuthorizationEndpoint"
        case clientParameters = "ClientParameters"
        case httpMethod = "HttpMethod"
        case oAuthHttpParameters = "OAuthHttpParameters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationEndpoint = authorizationEndpoint {
            try encodeContainer.encode(authorizationEndpoint, forKey: .authorizationEndpoint)
        }
        if let clientParameters = clientParameters {
            try encodeContainer.encode(clientParameters, forKey: .clientParameters)
        }
        if let httpMethod = httpMethod {
            try encodeContainer.encode(httpMethod.rawValue, forKey: .httpMethod)
        }
        if let oAuthHttpParameters = oAuthHttpParameters {
            try encodeContainer.encode(oAuthHttpParameters, forKey: .oAuthHttpParameters)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientParametersDecoded = try containerValues.decodeIfPresent(UpdateConnectionOAuthClientRequestParameters.self, forKey: .clientParameters)
        clientParameters = clientParametersDecoded
        let authorizationEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorizationEndpoint)
        authorizationEndpoint = authorizationEndpointDecoded
        let httpMethodDecoded = try containerValues.decodeIfPresent(ConnectionOAuthHttpMethod.self, forKey: .httpMethod)
        httpMethod = httpMethodDecoded
        let oAuthHttpParametersDecoded = try containerValues.decodeIfPresent(ConnectionHttpParameters.self, forKey: .oAuthHttpParameters)
        oAuthHttpParameters = oAuthHttpParametersDecoded
    }
}

extension UpdateConnectionOAuthRequestParameters: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConnectionOAuthRequestParameters(authorizationEndpoint: \(String(describing: authorizationEndpoint)), clientParameters: \(String(describing: clientParameters)), httpMethod: \(String(describing: httpMethod)), oAuthHttpParameters: \(String(describing: oAuthHttpParameters)))"}
}

/// <p>Contains the OAuth request parameters to use for the connection.</p>
public struct UpdateConnectionOAuthRequestParameters: Equatable {
    /// <p>The URL to the authorization endpoint when OAuth is specified as the authorization
    ///       type.</p>
    public let authorizationEndpoint: String?
    /// <p>A <code>UpdateConnectionOAuthClientRequestParameters</code> object that contains the
    ///       client parameters to use for the connection when OAuth is specified as the authorization
    ///       type.</p>
    public let clientParameters: UpdateConnectionOAuthClientRequestParameters?
    /// <p>The method used to connect to the HTTP endpoint.</p>
    public let httpMethod: ConnectionOAuthHttpMethod?
    /// <p>The additional HTTP parameters used for the OAuth authorization request.</p>
    public let oAuthHttpParameters: ConnectionHttpParameters?

    public init (
        authorizationEndpoint: String? = nil,
        clientParameters: UpdateConnectionOAuthClientRequestParameters? = nil,
        httpMethod: ConnectionOAuthHttpMethod? = nil,
        oAuthHttpParameters: ConnectionHttpParameters? = nil
    )
    {
        self.authorizationEndpoint = authorizationEndpoint
        self.clientParameters = clientParameters
        self.httpMethod = httpMethod
        self.oAuthHttpParameters = oAuthHttpParameters
    }
}

extension UpdateConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConnectionOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalException(InternalException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConnectionOutputResponse(connectionArn: \(String(describing: connectionArn)), connectionState: \(String(describing: connectionState)), creationTime: \(String(describing: creationTime)), lastAuthorizedTime: \(String(describing: lastAuthorizedTime)), lastModifiedTime: \(String(describing: lastModifiedTime)))"}
}

extension UpdateConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connectionArn = output.connectionArn
            self.connectionState = output.connectionState
            self.creationTime = output.creationTime
            self.lastAuthorizedTime = output.lastAuthorizedTime
            self.lastModifiedTime = output.lastModifiedTime
        } else {
            self.connectionArn = nil
            self.connectionState = nil
            self.creationTime = nil
            self.lastAuthorizedTime = nil
            self.lastModifiedTime = nil
        }
    }
}

public struct UpdateConnectionOutputResponse: Equatable {
    /// <p>The ARN of the connection that was updated.</p>
    public let connectionArn: String?
    /// <p>The state of the connection that was updated.</p>
    public let connectionState: ConnectionState?
    /// <p>A time stamp for the time that the connection was created.</p>
    public let creationTime: Date?
    /// <p>A time stamp for the time that the connection was last authorized.</p>
    public let lastAuthorizedTime: Date?
    /// <p>A time stamp for the time that the connection was last modified.</p>
    public let lastModifiedTime: Date?

    public init (
        connectionArn: String? = nil,
        connectionState: ConnectionState? = nil,
        creationTime: Date? = nil,
        lastAuthorizedTime: Date? = nil,
        lastModifiedTime: Date? = nil
    )
    {
        self.connectionArn = connectionArn
        self.connectionState = connectionState
        self.creationTime = creationTime
        self.lastAuthorizedTime = lastAuthorizedTime
        self.lastModifiedTime = lastModifiedTime
    }
}

struct UpdateConnectionOutputResponseBody: Equatable {
    public let connectionArn: String?
    public let connectionState: ConnectionState?
    public let creationTime: Date?
    public let lastModifiedTime: Date?
    public let lastAuthorizedTime: Date?
}

extension UpdateConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionArn = "ConnectionArn"
        case connectionState = "ConnectionState"
        case creationTime = "CreationTime"
        case lastAuthorizedTime = "LastAuthorizedTime"
        case lastModifiedTime = "LastModifiedTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let connectionStateDecoded = try containerValues.decodeIfPresent(ConnectionState.self, forKey: .connectionState)
        connectionState = connectionStateDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastAuthorizedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastAuthorizedTime)
        lastAuthorizedTime = lastAuthorizedTimeDecoded
    }
}
