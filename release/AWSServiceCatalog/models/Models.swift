// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public struct AcceptPortfolioShareInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptPortfolioShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptPortfolioShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptPortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptPortfolioShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptPortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptPortfolioShareOutputError>
}

extension AcceptPortfolioShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptPortfolioShareInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), portfolioId: \(Swift.String(describing: portfolioId)), portfolioShareType: \(Swift.String(describing: portfolioShareType)))"}
}

extension AcceptPortfolioShareInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case portfolioShareType = "PortfolioShareType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let portfolioShareType = portfolioShareType {
            try encodeContainer.encode(portfolioShareType.rawValue, forKey: .portfolioShareType)
        }
    }
}

public struct AcceptPortfolioShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptPortfolioShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptPortfolioShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptPortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptPortfolioShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptPortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptPortfolioShareOutputError>
}

public struct AcceptPortfolioShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptPortfolioShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AcceptPortfolioShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptPortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AcceptPortfolioShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptPortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptPortfolioShareOutputError>
}

public struct AcceptPortfolioShareInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AcceptPortfolioShareInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AcceptPortfolioShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AcceptPortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AcceptPortfolioShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<AcceptPortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AcceptPortfolioShareOutputError>
}

public struct AcceptPortfolioShareInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The type of shared portfolios to accept. The default is to accept imported portfolios.
    ///
    ///
    ///
    ///                   AWS_ORGANIZATIONS - Accept portfolios shared by the management account of your
    ///                organization.
    ///
    ///
    ///
    ///                   IMPORTED - Accept imported portfolios.
    ///
    ///
    ///
    ///                   AWS_SERVICECATALOG - Not supported. (Throws ResourceNotFoundException.)
    ///
    ///
    ///          For example, aws servicecatalog accept-portfolio-share --portfolio-id "port-2qwzkwxt3y5fk" --portfolio-share-type AWS_ORGANIZATIONS
    ///
    public var portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType?

    public init (
        acceptLanguage: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.portfolioShareType = portfolioShareType
    }
}

struct AcceptPortfolioShareInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let portfolioId: Swift.String?
    public let portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType?
}

extension AcceptPortfolioShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case portfolioShareType = "PortfolioShareType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let portfolioShareTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.PortfolioShareType.self, forKey: .portfolioShareType)
        portfolioShareType = portfolioShareTypeDecoded
    }
}

extension AcceptPortfolioShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptPortfolioShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AcceptPortfolioShareOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptPortfolioShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AcceptPortfolioShareOutputResponse()"}
}

extension AcceptPortfolioShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AcceptPortfolioShareOutputResponse: Swift.Equatable {

    public init() {}
}

struct AcceptPortfolioShareOutputResponseBody: Swift.Equatable {
}

extension AcceptPortfolioShareOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ServiceCatalogClientTypes.AccessLevelFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.AccessLevelFilterKey.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceCatalogClientTypes.AccessLevelFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessLevelFilter(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension ServiceCatalogClientTypes {
    /// The access level to use to filter results.
    public struct AccessLevelFilter: Swift.Equatable {
        /// The access level.
        ///
        ///
        ///
        ///                   Account - Filter results based on the account.
        ///
        ///
        ///
        ///                   Role - Filter results based on the federated role of the specified user.
        ///
        ///
        ///
        ///                   User - Filter results based on the specified user.
        ///
        ///
        public var key: ServiceCatalogClientTypes.AccessLevelFilterKey?
        /// The user to which the access level applies. The only supported value is Self.
        public var value: Swift.String?

        public init (
            key: ServiceCatalogClientTypes.AccessLevelFilterKey? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum AccessLevelFilterKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case role
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessLevelFilterKey] {
            return [
                .account,
                .role,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "Account"
            case .role: return "Role"
            case .user: return "User"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessLevelFilterKey(rawValue: rawValue) ?? AccessLevelFilterKey.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum AccessStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case underChange
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessStatus] {
            return [
                .disabled,
                .enabled,
                .underChange,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case .underChange: return "UNDER_CHANGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessStatus(rawValue: rawValue) ?? AccessStatus.sdkUnknown(rawValue)
        }
    }
}

public struct AssociateBudgetWithResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateBudgetWithResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateBudgetWithResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateBudgetWithResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateBudgetWithResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateBudgetWithResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateBudgetWithResourceOutputError>
}

extension AssociateBudgetWithResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateBudgetWithResourceInput(budgetName: \(Swift.String(describing: budgetName)), resourceId: \(Swift.String(describing: resourceId)))"}
}

extension AssociateBudgetWithResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetName = "BudgetName"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct AssociateBudgetWithResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateBudgetWithResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateBudgetWithResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateBudgetWithResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateBudgetWithResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateBudgetWithResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateBudgetWithResourceOutputError>
}

public struct AssociateBudgetWithResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateBudgetWithResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateBudgetWithResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateBudgetWithResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateBudgetWithResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateBudgetWithResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateBudgetWithResourceOutputError>
}

public struct AssociateBudgetWithResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateBudgetWithResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AssociateBudgetWithResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateBudgetWithResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateBudgetWithResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateBudgetWithResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateBudgetWithResourceOutputError>
}

public struct AssociateBudgetWithResourceInput: Swift.Equatable {
    /// The name of the budget you want to associate.
    /// This member is required.
    public var budgetName: Swift.String?
    ///  The resource identifier. Either a portfolio-id or a product-id.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        budgetName: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.budgetName = budgetName
        self.resourceId = resourceId
    }
}

struct AssociateBudgetWithResourceInputBody: Swift.Equatable {
    public let budgetName: Swift.String?
    public let resourceId: Swift.String?
}

extension AssociateBudgetWithResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetName = "BudgetName"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension AssociateBudgetWithResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateBudgetWithResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateBudgetWithResourceOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case invalidParametersException(InvalidParametersException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateBudgetWithResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateBudgetWithResourceOutputResponse()"}
}

extension AssociateBudgetWithResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateBudgetWithResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateBudgetWithResourceOutputResponseBody: Swift.Equatable {
}

extension AssociateBudgetWithResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct AssociatePrincipalWithPortfolioInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociatePrincipalWithPortfolioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociatePrincipalWithPortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociatePrincipalWithPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociatePrincipalWithPortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociatePrincipalWithPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociatePrincipalWithPortfolioOutputError>
}

extension AssociatePrincipalWithPortfolioInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociatePrincipalWithPortfolioInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), portfolioId: \(Swift.String(describing: portfolioId)), principalARN: \(Swift.String(describing: principalARN)), principalType: \(Swift.String(describing: principalType)))"}
}

extension AssociatePrincipalWithPortfolioInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case principalARN = "PrincipalARN"
        case principalType = "PrincipalType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let principalARN = principalARN {
            try encodeContainer.encode(principalARN, forKey: .principalARN)
        }
        if let principalType = principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }
}

public struct AssociatePrincipalWithPortfolioInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociatePrincipalWithPortfolioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociatePrincipalWithPortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociatePrincipalWithPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociatePrincipalWithPortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociatePrincipalWithPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociatePrincipalWithPortfolioOutputError>
}

public struct AssociatePrincipalWithPortfolioInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociatePrincipalWithPortfolioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociatePrincipalWithPortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociatePrincipalWithPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociatePrincipalWithPortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociatePrincipalWithPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociatePrincipalWithPortfolioOutputError>
}

public struct AssociatePrincipalWithPortfolioInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociatePrincipalWithPortfolioInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AssociatePrincipalWithPortfolioInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociatePrincipalWithPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociatePrincipalWithPortfolioInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociatePrincipalWithPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociatePrincipalWithPortfolioOutputError>
}

public struct AssociatePrincipalWithPortfolioInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The ARN of the principal (IAM user, role, or group).
    /// This member is required.
    public var principalARN: Swift.String?
    /// The principal type. The supported value is IAM.
    /// This member is required.
    public var principalType: ServiceCatalogClientTypes.PrincipalType?

    public init (
        acceptLanguage: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        principalARN: Swift.String? = nil,
        principalType: ServiceCatalogClientTypes.PrincipalType? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.principalARN = principalARN
        self.principalType = principalType
    }
}

struct AssociatePrincipalWithPortfolioInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let portfolioId: Swift.String?
    public let principalARN: Swift.String?
    public let principalType: ServiceCatalogClientTypes.PrincipalType?
}

extension AssociatePrincipalWithPortfolioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case principalARN = "PrincipalARN"
        case principalType = "PrincipalType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let principalARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalARN)
        principalARN = principalARNDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
    }
}

extension AssociatePrincipalWithPortfolioOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociatePrincipalWithPortfolioOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociatePrincipalWithPortfolioOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociatePrincipalWithPortfolioOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociatePrincipalWithPortfolioOutputResponse()"}
}

extension AssociatePrincipalWithPortfolioOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociatePrincipalWithPortfolioOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociatePrincipalWithPortfolioOutputResponseBody: Swift.Equatable {
}

extension AssociatePrincipalWithPortfolioOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct AssociateProductWithPortfolioInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateProductWithPortfolioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateProductWithPortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateProductWithPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateProductWithPortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateProductWithPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateProductWithPortfolioOutputError>
}

extension AssociateProductWithPortfolioInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateProductWithPortfolioInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), portfolioId: \(Swift.String(describing: portfolioId)), productId: \(Swift.String(describing: productId)), sourcePortfolioId: \(Swift.String(describing: sourcePortfolioId)))"}
}

extension AssociateProductWithPortfolioInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
        case sourcePortfolioId = "SourcePortfolioId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let sourcePortfolioId = sourcePortfolioId {
            try encodeContainer.encode(sourcePortfolioId, forKey: .sourcePortfolioId)
        }
    }
}

public struct AssociateProductWithPortfolioInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateProductWithPortfolioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateProductWithPortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateProductWithPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateProductWithPortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateProductWithPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateProductWithPortfolioOutputError>
}

public struct AssociateProductWithPortfolioInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateProductWithPortfolioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateProductWithPortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateProductWithPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateProductWithPortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateProductWithPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateProductWithPortfolioOutputError>
}

public struct AssociateProductWithPortfolioInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateProductWithPortfolioInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AssociateProductWithPortfolioInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateProductWithPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateProductWithPortfolioInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateProductWithPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateProductWithPortfolioOutputError>
}

public struct AssociateProductWithPortfolioInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?
    /// The identifier of the source portfolio.
    public var sourcePortfolioId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        productId: Swift.String? = nil,
        sourcePortfolioId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.productId = productId
        self.sourcePortfolioId = sourcePortfolioId
    }
}

struct AssociateProductWithPortfolioInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let productId: Swift.String?
    public let portfolioId: Swift.String?
    public let sourcePortfolioId: Swift.String?
}

extension AssociateProductWithPortfolioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
        case sourcePortfolioId = "SourcePortfolioId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let sourcePortfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePortfolioId)
        sourcePortfolioId = sourcePortfolioIdDecoded
    }
}

extension AssociateProductWithPortfolioOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateProductWithPortfolioOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateProductWithPortfolioOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateProductWithPortfolioOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateProductWithPortfolioOutputResponse()"}
}

extension AssociateProductWithPortfolioOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateProductWithPortfolioOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateProductWithPortfolioOutputResponseBody: Swift.Equatable {
}

extension AssociateProductWithPortfolioOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct AssociateServiceActionWithProvisioningArtifactInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateServiceActionWithProvisioningArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateServiceActionWithProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateServiceActionWithProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateServiceActionWithProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateServiceActionWithProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateServiceActionWithProvisioningArtifactOutputError>
}

extension AssociateServiceActionWithProvisioningArtifactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateServiceActionWithProvisioningArtifactInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), productId: \(Swift.String(describing: productId)), provisioningArtifactId: \(Swift.String(describing: provisioningArtifactId)), serviceActionId: \(Swift.String(describing: serviceActionId)))"}
}

extension AssociateServiceActionWithProvisioningArtifactInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case serviceActionId = "ServiceActionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let serviceActionId = serviceActionId {
            try encodeContainer.encode(serviceActionId, forKey: .serviceActionId)
        }
    }
}

public struct AssociateServiceActionWithProvisioningArtifactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateServiceActionWithProvisioningArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateServiceActionWithProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateServiceActionWithProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateServiceActionWithProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateServiceActionWithProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateServiceActionWithProvisioningArtifactOutputError>
}

public struct AssociateServiceActionWithProvisioningArtifactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateServiceActionWithProvisioningArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateServiceActionWithProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateServiceActionWithProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateServiceActionWithProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateServiceActionWithProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateServiceActionWithProvisioningArtifactOutputError>
}

public struct AssociateServiceActionWithProvisioningArtifactInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateServiceActionWithProvisioningArtifactInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AssociateServiceActionWithProvisioningArtifactInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateServiceActionWithProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateServiceActionWithProvisioningArtifactInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateServiceActionWithProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateServiceActionWithProvisioningArtifactOutputError>
}

public struct AssociateServiceActionWithProvisioningArtifactInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The product identifier. For example, prod-abcdzk7xy33qa.
    /// This member is required.
    public var productId: Swift.String?
    /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
    /// This member is required.
    public var provisioningArtifactId: Swift.String?
    /// The self-service action identifier. For example, act-fs7abcd89wxyz.
    /// This member is required.
    public var serviceActionId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        productId: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil,
        serviceActionId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
        self.serviceActionId = serviceActionId
    }
}

struct AssociateServiceActionWithProvisioningArtifactInputBody: Swift.Equatable {
    public let productId: Swift.String?
    public let provisioningArtifactId: Swift.String?
    public let serviceActionId: Swift.String?
    public let acceptLanguage: Swift.String?
}

extension AssociateServiceActionWithProvisioningArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case serviceActionId = "ServiceActionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let serviceActionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceActionId)
        serviceActionId = serviceActionIdDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension AssociateServiceActionWithProvisioningArtifactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateServiceActionWithProvisioningArtifactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateServiceActionWithProvisioningArtifactOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateServiceActionWithProvisioningArtifactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateServiceActionWithProvisioningArtifactOutputResponse()"}
}

extension AssociateServiceActionWithProvisioningArtifactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateServiceActionWithProvisioningArtifactOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateServiceActionWithProvisioningArtifactOutputResponseBody: Swift.Equatable {
}

extension AssociateServiceActionWithProvisioningArtifactOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct AssociateTagOptionWithResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTagOptionWithResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateTagOptionWithResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTagOptionWithResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateTagOptionWithResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTagOptionWithResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTagOptionWithResourceOutputError>
}

extension AssociateTagOptionWithResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateTagOptionWithResourceInput(resourceId: \(Swift.String(describing: resourceId)), tagOptionId: \(Swift.String(describing: tagOptionId)))"}
}

extension AssociateTagOptionWithResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagOptionId = "TagOptionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let tagOptionId = tagOptionId {
            try encodeContainer.encode(tagOptionId, forKey: .tagOptionId)
        }
    }
}

public struct AssociateTagOptionWithResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTagOptionWithResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateTagOptionWithResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTagOptionWithResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateTagOptionWithResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTagOptionWithResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTagOptionWithResourceOutputError>
}

public struct AssociateTagOptionWithResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTagOptionWithResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateTagOptionWithResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTagOptionWithResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateTagOptionWithResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTagOptionWithResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTagOptionWithResourceOutputError>
}

public struct AssociateTagOptionWithResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateTagOptionWithResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AssociateTagOptionWithResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateTagOptionWithResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateTagOptionWithResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateTagOptionWithResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateTagOptionWithResourceOutputError>
}

public struct AssociateTagOptionWithResourceInput: Swift.Equatable {
    /// The resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The TagOption identifier.
    /// This member is required.
    public var tagOptionId: Swift.String?

    public init (
        resourceId: Swift.String? = nil,
        tagOptionId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
        self.tagOptionId = tagOptionId
    }
}

struct AssociateTagOptionWithResourceInputBody: Swift.Equatable {
    public let resourceId: Swift.String?
    public let tagOptionId: Swift.String?
}

extension AssociateTagOptionWithResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceId = "ResourceId"
        case tagOptionId = "TagOptionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let tagOptionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tagOptionId)
        tagOptionId = tagOptionIdDecoded
    }
}

extension AssociateTagOptionWithResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateTagOptionWithResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateTagOptionWithResourceOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case invalidParametersException(InvalidParametersException)
    case invalidStateException(InvalidStateException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateTagOptionWithResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateTagOptionWithResourceOutputResponse()"}
}

extension AssociateTagOptionWithResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateTagOptionWithResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateTagOptionWithResourceOutputResponseBody: Swift.Equatable {
}

extension AssociateTagOptionWithResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct BatchAssociateServiceActionWithProvisioningArtifactInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateServiceActionWithProvisioningArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchAssociateServiceActionWithProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateServiceActionWithProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchAssociateServiceActionWithProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateServiceActionWithProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateServiceActionWithProvisioningArtifactOutputError>
}

extension BatchAssociateServiceActionWithProvisioningArtifactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAssociateServiceActionWithProvisioningArtifactInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), serviceActionAssociations: \(Swift.String(describing: serviceActionAssociations)))"}
}

extension BatchAssociateServiceActionWithProvisioningArtifactInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case serviceActionAssociations = "ServiceActionAssociations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let serviceActionAssociations = serviceActionAssociations {
            var serviceActionAssociationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceActionAssociations)
            for serviceactionassociations0 in serviceActionAssociations {
                try serviceActionAssociationsContainer.encode(serviceactionassociations0)
            }
        }
    }
}

public struct BatchAssociateServiceActionWithProvisioningArtifactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateServiceActionWithProvisioningArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchAssociateServiceActionWithProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateServiceActionWithProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchAssociateServiceActionWithProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateServiceActionWithProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateServiceActionWithProvisioningArtifactOutputError>
}

public struct BatchAssociateServiceActionWithProvisioningArtifactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateServiceActionWithProvisioningArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchAssociateServiceActionWithProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateServiceActionWithProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchAssociateServiceActionWithProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateServiceActionWithProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateServiceActionWithProvisioningArtifactOutputError>
}

public struct BatchAssociateServiceActionWithProvisioningArtifactInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateServiceActionWithProvisioningArtifactInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: BatchAssociateServiceActionWithProvisioningArtifactInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateServiceActionWithProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchAssociateServiceActionWithProvisioningArtifactInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateServiceActionWithProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateServiceActionWithProvisioningArtifactOutputError>
}

public struct BatchAssociateServiceActionWithProvisioningArtifactInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// One or more associations, each consisting of the Action ID, the Product ID, and the Provisioning Artifact ID.
    /// This member is required.
    public var serviceActionAssociations: [ServiceCatalogClientTypes.ServiceActionAssociation]?

    public init (
        acceptLanguage: Swift.String? = nil,
        serviceActionAssociations: [ServiceCatalogClientTypes.ServiceActionAssociation]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.serviceActionAssociations = serviceActionAssociations
    }
}

struct BatchAssociateServiceActionWithProvisioningArtifactInputBody: Swift.Equatable {
    public let serviceActionAssociations: [ServiceCatalogClientTypes.ServiceActionAssociation]?
    public let acceptLanguage: Swift.String?
}

extension BatchAssociateServiceActionWithProvisioningArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case serviceActionAssociations = "ServiceActionAssociations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionAssociationsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ServiceActionAssociation?].self, forKey: .serviceActionAssociations)
        var serviceActionAssociationsDecoded0:[ServiceCatalogClientTypes.ServiceActionAssociation]? = nil
        if let serviceActionAssociationsContainer = serviceActionAssociationsContainer {
            serviceActionAssociationsDecoded0 = [ServiceCatalogClientTypes.ServiceActionAssociation]()
            for structure0 in serviceActionAssociationsContainer {
                if let structure0 = structure0 {
                    serviceActionAssociationsDecoded0?.append(structure0)
                }
            }
        }
        serviceActionAssociations = serviceActionAssociationsDecoded0
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension BatchAssociateServiceActionWithProvisioningArtifactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchAssociateServiceActionWithProvisioningArtifactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchAssociateServiceActionWithProvisioningArtifactOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchAssociateServiceActionWithProvisioningArtifactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAssociateServiceActionWithProvisioningArtifactOutputResponse(failedServiceActionAssociations: \(Swift.String(describing: failedServiceActionAssociations)))"}
}

extension BatchAssociateServiceActionWithProvisioningArtifactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchAssociateServiceActionWithProvisioningArtifactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedServiceActionAssociations = output.failedServiceActionAssociations
        } else {
            self.failedServiceActionAssociations = nil
        }
    }
}

public struct BatchAssociateServiceActionWithProvisioningArtifactOutputResponse: Swift.Equatable {
    /// An object that contains a list of errors, along with information to help you identify the self-service action.
    public var failedServiceActionAssociations: [ServiceCatalogClientTypes.FailedServiceActionAssociation]?

    public init (
        failedServiceActionAssociations: [ServiceCatalogClientTypes.FailedServiceActionAssociation]? = nil
    )
    {
        self.failedServiceActionAssociations = failedServiceActionAssociations
    }
}

struct BatchAssociateServiceActionWithProvisioningArtifactOutputResponseBody: Swift.Equatable {
    public let failedServiceActionAssociations: [ServiceCatalogClientTypes.FailedServiceActionAssociation]?
}

extension BatchAssociateServiceActionWithProvisioningArtifactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedServiceActionAssociations = "FailedServiceActionAssociations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedServiceActionAssociationsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.FailedServiceActionAssociation?].self, forKey: .failedServiceActionAssociations)
        var failedServiceActionAssociationsDecoded0:[ServiceCatalogClientTypes.FailedServiceActionAssociation]? = nil
        if let failedServiceActionAssociationsContainer = failedServiceActionAssociationsContainer {
            failedServiceActionAssociationsDecoded0 = [ServiceCatalogClientTypes.FailedServiceActionAssociation]()
            for structure0 in failedServiceActionAssociationsContainer {
                if let structure0 = structure0 {
                    failedServiceActionAssociationsDecoded0?.append(structure0)
                }
            }
        }
        failedServiceActionAssociations = failedServiceActionAssociationsDecoded0
    }
}

public struct BatchDisassociateServiceActionFromProvisioningArtifactInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateServiceActionFromProvisioningArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDisassociateServiceActionFromProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDisassociateServiceActionFromProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateServiceActionFromProvisioningArtifactOutputError>
}

extension BatchDisassociateServiceActionFromProvisioningArtifactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDisassociateServiceActionFromProvisioningArtifactInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), serviceActionAssociations: \(Swift.String(describing: serviceActionAssociations)))"}
}

extension BatchDisassociateServiceActionFromProvisioningArtifactInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case serviceActionAssociations = "ServiceActionAssociations"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let serviceActionAssociations = serviceActionAssociations {
            var serviceActionAssociationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceActionAssociations)
            for serviceactionassociations0 in serviceActionAssociations {
                try serviceActionAssociationsContainer.encode(serviceactionassociations0)
            }
        }
    }
}

public struct BatchDisassociateServiceActionFromProvisioningArtifactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateServiceActionFromProvisioningArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDisassociateServiceActionFromProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDisassociateServiceActionFromProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateServiceActionFromProvisioningArtifactOutputError>
}

public struct BatchDisassociateServiceActionFromProvisioningArtifactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateServiceActionFromProvisioningArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDisassociateServiceActionFromProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDisassociateServiceActionFromProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateServiceActionFromProvisioningArtifactOutputError>
}

public struct BatchDisassociateServiceActionFromProvisioningArtifactInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateServiceActionFromProvisioningArtifactInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: BatchDisassociateServiceActionFromProvisioningArtifactInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchDisassociateServiceActionFromProvisioningArtifactInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateServiceActionFromProvisioningArtifactOutputError>
}

public struct BatchDisassociateServiceActionFromProvisioningArtifactInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// One or more associations, each consisting of the Action ID, the Product ID, and the Provisioning Artifact ID.
    /// This member is required.
    public var serviceActionAssociations: [ServiceCatalogClientTypes.ServiceActionAssociation]?

    public init (
        acceptLanguage: Swift.String? = nil,
        serviceActionAssociations: [ServiceCatalogClientTypes.ServiceActionAssociation]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.serviceActionAssociations = serviceActionAssociations
    }
}

struct BatchDisassociateServiceActionFromProvisioningArtifactInputBody: Swift.Equatable {
    public let serviceActionAssociations: [ServiceCatalogClientTypes.ServiceActionAssociation]?
    public let acceptLanguage: Swift.String?
}

extension BatchDisassociateServiceActionFromProvisioningArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case serviceActionAssociations = "ServiceActionAssociations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionAssociationsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ServiceActionAssociation?].self, forKey: .serviceActionAssociations)
        var serviceActionAssociationsDecoded0:[ServiceCatalogClientTypes.ServiceActionAssociation]? = nil
        if let serviceActionAssociationsContainer = serviceActionAssociationsContainer {
            serviceActionAssociationsDecoded0 = [ServiceCatalogClientTypes.ServiceActionAssociation]()
            for structure0 in serviceActionAssociationsContainer {
                if let structure0 = structure0 {
                    serviceActionAssociationsDecoded0?.append(structure0)
                }
            }
        }
        serviceActionAssociations = serviceActionAssociationsDecoded0
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension BatchDisassociateServiceActionFromProvisioningArtifactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDisassociateServiceActionFromProvisioningArtifactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDisassociateServiceActionFromProvisioningArtifactOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse(failedServiceActionAssociations: \(Swift.String(describing: failedServiceActionAssociations)))"}
}

extension BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchDisassociateServiceActionFromProvisioningArtifactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedServiceActionAssociations = output.failedServiceActionAssociations
        } else {
            self.failedServiceActionAssociations = nil
        }
    }
}

public struct BatchDisassociateServiceActionFromProvisioningArtifactOutputResponse: Swift.Equatable {
    /// An object that contains a list of errors, along with information to help you identify the self-service action.
    public var failedServiceActionAssociations: [ServiceCatalogClientTypes.FailedServiceActionAssociation]?

    public init (
        failedServiceActionAssociations: [ServiceCatalogClientTypes.FailedServiceActionAssociation]? = nil
    )
    {
        self.failedServiceActionAssociations = failedServiceActionAssociations
    }
}

struct BatchDisassociateServiceActionFromProvisioningArtifactOutputResponseBody: Swift.Equatable {
    public let failedServiceActionAssociations: [ServiceCatalogClientTypes.FailedServiceActionAssociation]?
}

extension BatchDisassociateServiceActionFromProvisioningArtifactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedServiceActionAssociations = "FailedServiceActionAssociations"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedServiceActionAssociationsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.FailedServiceActionAssociation?].self, forKey: .failedServiceActionAssociations)
        var failedServiceActionAssociationsDecoded0:[ServiceCatalogClientTypes.FailedServiceActionAssociation]? = nil
        if let failedServiceActionAssociationsContainer = failedServiceActionAssociationsContainer {
            failedServiceActionAssociationsDecoded0 = [ServiceCatalogClientTypes.FailedServiceActionAssociation]()
            for structure0 in failedServiceActionAssociationsContainer {
                if let structure0 = structure0 {
                    failedServiceActionAssociationsDecoded0?.append(structure0)
                }
            }
        }
        failedServiceActionAssociations = failedServiceActionAssociationsDecoded0
    }
}

extension ServiceCatalogClientTypes.BudgetDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetName = "BudgetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
    }
}

extension ServiceCatalogClientTypes.BudgetDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BudgetDetail(budgetName: \(Swift.String(describing: budgetName)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a budget.
    public struct BudgetDetail: Swift.Equatable {
        /// Name of the associated budget.
        public var budgetName: Swift.String?

        public init (
            budgetName: Swift.String? = nil
        )
        {
            self.budgetName = budgetName
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum ChangeAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case add
        case modify
        case remove
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeAction] {
            return [
                .add,
                .modify,
                .remove,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .add: return "ADD"
            case .modify: return "MODIFY"
            case .remove: return "REMOVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeAction(rawValue: rawValue) ?? ChangeAction.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.CloudWatchDashboard: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ServiceCatalogClientTypes.CloudWatchDashboard: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CloudWatchDashboard(name: \(Swift.String(describing: name)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a CloudWatch dashboard.
    public struct CloudWatchDashboard: Swift.Equatable {
        /// The name of the CloudWatch dashboard.
        public var name: Swift.String?

        public init (
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension ServiceCatalogClientTypes.ConstraintDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constraintId = "ConstraintId"
        case description = "Description"
        case owner = "Owner"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constraintId = constraintId {
            try encodeContainer.encode(constraintId, forKey: .constraintId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constraintIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constraintId)
        constraintId = constraintIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
    }
}

extension ServiceCatalogClientTypes.ConstraintDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConstraintDetail(constraintId: \(Swift.String(describing: constraintId)), description: \(Swift.String(describing: description)), owner: \(Swift.String(describing: owner)), portfolioId: \(Swift.String(describing: portfolioId)), productId: \(Swift.String(describing: productId)), type: \(Swift.String(describing: type)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a constraint.
    public struct ConstraintDetail: Swift.Equatable {
        /// The identifier of the constraint.
        public var constraintId: Swift.String?
        /// The description of the constraint.
        public var description: Swift.String?
        /// The owner of the constraint.
        public var owner: Swift.String?
        /// The identifier of the portfolio the product resides in. The constraint applies only to the instance of the product that lives within this portfolio.
        public var portfolioId: Swift.String?
        /// The identifier of the product the constraint applies to. Note that a constraint applies to a specific instance of a product within a certain portfolio.
        public var productId: Swift.String?
        /// The type of constraint.
        ///
        ///
        ///
        ///                   LAUNCH
        ///
        ///
        ///
        ///
        ///                   NOTIFICATION
        ///
        ///
        ///
        ///                STACKSET
        ///
        ///
        ///
        ///                   TEMPLATE
        ///
        ///
        ///
        public var type: Swift.String?

        public init (
            constraintId: Swift.String? = nil,
            description: Swift.String? = nil,
            owner: Swift.String? = nil,
            portfolioId: Swift.String? = nil,
            productId: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.constraintId = constraintId
            self.description = description
            self.owner = owner
            self.portfolioId = portfolioId
            self.productId = productId
            self.type = type
        }
    }

}

extension ServiceCatalogClientTypes.ConstraintSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ServiceCatalogClientTypes.ConstraintSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConstraintSummary(description: \(Swift.String(describing: description)), type: \(Swift.String(describing: type)))"}
}

extension ServiceCatalogClientTypes {
    /// Summary information about a constraint.
    public struct ConstraintSummary: Swift.Equatable {
        /// The description of the constraint.
        public var description: Swift.String?
        /// The type of constraint.
        ///
        ///
        ///
        ///                   LAUNCH
        ///
        ///
        ///
        ///
        ///                   NOTIFICATION
        ///
        ///
        ///
        ///                STACKSET
        ///
        ///
        ///
        ///                   TEMPLATE
        ///
        ///
        ///
        public var type: Swift.String?

        public init (
            description: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.type = type
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum CopyOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case copytags
        case sdkUnknown(Swift.String)

        public static var allCases: [CopyOption] {
            return [
                .copytags,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .copytags: return "CopyTags"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CopyOption(rawValue: rawValue) ?? CopyOption.sdkUnknown(rawValue)
        }
    }
}

public struct CopyProductInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyProductOutputError>
}

extension CopyProductInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyProductInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), copyOptions: \(Swift.String(describing: copyOptions)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), sourceProductArn: \(Swift.String(describing: sourceProductArn)), sourceProvisioningArtifactIdentifiers: \(Swift.String(describing: sourceProvisioningArtifactIdentifiers)), targetProductId: \(Swift.String(describing: targetProductId)), targetProductName: \(Swift.String(describing: targetProductName)))"}
}

extension CopyProductInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case copyOptions = "CopyOptions"
        case idempotencyToken = "IdempotencyToken"
        case sourceProductArn = "SourceProductArn"
        case sourceProvisioningArtifactIdentifiers = "SourceProvisioningArtifactIdentifiers"
        case targetProductId = "TargetProductId"
        case targetProductName = "TargetProductName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let copyOptions = copyOptions {
            var copyOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .copyOptions)
            for copyoptions0 in copyOptions {
                try copyOptionsContainer.encode(copyoptions0.rawValue)
            }
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let sourceProductArn = sourceProductArn {
            try encodeContainer.encode(sourceProductArn, forKey: .sourceProductArn)
        }
        if let sourceProvisioningArtifactIdentifiers = sourceProvisioningArtifactIdentifiers {
            var sourceProvisioningArtifactIdentifiersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceProvisioningArtifactIdentifiers)
            for sourceprovisioningartifactproperties0 in sourceProvisioningArtifactIdentifiers {
                var sourceprovisioningartifactproperties0Container = sourceProvisioningArtifactIdentifiersContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, sourceprovisioningartifactpropertiesmap1) in sourceprovisioningartifactproperties0 {
                    try sourceprovisioningartifactproperties0Container.encode(sourceprovisioningartifactpropertiesmap1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let targetProductId = targetProductId {
            try encodeContainer.encode(targetProductId, forKey: .targetProductId)
        }
        if let targetProductName = targetProductName {
            try encodeContainer.encode(targetProductName, forKey: .targetProductName)
        }
    }
}

public struct CopyProductInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyProductOutputError>
}

public struct CopyProductInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CopyProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CopyProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CopyProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyProductOutputError>
}

public struct CopyProductInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CopyProductInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CopyProductInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CopyProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CopyProductInput
    public typealias MOutput = ClientRuntime.OperationOutput<CopyProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CopyProductOutputError>
}

public struct CopyProductInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The copy options. If the value is CopyTags, the tags from the source
    ///          product are copied to the target product.
    public var copyOptions: [ServiceCatalogClientTypes.CopyOption]?
    ///  A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
    ///   the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the source product.
    /// This member is required.
    public var sourceProductArn: Swift.String?
    /// The identifiers of the provisioning artifacts (also known as versions) of the product to copy.
    ///          By default, all provisioning artifacts are copied.
    public var sourceProvisioningArtifactIdentifiers: [[Swift.String:Swift.String]]?
    /// The identifier of the target product. By default, a new product is created.
    public var targetProductId: Swift.String?
    /// A name for the target product. The default is the name of the source product.
    public var targetProductName: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        copyOptions: [ServiceCatalogClientTypes.CopyOption]? = nil,
        idempotencyToken: Swift.String? = nil,
        sourceProductArn: Swift.String? = nil,
        sourceProvisioningArtifactIdentifiers: [[Swift.String:Swift.String]]? = nil,
        targetProductId: Swift.String? = nil,
        targetProductName: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.copyOptions = copyOptions
        self.idempotencyToken = idempotencyToken
        self.sourceProductArn = sourceProductArn
        self.sourceProvisioningArtifactIdentifiers = sourceProvisioningArtifactIdentifiers
        self.targetProductId = targetProductId
        self.targetProductName = targetProductName
    }
}

struct CopyProductInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let sourceProductArn: Swift.String?
    public let targetProductId: Swift.String?
    public let targetProductName: Swift.String?
    public let sourceProvisioningArtifactIdentifiers: [[Swift.String:Swift.String]]?
    public let copyOptions: [ServiceCatalogClientTypes.CopyOption]?
    public let idempotencyToken: Swift.String?
}

extension CopyProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case copyOptions = "CopyOptions"
        case idempotencyToken = "IdempotencyToken"
        case sourceProductArn = "SourceProductArn"
        case sourceProvisioningArtifactIdentifiers = "SourceProvisioningArtifactIdentifiers"
        case targetProductId = "TargetProductId"
        case targetProductName = "TargetProductName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let sourceProductArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceProductArn)
        sourceProductArn = sourceProductArnDecoded
        let targetProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetProductId)
        targetProductId = targetProductIdDecoded
        let targetProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetProductName)
        targetProductName = targetProductNameDecoded
        let sourceProvisioningArtifactIdentifiersContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.String?]?].self, forKey: .sourceProvisioningArtifactIdentifiers)
        var sourceProvisioningArtifactIdentifiersDecoded0:[[Swift.String:Swift.String]]? = nil
        if let sourceProvisioningArtifactIdentifiersContainer = sourceProvisioningArtifactIdentifiersContainer {
            sourceProvisioningArtifactIdentifiersDecoded0 = [[Swift.String:Swift.String]]()
            for map0 in sourceProvisioningArtifactIdentifiersContainer {
                var sourceProvisioningArtifactIdentifiersContainerDecoded0: [Swift.String: Swift.String]? = nil
                if let map0 = map0 {
                    sourceProvisioningArtifactIdentifiersContainerDecoded0 = [Swift.String: Swift.String]()
                    for (key1, provisioningartifactpropertyvalue1) in map0 {
                        if let provisioningartifactpropertyvalue1 = provisioningartifactpropertyvalue1 {
                            sourceProvisioningArtifactIdentifiersContainerDecoded0?[key1] = provisioningartifactpropertyvalue1
                        }
                    }
                }
                if let sourceProvisioningArtifactIdentifiersContainerDecoded0 = sourceProvisioningArtifactIdentifiersContainerDecoded0 {
                    sourceProvisioningArtifactIdentifiersDecoded0?.append(sourceProvisioningArtifactIdentifiersContainerDecoded0)
                }
            }
        }
        sourceProvisioningArtifactIdentifiers = sourceProvisioningArtifactIdentifiersDecoded0
        let copyOptionsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.CopyOption?].self, forKey: .copyOptions)
        var copyOptionsDecoded0:[ServiceCatalogClientTypes.CopyOption]? = nil
        if let copyOptionsContainer = copyOptionsContainer {
            copyOptionsDecoded0 = [ServiceCatalogClientTypes.CopyOption]()
            for string0 in copyOptionsContainer {
                if let string0 = string0 {
                    copyOptionsDecoded0?.append(string0)
                }
            }
        }
        copyOptions = copyOptionsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CopyProductOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CopyProductOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CopyProductOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CopyProductOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CopyProductOutputResponse(copyProductToken: \(Swift.String(describing: copyProductToken)))"}
}

extension CopyProductOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CopyProductOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.copyProductToken = output.copyProductToken
        } else {
            self.copyProductToken = nil
        }
    }
}

public struct CopyProductOutputResponse: Swift.Equatable {
    /// The token to use to track the progress of the operation.
    public var copyProductToken: Swift.String?

    public init (
        copyProductToken: Swift.String? = nil
    )
    {
        self.copyProductToken = copyProductToken
    }
}

struct CopyProductOutputResponseBody: Swift.Equatable {
    public let copyProductToken: Swift.String?
}

extension CopyProductOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyProductToken = "CopyProductToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyProductTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .copyProductToken)
        copyProductToken = copyProductTokenDecoded
    }
}

extension ServiceCatalogClientTypes {
    public enum CopyProductStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [CopyProductStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CopyProductStatus(rawValue: rawValue) ?? CopyProductStatus.sdkUnknown(rawValue)
        }
    }
}

public struct CreateConstraintInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConstraintInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConstraintInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConstraintInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConstraintOutputError>
}

extension CreateConstraintInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConstraintInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), description: \(Swift.String(describing: description)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), parameters: \(Swift.String(describing: parameters)), portfolioId: \(Swift.String(describing: portfolioId)), productId: \(Swift.String(describing: productId)), type: \(Swift.String(describing: type)))"}
}

extension CreateConstraintInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case idempotencyToken = "IdempotencyToken"
        case parameters = "Parameters"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

public struct CreateConstraintInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConstraintInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConstraintInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConstraintInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConstraintOutputError>
}

public struct CreateConstraintInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConstraintInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateConstraintInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateConstraintInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConstraintOutputError>
}

public struct CreateConstraintInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateConstraintInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateConstraintInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateConstraintInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateConstraintOutputError>
}

public struct CreateConstraintInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The description of the constraint.
    public var description: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
    ///   the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The constraint parameters, in JSON format. The syntax depends on the constraint type as follows:
    ///
    ///             LAUNCH
    ///
    ///                You are required to specify either the RoleArn or the LocalRoleName but can't use both.
    ///                Specify the RoleArn property as follows:
    ///
    ///                   {"RoleArn" : "arn:aws:iam::123456789012:role/LaunchRole"}
    ///
    ///                Specify the LocalRoleName property as follows:
    ///
    ///                   {"LocalRoleName": "SCBasicLaunchRole"}
    ///
    ///                If you specify the LocalRoleName property, when an account uses the launch constraint, the IAM role with that name in the account will be used. This allows launch-role constraints to be
    ///                account-agnostic so the administrator can create fewer resources per shared account.
    ///
    ///                   The given role name must exist in the account used to create the launch constraint and the account of the user who launches a product with this launch constraint.
    ///
    ///                You cannot have both a LAUNCH and a STACKSET constraint.
    ///                You also cannot have more than one LAUNCH constraint on a product and portfolio.
    ///
    ///             NOTIFICATION
    ///
    ///                Specify the NotificationArns property as follows:
    ///
    ///                   {"NotificationArns" : ["arn:aws:sns:us-east-1:123456789012:Topic"]}
    ///
    ///
    ///             RESOURCE_UPDATE
    ///
    ///                Specify the TagUpdatesOnProvisionedProduct property as follows:
    ///
    ///                   {"Version":"2.0","Properties":{"TagUpdateOnProvisionedProduct":"String"}}
    ///
    ///                The TagUpdatesOnProvisionedProduct property accepts a string value of ALLOWED or NOT_ALLOWED.
    ///
    ///             STACKSET
    ///
    ///                Specify the Parameters property as follows:
    ///
    ///                   {"Version": "String", "Properties": {"AccountList": [ "String" ], "RegionList": [ "String" ], "AdminRole": "String", "ExecutionRole": "String"}}
    ///
    ///                You cannot have both a LAUNCH and a STACKSET constraint.
    ///                You also cannot have more than one STACKSET constraint on a product and portfolio.
    ///                Products with a STACKSET constraint will launch an AWS CloudFormation stack set.
    ///
    ///             TEMPLATE
    ///
    ///                Specify the Rules property. For more information, see
    ///                   <a href="http://docs.aws.amazon.com/servicecatalog/latest/adminguide/reference-template_constraint_rules.html">Template Constraint Rules.
    ///
    ///
    /// This member is required.
    public var parameters: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?
    /// The type of constraint.
    ///
    ///
    ///
    ///                   LAUNCH
    ///
    ///
    ///
    ///
    ///                   NOTIFICATION
    ///
    ///
    ///
    ///
    ///                   RESOURCE_UPDATE
    ///
    ///
    ///
    ///
    ///                   STACKSET
    ///
    ///
    ///
    ///
    ///                   TEMPLATE
    ///
    ///
    ///
    /// This member is required.
    public var type: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        description: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        parameters: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        productId: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.description = description
        self.idempotencyToken = idempotencyToken
        self.parameters = parameters
        self.portfolioId = portfolioId
        self.productId = productId
        self.type = type
    }
}

struct CreateConstraintInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let portfolioId: Swift.String?
    public let productId: Swift.String?
    public let parameters: Swift.String?
    public let type: Swift.String?
    public let description: Swift.String?
    public let idempotencyToken: Swift.String?
}

extension CreateConstraintInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case idempotencyToken = "IdempotencyToken"
        case parameters = "Parameters"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameters)
        parameters = parametersDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateConstraintOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConstraintOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConstraintOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case invalidParametersException(InvalidParametersException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConstraintOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConstraintOutputResponse(constraintDetail: \(Swift.String(describing: constraintDetail)), constraintParameters: \(Swift.String(describing: constraintParameters)), status: \(Swift.String(describing: status)))"}
}

extension CreateConstraintOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConstraintOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.constraintDetail = output.constraintDetail
            self.constraintParameters = output.constraintParameters
            self.status = output.status
        } else {
            self.constraintDetail = nil
            self.constraintParameters = nil
            self.status = nil
        }
    }
}

public struct CreateConstraintOutputResponse: Swift.Equatable {
    /// Information about the constraint.
    public var constraintDetail: ServiceCatalogClientTypes.ConstraintDetail?
    /// The constraint parameters.
    public var constraintParameters: Swift.String?
    /// The status of the current request.
    public var status: ServiceCatalogClientTypes.Status?

    public init (
        constraintDetail: ServiceCatalogClientTypes.ConstraintDetail? = nil,
        constraintParameters: Swift.String? = nil,
        status: ServiceCatalogClientTypes.Status? = nil
    )
    {
        self.constraintDetail = constraintDetail
        self.constraintParameters = constraintParameters
        self.status = status
    }
}

struct CreateConstraintOutputResponseBody: Swift.Equatable {
    public let constraintDetail: ServiceCatalogClientTypes.ConstraintDetail?
    public let constraintParameters: Swift.String?
    public let status: ServiceCatalogClientTypes.Status?
}

extension CreateConstraintOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constraintDetail = "ConstraintDetail"
        case constraintParameters = "ConstraintParameters"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constraintDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ConstraintDetail.self, forKey: .constraintDetail)
        constraintDetail = constraintDetailDecoded
        let constraintParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constraintParameters)
        constraintParameters = constraintParametersDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreatePortfolioInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePortfolioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePortfolioOutputError>
}

extension CreatePortfolioInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePortfolioInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), providerName: \(Swift.String(describing: providerName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreatePortfolioInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case displayName = "DisplayName"
        case idempotencyToken = "IdempotencyToken"
        case providerName = "ProviderName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for addtags0 in tags {
                try tagsContainer.encode(addtags0)
            }
        }
    }
}

public struct CreatePortfolioInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePortfolioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePortfolioOutputError>
}

public struct CreatePortfolioInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePortfolioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePortfolioOutputError>
}

public struct CreatePortfolioInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePortfolioInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreatePortfolioInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreatePortfolioInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePortfolioOutputError>
}

public struct CreatePortfolioInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The description of the portfolio.
    public var description: Swift.String?
    /// The name to use for display purposes.
    /// This member is required.
    public var displayName: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
    ///   the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The name of the portfolio provider.
    /// This member is required.
    public var providerName: Swift.String?
    /// One or more tags.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init (
        acceptLanguage: Swift.String? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        providerName: Swift.String? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.description = description
        self.displayName = displayName
        self.idempotencyToken = idempotencyToken
        self.providerName = providerName
        self.tags = tags
    }
}

struct CreatePortfolioInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let displayName: Swift.String?
    public let description: Swift.String?
    public let providerName: Swift.String?
    public let tags: [ServiceCatalogClientTypes.Tag]?
    public let idempotencyToken: Swift.String?
}

extension CreatePortfolioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case displayName = "DisplayName"
        case idempotencyToken = "IdempotencyToken"
        case providerName = "ProviderName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreatePortfolioOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePortfolioOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePortfolioOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case limitExceededException(LimitExceededException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePortfolioOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePortfolioOutputResponse(portfolioDetail: \(Swift.String(describing: portfolioDetail)), tags: \(Swift.String(describing: tags)))"}
}

extension CreatePortfolioOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePortfolioOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portfolioDetail = output.portfolioDetail
            self.tags = output.tags
        } else {
            self.portfolioDetail = nil
            self.tags = nil
        }
    }
}

public struct CreatePortfolioOutputResponse: Swift.Equatable {
    /// Information about the portfolio.
    public var portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail?
    /// Information about the tags associated with the portfolio.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init (
        portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.portfolioDetail = portfolioDetail
        self.tags = tags
    }
}

struct CreatePortfolioOutputResponseBody: Swift.Equatable {
    public let portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail?
    public let tags: [ServiceCatalogClientTypes.Tag]?
}

extension CreatePortfolioOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portfolioDetail = "PortfolioDetail"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.PortfolioDetail.self, forKey: .portfolioDetail)
        portfolioDetail = portfolioDetailDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreatePortfolioShareInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePortfolioShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePortfolioShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePortfolioShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePortfolioShareOutputError>
}

extension CreatePortfolioShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePortfolioShareInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), accountId: \(Swift.String(describing: accountId)), organizationNode: \(Swift.String(describing: organizationNode)), portfolioId: \(Swift.String(describing: portfolioId)), shareTagOptions: \(Swift.String(describing: shareTagOptions)))"}
}

extension CreatePortfolioShareInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accountId = "AccountId"
        case organizationNode = "OrganizationNode"
        case portfolioId = "PortfolioId"
        case shareTagOptions = "ShareTagOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let organizationNode = organizationNode {
            try encodeContainer.encode(organizationNode, forKey: .organizationNode)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if shareTagOptions != false {
            try encodeContainer.encode(shareTagOptions, forKey: .shareTagOptions)
        }
    }
}

public struct CreatePortfolioShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePortfolioShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePortfolioShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePortfolioShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePortfolioShareOutputError>
}

public struct CreatePortfolioShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePortfolioShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePortfolioShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePortfolioShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePortfolioShareOutputError>
}

public struct CreatePortfolioShareInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePortfolioShareInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreatePortfolioShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreatePortfolioShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePortfolioShareOutputError>
}

public struct CreatePortfolioShareInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The AWS account ID. For example, 123456789012.
    public var accountId: Swift.String?
    /// The organization node to whom you are going to share. If OrganizationNode
    ///          is passed in, PortfolioShare will be created for the node an
    ///          ListOrganizationPortfolioAccessd its children (when applies), and a
    ///             PortfolioShareToken will be returned in the output in order for the
    ///          administrator to monitor the status of the PortfolioShare creation
    ///          process.
    public var organizationNode: ServiceCatalogClientTypes.OrganizationNode?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// Enables or disables TagOptions  sharing when creating the portfolio share. If this flag is not provided, TagOptions sharing is disabled.
    public var shareTagOptions: Swift.Bool

    public init (
        acceptLanguage: Swift.String? = nil,
        accountId: Swift.String? = nil,
        organizationNode: ServiceCatalogClientTypes.OrganizationNode? = nil,
        portfolioId: Swift.String? = nil,
        shareTagOptions: Swift.Bool = false
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accountId = accountId
        self.organizationNode = organizationNode
        self.portfolioId = portfolioId
        self.shareTagOptions = shareTagOptions
    }
}

struct CreatePortfolioShareInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let portfolioId: Swift.String?
    public let accountId: Swift.String?
    public let organizationNode: ServiceCatalogClientTypes.OrganizationNode?
    public let shareTagOptions: Swift.Bool
}

extension CreatePortfolioShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accountId = "AccountId"
        case organizationNode = "OrganizationNode"
        case portfolioId = "PortfolioId"
        case shareTagOptions = "ShareTagOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let organizationNodeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.OrganizationNode.self, forKey: .organizationNode)
        organizationNode = organizationNodeDecoded
        let shareTagOptionsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .shareTagOptions)
        shareTagOptions = shareTagOptionsDecoded
    }
}

extension CreatePortfolioShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePortfolioShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePortfolioShareOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case invalidStateException(InvalidStateException)
    case limitExceededException(LimitExceededException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePortfolioShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePortfolioShareOutputResponse(portfolioShareToken: \(Swift.String(describing: portfolioShareToken)))"}
}

extension CreatePortfolioShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePortfolioShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portfolioShareToken = output.portfolioShareToken
        } else {
            self.portfolioShareToken = nil
        }
    }
}

public struct CreatePortfolioShareOutputResponse: Swift.Equatable {
    /// The portfolio shares a unique identifier that only returns if the portfolio is shared to an organization node.
    public var portfolioShareToken: Swift.String?

    public init (
        portfolioShareToken: Swift.String? = nil
    )
    {
        self.portfolioShareToken = portfolioShareToken
    }
}

struct CreatePortfolioShareOutputResponseBody: Swift.Equatable {
    public let portfolioShareToken: Swift.String?
}

extension CreatePortfolioShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portfolioShareToken = "PortfolioShareToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioShareTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioShareToken)
        portfolioShareToken = portfolioShareTokenDecoded
    }
}

public struct CreateProductInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProductOutputError>
}

extension CreateProductInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProductInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), description: \(Swift.String(describing: description)), distributor: \(Swift.String(describing: distributor)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), productType: \(Swift.String(describing: productType)), provisioningArtifactParameters: \(Swift.String(describing: provisioningArtifactParameters)), supportDescription: \(Swift.String(describing: supportDescription)), supportEmail: \(Swift.String(describing: supportEmail)), supportUrl: \(Swift.String(describing: supportUrl)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateProductInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case distributor = "Distributor"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
        case owner = "Owner"
        case productType = "ProductType"
        case provisioningArtifactParameters = "ProvisioningArtifactParameters"
        case supportDescription = "SupportDescription"
        case supportEmail = "SupportEmail"
        case supportUrl = "SupportUrl"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributor = distributor {
            try encodeContainer.encode(distributor, forKey: .distributor)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let productType = productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
        if let provisioningArtifactParameters = provisioningArtifactParameters {
            try encodeContainer.encode(provisioningArtifactParameters, forKey: .provisioningArtifactParameters)
        }
        if let supportDescription = supportDescription {
            try encodeContainer.encode(supportDescription, forKey: .supportDescription)
        }
        if let supportEmail = supportEmail {
            try encodeContainer.encode(supportEmail, forKey: .supportEmail)
        }
        if let supportUrl = supportUrl {
            try encodeContainer.encode(supportUrl, forKey: .supportUrl)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for addtags0 in tags {
                try tagsContainer.encode(addtags0)
            }
        }
    }
}

public struct CreateProductInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProductOutputError>
}

public struct CreateProductInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProductOutputError>
}

public struct CreateProductInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProductInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateProductInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateProductInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProductOutputError>
}

public struct CreateProductInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The description of the product.
    public var description: Swift.String?
    /// The distributor of the product.
    public var distributor: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
    ///   the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The name of the product.
    /// This member is required.
    public var name: Swift.String?
    /// The owner of the product.
    /// This member is required.
    public var owner: Swift.String?
    /// The type of product.
    /// This member is required.
    public var productType: ServiceCatalogClientTypes.ProductType?
    /// The configuration of the provisioning artifact.
    /// This member is required.
    public var provisioningArtifactParameters: ServiceCatalogClientTypes.ProvisioningArtifactProperties?
    /// The support information about the product.
    public var supportDescription: Swift.String?
    /// The contact email for product support.
    public var supportEmail: Swift.String?
    /// The contact URL for product support.
    ///
    ///             ^https?:\/\// / is the pattern used to validate SupportUrl.
    public var supportUrl: Swift.String?
    /// One or more tags.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init (
        acceptLanguage: Swift.String? = nil,
        description: Swift.String? = nil,
        distributor: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        name: Swift.String? = nil,
        owner: Swift.String? = nil,
        productType: ServiceCatalogClientTypes.ProductType? = nil,
        provisioningArtifactParameters: ServiceCatalogClientTypes.ProvisioningArtifactProperties? = nil,
        supportDescription: Swift.String? = nil,
        supportEmail: Swift.String? = nil,
        supportUrl: Swift.String? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.description = description
        self.distributor = distributor
        self.idempotencyToken = idempotencyToken
        self.name = name
        self.owner = owner
        self.productType = productType
        self.provisioningArtifactParameters = provisioningArtifactParameters
        self.supportDescription = supportDescription
        self.supportEmail = supportEmail
        self.supportUrl = supportUrl
        self.tags = tags
    }
}

struct CreateProductInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let name: Swift.String?
    public let owner: Swift.String?
    public let description: Swift.String?
    public let distributor: Swift.String?
    public let supportDescription: Swift.String?
    public let supportEmail: Swift.String?
    public let supportUrl: Swift.String?
    public let productType: ServiceCatalogClientTypes.ProductType?
    public let tags: [ServiceCatalogClientTypes.Tag]?
    public let provisioningArtifactParameters: ServiceCatalogClientTypes.ProvisioningArtifactProperties?
    public let idempotencyToken: Swift.String?
}

extension CreateProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case distributor = "Distributor"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
        case owner = "Owner"
        case productType = "ProductType"
        case provisioningArtifactParameters = "ProvisioningArtifactParameters"
        case supportDescription = "SupportDescription"
        case supportEmail = "SupportEmail"
        case supportUrl = "SupportUrl"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let distributorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributor)
        distributor = distributorDecoded
        let supportDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportDescription)
        supportDescription = supportDescriptionDecoded
        let supportEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportEmail)
        supportEmail = supportEmailDecoded
        let supportUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportUrl)
        supportUrl = supportUrlDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let provisioningArtifactParametersDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactProperties.self, forKey: .provisioningArtifactParameters)
        provisioningArtifactParameters = provisioningArtifactParametersDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateProductOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProductOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProductOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case limitExceededException(LimitExceededException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProductOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProductOutputResponse(productViewDetail: \(Swift.String(describing: productViewDetail)), provisioningArtifactDetail: \(Swift.String(describing: provisioningArtifactDetail)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateProductOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateProductOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.productViewDetail = output.productViewDetail
            self.provisioningArtifactDetail = output.provisioningArtifactDetail
            self.tags = output.tags
        } else {
            self.productViewDetail = nil
            self.provisioningArtifactDetail = nil
            self.tags = nil
        }
    }
}

public struct CreateProductOutputResponse: Swift.Equatable {
    /// Information about the product view.
    public var productViewDetail: ServiceCatalogClientTypes.ProductViewDetail?
    /// Information about the provisioning artifact.
    public var provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail?
    /// Information about the tags associated with the product.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init (
        productViewDetail: ServiceCatalogClientTypes.ProductViewDetail? = nil,
        provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.productViewDetail = productViewDetail
        self.provisioningArtifactDetail = provisioningArtifactDetail
        self.tags = tags
    }
}

struct CreateProductOutputResponseBody: Swift.Equatable {
    public let productViewDetail: ServiceCatalogClientTypes.ProductViewDetail?
    public let provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail?
    public let tags: [ServiceCatalogClientTypes.Tag]?
}

extension CreateProductOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productViewDetail = "ProductViewDetail"
        case provisioningArtifactDetail = "ProvisioningArtifactDetail"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductViewDetail.self, forKey: .productViewDetail)
        productViewDetail = productViewDetailDecoded
        let provisioningArtifactDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactDetail.self, forKey: .provisioningArtifactDetail)
        provisioningArtifactDetail = provisioningArtifactDetailDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateProvisionedProductPlanInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProvisionedProductPlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProvisionedProductPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProvisionedProductPlanOutputError>
}

extension CreateProvisionedProductPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProvisionedProductPlanInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), notificationArns: \(Swift.String(describing: notificationArns)), pathId: \(Swift.String(describing: pathId)), planName: \(Swift.String(describing: planName)), planType: \(Swift.String(describing: planType)), productId: \(Swift.String(describing: productId)), provisionedProductName: \(Swift.String(describing: provisionedProductName)), provisioningArtifactId: \(Swift.String(describing: provisioningArtifactId)), provisioningParameters: \(Swift.String(describing: provisioningParameters)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateProvisionedProductPlanInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case notificationArns = "NotificationArns"
        case pathId = "PathId"
        case planName = "PlanName"
        case planType = "PlanType"
        case productId = "ProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningParameters = "ProvisioningParameters"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let notificationArns = notificationArns {
            var notificationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationArns)
            for notificationarns0 in notificationArns {
                try notificationArnsContainer.encode(notificationarns0)
            }
        }
        if let pathId = pathId {
            try encodeContainer.encode(pathId, forKey: .pathId)
        }
        if let planName = planName {
            try encodeContainer.encode(planName, forKey: .planName)
        }
        if let planType = planType {
            try encodeContainer.encode(planType.rawValue, forKey: .planType)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisionedProductName = provisionedProductName {
            try encodeContainer.encode(provisionedProductName, forKey: .provisionedProductName)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let provisioningParameters = provisioningParameters {
            var provisioningParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .provisioningParameters)
            for updateprovisioningparameters0 in provisioningParameters {
                try provisioningParametersContainer.encode(updateprovisioningparameters0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct CreateProvisionedProductPlanInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProvisionedProductPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProvisionedProductPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProvisionedProductPlanOutputError>
}

public struct CreateProvisionedProductPlanInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProvisionedProductPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProvisionedProductPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProvisionedProductPlanOutputError>
}

public struct CreateProvisionedProductPlanInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProvisionedProductPlanInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateProvisionedProductPlanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateProvisionedProductPlanInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProvisionedProductPlanOutputError>
}

public struct CreateProvisionedProductPlanInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
    ///   the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// Passed to CloudFormation. The SNS topic ARNs to which to publish stack-related
    ///          events.
    public var notificationArns: [Swift.String]?
    /// The path identifier of the product. This value is optional if the product
    ///          has a default path, and required if the product has more than one path.
    ///          To list the paths for a product, use ListLaunchPaths.
    public var pathId: Swift.String?
    /// The name of the plan.
    /// This member is required.
    public var planName: Swift.String?
    /// The plan type.
    /// This member is required.
    public var planType: ServiceCatalogClientTypes.ProvisionedProductPlanType?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?
    /// A user-friendly name for the provisioned product. This value must be
    ///          unique for the AWS account and cannot be updated after the product is provisioned.
    /// This member is required.
    public var provisionedProductName: Swift.String?
    /// The identifier of the provisioning artifact.
    /// This member is required.
    public var provisioningArtifactId: Swift.String?
    /// Parameters specified by the administrator that are required for provisioning the
    ///          product.
    public var provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]?
    /// One or more tags.
    ///          If the plan is for an existing provisioned product, the product must have a RESOURCE_UPDATE constraint with TagUpdatesOnProvisionedProduct set to ALLOWED to allow tag updates.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init (
        acceptLanguage: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        notificationArns: [Swift.String]? = nil,
        pathId: Swift.String? = nil,
        planName: Swift.String? = nil,
        planType: ServiceCatalogClientTypes.ProvisionedProductPlanType? = nil,
        productId: Swift.String? = nil,
        provisionedProductName: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil,
        provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.notificationArns = notificationArns
        self.pathId = pathId
        self.planName = planName
        self.planType = planType
        self.productId = productId
        self.provisionedProductName = provisionedProductName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningParameters = provisioningParameters
        self.tags = tags
    }
}

struct CreateProvisionedProductPlanInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let planName: Swift.String?
    public let planType: ServiceCatalogClientTypes.ProvisionedProductPlanType?
    public let notificationArns: [Swift.String]?
    public let pathId: Swift.String?
    public let productId: Swift.String?
    public let provisionedProductName: Swift.String?
    public let provisioningArtifactId: Swift.String?
    public let provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]?
    public let idempotencyToken: Swift.String?
    public let tags: [ServiceCatalogClientTypes.Tag]?
}

extension CreateProvisionedProductPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case notificationArns = "NotificationArns"
        case pathId = "PathId"
        case planName = "PlanName"
        case planType = "PlanType"
        case productId = "ProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningParameters = "ProvisioningParameters"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let planNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .planName)
        planName = planNameDecoded
        let planTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisionedProductPlanType.self, forKey: .planType)
        planType = planTypeDecoded
        let notificationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notificationArns)
        var notificationArnsDecoded0:[Swift.String]? = nil
        if let notificationArnsContainer = notificationArnsContainer {
            notificationArnsDecoded0 = [Swift.String]()
            for string0 in notificationArnsContainer {
                if let string0 = string0 {
                    notificationArnsDecoded0?.append(string0)
                }
            }
        }
        notificationArns = notificationArnsDecoded0
        let pathIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathId)
        pathId = pathIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let provisioningParametersContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.UpdateProvisioningParameter?].self, forKey: .provisioningParameters)
        var provisioningParametersDecoded0:[ServiceCatalogClientTypes.UpdateProvisioningParameter]? = nil
        if let provisioningParametersContainer = provisioningParametersContainer {
            provisioningParametersDecoded0 = [ServiceCatalogClientTypes.UpdateProvisioningParameter]()
            for structure0 in provisioningParametersContainer {
                if let structure0 = structure0 {
                    provisioningParametersDecoded0?.append(structure0)
                }
            }
        }
        provisioningParameters = provisioningParametersDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProvisionedProductPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProvisionedProductPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProvisionedProductPlanOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProvisionedProductPlanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProvisionedProductPlanOutputResponse(planId: \(Swift.String(describing: planId)), planName: \(Swift.String(describing: planName)), provisionProductId: \(Swift.String(describing: provisionProductId)), provisionedProductName: \(Swift.String(describing: provisionedProductName)), provisioningArtifactId: \(Swift.String(describing: provisioningArtifactId)))"}
}

extension CreateProvisionedProductPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateProvisionedProductPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.planId = output.planId
            self.planName = output.planName
            self.provisionProductId = output.provisionProductId
            self.provisionedProductName = output.provisionedProductName
            self.provisioningArtifactId = output.provisioningArtifactId
        } else {
            self.planId = nil
            self.planName = nil
            self.provisionProductId = nil
            self.provisionedProductName = nil
            self.provisioningArtifactId = nil
        }
    }
}

public struct CreateProvisionedProductPlanOutputResponse: Swift.Equatable {
    /// The plan identifier.
    public var planId: Swift.String?
    /// The name of the plan.
    public var planName: Swift.String?
    /// The product identifier.
    public var provisionProductId: Swift.String?
    /// The user-friendly name of the provisioned product.
    public var provisionedProductName: Swift.String?
    /// The identifier of the provisioning artifact.
    public var provisioningArtifactId: Swift.String?

    public init (
        planId: Swift.String? = nil,
        planName: Swift.String? = nil,
        provisionProductId: Swift.String? = nil,
        provisionedProductName: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil
    )
    {
        self.planId = planId
        self.planName = planName
        self.provisionProductId = provisionProductId
        self.provisionedProductName = provisionedProductName
        self.provisioningArtifactId = provisioningArtifactId
    }
}

struct CreateProvisionedProductPlanOutputResponseBody: Swift.Equatable {
    public let planName: Swift.String?
    public let planId: Swift.String?
    public let provisionProductId: Swift.String?
    public let provisionedProductName: Swift.String?
    public let provisioningArtifactId: Swift.String?
}

extension CreateProvisionedProductPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case planId = "PlanId"
        case planName = "PlanName"
        case provisionProductId = "ProvisionProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let planNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .planName)
        planName = planNameDecoded
        let planIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .planId)
        planId = planIdDecoded
        let provisionProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionProductId)
        provisionProductId = provisionProductIdDecoded
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
    }
}

public struct CreateProvisioningArtifactInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProvisioningArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProvisioningArtifactOutputError>
}

extension CreateProvisioningArtifactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProvisioningArtifactInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), parameters: \(Swift.String(describing: parameters)), productId: \(Swift.String(describing: productId)))"}
}

extension CreateProvisioningArtifactInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case parameters = "Parameters"
        case productId = "ProductId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
    }
}

public struct CreateProvisioningArtifactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProvisioningArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProvisioningArtifactOutputError>
}

public struct CreateProvisioningArtifactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProvisioningArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProvisioningArtifactOutputError>
}

public struct CreateProvisioningArtifactInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProvisioningArtifactInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateProvisioningArtifactInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateProvisioningArtifactInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProvisioningArtifactOutputError>
}

public struct CreateProvisioningArtifactInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
    ///   the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The configuration for the provisioning artifact.
    /// This member is required.
    public var parameters: ServiceCatalogClientTypes.ProvisioningArtifactProperties?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        parameters: ServiceCatalogClientTypes.ProvisioningArtifactProperties? = nil,
        productId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.parameters = parameters
        self.productId = productId
    }
}

struct CreateProvisioningArtifactInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let productId: Swift.String?
    public let parameters: ServiceCatalogClientTypes.ProvisioningArtifactProperties?
    public let idempotencyToken: Swift.String?
}

extension CreateProvisioningArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case parameters = "Parameters"
        case productId = "ProductId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactProperties.self, forKey: .parameters)
        parameters = parametersDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateProvisioningArtifactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProvisioningArtifactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProvisioningArtifactOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProvisioningArtifactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProvisioningArtifactOutputResponse(info: \(Swift.String(describing: info)), provisioningArtifactDetail: \(Swift.String(describing: provisioningArtifactDetail)), status: \(Swift.String(describing: status)))"}
}

extension CreateProvisioningArtifactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateProvisioningArtifactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.info = output.info
            self.provisioningArtifactDetail = output.provisioningArtifactDetail
            self.status = output.status
        } else {
            self.info = nil
            self.provisioningArtifactDetail = nil
            self.status = nil
        }
    }
}

public struct CreateProvisioningArtifactOutputResponse: Swift.Equatable {
    /// Specify the template source with one of the following options, but not both. Keys
    ///          accepted: [ LoadTemplateFromURL, ImportFromPhysicalId ].
    ///          The URL of the CloudFormation template in Amazon S3, in JSON format.
    ///
    ///             LoadTemplateFromURL
    ///
    ///          Use the URL of the CloudFormation template in Amazon S3 in JSON format.
    ///
    ///             ImportFromPhysicalId
    ///
    ///          Use the physical id of the resource that contains the template; currently supports
    ///          CloudFormation stack ARN.
    public var info: [Swift.String:Swift.String]?
    /// Information about the provisioning artifact.
    public var provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail?
    /// The status of the current request.
    public var status: ServiceCatalogClientTypes.Status?

    public init (
        info: [Swift.String:Swift.String]? = nil,
        provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail? = nil,
        status: ServiceCatalogClientTypes.Status? = nil
    )
    {
        self.info = info
        self.provisioningArtifactDetail = provisioningArtifactDetail
        self.status = status
    }
}

struct CreateProvisioningArtifactOutputResponseBody: Swift.Equatable {
    public let provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail?
    public let info: [Swift.String:Swift.String]?
    public let status: ServiceCatalogClientTypes.Status?
}

extension CreateProvisioningArtifactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case info = "Info"
        case provisioningArtifactDetail = "ProvisioningArtifactDetail"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisioningArtifactDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactDetail.self, forKey: .provisioningArtifactDetail)
        provisioningArtifactDetail = provisioningArtifactDetailDecoded
        let infoContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .info)
        var infoDecoded0: [Swift.String:Swift.String]? = nil
        if let infoContainer = infoContainer {
            infoDecoded0 = [Swift.String:Swift.String]()
            for (key0, provisioningartifactinfovalue0) in infoContainer {
                if let provisioningartifactinfovalue0 = provisioningartifactinfovalue0 {
                    infoDecoded0?[key0] = provisioningartifactinfovalue0
                }
            }
        }
        info = infoDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

public struct CreateServiceActionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceActionOutputError>
}

extension CreateServiceActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceActionInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), definition: \(Swift.String(describing: definition)), definitionType: \(Swift.String(describing: definitionType)), description: \(Swift.String(describing: description)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), name: \(Swift.String(describing: name)))"}
}

extension CreateServiceActionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case definition = "Definition"
        case definitionType = "DefinitionType"
        case description = "Description"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let definition = definition {
            var definitionContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .definition)
            for (dictKey0, serviceactiondefinitionmap0) in definition {
                try definitionContainer.encode(serviceactiondefinitionmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let definitionType = definitionType {
            try encodeContainer.encode(definitionType.rawValue, forKey: .definitionType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateServiceActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceActionOutputError>
}

public struct CreateServiceActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServiceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServiceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceActionOutputError>
}

public struct CreateServiceActionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServiceActionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateServiceActionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateServiceActionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServiceActionOutputError>
}

public struct CreateServiceActionInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The self-service action definition. Can be one of the following:
    ///
    ///             Name
    ///
    ///                The name of the AWS Systems Manager document (SSM document). For example, AWS-RestartEC2Instance.
    ///                If you are using a shared SSM document, you must provide the ARN instead of the name.
    ///
    ///             Version
    ///
    ///                The AWS Systems Manager automation document version. For example, "Version": "1"
    ///
    ///
    ///             AssumeRole
    ///
    ///                The Amazon Resource Name (ARN) of the role that performs the self-service actions on your behalf. For example, "AssumeRole": "arn:aws:iam::12345678910:role/ActionRole".
    ///                To reuse the provisioned product launch role, set to "AssumeRole": "LAUNCH_ROLE".
    ///
    ///             Parameters
    ///
    ///                The list of parameters in JSON format.
    ///                For example: [{\"Name\":\"InstanceId\",\"Type\":\"TARGET\"}] or [{\"Name\":\"InstanceId\",\"Type\":\"TEXT_VALUE\"}].
    ///
    ///
    /// This member is required.
    public var definition: [Swift.String:Swift.String]?
    /// The service action definition type. For example, SSM_AUTOMATION.
    /// This member is required.
    public var definitionType: ServiceCatalogClientTypes.ServiceActionDefinitionType?
    /// The self-service action description.
    public var description: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
    ///   the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The self-service action name.
    /// This member is required.
    public var name: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        definition: [Swift.String:Swift.String]? = nil,
        definitionType: ServiceCatalogClientTypes.ServiceActionDefinitionType? = nil,
        description: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.definition = definition
        self.definitionType = definitionType
        self.description = description
        self.idempotencyToken = idempotencyToken
        self.name = name
    }
}

struct CreateServiceActionInputBody: Swift.Equatable {
    public let name: Swift.String?
    public let definitionType: ServiceCatalogClientTypes.ServiceActionDefinitionType?
    public let definition: [Swift.String:Swift.String]?
    public let description: Swift.String?
    public let acceptLanguage: Swift.String?
    public let idempotencyToken: Swift.String?
}

extension CreateServiceActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case definition = "Definition"
        case definitionType = "DefinitionType"
        case description = "Description"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let definitionTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ServiceActionDefinitionType.self, forKey: .definitionType)
        definitionType = definitionTypeDecoded
        let definitionContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .definition)
        var definitionDecoded0: [Swift.String:Swift.String]? = nil
        if let definitionContainer = definitionContainer {
            definitionDecoded0 = [Swift.String:Swift.String]()
            for (key0, serviceactiondefinitionvalue0) in definitionContainer {
                if let serviceactiondefinitionvalue0 = serviceactiondefinitionvalue0 {
                    definitionDecoded0?[key0] = serviceactiondefinitionvalue0
                }
            }
        }
        definition = definitionDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateServiceActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServiceActionOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServiceActionOutputResponse(serviceActionDetail: \(Swift.String(describing: serviceActionDetail)))"}
}

extension CreateServiceActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateServiceActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceActionDetail = output.serviceActionDetail
        } else {
            self.serviceActionDetail = nil
        }
    }
}

public struct CreateServiceActionOutputResponse: Swift.Equatable {
    /// An object containing information about the self-service action.
    public var serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail?

    public init (
        serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail? = nil
    )
    {
        self.serviceActionDetail = serviceActionDetail
    }
}

struct CreateServiceActionOutputResponseBody: Swift.Equatable {
    public let serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail?
}

extension CreateServiceActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceActionDetail = "ServiceActionDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ServiceActionDetail.self, forKey: .serviceActionDetail)
        serviceActionDetail = serviceActionDetailDecoded
    }
}

public struct CreateTagOptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTagOptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTagOptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTagOptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTagOptionOutputError>
}

extension CreateTagOptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTagOptionInput(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension CreateTagOptionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }
}

public struct CreateTagOptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTagOptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTagOptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTagOptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTagOptionOutputError>
}

public struct CreateTagOptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTagOptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateTagOptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateTagOptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTagOptionOutputError>
}

public struct CreateTagOptionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateTagOptionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateTagOptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateTagOptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateTagOptionOutputError>
}

public struct CreateTagOptionInput: Swift.Equatable {
    /// The TagOption key.
    /// This member is required.
    public var key: Swift.String?
    /// The TagOption value.
    /// This member is required.
    public var value: Swift.String?

    public init (
        key: Swift.String? = nil,
        value: Swift.String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

struct CreateTagOptionInputBody: Swift.Equatable {
    public let key: Swift.String?
    public let value: Swift.String?
}

extension CreateTagOptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CreateTagOptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTagOptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTagOptionOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case limitExceededException(LimitExceededException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTagOptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateTagOptionOutputResponse(tagOptionDetail: \(Swift.String(describing: tagOptionDetail)))"}
}

extension CreateTagOptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateTagOptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagOptionDetail = output.tagOptionDetail
        } else {
            self.tagOptionDetail = nil
        }
    }
}

public struct CreateTagOptionOutputResponse: Swift.Equatable {
    /// Information about the TagOption.
    public var tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail?

    public init (
        tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail? = nil
    )
    {
        self.tagOptionDetail = tagOptionDetail
    }
}

struct CreateTagOptionOutputResponseBody: Swift.Equatable {
    public let tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail?
}

extension CreateTagOptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagOptionDetail = "TagOptionDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagOptionDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.TagOptionDetail.self, forKey: .tagOptionDetail)
        tagOptionDetail = tagOptionDetailDecoded
    }
}

public struct DeleteConstraintInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConstraintInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConstraintInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConstraintInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConstraintOutputError>
}

extension DeleteConstraintInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConstraintInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), id: \(Swift.String(describing: id)))"}
}

extension DeleteConstraintInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeleteConstraintInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConstraintInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConstraintInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConstraintInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConstraintOutputError>
}

public struct DeleteConstraintInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConstraintInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteConstraintInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteConstraintInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConstraintOutputError>
}

public struct DeleteConstraintInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteConstraintInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteConstraintInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteConstraintInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteConstraintOutputError>
}

public struct DeleteConstraintInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The identifier of the constraint.
    /// This member is required.
    public var id: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DeleteConstraintInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let id: Swift.String?
}

extension DeleteConstraintInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteConstraintOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConstraintOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConstraintOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConstraintOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteConstraintOutputResponse()"}
}

extension DeleteConstraintOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConstraintOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteConstraintOutputResponseBody: Swift.Equatable {
}

extension DeleteConstraintOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeletePortfolioInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePortfolioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePortfolioOutputError>
}

extension DeletePortfolioInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePortfolioInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), id: \(Swift.String(describing: id)))"}
}

extension DeletePortfolioInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeletePortfolioInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePortfolioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePortfolioOutputError>
}

public struct DeletePortfolioInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePortfolioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePortfolioOutputError>
}

public struct DeletePortfolioInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePortfolioInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeletePortfolioInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePortfolioInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePortfolioOutputError>
}

public struct DeletePortfolioInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var id: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DeletePortfolioInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let id: Swift.String?
}

extension DeletePortfolioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeletePortfolioOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePortfolioOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePortfolioOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePortfolioOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePortfolioOutputResponse()"}
}

extension DeletePortfolioOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePortfolioOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeletePortfolioOutputResponseBody: Swift.Equatable {
}

extension DeletePortfolioOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeletePortfolioShareInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePortfolioShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePortfolioShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePortfolioShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePortfolioShareOutputError>
}

extension DeletePortfolioShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePortfolioShareInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), accountId: \(Swift.String(describing: accountId)), organizationNode: \(Swift.String(describing: organizationNode)), portfolioId: \(Swift.String(describing: portfolioId)))"}
}

extension DeletePortfolioShareInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accountId = "AccountId"
        case organizationNode = "OrganizationNode"
        case portfolioId = "PortfolioId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let organizationNode = organizationNode {
            try encodeContainer.encode(organizationNode, forKey: .organizationNode)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
    }
}

public struct DeletePortfolioShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePortfolioShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePortfolioShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePortfolioShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePortfolioShareOutputError>
}

public struct DeletePortfolioShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePortfolioShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePortfolioShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePortfolioShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePortfolioShareOutputError>
}

public struct DeletePortfolioShareInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePortfolioShareInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeletePortfolioShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePortfolioShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePortfolioShareOutputError>
}

public struct DeletePortfolioShareInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The AWS account ID.
    public var accountId: Swift.String?
    /// The organization node to whom you are going to stop sharing.
    public var organizationNode: ServiceCatalogClientTypes.OrganizationNode?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        accountId: Swift.String? = nil,
        organizationNode: ServiceCatalogClientTypes.OrganizationNode? = nil,
        portfolioId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accountId = accountId
        self.organizationNode = organizationNode
        self.portfolioId = portfolioId
    }
}

struct DeletePortfolioShareInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let portfolioId: Swift.String?
    public let accountId: Swift.String?
    public let organizationNode: ServiceCatalogClientTypes.OrganizationNode?
}

extension DeletePortfolioShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accountId = "AccountId"
        case organizationNode = "OrganizationNode"
        case portfolioId = "PortfolioId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let organizationNodeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.OrganizationNode.self, forKey: .organizationNode)
        organizationNode = organizationNodeDecoded
    }
}

extension DeletePortfolioShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePortfolioShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePortfolioShareOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case invalidStateException(InvalidStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePortfolioShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePortfolioShareOutputResponse(portfolioShareToken: \(Swift.String(describing: portfolioShareToken)))"}
}

extension DeletePortfolioShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeletePortfolioShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portfolioShareToken = output.portfolioShareToken
        } else {
            self.portfolioShareToken = nil
        }
    }
}

public struct DeletePortfolioShareOutputResponse: Swift.Equatable {
    /// The portfolio share unique identifier. This will only be returned if delete is made to an organization node.
    public var portfolioShareToken: Swift.String?

    public init (
        portfolioShareToken: Swift.String? = nil
    )
    {
        self.portfolioShareToken = portfolioShareToken
    }
}

struct DeletePortfolioShareOutputResponseBody: Swift.Equatable {
    public let portfolioShareToken: Swift.String?
}

extension DeletePortfolioShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portfolioShareToken = "PortfolioShareToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioShareTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioShareToken)
        portfolioShareToken = portfolioShareTokenDecoded
    }
}

public struct DeleteProductInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProductOutputError>
}

extension DeleteProductInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProductInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), id: \(Swift.String(describing: id)))"}
}

extension DeleteProductInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeleteProductInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProductOutputError>
}

public struct DeleteProductInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProductOutputError>
}

public struct DeleteProductInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProductInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteProductInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteProductInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProductOutputError>
}

public struct DeleteProductInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var id: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DeleteProductInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let id: Swift.String?
}

extension DeleteProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeleteProductOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProductOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProductOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProductOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProductOutputResponse()"}
}

extension DeleteProductOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProductOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteProductOutputResponseBody: Swift.Equatable {
}

extension DeleteProductOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteProvisionedProductPlanInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProvisionedProductPlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProvisionedProductPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProvisionedProductPlanOutputError>
}

extension DeleteProvisionedProductPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProvisionedProductPlanInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), ignoreErrors: \(Swift.String(describing: ignoreErrors)), planId: \(Swift.String(describing: planId)))"}
}

extension DeleteProvisionedProductPlanInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case ignoreErrors = "IgnoreErrors"
        case planId = "PlanId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if ignoreErrors != false {
            try encodeContainer.encode(ignoreErrors, forKey: .ignoreErrors)
        }
        if let planId = planId {
            try encodeContainer.encode(planId, forKey: .planId)
        }
    }
}

public struct DeleteProvisionedProductPlanInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProvisionedProductPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProvisionedProductPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProvisionedProductPlanOutputError>
}

public struct DeleteProvisionedProductPlanInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProvisionedProductPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProvisionedProductPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProvisionedProductPlanOutputError>
}

public struct DeleteProvisionedProductPlanInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProvisionedProductPlanInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteProvisionedProductPlanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteProvisionedProductPlanInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProvisionedProductPlanOutputError>
}

public struct DeleteProvisionedProductPlanInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// If set to true, AWS Service Catalog stops managing the specified provisioned product even
    ///          if it cannot delete the underlying resources.
    public var ignoreErrors: Swift.Bool
    /// The plan identifier.
    /// This member is required.
    public var planId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        ignoreErrors: Swift.Bool = false,
        planId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.ignoreErrors = ignoreErrors
        self.planId = planId
    }
}

struct DeleteProvisionedProductPlanInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let planId: Swift.String?
    public let ignoreErrors: Swift.Bool
}

extension DeleteProvisionedProductPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case ignoreErrors = "IgnoreErrors"
        case planId = "PlanId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let planIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .planId)
        planId = planIdDecoded
        let ignoreErrorsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .ignoreErrors)
        ignoreErrors = ignoreErrorsDecoded
    }
}

extension DeleteProvisionedProductPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProvisionedProductPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProvisionedProductPlanOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProvisionedProductPlanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProvisionedProductPlanOutputResponse()"}
}

extension DeleteProvisionedProductPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProvisionedProductPlanOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteProvisionedProductPlanOutputResponseBody: Swift.Equatable {
}

extension DeleteProvisionedProductPlanOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteProvisioningArtifactInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProvisioningArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProvisioningArtifactOutputError>
}

extension DeleteProvisioningArtifactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProvisioningArtifactInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), productId: \(Swift.String(describing: productId)), provisioningArtifactId: \(Swift.String(describing: provisioningArtifactId)))"}
}

extension DeleteProvisioningArtifactInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
    }
}

public struct DeleteProvisioningArtifactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProvisioningArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProvisioningArtifactOutputError>
}

public struct DeleteProvisioningArtifactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProvisioningArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProvisioningArtifactOutputError>
}

public struct DeleteProvisioningArtifactInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProvisioningArtifactInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteProvisioningArtifactInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteProvisioningArtifactInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProvisioningArtifactOutputError>
}

public struct DeleteProvisioningArtifactInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?
    /// The identifier of the provisioning artifact.
    /// This member is required.
    public var provisioningArtifactId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        productId: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
    }
}

struct DeleteProvisioningArtifactInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let productId: Swift.String?
    public let provisioningArtifactId: Swift.String?
}

extension DeleteProvisioningArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
    }
}

extension DeleteProvisioningArtifactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProvisioningArtifactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProvisioningArtifactOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProvisioningArtifactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProvisioningArtifactOutputResponse()"}
}

extension DeleteProvisioningArtifactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProvisioningArtifactOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteProvisioningArtifactOutputResponseBody: Swift.Equatable {
}

extension DeleteProvisioningArtifactOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteServiceActionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceActionOutputError>
}

extension DeleteServiceActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServiceActionInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), id: \(Swift.String(describing: id)))"}
}

extension DeleteServiceActionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DeleteServiceActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceActionOutputError>
}

public struct DeleteServiceActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServiceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServiceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceActionOutputError>
}

public struct DeleteServiceActionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServiceActionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteServiceActionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteServiceActionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServiceActionOutputError>
}

public struct DeleteServiceActionInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The self-service action identifier. For example, act-fs7abcd89wxyz.
    /// This member is required.
    public var id: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DeleteServiceActionInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let acceptLanguage: Swift.String?
}

extension DeleteServiceActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension DeleteServiceActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServiceActionOutputError: Swift.Error, Swift.Equatable {
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServiceActionOutputResponse()"}
}

extension DeleteServiceActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServiceActionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteServiceActionOutputResponseBody: Swift.Equatable {
}

extension DeleteServiceActionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTagOptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTagOptionInput(id: \(Swift.String(describing: id)))"}
}

extension DeleteTagOptionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteTagOptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTagOptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTagOptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTagOptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTagOptionOutputError>
}

public struct DeleteTagOptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTagOptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteTagOptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteTagOptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTagOptionOutputError>
}

public struct DeleteTagOptionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteTagOptionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteTagOptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteTagOptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteTagOptionOutputError>
}

public struct DeleteTagOptionInput: Swift.Equatable {
    /// The TagOption identifier.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteTagOptionInputBody: Swift.Equatable {
}

extension DeleteTagOptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteTagOptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTagOptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTagOptionOutputError: Swift.Error, Swift.Equatable {
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTagOptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteTagOptionOutputResponse()"}
}

extension DeleteTagOptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTagOptionOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteTagOptionOutputResponseBody: Swift.Equatable {
}

extension DeleteTagOptionOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DescribeConstraintInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConstraintInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConstraintInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConstraintInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConstraintOutputError>
}

extension DescribeConstraintInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeConstraintInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), id: \(Swift.String(describing: id)))"}
}

extension DescribeConstraintInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DescribeConstraintInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConstraintInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConstraintInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConstraintInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConstraintOutputError>
}

public struct DescribeConstraintInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConstraintInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeConstraintInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeConstraintInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConstraintOutputError>
}

public struct DescribeConstraintInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeConstraintInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeConstraintInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeConstraintInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeConstraintOutputError>
}

public struct DescribeConstraintInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The identifier of the constraint.
    /// This member is required.
    public var id: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DescribeConstraintInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let id: Swift.String?
}

extension DescribeConstraintInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribeConstraintOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeConstraintOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeConstraintOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeConstraintOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeConstraintOutputResponse(constraintDetail: \(Swift.String(describing: constraintDetail)), constraintParameters: \(Swift.String(describing: constraintParameters)), status: \(Swift.String(describing: status)))"}
}

extension DescribeConstraintOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeConstraintOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.constraintDetail = output.constraintDetail
            self.constraintParameters = output.constraintParameters
            self.status = output.status
        } else {
            self.constraintDetail = nil
            self.constraintParameters = nil
            self.status = nil
        }
    }
}

public struct DescribeConstraintOutputResponse: Swift.Equatable {
    /// Information about the constraint.
    public var constraintDetail: ServiceCatalogClientTypes.ConstraintDetail?
    /// The constraint parameters.
    public var constraintParameters: Swift.String?
    /// The status of the current request.
    public var status: ServiceCatalogClientTypes.Status?

    public init (
        constraintDetail: ServiceCatalogClientTypes.ConstraintDetail? = nil,
        constraintParameters: Swift.String? = nil,
        status: ServiceCatalogClientTypes.Status? = nil
    )
    {
        self.constraintDetail = constraintDetail
        self.constraintParameters = constraintParameters
        self.status = status
    }
}

struct DescribeConstraintOutputResponseBody: Swift.Equatable {
    public let constraintDetail: ServiceCatalogClientTypes.ConstraintDetail?
    public let constraintParameters: Swift.String?
    public let status: ServiceCatalogClientTypes.Status?
}

extension DescribeConstraintOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constraintDetail = "ConstraintDetail"
        case constraintParameters = "ConstraintParameters"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constraintDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ConstraintDetail.self, forKey: .constraintDetail)
        constraintDetail = constraintDetailDecoded
        let constraintParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constraintParameters)
        constraintParameters = constraintParametersDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DescribeCopyProductStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCopyProductStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCopyProductStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCopyProductStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCopyProductStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCopyProductStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCopyProductStatusOutputError>
}

extension DescribeCopyProductStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCopyProductStatusInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), copyProductToken: \(Swift.String(describing: copyProductToken)))"}
}

extension DescribeCopyProductStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case copyProductToken = "CopyProductToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let copyProductToken = copyProductToken {
            try encodeContainer.encode(copyProductToken, forKey: .copyProductToken)
        }
    }
}

public struct DescribeCopyProductStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCopyProductStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCopyProductStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCopyProductStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCopyProductStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCopyProductStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCopyProductStatusOutputError>
}

public struct DescribeCopyProductStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCopyProductStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeCopyProductStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCopyProductStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeCopyProductStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCopyProductStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCopyProductStatusOutputError>
}

public struct DescribeCopyProductStatusInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeCopyProductStatusInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeCopyProductStatusInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeCopyProductStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeCopyProductStatusInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeCopyProductStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeCopyProductStatusOutputError>
}

public struct DescribeCopyProductStatusInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The token for the copy product operation. This token is returned by CopyProduct.
    /// This member is required.
    public var copyProductToken: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        copyProductToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.copyProductToken = copyProductToken
    }
}

struct DescribeCopyProductStatusInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let copyProductToken: Swift.String?
}

extension DescribeCopyProductStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case copyProductToken = "CopyProductToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let copyProductTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .copyProductToken)
        copyProductToken = copyProductTokenDecoded
    }
}

extension DescribeCopyProductStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCopyProductStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCopyProductStatusOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCopyProductStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeCopyProductStatusOutputResponse(copyProductStatus: \(Swift.String(describing: copyProductStatus)), statusDetail: \(Swift.String(describing: statusDetail)), targetProductId: \(Swift.String(describing: targetProductId)))"}
}

extension DescribeCopyProductStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeCopyProductStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.copyProductStatus = output.copyProductStatus
            self.statusDetail = output.statusDetail
            self.targetProductId = output.targetProductId
        } else {
            self.copyProductStatus = nil
            self.statusDetail = nil
            self.targetProductId = nil
        }
    }
}

public struct DescribeCopyProductStatusOutputResponse: Swift.Equatable {
    /// The status of the copy product operation.
    public var copyProductStatus: ServiceCatalogClientTypes.CopyProductStatus?
    /// The status message.
    public var statusDetail: Swift.String?
    /// The identifier of the copied product.
    public var targetProductId: Swift.String?

    public init (
        copyProductStatus: ServiceCatalogClientTypes.CopyProductStatus? = nil,
        statusDetail: Swift.String? = nil,
        targetProductId: Swift.String? = nil
    )
    {
        self.copyProductStatus = copyProductStatus
        self.statusDetail = statusDetail
        self.targetProductId = targetProductId
    }
}

struct DescribeCopyProductStatusOutputResponseBody: Swift.Equatable {
    public let copyProductStatus: ServiceCatalogClientTypes.CopyProductStatus?
    public let targetProductId: Swift.String?
    public let statusDetail: Swift.String?
}

extension DescribeCopyProductStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyProductStatus = "CopyProductStatus"
        case statusDetail = "StatusDetail"
        case targetProductId = "TargetProductId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let copyProductStatusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.CopyProductStatus.self, forKey: .copyProductStatus)
        copyProductStatus = copyProductStatusDecoded
        let targetProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetProductId)
        targetProductId = targetProductIdDecoded
        let statusDetailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDetail)
        statusDetail = statusDetailDecoded
    }
}

public struct DescribePortfolioInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePortfolioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePortfolioOutputError>
}

extension DescribePortfolioInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePortfolioInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), id: \(Swift.String(describing: id)))"}
}

extension DescribePortfolioInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DescribePortfolioInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePortfolioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePortfolioOutputError>
}

public struct DescribePortfolioInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePortfolioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePortfolioOutputError>
}

public struct DescribePortfolioInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePortfolioInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribePortfolioInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePortfolioInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePortfolioOutputError>
}

public struct DescribePortfolioInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var id: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DescribePortfolioInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let id: Swift.String?
}

extension DescribePortfolioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribePortfolioOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePortfolioOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePortfolioOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePortfolioOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePortfolioOutputResponse(budgets: \(Swift.String(describing: budgets)), portfolioDetail: \(Swift.String(describing: portfolioDetail)), tagOptions: \(Swift.String(describing: tagOptions)), tags: \(Swift.String(describing: tags)))"}
}

extension DescribePortfolioOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePortfolioOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.budgets = output.budgets
            self.portfolioDetail = output.portfolioDetail
            self.tagOptions = output.tagOptions
            self.tags = output.tags
        } else {
            self.budgets = nil
            self.portfolioDetail = nil
            self.tagOptions = nil
            self.tags = nil
        }
    }
}

public struct DescribePortfolioOutputResponse: Swift.Equatable {
    /// Information about the associated budgets.
    public var budgets: [ServiceCatalogClientTypes.BudgetDetail]?
    /// Information about the portfolio.
    public var portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail?
    /// Information about the TagOptions associated with the portfolio.
    public var tagOptions: [ServiceCatalogClientTypes.TagOptionDetail]?
    /// Information about the tags associated with the portfolio.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init (
        budgets: [ServiceCatalogClientTypes.BudgetDetail]? = nil,
        portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail? = nil,
        tagOptions: [ServiceCatalogClientTypes.TagOptionDetail]? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.budgets = budgets
        self.portfolioDetail = portfolioDetail
        self.tagOptions = tagOptions
        self.tags = tags
    }
}

struct DescribePortfolioOutputResponseBody: Swift.Equatable {
    public let portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail?
    public let tags: [ServiceCatalogClientTypes.Tag]?
    public let tagOptions: [ServiceCatalogClientTypes.TagOptionDetail]?
    public let budgets: [ServiceCatalogClientTypes.BudgetDetail]?
}

extension DescribePortfolioOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgets = "Budgets"
        case portfolioDetail = "PortfolioDetail"
        case tagOptions = "TagOptions"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.PortfolioDetail.self, forKey: .portfolioDetail)
        portfolioDetail = portfolioDetailDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let tagOptionsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.TagOptionDetail?].self, forKey: .tagOptions)
        var tagOptionsDecoded0:[ServiceCatalogClientTypes.TagOptionDetail]? = nil
        if let tagOptionsContainer = tagOptionsContainer {
            tagOptionsDecoded0 = [ServiceCatalogClientTypes.TagOptionDetail]()
            for structure0 in tagOptionsContainer {
                if let structure0 = structure0 {
                    tagOptionsDecoded0?.append(structure0)
                }
            }
        }
        tagOptions = tagOptionsDecoded0
        let budgetsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.BudgetDetail?].self, forKey: .budgets)
        var budgetsDecoded0:[ServiceCatalogClientTypes.BudgetDetail]? = nil
        if let budgetsContainer = budgetsContainer {
            budgetsDecoded0 = [ServiceCatalogClientTypes.BudgetDetail]()
            for structure0 in budgetsContainer {
                if let structure0 = structure0 {
                    budgetsDecoded0?.append(structure0)
                }
            }
        }
        budgets = budgetsDecoded0
    }
}

public struct DescribePortfolioShareStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePortfolioShareStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePortfolioShareStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePortfolioShareStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePortfolioShareStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePortfolioShareStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePortfolioShareStatusOutputError>
}

extension DescribePortfolioShareStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePortfolioShareStatusInput(portfolioShareToken: \(Swift.String(describing: portfolioShareToken)))"}
}

extension DescribePortfolioShareStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portfolioShareToken = "PortfolioShareToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let portfolioShareToken = portfolioShareToken {
            try encodeContainer.encode(portfolioShareToken, forKey: .portfolioShareToken)
        }
    }
}

public struct DescribePortfolioShareStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePortfolioShareStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePortfolioShareStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePortfolioShareStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePortfolioShareStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePortfolioShareStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePortfolioShareStatusOutputError>
}

public struct DescribePortfolioShareStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePortfolioShareStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePortfolioShareStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePortfolioShareStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePortfolioShareStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePortfolioShareStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePortfolioShareStatusOutputError>
}

public struct DescribePortfolioShareStatusInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePortfolioShareStatusInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribePortfolioShareStatusInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePortfolioShareStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePortfolioShareStatusInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePortfolioShareStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePortfolioShareStatusOutputError>
}

public struct DescribePortfolioShareStatusInput: Swift.Equatable {
    /// The token for the portfolio share operation. This token is returned either by CreatePortfolioShare or by DeletePortfolioShare.
    /// This member is required.
    public var portfolioShareToken: Swift.String?

    public init (
        portfolioShareToken: Swift.String? = nil
    )
    {
        self.portfolioShareToken = portfolioShareToken
    }
}

struct DescribePortfolioShareStatusInputBody: Swift.Equatable {
    public let portfolioShareToken: Swift.String?
}

extension DescribePortfolioShareStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portfolioShareToken = "PortfolioShareToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioShareTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioShareToken)
        portfolioShareToken = portfolioShareTokenDecoded
    }
}

extension DescribePortfolioShareStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePortfolioShareStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePortfolioShareStatusOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePortfolioShareStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePortfolioShareStatusOutputResponse(organizationNodeValue: \(Swift.String(describing: organizationNodeValue)), portfolioId: \(Swift.String(describing: portfolioId)), portfolioShareToken: \(Swift.String(describing: portfolioShareToken)), shareDetails: \(Swift.String(describing: shareDetails)), status: \(Swift.String(describing: status)))"}
}

extension DescribePortfolioShareStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePortfolioShareStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.organizationNodeValue = output.organizationNodeValue
            self.portfolioId = output.portfolioId
            self.portfolioShareToken = output.portfolioShareToken
            self.shareDetails = output.shareDetails
            self.status = output.status
        } else {
            self.organizationNodeValue = nil
            self.portfolioId = nil
            self.portfolioShareToken = nil
            self.shareDetails = nil
            self.status = nil
        }
    }
}

public struct DescribePortfolioShareStatusOutputResponse: Swift.Equatable {
    /// Organization node identifier. It can be either account id, organizational unit id or organization id.
    public var organizationNodeValue: Swift.String?
    /// The portfolio identifier.
    public var portfolioId: Swift.String?
    /// The token for the portfolio share operation. For example, share-6v24abcdefghi.
    public var portfolioShareToken: Swift.String?
    /// Information about the portfolio share operation.
    public var shareDetails: ServiceCatalogClientTypes.ShareDetails?
    /// Status of the portfolio share operation.
    public var status: ServiceCatalogClientTypes.ShareStatus?

    public init (
        organizationNodeValue: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        portfolioShareToken: Swift.String? = nil,
        shareDetails: ServiceCatalogClientTypes.ShareDetails? = nil,
        status: ServiceCatalogClientTypes.ShareStatus? = nil
    )
    {
        self.organizationNodeValue = organizationNodeValue
        self.portfolioId = portfolioId
        self.portfolioShareToken = portfolioShareToken
        self.shareDetails = shareDetails
        self.status = status
    }
}

struct DescribePortfolioShareStatusOutputResponseBody: Swift.Equatable {
    public let portfolioShareToken: Swift.String?
    public let portfolioId: Swift.String?
    public let organizationNodeValue: Swift.String?
    public let status: ServiceCatalogClientTypes.ShareStatus?
    public let shareDetails: ServiceCatalogClientTypes.ShareDetails?
}

extension DescribePortfolioShareStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationNodeValue = "OrganizationNodeValue"
        case portfolioId = "PortfolioId"
        case portfolioShareToken = "PortfolioShareToken"
        case shareDetails = "ShareDetails"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioShareTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioShareToken)
        portfolioShareToken = portfolioShareTokenDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let organizationNodeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationNodeValue)
        organizationNodeValue = organizationNodeValueDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ShareStatus.self, forKey: .status)
        status = statusDecoded
        let shareDetailsDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ShareDetails.self, forKey: .shareDetails)
        shareDetails = shareDetailsDecoded
    }
}

extension ServiceCatalogClientTypes {
    public enum DescribePortfolioShareType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case organization
        case organizationalUnit
        case organizationMemberAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [DescribePortfolioShareType] {
            return [
                .account,
                .organization,
                .organizationalUnit,
                .organizationMemberAccount,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .organization: return "ORGANIZATION"
            case .organizationalUnit: return "ORGANIZATIONAL_UNIT"
            case .organizationMemberAccount: return "ORGANIZATION_MEMBER_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DescribePortfolioShareType(rawValue: rawValue) ?? DescribePortfolioShareType.sdkUnknown(rawValue)
        }
    }
}

public struct DescribePortfolioSharesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePortfolioSharesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePortfolioSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePortfolioSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePortfolioSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePortfolioSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePortfolioSharesOutputError>
}

extension DescribePortfolioSharesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePortfolioSharesInput(pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)), portfolioId: \(Swift.String(describing: portfolioId)), type: \(Swift.String(describing: type)))"}
}

extension DescribePortfolioSharesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct DescribePortfolioSharesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePortfolioSharesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePortfolioSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePortfolioSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePortfolioSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePortfolioSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePortfolioSharesOutputError>
}

public struct DescribePortfolioSharesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePortfolioSharesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePortfolioSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePortfolioSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePortfolioSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePortfolioSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePortfolioSharesOutputError>
}

public struct DescribePortfolioSharesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePortfolioSharesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribePortfolioSharesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePortfolioSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePortfolioSharesInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePortfolioSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePortfolioSharesOutputError>
}

public struct DescribePortfolioSharesInput: Swift.Equatable {
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The unique identifier of the portfolio for which shares will be retrieved.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The type of portfolio share to summarize. This field acts as a filter on the type of portfolio share, which can be one of the following:
    ///          1. ACCOUNT - Represents an external account to account share.
    ///          2. ORGANIZATION - Represents a share to an organization. This share is available to every account in the organization.
    ///          3. ORGANIZATIONAL_UNIT - Represents a share to an organizational unit.
    ///          4. ORGANIZATION_MEMBER_ACCOUNT - Represents a share to an account in the organization.
    /// This member is required.
    public var type: ServiceCatalogClientTypes.DescribePortfolioShareType?

    public init (
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        type: ServiceCatalogClientTypes.DescribePortfolioShareType? = nil
    )
    {
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
        self.type = type
    }
}

struct DescribePortfolioSharesInputBody: Swift.Equatable {
    public let portfolioId: Swift.String?
    public let type: ServiceCatalogClientTypes.DescribePortfolioShareType?
    public let pageToken: Swift.String?
    public let pageSize: Swift.Int
}

extension DescribePortfolioSharesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.DescribePortfolioShareType.self, forKey: .type)
        type = typeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension DescribePortfolioSharesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePortfolioSharesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePortfolioSharesOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePortfolioSharesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePortfolioSharesOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), portfolioShareDetails: \(Swift.String(describing: portfolioShareDetails)))"}
}

extension DescribePortfolioSharesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePortfolioSharesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.portfolioShareDetails = output.portfolioShareDetails
        } else {
            self.nextPageToken = nil
            self.portfolioShareDetails = nil
        }
    }
}

public struct DescribePortfolioSharesOutputResponse: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Summaries about each of the portfolio shares.
    public var portfolioShareDetails: [ServiceCatalogClientTypes.PortfolioShareDetail]?

    public init (
        nextPageToken: Swift.String? = nil,
        portfolioShareDetails: [ServiceCatalogClientTypes.PortfolioShareDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.portfolioShareDetails = portfolioShareDetails
    }
}

struct DescribePortfolioSharesOutputResponseBody: Swift.Equatable {
    public let nextPageToken: Swift.String?
    public let portfolioShareDetails: [ServiceCatalogClientTypes.PortfolioShareDetail]?
}

extension DescribePortfolioSharesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case portfolioShareDetails = "PortfolioShareDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
        let portfolioShareDetailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.PortfolioShareDetail?].self, forKey: .portfolioShareDetails)
        var portfolioShareDetailsDecoded0:[ServiceCatalogClientTypes.PortfolioShareDetail]? = nil
        if let portfolioShareDetailsContainer = portfolioShareDetailsContainer {
            portfolioShareDetailsDecoded0 = [ServiceCatalogClientTypes.PortfolioShareDetail]()
            for structure0 in portfolioShareDetailsContainer {
                if let structure0 = structure0 {
                    portfolioShareDetailsDecoded0?.append(structure0)
                }
            }
        }
        portfolioShareDetails = portfolioShareDetailsDecoded0
    }
}

public struct DescribeProductAsAdminInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProductAsAdminInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProductAsAdminInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProductAsAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProductAsAdminInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProductAsAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProductAsAdminOutputError>
}

extension DescribeProductAsAdminInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProductAsAdminInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), sourcePortfolioId: \(Swift.String(describing: sourcePortfolioId)))"}
}

extension DescribeProductAsAdminInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case name = "Name"
        case sourcePortfolioId = "SourcePortfolioId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourcePortfolioId = sourcePortfolioId {
            try encodeContainer.encode(sourcePortfolioId, forKey: .sourcePortfolioId)
        }
    }
}

public struct DescribeProductAsAdminInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProductAsAdminInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProductAsAdminInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProductAsAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProductAsAdminInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProductAsAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProductAsAdminOutputError>
}

public struct DescribeProductAsAdminInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProductAsAdminInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProductAsAdminInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProductAsAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProductAsAdminInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProductAsAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProductAsAdminOutputError>
}

public struct DescribeProductAsAdminInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProductAsAdminInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeProductAsAdminInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProductAsAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeProductAsAdminInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProductAsAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProductAsAdminOutputError>
}

public struct DescribeProductAsAdminInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The product identifier.
    public var id: Swift.String?
    /// The product name.
    public var name: Swift.String?
    /// The unique identifier of the shared portfolio that the specified product is associated
    ///          with.
    ///          You can provide this parameter to retrieve the shared TagOptions associated with the
    ///          product. If this parameter is provided and if TagOptions sharing is enabled in the
    ///          portfolio share, the API returns both local and shared TagOptions associated with the
    ///          product. Otherwise only local TagOptions will be returned.
    public var sourcePortfolioId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        sourcePortfolioId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
        self.name = name
        self.sourcePortfolioId = sourcePortfolioId
    }
}

struct DescribeProductAsAdminInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let id: Swift.String?
    public let name: Swift.String?
    public let sourcePortfolioId: Swift.String?
}

extension DescribeProductAsAdminInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case name = "Name"
        case sourcePortfolioId = "SourcePortfolioId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let sourcePortfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePortfolioId)
        sourcePortfolioId = sourcePortfolioIdDecoded
    }
}

extension DescribeProductAsAdminOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProductAsAdminOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProductAsAdminOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProductAsAdminOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProductAsAdminOutputResponse(budgets: \(Swift.String(describing: budgets)), productViewDetail: \(Swift.String(describing: productViewDetail)), provisioningArtifactSummaries: \(Swift.String(describing: provisioningArtifactSummaries)), tagOptions: \(Swift.String(describing: tagOptions)), tags: \(Swift.String(describing: tags)))"}
}

extension DescribeProductAsAdminOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeProductAsAdminOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.budgets = output.budgets
            self.productViewDetail = output.productViewDetail
            self.provisioningArtifactSummaries = output.provisioningArtifactSummaries
            self.tagOptions = output.tagOptions
            self.tags = output.tags
        } else {
            self.budgets = nil
            self.productViewDetail = nil
            self.provisioningArtifactSummaries = nil
            self.tagOptions = nil
            self.tags = nil
        }
    }
}

public struct DescribeProductAsAdminOutputResponse: Swift.Equatable {
    /// Information about the associated budgets.
    public var budgets: [ServiceCatalogClientTypes.BudgetDetail]?
    /// Information about the product view.
    public var productViewDetail: ServiceCatalogClientTypes.ProductViewDetail?
    /// Information about the provisioning artifacts (also known as versions) for the specified product.
    public var provisioningArtifactSummaries: [ServiceCatalogClientTypes.ProvisioningArtifactSummary]?
    /// Information about the TagOptions associated with the product.
    public var tagOptions: [ServiceCatalogClientTypes.TagOptionDetail]?
    /// Information about the tags associated with the product.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init (
        budgets: [ServiceCatalogClientTypes.BudgetDetail]? = nil,
        productViewDetail: ServiceCatalogClientTypes.ProductViewDetail? = nil,
        provisioningArtifactSummaries: [ServiceCatalogClientTypes.ProvisioningArtifactSummary]? = nil,
        tagOptions: [ServiceCatalogClientTypes.TagOptionDetail]? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.budgets = budgets
        self.productViewDetail = productViewDetail
        self.provisioningArtifactSummaries = provisioningArtifactSummaries
        self.tagOptions = tagOptions
        self.tags = tags
    }
}

struct DescribeProductAsAdminOutputResponseBody: Swift.Equatable {
    public let productViewDetail: ServiceCatalogClientTypes.ProductViewDetail?
    public let provisioningArtifactSummaries: [ServiceCatalogClientTypes.ProvisioningArtifactSummary]?
    public let tags: [ServiceCatalogClientTypes.Tag]?
    public let tagOptions: [ServiceCatalogClientTypes.TagOptionDetail]?
    public let budgets: [ServiceCatalogClientTypes.BudgetDetail]?
}

extension DescribeProductAsAdminOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgets = "Budgets"
        case productViewDetail = "ProductViewDetail"
        case provisioningArtifactSummaries = "ProvisioningArtifactSummaries"
        case tagOptions = "TagOptions"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductViewDetail.self, forKey: .productViewDetail)
        productViewDetail = productViewDetailDecoded
        let provisioningArtifactSummariesContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisioningArtifactSummary?].self, forKey: .provisioningArtifactSummaries)
        var provisioningArtifactSummariesDecoded0:[ServiceCatalogClientTypes.ProvisioningArtifactSummary]? = nil
        if let provisioningArtifactSummariesContainer = provisioningArtifactSummariesContainer {
            provisioningArtifactSummariesDecoded0 = [ServiceCatalogClientTypes.ProvisioningArtifactSummary]()
            for structure0 in provisioningArtifactSummariesContainer {
                if let structure0 = structure0 {
                    provisioningArtifactSummariesDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifactSummaries = provisioningArtifactSummariesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let tagOptionsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.TagOptionDetail?].self, forKey: .tagOptions)
        var tagOptionsDecoded0:[ServiceCatalogClientTypes.TagOptionDetail]? = nil
        if let tagOptionsContainer = tagOptionsContainer {
            tagOptionsDecoded0 = [ServiceCatalogClientTypes.TagOptionDetail]()
            for structure0 in tagOptionsContainer {
                if let structure0 = structure0 {
                    tagOptionsDecoded0?.append(structure0)
                }
            }
        }
        tagOptions = tagOptionsDecoded0
        let budgetsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.BudgetDetail?].self, forKey: .budgets)
        var budgetsDecoded0:[ServiceCatalogClientTypes.BudgetDetail]? = nil
        if let budgetsContainer = budgetsContainer {
            budgetsDecoded0 = [ServiceCatalogClientTypes.BudgetDetail]()
            for structure0 in budgetsContainer {
                if let structure0 = structure0 {
                    budgetsDecoded0?.append(structure0)
                }
            }
        }
        budgets = budgetsDecoded0
    }
}

public struct DescribeProductInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProductOutputError>
}

extension DescribeProductInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProductInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)))"}
}

extension DescribeProductInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DescribeProductInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProductOutputError>
}

public struct DescribeProductInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProductOutputError>
}

public struct DescribeProductInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProductInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeProductInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeProductInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProductOutputError>
}

public struct DescribeProductInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The product identifier.
    public var id: Swift.String?
    /// The product name.
    public var name: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
        self.name = name
    }
}

struct DescribeProductInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let id: Swift.String?
    public let name: Swift.String?
}

extension DescribeProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribeProductOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProductOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProductOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProductOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProductOutputResponse(budgets: \(Swift.String(describing: budgets)), launchPaths: \(Swift.String(describing: launchPaths)), productViewSummary: \(Swift.String(describing: productViewSummary)), provisioningArtifacts: \(Swift.String(describing: provisioningArtifacts)))"}
}

extension DescribeProductOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeProductOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.budgets = output.budgets
            self.launchPaths = output.launchPaths
            self.productViewSummary = output.productViewSummary
            self.provisioningArtifacts = output.provisioningArtifacts
        } else {
            self.budgets = nil
            self.launchPaths = nil
            self.productViewSummary = nil
            self.provisioningArtifacts = nil
        }
    }
}

public struct DescribeProductOutputResponse: Swift.Equatable {
    /// Information about the associated budgets.
    public var budgets: [ServiceCatalogClientTypes.BudgetDetail]?
    /// Information about the associated launch paths.
    public var launchPaths: [ServiceCatalogClientTypes.LaunchPath]?
    /// Summary information about the product view.
    public var productViewSummary: ServiceCatalogClientTypes.ProductViewSummary?
    /// Information about the provisioning artifacts for the specified product.
    public var provisioningArtifacts: [ServiceCatalogClientTypes.ProvisioningArtifact]?

    public init (
        budgets: [ServiceCatalogClientTypes.BudgetDetail]? = nil,
        launchPaths: [ServiceCatalogClientTypes.LaunchPath]? = nil,
        productViewSummary: ServiceCatalogClientTypes.ProductViewSummary? = nil,
        provisioningArtifacts: [ServiceCatalogClientTypes.ProvisioningArtifact]? = nil
    )
    {
        self.budgets = budgets
        self.launchPaths = launchPaths
        self.productViewSummary = productViewSummary
        self.provisioningArtifacts = provisioningArtifacts
    }
}

struct DescribeProductOutputResponseBody: Swift.Equatable {
    public let productViewSummary: ServiceCatalogClientTypes.ProductViewSummary?
    public let provisioningArtifacts: [ServiceCatalogClientTypes.ProvisioningArtifact]?
    public let budgets: [ServiceCatalogClientTypes.BudgetDetail]?
    public let launchPaths: [ServiceCatalogClientTypes.LaunchPath]?
}

extension DescribeProductOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgets = "Budgets"
        case launchPaths = "LaunchPaths"
        case productViewSummary = "ProductViewSummary"
        case provisioningArtifacts = "ProvisioningArtifacts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewSummaryDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductViewSummary.self, forKey: .productViewSummary)
        productViewSummary = productViewSummaryDecoded
        let provisioningArtifactsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisioningArtifact?].self, forKey: .provisioningArtifacts)
        var provisioningArtifactsDecoded0:[ServiceCatalogClientTypes.ProvisioningArtifact]? = nil
        if let provisioningArtifactsContainer = provisioningArtifactsContainer {
            provisioningArtifactsDecoded0 = [ServiceCatalogClientTypes.ProvisioningArtifact]()
            for structure0 in provisioningArtifactsContainer {
                if let structure0 = structure0 {
                    provisioningArtifactsDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifacts = provisioningArtifactsDecoded0
        let budgetsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.BudgetDetail?].self, forKey: .budgets)
        var budgetsDecoded0:[ServiceCatalogClientTypes.BudgetDetail]? = nil
        if let budgetsContainer = budgetsContainer {
            budgetsDecoded0 = [ServiceCatalogClientTypes.BudgetDetail]()
            for structure0 in budgetsContainer {
                if let structure0 = structure0 {
                    budgetsDecoded0?.append(structure0)
                }
            }
        }
        budgets = budgetsDecoded0
        let launchPathsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.LaunchPath?].self, forKey: .launchPaths)
        var launchPathsDecoded0:[ServiceCatalogClientTypes.LaunchPath]? = nil
        if let launchPathsContainer = launchPathsContainer {
            launchPathsDecoded0 = [ServiceCatalogClientTypes.LaunchPath]()
            for structure0 in launchPathsContainer {
                if let structure0 = structure0 {
                    launchPathsDecoded0?.append(structure0)
                }
            }
        }
        launchPaths = launchPathsDecoded0
    }
}

public struct DescribeProductViewInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProductViewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProductViewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProductViewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProductViewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProductViewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProductViewOutputError>
}

extension DescribeProductViewInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProductViewInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), id: \(Swift.String(describing: id)))"}
}

extension DescribeProductViewInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DescribeProductViewInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProductViewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProductViewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProductViewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProductViewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProductViewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProductViewOutputError>
}

public struct DescribeProductViewInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProductViewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProductViewInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProductViewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProductViewInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProductViewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProductViewOutputError>
}

public struct DescribeProductViewInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProductViewInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeProductViewInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProductViewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeProductViewInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProductViewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProductViewOutputError>
}

public struct DescribeProductViewInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The product view identifier.
    /// This member is required.
    public var id: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DescribeProductViewInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let id: Swift.String?
}

extension DescribeProductViewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension DescribeProductViewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProductViewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProductViewOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProductViewOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProductViewOutputResponse(productViewSummary: \(Swift.String(describing: productViewSummary)), provisioningArtifacts: \(Swift.String(describing: provisioningArtifacts)))"}
}

extension DescribeProductViewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeProductViewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.productViewSummary = output.productViewSummary
            self.provisioningArtifacts = output.provisioningArtifacts
        } else {
            self.productViewSummary = nil
            self.provisioningArtifacts = nil
        }
    }
}

public struct DescribeProductViewOutputResponse: Swift.Equatable {
    /// Summary information about the product.
    public var productViewSummary: ServiceCatalogClientTypes.ProductViewSummary?
    /// Information about the provisioning artifacts for the product.
    public var provisioningArtifacts: [ServiceCatalogClientTypes.ProvisioningArtifact]?

    public init (
        productViewSummary: ServiceCatalogClientTypes.ProductViewSummary? = nil,
        provisioningArtifacts: [ServiceCatalogClientTypes.ProvisioningArtifact]? = nil
    )
    {
        self.productViewSummary = productViewSummary
        self.provisioningArtifacts = provisioningArtifacts
    }
}

struct DescribeProductViewOutputResponseBody: Swift.Equatable {
    public let productViewSummary: ServiceCatalogClientTypes.ProductViewSummary?
    public let provisioningArtifacts: [ServiceCatalogClientTypes.ProvisioningArtifact]?
}

extension DescribeProductViewOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productViewSummary = "ProductViewSummary"
        case provisioningArtifacts = "ProvisioningArtifacts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewSummaryDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductViewSummary.self, forKey: .productViewSummary)
        productViewSummary = productViewSummaryDecoded
        let provisioningArtifactsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisioningArtifact?].self, forKey: .provisioningArtifacts)
        var provisioningArtifactsDecoded0:[ServiceCatalogClientTypes.ProvisioningArtifact]? = nil
        if let provisioningArtifactsContainer = provisioningArtifactsContainer {
            provisioningArtifactsDecoded0 = [ServiceCatalogClientTypes.ProvisioningArtifact]()
            for structure0 in provisioningArtifactsContainer {
                if let structure0 = structure0 {
                    provisioningArtifactsDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifacts = provisioningArtifactsDecoded0
    }
}

public struct DescribeProvisionedProductInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProvisionedProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProvisionedProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProvisionedProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProvisionedProductOutputError>
}

extension DescribeProvisionedProductInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProvisionedProductInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)))"}
}

extension DescribeProvisionedProductInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct DescribeProvisionedProductInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProvisionedProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProvisionedProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProvisionedProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProvisionedProductOutputError>
}

public struct DescribeProvisionedProductInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProvisionedProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProvisionedProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProvisionedProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProvisionedProductOutputError>
}

public struct DescribeProvisionedProductInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProvisionedProductInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeProvisionedProductInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeProvisionedProductInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProvisionedProductOutputError>
}

/// DescribeProvisionedProductAPI input structure.
///
///         AcceptLanguage - [Optional]
///         The language code for localization.
///
///         Id - [Optional]
///         The provisioned product identifier.
///
///         Name - [Optional]
///         Another provisioned product identifier. Customers must provide either Id or Name.
public struct DescribeProvisionedProductInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The provisioned product identifier. You must provide the name or ID, but not both.
    ///          If you do not provide a name or ID, or you provide both name and ID, an InvalidParametersException will occur.
    public var id: Swift.String?
    /// The name of the provisioned product. You must provide the name or ID, but not both.
    ///          If you do not provide a name or ID, or you provide both name and ID, an InvalidParametersException will occur.
    public var name: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
        self.name = name
    }
}

struct DescribeProvisionedProductInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let id: Swift.String?
    public let name: Swift.String?
}

extension DescribeProvisionedProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension DescribeProvisionedProductOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProvisionedProductOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProvisionedProductOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProvisionedProductOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProvisionedProductOutputResponse(cloudWatchDashboards: \(Swift.String(describing: cloudWatchDashboards)), provisionedProductDetail: \(Swift.String(describing: provisionedProductDetail)))"}
}

extension DescribeProvisionedProductOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeProvisionedProductOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.cloudWatchDashboards = output.cloudWatchDashboards
            self.provisionedProductDetail = output.provisionedProductDetail
        } else {
            self.cloudWatchDashboards = nil
            self.provisionedProductDetail = nil
        }
    }
}

public struct DescribeProvisionedProductOutputResponse: Swift.Equatable {
    /// Any CloudWatch dashboards that were created when provisioning the product.
    public var cloudWatchDashboards: [ServiceCatalogClientTypes.CloudWatchDashboard]?
    /// Information about the provisioned product.
    public var provisionedProductDetail: ServiceCatalogClientTypes.ProvisionedProductDetail?

    public init (
        cloudWatchDashboards: [ServiceCatalogClientTypes.CloudWatchDashboard]? = nil,
        provisionedProductDetail: ServiceCatalogClientTypes.ProvisionedProductDetail? = nil
    )
    {
        self.cloudWatchDashboards = cloudWatchDashboards
        self.provisionedProductDetail = provisionedProductDetail
    }
}

struct DescribeProvisionedProductOutputResponseBody: Swift.Equatable {
    public let provisionedProductDetail: ServiceCatalogClientTypes.ProvisionedProductDetail?
    public let cloudWatchDashboards: [ServiceCatalogClientTypes.CloudWatchDashboard]?
}

extension DescribeProvisionedProductOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchDashboards = "CloudWatchDashboards"
        case provisionedProductDetail = "ProvisionedProductDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisionedProductDetail.self, forKey: .provisionedProductDetail)
        provisionedProductDetail = provisionedProductDetailDecoded
        let cloudWatchDashboardsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.CloudWatchDashboard?].self, forKey: .cloudWatchDashboards)
        var cloudWatchDashboardsDecoded0:[ServiceCatalogClientTypes.CloudWatchDashboard]? = nil
        if let cloudWatchDashboardsContainer = cloudWatchDashboardsContainer {
            cloudWatchDashboardsDecoded0 = [ServiceCatalogClientTypes.CloudWatchDashboard]()
            for structure0 in cloudWatchDashboardsContainer {
                if let structure0 = structure0 {
                    cloudWatchDashboardsDecoded0?.append(structure0)
                }
            }
        }
        cloudWatchDashboards = cloudWatchDashboardsDecoded0
    }
}

public struct DescribeProvisionedProductPlanInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProvisionedProductPlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProvisionedProductPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProvisionedProductPlanOutputError>
}

extension DescribeProvisionedProductPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProvisionedProductPlanInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)), planId: \(Swift.String(describing: planId)))"}
}

extension DescribeProvisionedProductPlanInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case planId = "PlanId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let planId = planId {
            try encodeContainer.encode(planId, forKey: .planId)
        }
    }
}

public struct DescribeProvisionedProductPlanInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProvisionedProductPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProvisionedProductPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProvisionedProductPlanOutputError>
}

public struct DescribeProvisionedProductPlanInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProvisionedProductPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProvisionedProductPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProvisionedProductPlanOutputError>
}

public struct DescribeProvisionedProductPlanInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProvisionedProductPlanInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeProvisionedProductPlanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeProvisionedProductPlanInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProvisionedProductPlanOutputError>
}

public struct DescribeProvisionedProductPlanInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The plan identifier.
    /// This member is required.
    public var planId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil,
        planId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.planId = planId
    }
}

struct DescribeProvisionedProductPlanInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let planId: Swift.String?
    public let pageSize: Swift.Int
    public let pageToken: Swift.String?
}

extension DescribeProvisionedProductPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case planId = "PlanId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let planIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .planId)
        planId = planIdDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension DescribeProvisionedProductPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProvisionedProductPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProvisionedProductPlanOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProvisionedProductPlanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProvisionedProductPlanOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), provisionedProductPlanDetails: \(Swift.String(describing: provisionedProductPlanDetails)), resourceChanges: \(Swift.String(describing: resourceChanges)))"}
}

extension DescribeProvisionedProductPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeProvisionedProductPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.provisionedProductPlanDetails = output.provisionedProductPlanDetails
            self.resourceChanges = output.resourceChanges
        } else {
            self.nextPageToken = nil
            self.provisionedProductPlanDetails = nil
            self.resourceChanges = nil
        }
    }
}

public struct DescribeProvisionedProductPlanOutputResponse: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the plan.
    public var provisionedProductPlanDetails: ServiceCatalogClientTypes.ProvisionedProductPlanDetails?
    /// Information about the resource changes that will occur when the plan is executed.
    public var resourceChanges: [ServiceCatalogClientTypes.ResourceChange]?

    public init (
        nextPageToken: Swift.String? = nil,
        provisionedProductPlanDetails: ServiceCatalogClientTypes.ProvisionedProductPlanDetails? = nil,
        resourceChanges: [ServiceCatalogClientTypes.ResourceChange]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.provisionedProductPlanDetails = provisionedProductPlanDetails
        self.resourceChanges = resourceChanges
    }
}

struct DescribeProvisionedProductPlanOutputResponseBody: Swift.Equatable {
    public let provisionedProductPlanDetails: ServiceCatalogClientTypes.ProvisionedProductPlanDetails?
    public let resourceChanges: [ServiceCatalogClientTypes.ResourceChange]?
    public let nextPageToken: Swift.String?
}

extension DescribeProvisionedProductPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case provisionedProductPlanDetails = "ProvisionedProductPlanDetails"
        case resourceChanges = "ResourceChanges"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductPlanDetailsDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisionedProductPlanDetails.self, forKey: .provisionedProductPlanDetails)
        provisionedProductPlanDetails = provisionedProductPlanDetailsDecoded
        let resourceChangesContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ResourceChange?].self, forKey: .resourceChanges)
        var resourceChangesDecoded0:[ServiceCatalogClientTypes.ResourceChange]? = nil
        if let resourceChangesContainer = resourceChangesContainer {
            resourceChangesDecoded0 = [ServiceCatalogClientTypes.ResourceChange]()
            for structure0 in resourceChangesContainer {
                if let structure0 = structure0 {
                    resourceChangesDecoded0?.append(structure0)
                }
            }
        }
        resourceChanges = resourceChangesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct DescribeProvisioningArtifactInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProvisioningArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProvisioningArtifactOutputError>
}

extension DescribeProvisioningArtifactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProvisioningArtifactInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), productId: \(Swift.String(describing: productId)), productName: \(Swift.String(describing: productName)), provisioningArtifactId: \(Swift.String(describing: provisioningArtifactId)), provisioningArtifactName: \(Swift.String(describing: provisioningArtifactName)), verbose: \(Swift.String(describing: verbose)))"}
}

extension DescribeProvisioningArtifactInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
        case verbose = "Verbose"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let productName = productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let provisioningArtifactName = provisioningArtifactName {
            try encodeContainer.encode(provisioningArtifactName, forKey: .provisioningArtifactName)
        }
        if verbose != false {
            try encodeContainer.encode(verbose, forKey: .verbose)
        }
    }
}

public struct DescribeProvisioningArtifactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProvisioningArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProvisioningArtifactOutputError>
}

public struct DescribeProvisioningArtifactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProvisioningArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProvisioningArtifactOutputError>
}

public struct DescribeProvisioningArtifactInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProvisioningArtifactInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeProvisioningArtifactInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeProvisioningArtifactInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProvisioningArtifactOutputError>
}

public struct DescribeProvisioningArtifactInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The product identifier.
    public var productId: Swift.String?
    /// The product name.
    public var productName: Swift.String?
    /// The identifier of the provisioning artifact.
    public var provisioningArtifactId: Swift.String?
    /// The provisioning artifact name.
    public var provisioningArtifactName: Swift.String?
    /// Indicates whether a verbose level of detail is enabled.
    public var verbose: Swift.Bool

    public init (
        acceptLanguage: Swift.String? = nil,
        productId: Swift.String? = nil,
        productName: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil,
        provisioningArtifactName: Swift.String? = nil,
        verbose: Swift.Bool = false
    )
    {
        self.acceptLanguage = acceptLanguage
        self.productId = productId
        self.productName = productName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningArtifactName = provisioningArtifactName
        self.verbose = verbose
    }
}

struct DescribeProvisioningArtifactInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let provisioningArtifactId: Swift.String?
    public let productId: Swift.String?
    public let provisioningArtifactName: Swift.String?
    public let productName: Swift.String?
    public let verbose: Swift.Bool
}

extension DescribeProvisioningArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
        case verbose = "Verbose"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactName)
        provisioningArtifactName = provisioningArtifactNameDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let verboseDecoded = try containerValues.decode(Swift.Bool.self, forKey: .verbose)
        verbose = verboseDecoded
    }
}

extension DescribeProvisioningArtifactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProvisioningArtifactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProvisioningArtifactOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProvisioningArtifactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProvisioningArtifactOutputResponse(info: \(Swift.String(describing: info)), provisioningArtifactDetail: \(Swift.String(describing: provisioningArtifactDetail)), status: \(Swift.String(describing: status)))"}
}

extension DescribeProvisioningArtifactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeProvisioningArtifactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.info = output.info
            self.provisioningArtifactDetail = output.provisioningArtifactDetail
            self.status = output.status
        } else {
            self.info = nil
            self.provisioningArtifactDetail = nil
            self.status = nil
        }
    }
}

public struct DescribeProvisioningArtifactOutputResponse: Swift.Equatable {
    /// The URL of the CloudFormation template in Amazon S3.
    public var info: [Swift.String:Swift.String]?
    /// Information about the provisioning artifact.
    public var provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail?
    /// The status of the current request.
    public var status: ServiceCatalogClientTypes.Status?

    public init (
        info: [Swift.String:Swift.String]? = nil,
        provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail? = nil,
        status: ServiceCatalogClientTypes.Status? = nil
    )
    {
        self.info = info
        self.provisioningArtifactDetail = provisioningArtifactDetail
        self.status = status
    }
}

struct DescribeProvisioningArtifactOutputResponseBody: Swift.Equatable {
    public let provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail?
    public let info: [Swift.String:Swift.String]?
    public let status: ServiceCatalogClientTypes.Status?
}

extension DescribeProvisioningArtifactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case info = "Info"
        case provisioningArtifactDetail = "ProvisioningArtifactDetail"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisioningArtifactDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactDetail.self, forKey: .provisioningArtifactDetail)
        provisioningArtifactDetail = provisioningArtifactDetailDecoded
        let infoContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .info)
        var infoDecoded0: [Swift.String:Swift.String]? = nil
        if let infoContainer = infoContainer {
            infoDecoded0 = [Swift.String:Swift.String]()
            for (key0, provisioningartifactinfovalue0) in infoContainer {
                if let provisioningartifactinfovalue0 = provisioningartifactinfovalue0 {
                    infoDecoded0?[key0] = provisioningartifactinfovalue0
                }
            }
        }
        info = infoDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DescribeProvisioningParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProvisioningParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProvisioningParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProvisioningParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProvisioningParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProvisioningParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProvisioningParametersOutputError>
}

extension DescribeProvisioningParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProvisioningParametersInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), pathId: \(Swift.String(describing: pathId)), pathName: \(Swift.String(describing: pathName)), productId: \(Swift.String(describing: productId)), productName: \(Swift.String(describing: productName)), provisioningArtifactId: \(Swift.String(describing: provisioningArtifactId)), provisioningArtifactName: \(Swift.String(describing: provisioningArtifactName)))"}
}

extension DescribeProvisioningParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pathId = "PathId"
        case pathName = "PathName"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let pathId = pathId {
            try encodeContainer.encode(pathId, forKey: .pathId)
        }
        if let pathName = pathName {
            try encodeContainer.encode(pathName, forKey: .pathName)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let productName = productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let provisioningArtifactName = provisioningArtifactName {
            try encodeContainer.encode(provisioningArtifactName, forKey: .provisioningArtifactName)
        }
    }
}

public struct DescribeProvisioningParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProvisioningParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProvisioningParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProvisioningParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProvisioningParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProvisioningParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProvisioningParametersOutputError>
}

public struct DescribeProvisioningParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProvisioningParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProvisioningParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProvisioningParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProvisioningParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProvisioningParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProvisioningParametersOutputError>
}

public struct DescribeProvisioningParametersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProvisioningParametersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeProvisioningParametersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProvisioningParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeProvisioningParametersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProvisioningParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProvisioningParametersOutputError>
}

public struct DescribeProvisioningParametersInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The path identifier of the product. This value is optional if the product
    ///          has a default path, and required if the product has more than one path.
    ///          To list the paths for a product, use ListLaunchPaths. You must provide the name or ID, but not both.
    public var pathId: Swift.String?
    /// The name of the path. You must provide the name or ID, but not both.
    public var pathName: Swift.String?
    /// The product identifier. You must provide the product name or ID, but not both.
    public var productId: Swift.String?
    /// The name of the product. You must provide the name or ID, but not both.
    public var productName: Swift.String?
    /// The identifier of the provisioning artifact. You must provide the name or ID, but not both.
    public var provisioningArtifactId: Swift.String?
    /// The name of the provisioning artifact. You must provide the name or ID, but not both.
    public var provisioningArtifactName: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        pathId: Swift.String? = nil,
        pathName: Swift.String? = nil,
        productId: Swift.String? = nil,
        productName: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil,
        provisioningArtifactName: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pathId = pathId
        self.pathName = pathName
        self.productId = productId
        self.productName = productName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningArtifactName = provisioningArtifactName
    }
}

struct DescribeProvisioningParametersInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let productId: Swift.String?
    public let productName: Swift.String?
    public let provisioningArtifactId: Swift.String?
    public let provisioningArtifactName: Swift.String?
    public let pathId: Swift.String?
    public let pathName: Swift.String?
}

extension DescribeProvisioningParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pathId = "PathId"
        case pathName = "PathName"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let provisioningArtifactNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactName)
        provisioningArtifactName = provisioningArtifactNameDecoded
        let pathIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathId)
        pathId = pathIdDecoded
        let pathNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathName)
        pathName = pathNameDecoded
    }
}

extension DescribeProvisioningParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProvisioningParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProvisioningParametersOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProvisioningParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProvisioningParametersOutputResponse(constraintSummaries: \(Swift.String(describing: constraintSummaries)), provisioningArtifactOutputs: \(Swift.String(describing: provisioningArtifactOutputs)), provisioningArtifactParameters: \(Swift.String(describing: provisioningArtifactParameters)), provisioningArtifactPreferences: \(Swift.String(describing: provisioningArtifactPreferences)), tagOptions: \(Swift.String(describing: tagOptions)), usageInstructions: \(Swift.String(describing: usageInstructions)))"}
}

extension DescribeProvisioningParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeProvisioningParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.constraintSummaries = output.constraintSummaries
            self.provisioningArtifactOutputs = output.provisioningArtifactOutputs
            self.provisioningArtifactParameters = output.provisioningArtifactParameters
            self.provisioningArtifactPreferences = output.provisioningArtifactPreferences
            self.tagOptions = output.tagOptions
            self.usageInstructions = output.usageInstructions
        } else {
            self.constraintSummaries = nil
            self.provisioningArtifactOutputs = nil
            self.provisioningArtifactParameters = nil
            self.provisioningArtifactPreferences = nil
            self.tagOptions = nil
            self.usageInstructions = nil
        }
    }
}

public struct DescribeProvisioningParametersOutputResponse: Swift.Equatable {
    /// Information about the constraints used to provision the product.
    public var constraintSummaries: [ServiceCatalogClientTypes.ConstraintSummary]?
    /// The output of the provisioning artifact.
    public var provisioningArtifactOutputs: [ServiceCatalogClientTypes.ProvisioningArtifactOutput]?
    /// Information about the parameters used to provision the product.
    public var provisioningArtifactParameters: [ServiceCatalogClientTypes.ProvisioningArtifactParameter]?
    /// An object that contains information about preferences, such as regions and accounts, for the provisioning artifact.
    public var provisioningArtifactPreferences: ServiceCatalogClientTypes.ProvisioningArtifactPreferences?
    /// Information about the TagOptions associated with the resource.
    public var tagOptions: [ServiceCatalogClientTypes.TagOptionSummary]?
    /// Any additional metadata specifically related to the provisioning of the product. For
    ///          example, see the Version field of the CloudFormation template.
    public var usageInstructions: [ServiceCatalogClientTypes.UsageInstruction]?

    public init (
        constraintSummaries: [ServiceCatalogClientTypes.ConstraintSummary]? = nil,
        provisioningArtifactOutputs: [ServiceCatalogClientTypes.ProvisioningArtifactOutput]? = nil,
        provisioningArtifactParameters: [ServiceCatalogClientTypes.ProvisioningArtifactParameter]? = nil,
        provisioningArtifactPreferences: ServiceCatalogClientTypes.ProvisioningArtifactPreferences? = nil,
        tagOptions: [ServiceCatalogClientTypes.TagOptionSummary]? = nil,
        usageInstructions: [ServiceCatalogClientTypes.UsageInstruction]? = nil
    )
    {
        self.constraintSummaries = constraintSummaries
        self.provisioningArtifactOutputs = provisioningArtifactOutputs
        self.provisioningArtifactParameters = provisioningArtifactParameters
        self.provisioningArtifactPreferences = provisioningArtifactPreferences
        self.tagOptions = tagOptions
        self.usageInstructions = usageInstructions
    }
}

struct DescribeProvisioningParametersOutputResponseBody: Swift.Equatable {
    public let provisioningArtifactParameters: [ServiceCatalogClientTypes.ProvisioningArtifactParameter]?
    public let constraintSummaries: [ServiceCatalogClientTypes.ConstraintSummary]?
    public let usageInstructions: [ServiceCatalogClientTypes.UsageInstruction]?
    public let tagOptions: [ServiceCatalogClientTypes.TagOptionSummary]?
    public let provisioningArtifactPreferences: ServiceCatalogClientTypes.ProvisioningArtifactPreferences?
    public let provisioningArtifactOutputs: [ServiceCatalogClientTypes.ProvisioningArtifactOutput]?
}

extension DescribeProvisioningParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constraintSummaries = "ConstraintSummaries"
        case provisioningArtifactOutputs = "ProvisioningArtifactOutputs"
        case provisioningArtifactParameters = "ProvisioningArtifactParameters"
        case provisioningArtifactPreferences = "ProvisioningArtifactPreferences"
        case tagOptions = "TagOptions"
        case usageInstructions = "UsageInstructions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisioningArtifactParametersContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisioningArtifactParameter?].self, forKey: .provisioningArtifactParameters)
        var provisioningArtifactParametersDecoded0:[ServiceCatalogClientTypes.ProvisioningArtifactParameter]? = nil
        if let provisioningArtifactParametersContainer = provisioningArtifactParametersContainer {
            provisioningArtifactParametersDecoded0 = [ServiceCatalogClientTypes.ProvisioningArtifactParameter]()
            for structure0 in provisioningArtifactParametersContainer {
                if let structure0 = structure0 {
                    provisioningArtifactParametersDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifactParameters = provisioningArtifactParametersDecoded0
        let constraintSummariesContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ConstraintSummary?].self, forKey: .constraintSummaries)
        var constraintSummariesDecoded0:[ServiceCatalogClientTypes.ConstraintSummary]? = nil
        if let constraintSummariesContainer = constraintSummariesContainer {
            constraintSummariesDecoded0 = [ServiceCatalogClientTypes.ConstraintSummary]()
            for structure0 in constraintSummariesContainer {
                if let structure0 = structure0 {
                    constraintSummariesDecoded0?.append(structure0)
                }
            }
        }
        constraintSummaries = constraintSummariesDecoded0
        let usageInstructionsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.UsageInstruction?].self, forKey: .usageInstructions)
        var usageInstructionsDecoded0:[ServiceCatalogClientTypes.UsageInstruction]? = nil
        if let usageInstructionsContainer = usageInstructionsContainer {
            usageInstructionsDecoded0 = [ServiceCatalogClientTypes.UsageInstruction]()
            for structure0 in usageInstructionsContainer {
                if let structure0 = structure0 {
                    usageInstructionsDecoded0?.append(structure0)
                }
            }
        }
        usageInstructions = usageInstructionsDecoded0
        let tagOptionsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.TagOptionSummary?].self, forKey: .tagOptions)
        var tagOptionsDecoded0:[ServiceCatalogClientTypes.TagOptionSummary]? = nil
        if let tagOptionsContainer = tagOptionsContainer {
            tagOptionsDecoded0 = [ServiceCatalogClientTypes.TagOptionSummary]()
            for structure0 in tagOptionsContainer {
                if let structure0 = structure0 {
                    tagOptionsDecoded0?.append(structure0)
                }
            }
        }
        tagOptions = tagOptionsDecoded0
        let provisioningArtifactPreferencesDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactPreferences.self, forKey: .provisioningArtifactPreferences)
        provisioningArtifactPreferences = provisioningArtifactPreferencesDecoded
        let provisioningArtifactOutputsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisioningArtifactOutput?].self, forKey: .provisioningArtifactOutputs)
        var provisioningArtifactOutputsDecoded0:[ServiceCatalogClientTypes.ProvisioningArtifactOutput]? = nil
        if let provisioningArtifactOutputsContainer = provisioningArtifactOutputsContainer {
            provisioningArtifactOutputsDecoded0 = [ServiceCatalogClientTypes.ProvisioningArtifactOutput]()
            for structure0 in provisioningArtifactOutputsContainer {
                if let structure0 = structure0 {
                    provisioningArtifactOutputsDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifactOutputs = provisioningArtifactOutputsDecoded0
    }
}

public struct DescribeRecordInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRecordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRecordOutputError>
}

extension DescribeRecordInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRecordInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), id: \(Swift.String(describing: id)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)))"}
}

extension DescribeRecordInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
    }
}

public struct DescribeRecordInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRecordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRecordOutputError>
}

public struct DescribeRecordInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRecordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeRecordInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeRecordInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRecordOutputError>
}

public struct DescribeRecordInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeRecordInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeRecordInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeRecordInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeRecordOutputError>
}

public struct DescribeRecordInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The record identifier of the provisioned product. This identifier is returned by the
    ///          request operation.
    /// This member is required.
    public var id: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
        self.pageSize = pageSize
        self.pageToken = pageToken
    }
}

struct DescribeRecordInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let id: Swift.String?
    public let pageToken: Swift.String?
    public let pageSize: Swift.Int
}

extension DescribeRecordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension DescribeRecordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRecordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRecordOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRecordOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeRecordOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), recordDetail: \(Swift.String(describing: recordDetail)), recordOutputs: \(Swift.String(describing: recordOutputs)))"}
}

extension DescribeRecordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRecordOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.recordDetail = output.recordDetail
            self.recordOutputs = output.recordOutputs
        } else {
            self.nextPageToken = nil
            self.recordDetail = nil
            self.recordOutputs = nil
        }
    }
}

public struct DescribeRecordOutputResponse: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the product.
    public var recordDetail: ServiceCatalogClientTypes.RecordDetail?
    /// Information about the product created as the result of a request. For example, the output for
    ///          a CloudFormation-backed product that creates an S3 bucket would include the S3 bucket URL.
    public var recordOutputs: [ServiceCatalogClientTypes.RecordOutput]?

    public init (
        nextPageToken: Swift.String? = nil,
        recordDetail: ServiceCatalogClientTypes.RecordDetail? = nil,
        recordOutputs: [ServiceCatalogClientTypes.RecordOutput]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.recordDetail = recordDetail
        self.recordOutputs = recordOutputs
    }
}

struct DescribeRecordOutputResponseBody: Swift.Equatable {
    public let recordDetail: ServiceCatalogClientTypes.RecordDetail?
    public let recordOutputs: [ServiceCatalogClientTypes.RecordOutput]?
    public let nextPageToken: Swift.String?
}

extension DescribeRecordOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case recordDetail = "RecordDetail"
        case recordOutputs = "RecordOutputs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.RecordDetail.self, forKey: .recordDetail)
        recordDetail = recordDetailDecoded
        let recordOutputsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.RecordOutput?].self, forKey: .recordOutputs)
        var recordOutputsDecoded0:[ServiceCatalogClientTypes.RecordOutput]? = nil
        if let recordOutputsContainer = recordOutputsContainer {
            recordOutputsDecoded0 = [ServiceCatalogClientTypes.RecordOutput]()
            for structure0 in recordOutputsContainer {
                if let structure0 = structure0 {
                    recordOutputsDecoded0?.append(structure0)
                }
            }
        }
        recordOutputs = recordOutputsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct DescribeServiceActionExecutionParametersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceActionExecutionParametersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServiceActionExecutionParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceActionExecutionParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServiceActionExecutionParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceActionExecutionParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceActionExecutionParametersOutputError>
}

extension DescribeServiceActionExecutionParametersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServiceActionExecutionParametersInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), provisionedProductId: \(Swift.String(describing: provisionedProductId)), serviceActionId: \(Swift.String(describing: serviceActionId)))"}
}

extension DescribeServiceActionExecutionParametersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case provisionedProductId = "ProvisionedProductId"
        case serviceActionId = "ServiceActionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let provisionedProductId = provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
        if let serviceActionId = serviceActionId {
            try encodeContainer.encode(serviceActionId, forKey: .serviceActionId)
        }
    }
}

public struct DescribeServiceActionExecutionParametersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceActionExecutionParametersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServiceActionExecutionParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceActionExecutionParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServiceActionExecutionParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceActionExecutionParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceActionExecutionParametersOutputError>
}

public struct DescribeServiceActionExecutionParametersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceActionExecutionParametersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServiceActionExecutionParametersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceActionExecutionParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServiceActionExecutionParametersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceActionExecutionParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceActionExecutionParametersOutputError>
}

public struct DescribeServiceActionExecutionParametersInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceActionExecutionParametersInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeServiceActionExecutionParametersInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceActionExecutionParametersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeServiceActionExecutionParametersInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceActionExecutionParametersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceActionExecutionParametersOutputError>
}

public struct DescribeServiceActionExecutionParametersInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The identifier of the provisioned product.
    /// This member is required.
    public var provisionedProductId: Swift.String?
    /// The self-service action identifier.
    /// This member is required.
    public var serviceActionId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        provisionedProductId: Swift.String? = nil,
        serviceActionId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.provisionedProductId = provisionedProductId
        self.serviceActionId = serviceActionId
    }
}

struct DescribeServiceActionExecutionParametersInputBody: Swift.Equatable {
    public let provisionedProductId: Swift.String?
    public let serviceActionId: Swift.String?
    public let acceptLanguage: Swift.String?
}

extension DescribeServiceActionExecutionParametersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case provisionedProductId = "ProvisionedProductId"
        case serviceActionId = "ServiceActionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let serviceActionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceActionId)
        serviceActionId = serviceActionIdDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension DescribeServiceActionExecutionParametersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServiceActionExecutionParametersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServiceActionExecutionParametersOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServiceActionExecutionParametersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServiceActionExecutionParametersOutputResponse(serviceActionParameters: \(Swift.String(describing: serviceActionParameters)))"}
}

extension DescribeServiceActionExecutionParametersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeServiceActionExecutionParametersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceActionParameters = output.serviceActionParameters
        } else {
            self.serviceActionParameters = nil
        }
    }
}

public struct DescribeServiceActionExecutionParametersOutputResponse: Swift.Equatable {
    /// The parameters of the self-service action.
    public var serviceActionParameters: [ServiceCatalogClientTypes.ExecutionParameter]?

    public init (
        serviceActionParameters: [ServiceCatalogClientTypes.ExecutionParameter]? = nil
    )
    {
        self.serviceActionParameters = serviceActionParameters
    }
}

struct DescribeServiceActionExecutionParametersOutputResponseBody: Swift.Equatable {
    public let serviceActionParameters: [ServiceCatalogClientTypes.ExecutionParameter]?
}

extension DescribeServiceActionExecutionParametersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceActionParameters = "ServiceActionParameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionParametersContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ExecutionParameter?].self, forKey: .serviceActionParameters)
        var serviceActionParametersDecoded0:[ServiceCatalogClientTypes.ExecutionParameter]? = nil
        if let serviceActionParametersContainer = serviceActionParametersContainer {
            serviceActionParametersDecoded0 = [ServiceCatalogClientTypes.ExecutionParameter]()
            for structure0 in serviceActionParametersContainer {
                if let structure0 = structure0 {
                    serviceActionParametersDecoded0?.append(structure0)
                }
            }
        }
        serviceActionParameters = serviceActionParametersDecoded0
    }
}

public struct DescribeServiceActionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServiceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServiceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceActionOutputError>
}

extension DescribeServiceActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServiceActionInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), id: \(Swift.String(describing: id)))"}
}

extension DescribeServiceActionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }
}

public struct DescribeServiceActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServiceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServiceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceActionOutputError>
}

public struct DescribeServiceActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServiceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServiceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceActionOutputError>
}

public struct DescribeServiceActionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServiceActionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeServiceActionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeServiceActionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServiceActionOutputError>
}

public struct DescribeServiceActionInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The self-service action identifier.
    /// This member is required.
    public var id: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.id = id
    }
}

struct DescribeServiceActionInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let acceptLanguage: Swift.String?
}

extension DescribeServiceActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension DescribeServiceActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServiceActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServiceActionOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServiceActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServiceActionOutputResponse(serviceActionDetail: \(Swift.String(describing: serviceActionDetail)))"}
}

extension DescribeServiceActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeServiceActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceActionDetail = output.serviceActionDetail
        } else {
            self.serviceActionDetail = nil
        }
    }
}

public struct DescribeServiceActionOutputResponse: Swift.Equatable {
    /// Detailed information about the self-service action.
    public var serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail?

    public init (
        serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail? = nil
    )
    {
        self.serviceActionDetail = serviceActionDetail
    }
}

struct DescribeServiceActionOutputResponseBody: Swift.Equatable {
    public let serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail?
}

extension DescribeServiceActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceActionDetail = "ServiceActionDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ServiceActionDetail.self, forKey: .serviceActionDetail)
        serviceActionDetail = serviceActionDetailDecoded
    }
}

extension DescribeTagOptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTagOptionInput(id: \(Swift.String(describing: id)))"}
}

extension DescribeTagOptionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeTagOptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTagOptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTagOptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTagOptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTagOptionOutputError>
}

public struct DescribeTagOptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTagOptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeTagOptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeTagOptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTagOptionOutputError>
}

public struct DescribeTagOptionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeTagOptionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeTagOptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeTagOptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeTagOptionOutputError>
}

public struct DescribeTagOptionInput: Swift.Equatable {
    /// The TagOption identifier.
    /// This member is required.
    public var id: Swift.String?

    public init (
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct DescribeTagOptionInputBody: Swift.Equatable {
}

extension DescribeTagOptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeTagOptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTagOptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTagOptionOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTagOptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeTagOptionOutputResponse(tagOptionDetail: \(Swift.String(describing: tagOptionDetail)))"}
}

extension DescribeTagOptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeTagOptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagOptionDetail = output.tagOptionDetail
        } else {
            self.tagOptionDetail = nil
        }
    }
}

public struct DescribeTagOptionOutputResponse: Swift.Equatable {
    /// Information about the TagOption.
    public var tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail?

    public init (
        tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail? = nil
    )
    {
        self.tagOptionDetail = tagOptionDetail
    }
}

struct DescribeTagOptionOutputResponseBody: Swift.Equatable {
    public let tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail?
}

extension DescribeTagOptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagOptionDetail = "TagOptionDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagOptionDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.TagOptionDetail.self, forKey: .tagOptionDetail)
        tagOptionDetail = tagOptionDetailDecoded
    }
}

extension DisableAWSOrganizationsAccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableAWSOrganizationsAccessInput()"}
}

extension DisableAWSOrganizationsAccessInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisableAWSOrganizationsAccessInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableAWSOrganizationsAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableAWSOrganizationsAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableAWSOrganizationsAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableAWSOrganizationsAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableAWSOrganizationsAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableAWSOrganizationsAccessOutputError>
}

public struct DisableAWSOrganizationsAccessInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableAWSOrganizationsAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisableAWSOrganizationsAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableAWSOrganizationsAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisableAWSOrganizationsAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisableAWSOrganizationsAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableAWSOrganizationsAccessOutputError>
}

public struct DisableAWSOrganizationsAccessInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisableAWSOrganizationsAccessInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DisableAWSOrganizationsAccessInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisableAWSOrganizationsAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisableAWSOrganizationsAccessInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisableAWSOrganizationsAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisableAWSOrganizationsAccessOutputError>
}

public struct DisableAWSOrganizationsAccessInput: Swift.Equatable {

    public init() {}
}

struct DisableAWSOrganizationsAccessInputBody: Swift.Equatable {
}

extension DisableAWSOrganizationsAccessInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisableAWSOrganizationsAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableAWSOrganizationsAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisableAWSOrganizationsAccessOutputError: Swift.Error, Swift.Equatable {
    case invalidStateException(InvalidStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableAWSOrganizationsAccessOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisableAWSOrganizationsAccessOutputResponse()"}
}

extension DisableAWSOrganizationsAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisableAWSOrganizationsAccessOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisableAWSOrganizationsAccessOutputResponseBody: Swift.Equatable {
}

extension DisableAWSOrganizationsAccessOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DisassociateBudgetFromResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateBudgetFromResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateBudgetFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateBudgetFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateBudgetFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateBudgetFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateBudgetFromResourceOutputError>
}

extension DisassociateBudgetFromResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateBudgetFromResourceInput(budgetName: \(Swift.String(describing: budgetName)), resourceId: \(Swift.String(describing: resourceId)))"}
}

extension DisassociateBudgetFromResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetName = "BudgetName"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let budgetName = budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct DisassociateBudgetFromResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateBudgetFromResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateBudgetFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateBudgetFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateBudgetFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateBudgetFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateBudgetFromResourceOutputError>
}

public struct DisassociateBudgetFromResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateBudgetFromResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateBudgetFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateBudgetFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateBudgetFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateBudgetFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateBudgetFromResourceOutputError>
}

public struct DisassociateBudgetFromResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateBudgetFromResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DisassociateBudgetFromResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateBudgetFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateBudgetFromResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateBudgetFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateBudgetFromResourceOutputError>
}

public struct DisassociateBudgetFromResourceInput: Swift.Equatable {
    /// The name of the budget you want to disassociate.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The resource identifier you want to disassociate from. Either a portfolio-id or a product-id.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        budgetName: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.budgetName = budgetName
        self.resourceId = resourceId
    }
}

struct DisassociateBudgetFromResourceInputBody: Swift.Equatable {
    public let budgetName: Swift.String?
    public let resourceId: Swift.String?
}

extension DisassociateBudgetFromResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetName = "BudgetName"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension DisassociateBudgetFromResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateBudgetFromResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateBudgetFromResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateBudgetFromResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateBudgetFromResourceOutputResponse()"}
}

extension DisassociateBudgetFromResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateBudgetFromResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateBudgetFromResourceOutputResponseBody: Swift.Equatable {
}

extension DisassociateBudgetFromResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DisassociatePrincipalFromPortfolioInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociatePrincipalFromPortfolioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociatePrincipalFromPortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociatePrincipalFromPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociatePrincipalFromPortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociatePrincipalFromPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociatePrincipalFromPortfolioOutputError>
}

extension DisassociatePrincipalFromPortfolioInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociatePrincipalFromPortfolioInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), portfolioId: \(Swift.String(describing: portfolioId)), principalARN: \(Swift.String(describing: principalARN)))"}
}

extension DisassociatePrincipalFromPortfolioInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case principalARN = "PrincipalARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let principalARN = principalARN {
            try encodeContainer.encode(principalARN, forKey: .principalARN)
        }
    }
}

public struct DisassociatePrincipalFromPortfolioInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociatePrincipalFromPortfolioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociatePrincipalFromPortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociatePrincipalFromPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociatePrincipalFromPortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociatePrincipalFromPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociatePrincipalFromPortfolioOutputError>
}

public struct DisassociatePrincipalFromPortfolioInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociatePrincipalFromPortfolioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociatePrincipalFromPortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociatePrincipalFromPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociatePrincipalFromPortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociatePrincipalFromPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociatePrincipalFromPortfolioOutputError>
}

public struct DisassociatePrincipalFromPortfolioInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociatePrincipalFromPortfolioInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DisassociatePrincipalFromPortfolioInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociatePrincipalFromPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociatePrincipalFromPortfolioInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociatePrincipalFromPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociatePrincipalFromPortfolioOutputError>
}

public struct DisassociatePrincipalFromPortfolioInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The ARN of the principal (IAM user, role, or group).
    /// This member is required.
    public var principalARN: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        principalARN: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.principalARN = principalARN
    }
}

struct DisassociatePrincipalFromPortfolioInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let portfolioId: Swift.String?
    public let principalARN: Swift.String?
}

extension DisassociatePrincipalFromPortfolioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case principalARN = "PrincipalARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let principalARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalARN)
        principalARN = principalARNDecoded
    }
}

extension DisassociatePrincipalFromPortfolioOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociatePrincipalFromPortfolioOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociatePrincipalFromPortfolioOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociatePrincipalFromPortfolioOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociatePrincipalFromPortfolioOutputResponse()"}
}

extension DisassociatePrincipalFromPortfolioOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociatePrincipalFromPortfolioOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociatePrincipalFromPortfolioOutputResponseBody: Swift.Equatable {
}

extension DisassociatePrincipalFromPortfolioOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DisassociateProductFromPortfolioInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateProductFromPortfolioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateProductFromPortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateProductFromPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateProductFromPortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateProductFromPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateProductFromPortfolioOutputError>
}

extension DisassociateProductFromPortfolioInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateProductFromPortfolioInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), portfolioId: \(Swift.String(describing: portfolioId)), productId: \(Swift.String(describing: productId)))"}
}

extension DisassociateProductFromPortfolioInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
    }
}

public struct DisassociateProductFromPortfolioInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateProductFromPortfolioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateProductFromPortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateProductFromPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateProductFromPortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateProductFromPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateProductFromPortfolioOutputError>
}

public struct DisassociateProductFromPortfolioInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateProductFromPortfolioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateProductFromPortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateProductFromPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateProductFromPortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateProductFromPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateProductFromPortfolioOutputError>
}

public struct DisassociateProductFromPortfolioInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateProductFromPortfolioInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DisassociateProductFromPortfolioInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateProductFromPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateProductFromPortfolioInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateProductFromPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateProductFromPortfolioOutputError>
}

public struct DisassociateProductFromPortfolioInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        productId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.productId = productId
    }
}

struct DisassociateProductFromPortfolioInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let productId: Swift.String?
    public let portfolioId: Swift.String?
}

extension DisassociateProductFromPortfolioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
    }
}

extension DisassociateProductFromPortfolioOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateProductFromPortfolioOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateProductFromPortfolioOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateProductFromPortfolioOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateProductFromPortfolioOutputResponse()"}
}

extension DisassociateProductFromPortfolioOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateProductFromPortfolioOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateProductFromPortfolioOutputResponseBody: Swift.Equatable {
}

extension DisassociateProductFromPortfolioOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DisassociateServiceActionFromProvisioningArtifactInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateServiceActionFromProvisioningArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateServiceActionFromProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateServiceActionFromProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateServiceActionFromProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateServiceActionFromProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateServiceActionFromProvisioningArtifactOutputError>
}

extension DisassociateServiceActionFromProvisioningArtifactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateServiceActionFromProvisioningArtifactInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), productId: \(Swift.String(describing: productId)), provisioningArtifactId: \(Swift.String(describing: provisioningArtifactId)), serviceActionId: \(Swift.String(describing: serviceActionId)))"}
}

extension DisassociateServiceActionFromProvisioningArtifactInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case serviceActionId = "ServiceActionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let serviceActionId = serviceActionId {
            try encodeContainer.encode(serviceActionId, forKey: .serviceActionId)
        }
    }
}

public struct DisassociateServiceActionFromProvisioningArtifactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateServiceActionFromProvisioningArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateServiceActionFromProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateServiceActionFromProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateServiceActionFromProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateServiceActionFromProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateServiceActionFromProvisioningArtifactOutputError>
}

public struct DisassociateServiceActionFromProvisioningArtifactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateServiceActionFromProvisioningArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateServiceActionFromProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateServiceActionFromProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateServiceActionFromProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateServiceActionFromProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateServiceActionFromProvisioningArtifactOutputError>
}

public struct DisassociateServiceActionFromProvisioningArtifactInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateServiceActionFromProvisioningArtifactInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DisassociateServiceActionFromProvisioningArtifactInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateServiceActionFromProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateServiceActionFromProvisioningArtifactInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateServiceActionFromProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateServiceActionFromProvisioningArtifactOutputError>
}

public struct DisassociateServiceActionFromProvisioningArtifactInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The product identifier. For example, prod-abcdzk7xy33qa.
    /// This member is required.
    public var productId: Swift.String?
    /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
    /// This member is required.
    public var provisioningArtifactId: Swift.String?
    /// The self-service action identifier. For example, act-fs7abcd89wxyz.
    /// This member is required.
    public var serviceActionId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        productId: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil,
        serviceActionId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
        self.serviceActionId = serviceActionId
    }
}

struct DisassociateServiceActionFromProvisioningArtifactInputBody: Swift.Equatable {
    public let productId: Swift.String?
    public let provisioningArtifactId: Swift.String?
    public let serviceActionId: Swift.String?
    public let acceptLanguage: Swift.String?
}

extension DisassociateServiceActionFromProvisioningArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case serviceActionId = "ServiceActionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let serviceActionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceActionId)
        serviceActionId = serviceActionIdDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension DisassociateServiceActionFromProvisioningArtifactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateServiceActionFromProvisioningArtifactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateServiceActionFromProvisioningArtifactOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateServiceActionFromProvisioningArtifactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateServiceActionFromProvisioningArtifactOutputResponse()"}
}

extension DisassociateServiceActionFromProvisioningArtifactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateServiceActionFromProvisioningArtifactOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateServiceActionFromProvisioningArtifactOutputResponseBody: Swift.Equatable {
}

extension DisassociateServiceActionFromProvisioningArtifactOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateTagOptionFromResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateTagOptionFromResourceInput(resourceId: \(Swift.String(describing: resourceId)), tagOptionId: \(Swift.String(describing: tagOptionId)))"}
}

extension DisassociateTagOptionFromResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DisassociateTagOptionFromResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTagOptionFromResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateTagOptionFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTagOptionFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateTagOptionFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTagOptionFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTagOptionFromResourceOutputError>
}

public struct DisassociateTagOptionFromResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTagOptionFromResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateTagOptionFromResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTagOptionFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateTagOptionFromResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTagOptionFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTagOptionFromResourceOutputError>
}

public struct DisassociateTagOptionFromResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateTagOptionFromResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DisassociateTagOptionFromResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateTagOptionFromResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateTagOptionFromResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateTagOptionFromResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateTagOptionFromResourceOutputError>
}

public struct DisassociateTagOptionFromResourceInput: Swift.Equatable {
    /// The resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?
    /// The TagOption identifier.
    /// This member is required.
    public var tagOptionId: Swift.String?

    public init (
        resourceId: Swift.String? = nil,
        tagOptionId: Swift.String? = nil
    )
    {
        self.resourceId = resourceId
        self.tagOptionId = tagOptionId
    }
}

struct DisassociateTagOptionFromResourceInputBody: Swift.Equatable {
}

extension DisassociateTagOptionFromResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateTagOptionFromResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateTagOptionFromResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateTagOptionFromResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateTagOptionFromResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateTagOptionFromResourceOutputResponse()"}
}

extension DisassociateTagOptionFromResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateTagOptionFromResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateTagOptionFromResourceOutputResponseBody: Swift.Equatable {
}

extension DisassociateTagOptionFromResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DuplicateResourceException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DuplicateResourceException(message: \(Swift.String(describing: message)))"}
}

extension DuplicateResourceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DuplicateResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource is a duplicate.
public struct DuplicateResourceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateResourceExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension DuplicateResourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EnableAWSOrganizationsAccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableAWSOrganizationsAccessInput()"}
}

extension EnableAWSOrganizationsAccessInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct EnableAWSOrganizationsAccessInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableAWSOrganizationsAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableAWSOrganizationsAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableAWSOrganizationsAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableAWSOrganizationsAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableAWSOrganizationsAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableAWSOrganizationsAccessOutputError>
}

public struct EnableAWSOrganizationsAccessInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableAWSOrganizationsAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<EnableAWSOrganizationsAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableAWSOrganizationsAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<EnableAWSOrganizationsAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<EnableAWSOrganizationsAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableAWSOrganizationsAccessOutputError>
}

public struct EnableAWSOrganizationsAccessInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "EnableAWSOrganizationsAccessInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: EnableAWSOrganizationsAccessInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<EnableAWSOrganizationsAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = EnableAWSOrganizationsAccessInput
    public typealias MOutput = ClientRuntime.OperationOutput<EnableAWSOrganizationsAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<EnableAWSOrganizationsAccessOutputError>
}

public struct EnableAWSOrganizationsAccessInput: Swift.Equatable {

    public init() {}
}

struct EnableAWSOrganizationsAccessInputBody: Swift.Equatable {
}

extension EnableAWSOrganizationsAccessInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension EnableAWSOrganizationsAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableAWSOrganizationsAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum EnableAWSOrganizationsAccessOutputError: Swift.Error, Swift.Equatable {
    case invalidStateException(InvalidStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableAWSOrganizationsAccessOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnableAWSOrganizationsAccessOutputResponse()"}
}

extension EnableAWSOrganizationsAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct EnableAWSOrganizationsAccessOutputResponse: Swift.Equatable {

    public init() {}
}

struct EnableAWSOrganizationsAccessOutputResponseBody: Swift.Equatable {
}

extension EnableAWSOrganizationsAccessOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ServiceCatalogClientTypes {
    public enum EvaluationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `dynamic`
        case `static`
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationType] {
            return [
                .dynamic,
                .static,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dynamic: return "DYNAMIC"
            case .static: return "STATIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EvaluationType(rawValue: rawValue) ?? EvaluationType.sdkUnknown(rawValue)
        }
    }
}

public struct ExecuteProvisionedProductPlanInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExecuteProvisionedProductPlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExecuteProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExecuteProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExecuteProvisionedProductPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExecuteProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExecuteProvisionedProductPlanOutputError>
}

extension ExecuteProvisionedProductPlanInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecuteProvisionedProductPlanInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), planId: \(Swift.String(describing: planId)))"}
}

extension ExecuteProvisionedProductPlanInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case planId = "PlanId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let planId = planId {
            try encodeContainer.encode(planId, forKey: .planId)
        }
    }
}

public struct ExecuteProvisionedProductPlanInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExecuteProvisionedProductPlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExecuteProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExecuteProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExecuteProvisionedProductPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExecuteProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExecuteProvisionedProductPlanOutputError>
}

public struct ExecuteProvisionedProductPlanInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExecuteProvisionedProductPlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExecuteProvisionedProductPlanInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExecuteProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExecuteProvisionedProductPlanInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExecuteProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExecuteProvisionedProductPlanOutputError>
}

public struct ExecuteProvisionedProductPlanInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExecuteProvisionedProductPlanInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ExecuteProvisionedProductPlanInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExecuteProvisionedProductPlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ExecuteProvisionedProductPlanInput
    public typealias MOutput = ClientRuntime.OperationOutput<ExecuteProvisionedProductPlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExecuteProvisionedProductPlanOutputError>
}

public struct ExecuteProvisionedProductPlanInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
    ///   the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The plan identifier.
    /// This member is required.
    public var planId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        planId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.planId = planId
    }
}

struct ExecuteProvisionedProductPlanInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let planId: Swift.String?
    public let idempotencyToken: Swift.String?
}

extension ExecuteProvisionedProductPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case planId = "PlanId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let planIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .planId)
        planId = planIdDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension ExecuteProvisionedProductPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExecuteProvisionedProductPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExecuteProvisionedProductPlanOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExecuteProvisionedProductPlanOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecuteProvisionedProductPlanOutputResponse(recordDetail: \(Swift.String(describing: recordDetail)))"}
}

extension ExecuteProvisionedProductPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExecuteProvisionedProductPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recordDetail = output.recordDetail
        } else {
            self.recordDetail = nil
        }
    }
}

public struct ExecuteProvisionedProductPlanOutputResponse: Swift.Equatable {
    /// Information about the result of provisioning the product.
    public var recordDetail: ServiceCatalogClientTypes.RecordDetail?

    public init (
        recordDetail: ServiceCatalogClientTypes.RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

struct ExecuteProvisionedProductPlanOutputResponseBody: Swift.Equatable {
    public let recordDetail: ServiceCatalogClientTypes.RecordDetail?
}

extension ExecuteProvisionedProductPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordDetail = "RecordDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.RecordDetail.self, forKey: .recordDetail)
        recordDetail = recordDetailDecoded
    }
}

public struct ExecuteProvisionedProductServiceActionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExecuteProvisionedProductServiceActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExecuteProvisionedProductServiceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExecuteProvisionedProductServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExecuteProvisionedProductServiceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExecuteProvisionedProductServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExecuteProvisionedProductServiceActionOutputError>
}

extension ExecuteProvisionedProductServiceActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecuteProvisionedProductServiceActionInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), executeToken: \(Swift.String(describing: executeToken)), parameters: \(Swift.String(describing: parameters)), provisionedProductId: \(Swift.String(describing: provisionedProductId)), serviceActionId: \(Swift.String(describing: serviceActionId)))"}
}

extension ExecuteProvisionedProductServiceActionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case executeToken = "ExecuteToken"
        case parameters = "Parameters"
        case provisionedProductId = "ProvisionedProductId"
        case serviceActionId = "ServiceActionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let executeToken = executeToken {
            try encodeContainer.encode(executeToken, forKey: .executeToken)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, executionparametermap0) in parameters {
                try parametersContainer.encode(executionparametermap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let provisionedProductId = provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
        if let serviceActionId = serviceActionId {
            try encodeContainer.encode(serviceActionId, forKey: .serviceActionId)
        }
    }
}

public struct ExecuteProvisionedProductServiceActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExecuteProvisionedProductServiceActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExecuteProvisionedProductServiceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExecuteProvisionedProductServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExecuteProvisionedProductServiceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExecuteProvisionedProductServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExecuteProvisionedProductServiceActionOutputError>
}

public struct ExecuteProvisionedProductServiceActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExecuteProvisionedProductServiceActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExecuteProvisionedProductServiceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExecuteProvisionedProductServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExecuteProvisionedProductServiceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExecuteProvisionedProductServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExecuteProvisionedProductServiceActionOutputError>
}

public struct ExecuteProvisionedProductServiceActionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExecuteProvisionedProductServiceActionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ExecuteProvisionedProductServiceActionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExecuteProvisionedProductServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ExecuteProvisionedProductServiceActionInput
    public typealias MOutput = ClientRuntime.OperationOutput<ExecuteProvisionedProductServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExecuteProvisionedProductServiceActionOutputError>
}

public struct ExecuteProvisionedProductServiceActionInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// An idempotency token that uniquely identifies the execute request.
    /// This member is required.
    public var executeToken: Swift.String?
    /// A map of all self-service action parameters and their values. If a provided parameter is of a special type, such as TARGET, the provided value will
    ///             override the default value generated by AWS Service Catalog. If the parameters field is not provided, no additional parameters are passed and default values will be used for
    ///             any special parameters such as TARGET.
    public var parameters: [Swift.String:[Swift.String]]?
    /// The identifier of the provisioned product.
    /// This member is required.
    public var provisionedProductId: Swift.String?
    /// The self-service action identifier. For example, act-fs7abcd89wxyz.
    /// This member is required.
    public var serviceActionId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        executeToken: Swift.String? = nil,
        parameters: [Swift.String:[Swift.String]]? = nil,
        provisionedProductId: Swift.String? = nil,
        serviceActionId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.executeToken = executeToken
        self.parameters = parameters
        self.provisionedProductId = provisionedProductId
        self.serviceActionId = serviceActionId
    }
}

struct ExecuteProvisionedProductServiceActionInputBody: Swift.Equatable {
    public let provisionedProductId: Swift.String?
    public let serviceActionId: Swift.String?
    public let executeToken: Swift.String?
    public let acceptLanguage: Swift.String?
    public let parameters: [Swift.String:[Swift.String]]?
}

extension ExecuteProvisionedProductServiceActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case executeToken = "ExecuteToken"
        case parameters = "Parameters"
        case provisionedProductId = "ProvisionedProductId"
        case serviceActionId = "ServiceActionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let serviceActionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceActionId)
        serviceActionId = serviceActionIdDecoded
        let executeTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executeToken)
        executeToken = executeTokenDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, executionparametervaluelist0) in parametersContainer {
                var executionparametervaluelist0Decoded0: [Swift.String]? = nil
                if let executionparametervaluelist0 = executionparametervaluelist0 {
                    executionparametervaluelist0Decoded0 = [Swift.String]()
                    for string1 in executionparametervaluelist0 {
                        if let string1 = string1 {
                            executionparametervaluelist0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = executionparametervaluelist0Decoded0
            }
        }
        parameters = parametersDecoded0
    }
}

extension ExecuteProvisionedProductServiceActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExecuteProvisionedProductServiceActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExecuteProvisionedProductServiceActionOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExecuteProvisionedProductServiceActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecuteProvisionedProductServiceActionOutputResponse(recordDetail: \(Swift.String(describing: recordDetail)))"}
}

extension ExecuteProvisionedProductServiceActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExecuteProvisionedProductServiceActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recordDetail = output.recordDetail
        } else {
            self.recordDetail = nil
        }
    }
}

public struct ExecuteProvisionedProductServiceActionOutputResponse: Swift.Equatable {
    /// An object containing detailed information about the result of provisioning the product.
    public var recordDetail: ServiceCatalogClientTypes.RecordDetail?

    public init (
        recordDetail: ServiceCatalogClientTypes.RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

struct ExecuteProvisionedProductServiceActionOutputResponseBody: Swift.Equatable {
    public let recordDetail: ServiceCatalogClientTypes.RecordDetail?
}

extension ExecuteProvisionedProductServiceActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordDetail = "RecordDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.RecordDetail.self, forKey: .recordDetail)
        recordDetail = recordDetailDecoded
    }
}

extension ServiceCatalogClientTypes.ExecutionParameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValues = "DefaultValues"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValues = defaultValues {
            var defaultValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultValues)
            for executionparametervaluelist0 in defaultValues {
                try defaultValuesContainer.encode(executionparametervaluelist0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let defaultValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .defaultValues)
        var defaultValuesDecoded0:[Swift.String]? = nil
        if let defaultValuesContainer = defaultValuesContainer {
            defaultValuesDecoded0 = [Swift.String]()
            for string0 in defaultValuesContainer {
                if let string0 = string0 {
                    defaultValuesDecoded0?.append(string0)
                }
            }
        }
        defaultValues = defaultValuesDecoded0
    }
}

extension ServiceCatalogClientTypes.ExecutionParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExecutionParameter(defaultValues: \(Swift.String(describing: defaultValues)), name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)))"}
}

extension ServiceCatalogClientTypes {
    /// Details of an execution parameter value that is passed to a self-service action when executed on a provisioned product.
    public struct ExecutionParameter: Swift.Equatable {
        /// The default values for the execution parameter.
        public var defaultValues: [Swift.String]?
        /// The name of the execution parameter.
        public var name: Swift.String?
        /// The execution parameter type.
        public var type: Swift.String?

        public init (
            defaultValues: [Swift.String]? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.defaultValues = defaultValues
            self.name = name
            self.type = type
        }
    }

}

extension ServiceCatalogClientTypes.FailedServiceActionAssociation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case serviceActionId = "ServiceActionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let serviceActionId = serviceActionId {
            try encodeContainer.encode(serviceActionId, forKey: .serviceActionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceActionId)
        serviceActionId = serviceActionIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ServiceActionAssociationErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension ServiceCatalogClientTypes.FailedServiceActionAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FailedServiceActionAssociation(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), productId: \(Swift.String(describing: productId)), provisioningArtifactId: \(Swift.String(describing: provisioningArtifactId)), serviceActionId: \(Swift.String(describing: serviceActionId)))"}
}

extension ServiceCatalogClientTypes {
    /// An object containing information about the error, along with identifying information about the self-service action and its associations.
    public struct FailedServiceActionAssociation: Swift.Equatable {
        /// The error code. Valid values are listed below.
        public var errorCode: ServiceCatalogClientTypes.ServiceActionAssociationErrorCode?
        /// A text description of the error.
        public var errorMessage: Swift.String?
        /// The product identifier. For example, prod-abcdzk7xy33qa.
        public var productId: Swift.String?
        /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
        public var provisioningArtifactId: Swift.String?
        /// The self-service action identifier. For example, act-fs7abcd89wxyz.
        public var serviceActionId: Swift.String?

        public init (
            errorCode: ServiceCatalogClientTypes.ServiceActionAssociationErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            productId: Swift.String? = nil,
            provisioningArtifactId: Swift.String? = nil,
            serviceActionId: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.productId = productId
            self.provisioningArtifactId = provisioningArtifactId
            self.serviceActionId = serviceActionId
        }
    }

}

extension GetAWSOrganizationsAccessStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAWSOrganizationsAccessStatusInput()"}
}

extension GetAWSOrganizationsAccessStatusInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAWSOrganizationsAccessStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAWSOrganizationsAccessStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAWSOrganizationsAccessStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAWSOrganizationsAccessStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAWSOrganizationsAccessStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAWSOrganizationsAccessStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAWSOrganizationsAccessStatusOutputError>
}

public struct GetAWSOrganizationsAccessStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAWSOrganizationsAccessStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAWSOrganizationsAccessStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAWSOrganizationsAccessStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAWSOrganizationsAccessStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAWSOrganizationsAccessStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAWSOrganizationsAccessStatusOutputError>
}

public struct GetAWSOrganizationsAccessStatusInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAWSOrganizationsAccessStatusInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetAWSOrganizationsAccessStatusInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAWSOrganizationsAccessStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAWSOrganizationsAccessStatusInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAWSOrganizationsAccessStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAWSOrganizationsAccessStatusOutputError>
}

public struct GetAWSOrganizationsAccessStatusInput: Swift.Equatable {

    public init() {}
}

struct GetAWSOrganizationsAccessStatusInputBody: Swift.Equatable {
}

extension GetAWSOrganizationsAccessStatusInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAWSOrganizationsAccessStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAWSOrganizationsAccessStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAWSOrganizationsAccessStatusOutputError: Swift.Error, Swift.Equatable {
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAWSOrganizationsAccessStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAWSOrganizationsAccessStatusOutputResponse(accessStatus: \(Swift.String(describing: accessStatus)))"}
}

extension GetAWSOrganizationsAccessStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAWSOrganizationsAccessStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessStatus = output.accessStatus
        } else {
            self.accessStatus = nil
        }
    }
}

public struct GetAWSOrganizationsAccessStatusOutputResponse: Swift.Equatable {
    /// The status of the portfolio share feature.
    public var accessStatus: ServiceCatalogClientTypes.AccessStatus?

    public init (
        accessStatus: ServiceCatalogClientTypes.AccessStatus? = nil
    )
    {
        self.accessStatus = accessStatus
    }
}

struct GetAWSOrganizationsAccessStatusOutputResponseBody: Swift.Equatable {
    public let accessStatus: ServiceCatalogClientTypes.AccessStatus?
}

extension GetAWSOrganizationsAccessStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessStatus = "AccessStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessStatusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.AccessStatus.self, forKey: .accessStatus)
        accessStatus = accessStatusDecoded
    }
}

public struct GetProvisionedProductOutputsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProvisionedProductOutputsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetProvisionedProductOutputsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProvisionedProductOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetProvisionedProductOutputsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetProvisionedProductOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProvisionedProductOutputsOutputError>
}

extension GetProvisionedProductOutputsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProvisionedProductOutputsInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), outputKeys: \(Swift.String(describing: outputKeys)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)), provisionedProductId: \(Swift.String(describing: provisionedProductId)), provisionedProductName: \(Swift.String(describing: provisionedProductName)))"}
}

extension GetProvisionedProductOutputsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case outputKeys = "OutputKeys"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductName = "ProvisionedProductName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let outputKeys = outputKeys {
            var outputKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputKeys)
            for outputkeys0 in outputKeys {
                try outputKeysContainer.encode(outputkeys0)
            }
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let provisionedProductId = provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
        if let provisionedProductName = provisionedProductName {
            try encodeContainer.encode(provisionedProductName, forKey: .provisionedProductName)
        }
    }
}

public struct GetProvisionedProductOutputsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProvisionedProductOutputsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetProvisionedProductOutputsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProvisionedProductOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetProvisionedProductOutputsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetProvisionedProductOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProvisionedProductOutputsOutputError>
}

public struct GetProvisionedProductOutputsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProvisionedProductOutputsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetProvisionedProductOutputsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProvisionedProductOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetProvisionedProductOutputsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetProvisionedProductOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProvisionedProductOutputsOutputError>
}

public struct GetProvisionedProductOutputsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetProvisionedProductOutputsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetProvisionedProductOutputsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetProvisionedProductOutputsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetProvisionedProductOutputsInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetProvisionedProductOutputsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetProvisionedProductOutputsOutputError>
}

public struct GetProvisionedProductOutputsInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The list of keys that the API should return with their values. If none are provided, the API will return all outputs of the provisioned product.
    public var outputKeys: [Swift.String]?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The identifier of the provisioned product that you want the outputs from.
    public var provisionedProductId: Swift.String?
    /// The name of the provisioned product that you want the outputs from.
    public var provisionedProductName: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        outputKeys: [Swift.String]? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil,
        provisionedProductId: Swift.String? = nil,
        provisionedProductName: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.outputKeys = outputKeys
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.provisionedProductId = provisionedProductId
        self.provisionedProductName = provisionedProductName
    }
}

struct GetProvisionedProductOutputsInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let provisionedProductId: Swift.String?
    public let provisionedProductName: Swift.String?
    public let outputKeys: [Swift.String]?
    public let pageSize: Swift.Int
    public let pageToken: Swift.String?
}

extension GetProvisionedProductOutputsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case outputKeys = "OutputKeys"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductName = "ProvisionedProductName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let outputKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .outputKeys)
        var outputKeysDecoded0:[Swift.String]? = nil
        if let outputKeysContainer = outputKeysContainer {
            outputKeysDecoded0 = [Swift.String]()
            for string0 in outputKeysContainer {
                if let string0 = string0 {
                    outputKeysDecoded0?.append(string0)
                }
            }
        }
        outputKeys = outputKeysDecoded0
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension GetProvisionedProductOutputsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProvisionedProductOutputsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProvisionedProductOutputsOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProvisionedProductOutputsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProvisionedProductOutputsOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), outputs: \(Swift.String(describing: outputs)))"}
}

extension GetProvisionedProductOutputsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetProvisionedProductOutputsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.outputs = output.outputs
        } else {
            self.nextPageToken = nil
            self.outputs = nil
        }
    }
}

public struct GetProvisionedProductOutputsOutputResponse: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the product created as the result of a request. For example, the output for a CloudFormation-backed product that creates an S3 bucket would include the S3 bucket URL.
    ///
    public var outputs: [ServiceCatalogClientTypes.RecordOutput]?

    public init (
        nextPageToken: Swift.String? = nil,
        outputs: [ServiceCatalogClientTypes.RecordOutput]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.outputs = outputs
    }
}

struct GetProvisionedProductOutputsOutputResponseBody: Swift.Equatable {
    public let outputs: [ServiceCatalogClientTypes.RecordOutput]?
    public let nextPageToken: Swift.String?
}

extension GetProvisionedProductOutputsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case outputs = "Outputs"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.RecordOutput?].self, forKey: .outputs)
        var outputsDecoded0:[ServiceCatalogClientTypes.RecordOutput]? = nil
        if let outputsContainer = outputsContainer {
            outputsDecoded0 = [ServiceCatalogClientTypes.RecordOutput]()
            for structure0 in outputsContainer {
                if let structure0 = structure0 {
                    outputsDecoded0?.append(structure0)
                }
            }
        }
        outputs = outputsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ImportAsProvisionedProductInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportAsProvisionedProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportAsProvisionedProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportAsProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportAsProvisionedProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportAsProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportAsProvisionedProductOutputError>
}

extension ImportAsProvisionedProductInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportAsProvisionedProductInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), physicalId: \(Swift.String(describing: physicalId)), productId: \(Swift.String(describing: productId)), provisionedProductName: \(Swift.String(describing: provisionedProductName)), provisioningArtifactId: \(Swift.String(describing: provisioningArtifactId)))"}
}

extension ImportAsProvisionedProductInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case physicalId = "PhysicalId"
        case productId = "ProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let physicalId = physicalId {
            try encodeContainer.encode(physicalId, forKey: .physicalId)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisionedProductName = provisionedProductName {
            try encodeContainer.encode(provisionedProductName, forKey: .provisionedProductName)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
    }
}

public struct ImportAsProvisionedProductInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportAsProvisionedProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportAsProvisionedProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportAsProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportAsProvisionedProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportAsProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportAsProvisionedProductOutputError>
}

public struct ImportAsProvisionedProductInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportAsProvisionedProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ImportAsProvisionedProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportAsProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ImportAsProvisionedProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ImportAsProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportAsProvisionedProductOutputError>
}

public struct ImportAsProvisionedProductInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ImportAsProvisionedProductInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ImportAsProvisionedProductInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ImportAsProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ImportAsProvisionedProductInput
    public typealias MOutput = ClientRuntime.OperationOutput<ImportAsProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ImportAsProvisionedProductOutputError>
}

public struct ImportAsProvisionedProductInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
    ///   the same response is returned for each repeated request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The unique identifier of the resource to be imported. It only currently supports
    ///          CloudFormation stack IDs.
    /// This member is required.
    public var physicalId: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?
    /// The user-friendly name of the provisioned product. The value must be unique for the AWS
    ///          account. The name cannot be updated after the product is provisioned.
    /// This member is required.
    public var provisionedProductName: Swift.String?
    /// The identifier of the provisioning artifact.
    /// This member is required.
    public var provisioningArtifactId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        physicalId: Swift.String? = nil,
        productId: Swift.String? = nil,
        provisionedProductName: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.physicalId = physicalId
        self.productId = productId
        self.provisionedProductName = provisionedProductName
        self.provisioningArtifactId = provisioningArtifactId
    }
}

struct ImportAsProvisionedProductInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let productId: Swift.String?
    public let provisioningArtifactId: Swift.String?
    public let provisionedProductName: Swift.String?
    public let physicalId: Swift.String?
    public let idempotencyToken: Swift.String?
}

extension ImportAsProvisionedProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case physicalId = "PhysicalId"
        case productId = "ProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let physicalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .physicalId)
        physicalId = physicalIdDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension ImportAsProvisionedProductOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportAsProvisionedProductOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ImportAsProvisionedProductOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case invalidParametersException(InvalidParametersException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportAsProvisionedProductOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportAsProvisionedProductOutputResponse(recordDetail: \(Swift.String(describing: recordDetail)))"}
}

extension ImportAsProvisionedProductOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ImportAsProvisionedProductOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recordDetail = output.recordDetail
        } else {
            self.recordDetail = nil
        }
    }
}

public struct ImportAsProvisionedProductOutputResponse: Swift.Equatable {
    /// Information about a request operation.
    public var recordDetail: ServiceCatalogClientTypes.RecordDetail?

    public init (
        recordDetail: ServiceCatalogClientTypes.RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

struct ImportAsProvisionedProductOutputResponseBody: Swift.Equatable {
    public let recordDetail: ServiceCatalogClientTypes.RecordDetail?
}

extension ImportAsProvisionedProductOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordDetail = "RecordDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.RecordDetail.self, forKey: .recordDetail)
        recordDetail = recordDetailDecoded
    }
}

extension InvalidParametersException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidParametersException(message: \(Swift.String(describing: message)))"}
}

extension InvalidParametersException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidParametersExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more parameters provided to the operation are not valid.
public struct InvalidParametersException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParametersExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidParametersExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidStateException(message: \(Swift.String(describing: message)))"}
}

extension InvalidStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An attempt was made to modify a resource that is in a state that is not valid.
///          Check your resources to ensure that they are in valid states before retrying the operation.
public struct InvalidStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStateExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceCatalogClientTypes.LaunchPath: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ServiceCatalogClientTypes.LaunchPath: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchPath(id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)))"}
}

extension ServiceCatalogClientTypes {
    /// A launch path object.
    public struct LaunchPath: Swift.Equatable {
        /// The identifier of the launch path.
        public var id: Swift.String?
        /// The name of the launch path.
        public var name: Swift.String?

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }

}

extension ServiceCatalogClientTypes.LaunchPathSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constraintSummaries = "ConstraintSummaries"
        case id = "Id"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let constraintSummaries = constraintSummaries {
            var constraintSummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .constraintSummaries)
            for constraintsummaries0 in constraintSummaries {
                try constraintSummariesContainer.encode(constraintsummaries0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let constraintSummariesContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ConstraintSummary?].self, forKey: .constraintSummaries)
        var constraintSummariesDecoded0:[ServiceCatalogClientTypes.ConstraintSummary]? = nil
        if let constraintSummariesContainer = constraintSummariesContainer {
            constraintSummariesDecoded0 = [ServiceCatalogClientTypes.ConstraintSummary]()
            for structure0 in constraintSummariesContainer {
                if let structure0 = structure0 {
                    constraintSummariesDecoded0?.append(structure0)
                }
            }
        }
        constraintSummaries = constraintSummariesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ServiceCatalogClientTypes.LaunchPathSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchPathSummary(constraintSummaries: \(Swift.String(describing: constraintSummaries)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)))"}
}

extension ServiceCatalogClientTypes {
    /// Summary information about a product path for a user.
    public struct LaunchPathSummary: Swift.Equatable {
        /// The constraints on the portfolio-product relationship.
        public var constraintSummaries: [ServiceCatalogClientTypes.ConstraintSummary]?
        /// The identifier of the product path.
        public var id: Swift.String?
        /// The name of the portfolio to which the user was assigned.
        public var name: Swift.String?
        /// The tags associated with this product path.
        public var tags: [ServiceCatalogClientTypes.Tag]?

        public init (
            constraintSummaries: [ServiceCatalogClientTypes.ConstraintSummary]? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [ServiceCatalogClientTypes.Tag]? = nil
        )
        {
            self.constraintSummaries = constraintSummaries
            self.id = id
            self.name = name
            self.tags = tags
        }
    }

}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The current limits of the service would have been exceeded by this operation. Decrease your
///          resource use or increase your service limits and retry the operation.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListAcceptedPortfolioSharesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAcceptedPortfolioSharesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAcceptedPortfolioSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAcceptedPortfolioSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAcceptedPortfolioSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAcceptedPortfolioSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAcceptedPortfolioSharesOutputError>
}

extension ListAcceptedPortfolioSharesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAcceptedPortfolioSharesInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)), portfolioShareType: \(Swift.String(describing: portfolioShareType)))"}
}

extension ListAcceptedPortfolioSharesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioShareType = "PortfolioShareType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let portfolioShareType = portfolioShareType {
            try encodeContainer.encode(portfolioShareType.rawValue, forKey: .portfolioShareType)
        }
    }
}

public struct ListAcceptedPortfolioSharesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAcceptedPortfolioSharesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAcceptedPortfolioSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAcceptedPortfolioSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAcceptedPortfolioSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAcceptedPortfolioSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAcceptedPortfolioSharesOutputError>
}

public struct ListAcceptedPortfolioSharesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAcceptedPortfolioSharesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAcceptedPortfolioSharesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAcceptedPortfolioSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAcceptedPortfolioSharesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAcceptedPortfolioSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAcceptedPortfolioSharesOutputError>
}

public struct ListAcceptedPortfolioSharesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAcceptedPortfolioSharesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListAcceptedPortfolioSharesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAcceptedPortfolioSharesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAcceptedPortfolioSharesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAcceptedPortfolioSharesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAcceptedPortfolioSharesOutputError>
}

public struct ListAcceptedPortfolioSharesInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The type of shared portfolios to list. The default is to list imported portfolios.
    ///
    ///
    ///
    ///                   AWS_ORGANIZATIONS - List portfolios shared by the management
    ///                account of your organization
    ///
    ///
    ///
    ///                   AWS_SERVICECATALOG - List default portfolios
    ///
    ///
    ///
    ///                   IMPORTED - List imported portfolios
    ///
    ///
    public var portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType?

    public init (
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil,
        portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioShareType = portfolioShareType
    }
}

struct ListAcceptedPortfolioSharesInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let pageToken: Swift.String?
    public let pageSize: Swift.Int
    public let portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType?
}

extension ListAcceptedPortfolioSharesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioShareType = "PortfolioShareType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let portfolioShareTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.PortfolioShareType.self, forKey: .portfolioShareType)
        portfolioShareType = portfolioShareTypeDecoded
    }
}

extension ListAcceptedPortfolioSharesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAcceptedPortfolioSharesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAcceptedPortfolioSharesOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case operationNotSupportedException(OperationNotSupportedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAcceptedPortfolioSharesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAcceptedPortfolioSharesOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), portfolioDetails: \(Swift.String(describing: portfolioDetails)))"}
}

extension ListAcceptedPortfolioSharesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAcceptedPortfolioSharesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.portfolioDetails = output.portfolioDetails
        } else {
            self.nextPageToken = nil
            self.portfolioDetails = nil
        }
    }
}

public struct ListAcceptedPortfolioSharesOutputResponse: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the portfolios.
    public var portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]?

    public init (
        nextPageToken: Swift.String? = nil,
        portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.portfolioDetails = portfolioDetails
    }
}

struct ListAcceptedPortfolioSharesOutputResponseBody: Swift.Equatable {
    public let portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]?
    public let nextPageToken: Swift.String?
}

extension ListAcceptedPortfolioSharesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case portfolioDetails = "PortfolioDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioDetailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.PortfolioDetail?].self, forKey: .portfolioDetails)
        var portfolioDetailsDecoded0:[ServiceCatalogClientTypes.PortfolioDetail]? = nil
        if let portfolioDetailsContainer = portfolioDetailsContainer {
            portfolioDetailsDecoded0 = [ServiceCatalogClientTypes.PortfolioDetail]()
            for structure0 in portfolioDetailsContainer {
                if let structure0 = structure0 {
                    portfolioDetailsDecoded0?.append(structure0)
                }
            }
        }
        portfolioDetails = portfolioDetailsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListBudgetsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBudgetsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBudgetsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBudgetsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBudgetsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBudgetsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBudgetsForResourceOutputError>
}

extension ListBudgetsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBudgetsForResourceInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)), resourceId: \(Swift.String(describing: resourceId)))"}
}

extension ListBudgetsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let resourceId = resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

public struct ListBudgetsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBudgetsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBudgetsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBudgetsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBudgetsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBudgetsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBudgetsForResourceOutputError>
}

public struct ListBudgetsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBudgetsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListBudgetsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBudgetsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListBudgetsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListBudgetsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBudgetsForResourceOutputError>
}

public struct ListBudgetsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListBudgetsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListBudgetsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListBudgetsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListBudgetsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListBudgetsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListBudgetsForResourceOutputError>
}

public struct ListBudgetsForResourceInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The resource identifier.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.resourceId = resourceId
    }
}

struct ListBudgetsForResourceInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let resourceId: Swift.String?
    public let pageSize: Swift.Int
    public let pageToken: Swift.String?
}

extension ListBudgetsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case resourceId = "ResourceId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ListBudgetsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBudgetsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBudgetsForResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBudgetsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListBudgetsForResourceOutputResponse(budgets: \(Swift.String(describing: budgets)), nextPageToken: \(Swift.String(describing: nextPageToken)))"}
}

extension ListBudgetsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBudgetsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.budgets = output.budgets
            self.nextPageToken = output.nextPageToken
        } else {
            self.budgets = nil
            self.nextPageToken = nil
        }
    }
}

public struct ListBudgetsForResourceOutputResponse: Swift.Equatable {
    /// Information about the associated budgets.
    public var budgets: [ServiceCatalogClientTypes.BudgetDetail]?
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?

    public init (
        budgets: [ServiceCatalogClientTypes.BudgetDetail]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.budgets = budgets
        self.nextPageToken = nextPageToken
    }
}

struct ListBudgetsForResourceOutputResponseBody: Swift.Equatable {
    public let budgets: [ServiceCatalogClientTypes.BudgetDetail]?
    public let nextPageToken: Swift.String?
}

extension ListBudgetsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgets = "Budgets"
        case nextPageToken = "NextPageToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.BudgetDetail?].self, forKey: .budgets)
        var budgetsDecoded0:[ServiceCatalogClientTypes.BudgetDetail]? = nil
        if let budgetsContainer = budgetsContainer {
            budgetsDecoded0 = [ServiceCatalogClientTypes.BudgetDetail]()
            for structure0 in budgetsContainer {
                if let structure0 = structure0 {
                    budgetsDecoded0?.append(structure0)
                }
            }
        }
        budgets = budgetsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListConstraintsForPortfolioInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConstraintsForPortfolioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConstraintsForPortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConstraintsForPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConstraintsForPortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConstraintsForPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConstraintsForPortfolioOutputError>
}

extension ListConstraintsForPortfolioInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConstraintsForPortfolioInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)), portfolioId: \(Swift.String(describing: portfolioId)), productId: \(Swift.String(describing: productId)))"}
}

extension ListConstraintsForPortfolioInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
    }
}

public struct ListConstraintsForPortfolioInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConstraintsForPortfolioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConstraintsForPortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConstraintsForPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConstraintsForPortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConstraintsForPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConstraintsForPortfolioOutputError>
}

public struct ListConstraintsForPortfolioInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConstraintsForPortfolioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListConstraintsForPortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConstraintsForPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListConstraintsForPortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListConstraintsForPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConstraintsForPortfolioOutputError>
}

public struct ListConstraintsForPortfolioInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListConstraintsForPortfolioInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListConstraintsForPortfolioInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListConstraintsForPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListConstraintsForPortfolioInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListConstraintsForPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListConstraintsForPortfolioOutputError>
}

public struct ListConstraintsForPortfolioInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The product identifier.
    public var productId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        productId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
        self.productId = productId
    }
}

struct ListConstraintsForPortfolioInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let portfolioId: Swift.String?
    public let productId: Swift.String?
    public let pageSize: Swift.Int
    public let pageToken: Swift.String?
}

extension ListConstraintsForPortfolioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
        case productId = "ProductId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ListConstraintsForPortfolioOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConstraintsForPortfolioOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConstraintsForPortfolioOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConstraintsForPortfolioOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListConstraintsForPortfolioOutputResponse(constraintDetails: \(Swift.String(describing: constraintDetails)), nextPageToken: \(Swift.String(describing: nextPageToken)))"}
}

extension ListConstraintsForPortfolioOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConstraintsForPortfolioOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.constraintDetails = output.constraintDetails
            self.nextPageToken = output.nextPageToken
        } else {
            self.constraintDetails = nil
            self.nextPageToken = nil
        }
    }
}

public struct ListConstraintsForPortfolioOutputResponse: Swift.Equatable {
    /// Information about the constraints.
    public var constraintDetails: [ServiceCatalogClientTypes.ConstraintDetail]?
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?

    public init (
        constraintDetails: [ServiceCatalogClientTypes.ConstraintDetail]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.constraintDetails = constraintDetails
        self.nextPageToken = nextPageToken
    }
}

struct ListConstraintsForPortfolioOutputResponseBody: Swift.Equatable {
    public let constraintDetails: [ServiceCatalogClientTypes.ConstraintDetail]?
    public let nextPageToken: Swift.String?
}

extension ListConstraintsForPortfolioOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constraintDetails = "ConstraintDetails"
        case nextPageToken = "NextPageToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constraintDetailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ConstraintDetail?].self, forKey: .constraintDetails)
        var constraintDetailsDecoded0:[ServiceCatalogClientTypes.ConstraintDetail]? = nil
        if let constraintDetailsContainer = constraintDetailsContainer {
            constraintDetailsDecoded0 = [ServiceCatalogClientTypes.ConstraintDetail]()
            for structure0 in constraintDetailsContainer {
                if let structure0 = structure0 {
                    constraintDetailsDecoded0?.append(structure0)
                }
            }
        }
        constraintDetails = constraintDetailsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListLaunchPathsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLaunchPathsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLaunchPathsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLaunchPathsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLaunchPathsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLaunchPathsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLaunchPathsOutputError>
}

extension ListLaunchPathsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLaunchPathsInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)), productId: \(Swift.String(describing: productId)))"}
}

extension ListLaunchPathsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case productId = "ProductId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
    }
}

public struct ListLaunchPathsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLaunchPathsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLaunchPathsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLaunchPathsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLaunchPathsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLaunchPathsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLaunchPathsOutputError>
}

public struct ListLaunchPathsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLaunchPathsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListLaunchPathsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLaunchPathsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListLaunchPathsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListLaunchPathsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLaunchPathsOutputError>
}

public struct ListLaunchPathsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListLaunchPathsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListLaunchPathsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListLaunchPathsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListLaunchPathsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListLaunchPathsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListLaunchPathsOutputError>
}

public struct ListLaunchPathsInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil,
        productId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.productId = productId
    }
}

struct ListLaunchPathsInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let productId: Swift.String?
    public let pageSize: Swift.Int
    public let pageToken: Swift.String?
}

extension ListLaunchPathsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case productId = "ProductId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ListLaunchPathsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLaunchPathsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLaunchPathsOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLaunchPathsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListLaunchPathsOutputResponse(launchPathSummaries: \(Swift.String(describing: launchPathSummaries)), nextPageToken: \(Swift.String(describing: nextPageToken)))"}
}

extension ListLaunchPathsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLaunchPathsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.launchPathSummaries = output.launchPathSummaries
            self.nextPageToken = output.nextPageToken
        } else {
            self.launchPathSummaries = nil
            self.nextPageToken = nil
        }
    }
}

public struct ListLaunchPathsOutputResponse: Swift.Equatable {
    /// Information about the launch path.
    public var launchPathSummaries: [ServiceCatalogClientTypes.LaunchPathSummary]?
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?

    public init (
        launchPathSummaries: [ServiceCatalogClientTypes.LaunchPathSummary]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.launchPathSummaries = launchPathSummaries
        self.nextPageToken = nextPageToken
    }
}

struct ListLaunchPathsOutputResponseBody: Swift.Equatable {
    public let launchPathSummaries: [ServiceCatalogClientTypes.LaunchPathSummary]?
    public let nextPageToken: Swift.String?
}

extension ListLaunchPathsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchPathSummaries = "LaunchPathSummaries"
        case nextPageToken = "NextPageToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchPathSummariesContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.LaunchPathSummary?].self, forKey: .launchPathSummaries)
        var launchPathSummariesDecoded0:[ServiceCatalogClientTypes.LaunchPathSummary]? = nil
        if let launchPathSummariesContainer = launchPathSummariesContainer {
            launchPathSummariesDecoded0 = [ServiceCatalogClientTypes.LaunchPathSummary]()
            for structure0 in launchPathSummariesContainer {
                if let structure0 = structure0 {
                    launchPathSummariesDecoded0?.append(structure0)
                }
            }
        }
        launchPathSummaries = launchPathSummariesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListOrganizationPortfolioAccessInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOrganizationPortfolioAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOrganizationPortfolioAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOrganizationPortfolioAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOrganizationPortfolioAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOrganizationPortfolioAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOrganizationPortfolioAccessOutputError>
}

extension ListOrganizationPortfolioAccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOrganizationPortfolioAccessInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), organizationNodeType: \(Swift.String(describing: organizationNodeType)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)), portfolioId: \(Swift.String(describing: portfolioId)))"}
}

extension ListOrganizationPortfolioAccessInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case organizationNodeType = "OrganizationNodeType"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let organizationNodeType = organizationNodeType {
            try encodeContainer.encode(organizationNodeType.rawValue, forKey: .organizationNodeType)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
    }
}

public struct ListOrganizationPortfolioAccessInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOrganizationPortfolioAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOrganizationPortfolioAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOrganizationPortfolioAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOrganizationPortfolioAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOrganizationPortfolioAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOrganizationPortfolioAccessOutputError>
}

public struct ListOrganizationPortfolioAccessInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOrganizationPortfolioAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListOrganizationPortfolioAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOrganizationPortfolioAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListOrganizationPortfolioAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListOrganizationPortfolioAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOrganizationPortfolioAccessOutputError>
}

public struct ListOrganizationPortfolioAccessInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListOrganizationPortfolioAccessInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListOrganizationPortfolioAccessInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListOrganizationPortfolioAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListOrganizationPortfolioAccessInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListOrganizationPortfolioAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListOrganizationPortfolioAccessOutputError>
}

public struct ListOrganizationPortfolioAccessInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The organization node type that will be returned in the output.
    ///
    ///
    ///
    ///                   ORGANIZATION - Organization that has access to the portfolio.
    ///
    ///
    ///
    ///                   ORGANIZATIONAL_UNIT - Organizational unit that has access to the portfolio within your organization.
    ///
    ///
    ///
    ///                   ACCOUNT - Account that has access to the portfolio within your organization.
    ///
    ///
    /// This member is required.
    public var organizationNodeType: ServiceCatalogClientTypes.OrganizationNodeType?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The portfolio identifier. For example, port-2abcdext3y5fk.
    /// This member is required.
    public var portfolioId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        organizationNodeType: ServiceCatalogClientTypes.OrganizationNodeType? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil,
        portfolioId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.organizationNodeType = organizationNodeType
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
    }
}

struct ListOrganizationPortfolioAccessInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let portfolioId: Swift.String?
    public let organizationNodeType: ServiceCatalogClientTypes.OrganizationNodeType?
    public let pageToken: Swift.String?
    public let pageSize: Swift.Int
}

extension ListOrganizationPortfolioAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case organizationNodeType = "OrganizationNodeType"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let organizationNodeTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.OrganizationNodeType.self, forKey: .organizationNodeType)
        organizationNodeType = organizationNodeTypeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension ListOrganizationPortfolioAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOrganizationPortfolioAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListOrganizationPortfolioAccessOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOrganizationPortfolioAccessOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListOrganizationPortfolioAccessOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), organizationNodes: \(Swift.String(describing: organizationNodes)))"}
}

extension ListOrganizationPortfolioAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListOrganizationPortfolioAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.organizationNodes = output.organizationNodes
        } else {
            self.nextPageToken = nil
            self.organizationNodes = nil
        }
    }
}

public struct ListOrganizationPortfolioAccessOutputResponse: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Displays information about the organization nodes.
    public var organizationNodes: [ServiceCatalogClientTypes.OrganizationNode]?

    public init (
        nextPageToken: Swift.String? = nil,
        organizationNodes: [ServiceCatalogClientTypes.OrganizationNode]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.organizationNodes = organizationNodes
    }
}

struct ListOrganizationPortfolioAccessOutputResponseBody: Swift.Equatable {
    public let organizationNodes: [ServiceCatalogClientTypes.OrganizationNode]?
    public let nextPageToken: Swift.String?
}

extension ListOrganizationPortfolioAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case organizationNodes = "OrganizationNodes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationNodesContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.OrganizationNode?].self, forKey: .organizationNodes)
        var organizationNodesDecoded0:[ServiceCatalogClientTypes.OrganizationNode]? = nil
        if let organizationNodesContainer = organizationNodesContainer {
            organizationNodesDecoded0 = [ServiceCatalogClientTypes.OrganizationNode]()
            for structure0 in organizationNodesContainer {
                if let structure0 = structure0 {
                    organizationNodesDecoded0?.append(structure0)
                }
            }
        }
        organizationNodes = organizationNodesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListPortfolioAccessInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPortfolioAccessInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPortfolioAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPortfolioAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPortfolioAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPortfolioAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPortfolioAccessOutputError>
}

extension ListPortfolioAccessInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPortfolioAccessInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), organizationParentId: \(Swift.String(describing: organizationParentId)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)), portfolioId: \(Swift.String(describing: portfolioId)))"}
}

extension ListPortfolioAccessInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case organizationParentId = "OrganizationParentId"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let organizationParentId = organizationParentId {
            try encodeContainer.encode(organizationParentId, forKey: .organizationParentId)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
    }
}

public struct ListPortfolioAccessInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPortfolioAccessInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPortfolioAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPortfolioAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPortfolioAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPortfolioAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPortfolioAccessOutputError>
}

public struct ListPortfolioAccessInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPortfolioAccessInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPortfolioAccessInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPortfolioAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPortfolioAccessInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPortfolioAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPortfolioAccessOutputError>
}

public struct ListPortfolioAccessInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPortfolioAccessInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListPortfolioAccessInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPortfolioAccessOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPortfolioAccessInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPortfolioAccessOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPortfolioAccessOutputError>
}

public struct ListPortfolioAccessInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The ID of an organization node the portfolio is shared with. All children of this node with an inherited portfolio share will be returned.
    public var organizationParentId: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        organizationParentId: Swift.String? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil,
        portfolioId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.organizationParentId = organizationParentId
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
    }
}

struct ListPortfolioAccessInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let portfolioId: Swift.String?
    public let organizationParentId: Swift.String?
    public let pageToken: Swift.String?
    public let pageSize: Swift.Int
}

extension ListPortfolioAccessInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case organizationParentId = "OrganizationParentId"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let organizationParentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationParentId)
        organizationParentId = organizationParentIdDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension ListPortfolioAccessOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPortfolioAccessOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPortfolioAccessOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPortfolioAccessOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPortfolioAccessOutputResponse(accountIds: \(Swift.String(describing: accountIds)), nextPageToken: \(Swift.String(describing: nextPageToken)))"}
}

extension ListPortfolioAccessOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPortfolioAccessOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountIds = output.accountIds
            self.nextPageToken = output.nextPageToken
        } else {
            self.accountIds = nil
            self.nextPageToken = nil
        }
    }
}

public struct ListPortfolioAccessOutputResponse: Swift.Equatable {
    /// Information about the AWS accounts with access to the portfolio.
    public var accountIds: [Swift.String]?
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        nextPageToken: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.nextPageToken = nextPageToken
    }
}

struct ListPortfolioAccessOutputResponseBody: Swift.Equatable {
    public let accountIds: [Swift.String]?
    public let nextPageToken: Swift.String?
}

extension ListPortfolioAccessOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case nextPageToken = "NextPageToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListPortfoliosForProductInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPortfoliosForProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPortfoliosForProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPortfoliosForProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPortfoliosForProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPortfoliosForProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPortfoliosForProductOutputError>
}

extension ListPortfoliosForProductInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPortfoliosForProductInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)), productId: \(Swift.String(describing: productId)))"}
}

extension ListPortfoliosForProductInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case productId = "ProductId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
    }
}

public struct ListPortfoliosForProductInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPortfoliosForProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPortfoliosForProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPortfoliosForProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPortfoliosForProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPortfoliosForProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPortfoliosForProductOutputError>
}

public struct ListPortfoliosForProductInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPortfoliosForProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPortfoliosForProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPortfoliosForProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPortfoliosForProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPortfoliosForProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPortfoliosForProductOutputError>
}

public struct ListPortfoliosForProductInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPortfoliosForProductInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListPortfoliosForProductInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPortfoliosForProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPortfoliosForProductInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPortfoliosForProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPortfoliosForProductOutputError>
}

public struct ListPortfoliosForProductInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil,
        productId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.productId = productId
    }
}

struct ListPortfoliosForProductInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let productId: Swift.String?
    public let pageToken: Swift.String?
    public let pageSize: Swift.Int
}

extension ListPortfoliosForProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case productId = "ProductId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension ListPortfoliosForProductOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPortfoliosForProductOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPortfoliosForProductOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPortfoliosForProductOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPortfoliosForProductOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), portfolioDetails: \(Swift.String(describing: portfolioDetails)))"}
}

extension ListPortfoliosForProductOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPortfoliosForProductOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.portfolioDetails = output.portfolioDetails
        } else {
            self.nextPageToken = nil
            self.portfolioDetails = nil
        }
    }
}

public struct ListPortfoliosForProductOutputResponse: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the portfolios.
    public var portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]?

    public init (
        nextPageToken: Swift.String? = nil,
        portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.portfolioDetails = portfolioDetails
    }
}

struct ListPortfoliosForProductOutputResponseBody: Swift.Equatable {
    public let portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]?
    public let nextPageToken: Swift.String?
}

extension ListPortfoliosForProductOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case portfolioDetails = "PortfolioDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioDetailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.PortfolioDetail?].self, forKey: .portfolioDetails)
        var portfolioDetailsDecoded0:[ServiceCatalogClientTypes.PortfolioDetail]? = nil
        if let portfolioDetailsContainer = portfolioDetailsContainer {
            portfolioDetailsDecoded0 = [ServiceCatalogClientTypes.PortfolioDetail]()
            for structure0 in portfolioDetailsContainer {
                if let structure0 = structure0 {
                    portfolioDetailsDecoded0?.append(structure0)
                }
            }
        }
        portfolioDetails = portfolioDetailsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListPortfoliosInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPortfoliosInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPortfoliosInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPortfoliosOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPortfoliosInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPortfoliosOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPortfoliosOutputError>
}

extension ListPortfoliosInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPortfoliosInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)))"}
}

extension ListPortfoliosInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
    }
}

public struct ListPortfoliosInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPortfoliosInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPortfoliosInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPortfoliosOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPortfoliosInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPortfoliosOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPortfoliosOutputError>
}

public struct ListPortfoliosInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPortfoliosInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPortfoliosInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPortfoliosOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPortfoliosInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPortfoliosOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPortfoliosOutputError>
}

public struct ListPortfoliosInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPortfoliosInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListPortfoliosInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPortfoliosOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPortfoliosInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPortfoliosOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPortfoliosOutputError>
}

public struct ListPortfoliosInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
    }
}

struct ListPortfoliosInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let pageToken: Swift.String?
    public let pageSize: Swift.Int
}

extension ListPortfoliosInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension ListPortfoliosOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPortfoliosOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPortfoliosOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPortfoliosOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPortfoliosOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), portfolioDetails: \(Swift.String(describing: portfolioDetails)))"}
}

extension ListPortfoliosOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPortfoliosOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.portfolioDetails = output.portfolioDetails
        } else {
            self.nextPageToken = nil
            self.portfolioDetails = nil
        }
    }
}

public struct ListPortfoliosOutputResponse: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the portfolios.
    public var portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]?

    public init (
        nextPageToken: Swift.String? = nil,
        portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.portfolioDetails = portfolioDetails
    }
}

struct ListPortfoliosOutputResponseBody: Swift.Equatable {
    public let portfolioDetails: [ServiceCatalogClientTypes.PortfolioDetail]?
    public let nextPageToken: Swift.String?
}

extension ListPortfoliosOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case portfolioDetails = "PortfolioDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioDetailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.PortfolioDetail?].self, forKey: .portfolioDetails)
        var portfolioDetailsDecoded0:[ServiceCatalogClientTypes.PortfolioDetail]? = nil
        if let portfolioDetailsContainer = portfolioDetailsContainer {
            portfolioDetailsDecoded0 = [ServiceCatalogClientTypes.PortfolioDetail]()
            for structure0 in portfolioDetailsContainer {
                if let structure0 = structure0 {
                    portfolioDetailsDecoded0?.append(structure0)
                }
            }
        }
        portfolioDetails = portfolioDetailsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListPrincipalsForPortfolioInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPrincipalsForPortfolioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPrincipalsForPortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPrincipalsForPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPrincipalsForPortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPrincipalsForPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPrincipalsForPortfolioOutputError>
}

extension ListPrincipalsForPortfolioInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPrincipalsForPortfolioInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)), portfolioId: \(Swift.String(describing: portfolioId)))"}
}

extension ListPrincipalsForPortfolioInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
    }
}

public struct ListPrincipalsForPortfolioInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPrincipalsForPortfolioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPrincipalsForPortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPrincipalsForPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPrincipalsForPortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPrincipalsForPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPrincipalsForPortfolioOutputError>
}

public struct ListPrincipalsForPortfolioInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPrincipalsForPortfolioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPrincipalsForPortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPrincipalsForPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPrincipalsForPortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPrincipalsForPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPrincipalsForPortfolioOutputError>
}

public struct ListPrincipalsForPortfolioInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPrincipalsForPortfolioInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListPrincipalsForPortfolioInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPrincipalsForPortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPrincipalsForPortfolioInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPrincipalsForPortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPrincipalsForPortfolioOutputError>
}

public struct ListPrincipalsForPortfolioInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil,
        portfolioId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
    }
}

struct ListPrincipalsForPortfolioInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let portfolioId: Swift.String?
    public let pageSize: Swift.Int
    public let pageToken: Swift.String?
}

extension ListPrincipalsForPortfolioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ListPrincipalsForPortfolioOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPrincipalsForPortfolioOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPrincipalsForPortfolioOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPrincipalsForPortfolioOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPrincipalsForPortfolioOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), principals: \(Swift.String(describing: principals)))"}
}

extension ListPrincipalsForPortfolioOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPrincipalsForPortfolioOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.principals = output.principals
        } else {
            self.nextPageToken = nil
            self.principals = nil
        }
    }
}

public struct ListPrincipalsForPortfolioOutputResponse: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// The IAM principals (users or roles) associated with the portfolio.
    public var principals: [ServiceCatalogClientTypes.Principal]?

    public init (
        nextPageToken: Swift.String? = nil,
        principals: [ServiceCatalogClientTypes.Principal]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.principals = principals
    }
}

struct ListPrincipalsForPortfolioOutputResponseBody: Swift.Equatable {
    public let principals: [ServiceCatalogClientTypes.Principal]?
    public let nextPageToken: Swift.String?
}

extension ListPrincipalsForPortfolioOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case principals = "Principals"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Principal?].self, forKey: .principals)
        var principalsDecoded0:[ServiceCatalogClientTypes.Principal]? = nil
        if let principalsContainer = principalsContainer {
            principalsDecoded0 = [ServiceCatalogClientTypes.Principal]()
            for structure0 in principalsContainer {
                if let structure0 = structure0 {
                    principalsDecoded0?.append(structure0)
                }
            }
        }
        principals = principalsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListProvisionedProductPlansInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProvisionedProductPlansInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProvisionedProductPlansInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProvisionedProductPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProvisionedProductPlansInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProvisionedProductPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProvisionedProductPlansOutputError>
}

extension ListProvisionedProductPlansInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProvisionedProductPlansInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), accessLevelFilter: \(Swift.String(describing: accessLevelFilter)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)), provisionProductId: \(Swift.String(describing: provisionProductId)))"}
}

extension ListProvisionedProductPlansInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case provisionProductId = "ProvisionProductId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let accessLevelFilter = accessLevelFilter {
            try encodeContainer.encode(accessLevelFilter, forKey: .accessLevelFilter)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let provisionProductId = provisionProductId {
            try encodeContainer.encode(provisionProductId, forKey: .provisionProductId)
        }
    }
}

public struct ListProvisionedProductPlansInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProvisionedProductPlansInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProvisionedProductPlansInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProvisionedProductPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProvisionedProductPlansInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProvisionedProductPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProvisionedProductPlansOutputError>
}

public struct ListProvisionedProductPlansInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProvisionedProductPlansInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProvisionedProductPlansInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProvisionedProductPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProvisionedProductPlansInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProvisionedProductPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProvisionedProductPlansOutputError>
}

public struct ListProvisionedProductPlansInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProvisionedProductPlansInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListProvisionedProductPlansInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProvisionedProductPlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListProvisionedProductPlansInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListProvisionedProductPlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProvisionedProductPlansOutputError>
}

public struct ListProvisionedProductPlansInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The access level to use to obtain results. The default is User.
    public var accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The product identifier.
    public var provisionProductId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil,
        provisionProductId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accessLevelFilter = accessLevelFilter
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.provisionProductId = provisionProductId
    }
}

struct ListProvisionedProductPlansInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let provisionProductId: Swift.String?
    public let pageSize: Swift.Int
    public let pageToken: Swift.String?
    public let accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter?
}

extension ListProvisionedProductPlansInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case provisionProductId = "ProvisionProductId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let provisionProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionProductId)
        provisionProductId = provisionProductIdDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let accessLevelFilterDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.AccessLevelFilter.self, forKey: .accessLevelFilter)
        accessLevelFilter = accessLevelFilterDecoded
    }
}

extension ListProvisionedProductPlansOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProvisionedProductPlansOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProvisionedProductPlansOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProvisionedProductPlansOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProvisionedProductPlansOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), provisionedProductPlans: \(Swift.String(describing: provisionedProductPlans)))"}
}

extension ListProvisionedProductPlansOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProvisionedProductPlansOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.provisionedProductPlans = output.provisionedProductPlans
        } else {
            self.nextPageToken = nil
            self.provisionedProductPlans = nil
        }
    }
}

public struct ListProvisionedProductPlansOutputResponse: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the plans.
    public var provisionedProductPlans: [ServiceCatalogClientTypes.ProvisionedProductPlanSummary]?

    public init (
        nextPageToken: Swift.String? = nil,
        provisionedProductPlans: [ServiceCatalogClientTypes.ProvisionedProductPlanSummary]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.provisionedProductPlans = provisionedProductPlans
    }
}

struct ListProvisionedProductPlansOutputResponseBody: Swift.Equatable {
    public let provisionedProductPlans: [ServiceCatalogClientTypes.ProvisionedProductPlanSummary]?
    public let nextPageToken: Swift.String?
}

extension ListProvisionedProductPlansOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case provisionedProductPlans = "ProvisionedProductPlans"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductPlansContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisionedProductPlanSummary?].self, forKey: .provisionedProductPlans)
        var provisionedProductPlansDecoded0:[ServiceCatalogClientTypes.ProvisionedProductPlanSummary]? = nil
        if let provisionedProductPlansContainer = provisionedProductPlansContainer {
            provisionedProductPlansDecoded0 = [ServiceCatalogClientTypes.ProvisionedProductPlanSummary]()
            for structure0 in provisionedProductPlansContainer {
                if let structure0 = structure0 {
                    provisionedProductPlansDecoded0?.append(structure0)
                }
            }
        }
        provisionedProductPlans = provisionedProductPlansDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListProvisioningArtifactsForServiceActionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProvisioningArtifactsForServiceActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProvisioningArtifactsForServiceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProvisioningArtifactsForServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProvisioningArtifactsForServiceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProvisioningArtifactsForServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProvisioningArtifactsForServiceActionOutputError>
}

extension ListProvisioningArtifactsForServiceActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProvisioningArtifactsForServiceActionInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)), serviceActionId: \(Swift.String(describing: serviceActionId)))"}
}

extension ListProvisioningArtifactsForServiceActionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case serviceActionId = "ServiceActionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let serviceActionId = serviceActionId {
            try encodeContainer.encode(serviceActionId, forKey: .serviceActionId)
        }
    }
}

public struct ListProvisioningArtifactsForServiceActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProvisioningArtifactsForServiceActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProvisioningArtifactsForServiceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProvisioningArtifactsForServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProvisioningArtifactsForServiceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProvisioningArtifactsForServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProvisioningArtifactsForServiceActionOutputError>
}

public struct ListProvisioningArtifactsForServiceActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProvisioningArtifactsForServiceActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProvisioningArtifactsForServiceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProvisioningArtifactsForServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProvisioningArtifactsForServiceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProvisioningArtifactsForServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProvisioningArtifactsForServiceActionOutputError>
}

public struct ListProvisioningArtifactsForServiceActionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProvisioningArtifactsForServiceActionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListProvisioningArtifactsForServiceActionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProvisioningArtifactsForServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListProvisioningArtifactsForServiceActionInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListProvisioningArtifactsForServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProvisioningArtifactsForServiceActionOutputError>
}

public struct ListProvisioningArtifactsForServiceActionInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The self-service action identifier. For example, act-fs7abcd89wxyz.
    /// This member is required.
    public var serviceActionId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil,
        serviceActionId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.serviceActionId = serviceActionId
    }
}

struct ListProvisioningArtifactsForServiceActionInputBody: Swift.Equatable {
    public let serviceActionId: Swift.String?
    public let pageSize: Swift.Int
    public let pageToken: Swift.String?
    public let acceptLanguage: Swift.String?
}

extension ListProvisioningArtifactsForServiceActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case serviceActionId = "ServiceActionId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceActionId)
        serviceActionId = serviceActionIdDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension ListProvisioningArtifactsForServiceActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProvisioningArtifactsForServiceActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProvisioningArtifactsForServiceActionOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProvisioningArtifactsForServiceActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProvisioningArtifactsForServiceActionOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), provisioningArtifactViews: \(Swift.String(describing: provisioningArtifactViews)))"}
}

extension ListProvisioningArtifactsForServiceActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProvisioningArtifactsForServiceActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.provisioningArtifactViews = output.provisioningArtifactViews
        } else {
            self.nextPageToken = nil
            self.provisioningArtifactViews = nil
        }
    }
}

public struct ListProvisioningArtifactsForServiceActionOutputResponse: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// An array of objects with information about product views and provisioning artifacts.
    public var provisioningArtifactViews: [ServiceCatalogClientTypes.ProvisioningArtifactView]?

    public init (
        nextPageToken: Swift.String? = nil,
        provisioningArtifactViews: [ServiceCatalogClientTypes.ProvisioningArtifactView]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.provisioningArtifactViews = provisioningArtifactViews
    }
}

struct ListProvisioningArtifactsForServiceActionOutputResponseBody: Swift.Equatable {
    public let provisioningArtifactViews: [ServiceCatalogClientTypes.ProvisioningArtifactView]?
    public let nextPageToken: Swift.String?
}

extension ListProvisioningArtifactsForServiceActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case provisioningArtifactViews = "ProvisioningArtifactViews"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisioningArtifactViewsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisioningArtifactView?].self, forKey: .provisioningArtifactViews)
        var provisioningArtifactViewsDecoded0:[ServiceCatalogClientTypes.ProvisioningArtifactView]? = nil
        if let provisioningArtifactViewsContainer = provisioningArtifactViewsContainer {
            provisioningArtifactViewsDecoded0 = [ServiceCatalogClientTypes.ProvisioningArtifactView]()
            for structure0 in provisioningArtifactViewsContainer {
                if let structure0 = structure0 {
                    provisioningArtifactViewsDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifactViews = provisioningArtifactViewsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListProvisioningArtifactsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProvisioningArtifactsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProvisioningArtifactsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProvisioningArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProvisioningArtifactsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProvisioningArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProvisioningArtifactsOutputError>
}

extension ListProvisioningArtifactsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProvisioningArtifactsInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), productId: \(Swift.String(describing: productId)))"}
}

extension ListProvisioningArtifactsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
    }
}

public struct ListProvisioningArtifactsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProvisioningArtifactsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProvisioningArtifactsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProvisioningArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProvisioningArtifactsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProvisioningArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProvisioningArtifactsOutputError>
}

public struct ListProvisioningArtifactsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProvisioningArtifactsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProvisioningArtifactsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProvisioningArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProvisioningArtifactsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProvisioningArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProvisioningArtifactsOutputError>
}

public struct ListProvisioningArtifactsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProvisioningArtifactsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListProvisioningArtifactsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProvisioningArtifactsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListProvisioningArtifactsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListProvisioningArtifactsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProvisioningArtifactsOutputError>
}

public struct ListProvisioningArtifactsInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        productId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.productId = productId
    }
}

struct ListProvisioningArtifactsInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let productId: Swift.String?
}

extension ListProvisioningArtifactsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case productId = "ProductId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
    }
}

extension ListProvisioningArtifactsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProvisioningArtifactsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProvisioningArtifactsOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProvisioningArtifactsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProvisioningArtifactsOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), provisioningArtifactDetails: \(Swift.String(describing: provisioningArtifactDetails)))"}
}

extension ListProvisioningArtifactsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProvisioningArtifactsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.provisioningArtifactDetails = output.provisioningArtifactDetails
        } else {
            self.nextPageToken = nil
            self.provisioningArtifactDetails = nil
        }
    }
}

public struct ListProvisioningArtifactsOutputResponse: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the provisioning artifacts.
    public var provisioningArtifactDetails: [ServiceCatalogClientTypes.ProvisioningArtifactDetail]?

    public init (
        nextPageToken: Swift.String? = nil,
        provisioningArtifactDetails: [ServiceCatalogClientTypes.ProvisioningArtifactDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.provisioningArtifactDetails = provisioningArtifactDetails
    }
}

struct ListProvisioningArtifactsOutputResponseBody: Swift.Equatable {
    public let provisioningArtifactDetails: [ServiceCatalogClientTypes.ProvisioningArtifactDetail]?
    public let nextPageToken: Swift.String?
}

extension ListProvisioningArtifactsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case provisioningArtifactDetails = "ProvisioningArtifactDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisioningArtifactDetailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisioningArtifactDetail?].self, forKey: .provisioningArtifactDetails)
        var provisioningArtifactDetailsDecoded0:[ServiceCatalogClientTypes.ProvisioningArtifactDetail]? = nil
        if let provisioningArtifactDetailsContainer = provisioningArtifactDetailsContainer {
            provisioningArtifactDetailsDecoded0 = [ServiceCatalogClientTypes.ProvisioningArtifactDetail]()
            for structure0 in provisioningArtifactDetailsContainer {
                if let structure0 = structure0 {
                    provisioningArtifactDetailsDecoded0?.append(structure0)
                }
            }
        }
        provisioningArtifactDetails = provisioningArtifactDetailsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListRecordHistoryInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecordHistoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecordHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecordHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecordHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecordHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecordHistoryOutputError>
}

extension ListRecordHistoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRecordHistoryInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), accessLevelFilter: \(Swift.String(describing: accessLevelFilter)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)), searchFilter: \(Swift.String(describing: searchFilter)))"}
}

extension ListRecordHistoryInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case searchFilter = "SearchFilter"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let accessLevelFilter = accessLevelFilter {
            try encodeContainer.encode(accessLevelFilter, forKey: .accessLevelFilter)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let searchFilter = searchFilter {
            try encodeContainer.encode(searchFilter, forKey: .searchFilter)
        }
    }
}

public struct ListRecordHistoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecordHistoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecordHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecordHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecordHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecordHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecordHistoryOutputError>
}

public struct ListRecordHistoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecordHistoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListRecordHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecordHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListRecordHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecordHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecordHistoryOutputError>
}

public struct ListRecordHistoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListRecordHistoryInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListRecordHistoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListRecordHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListRecordHistoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListRecordHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListRecordHistoryOutputError>
}

public struct ListRecordHistoryInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The access level to use to obtain results. The default is User.
    public var accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The search filter to scope the results.
    public var searchFilter: ServiceCatalogClientTypes.ListRecordHistorySearchFilter?

    public init (
        acceptLanguage: Swift.String? = nil,
        accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil,
        searchFilter: ServiceCatalogClientTypes.ListRecordHistorySearchFilter? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accessLevelFilter = accessLevelFilter
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.searchFilter = searchFilter
    }
}

struct ListRecordHistoryInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter?
    public let searchFilter: ServiceCatalogClientTypes.ListRecordHistorySearchFilter?
    public let pageSize: Swift.Int
    public let pageToken: Swift.String?
}

extension ListRecordHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case searchFilter = "SearchFilter"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let accessLevelFilterDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.AccessLevelFilter.self, forKey: .accessLevelFilter)
        accessLevelFilter = accessLevelFilterDecoded
        let searchFilterDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ListRecordHistorySearchFilter.self, forKey: .searchFilter)
        searchFilter = searchFilterDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ListRecordHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecordHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRecordHistoryOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecordHistoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRecordHistoryOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), recordDetails: \(Swift.String(describing: recordDetails)))"}
}

extension ListRecordHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListRecordHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.recordDetails = output.recordDetails
        } else {
            self.nextPageToken = nil
            self.recordDetails = nil
        }
    }
}

public struct ListRecordHistoryOutputResponse: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// The records, in reverse chronological order.
    public var recordDetails: [ServiceCatalogClientTypes.RecordDetail]?

    public init (
        nextPageToken: Swift.String? = nil,
        recordDetails: [ServiceCatalogClientTypes.RecordDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.recordDetails = recordDetails
    }
}

struct ListRecordHistoryOutputResponseBody: Swift.Equatable {
    public let recordDetails: [ServiceCatalogClientTypes.RecordDetail]?
    public let nextPageToken: Swift.String?
}

extension ListRecordHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case recordDetails = "RecordDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.RecordDetail?].self, forKey: .recordDetails)
        var recordDetailsDecoded0:[ServiceCatalogClientTypes.RecordDetail]? = nil
        if let recordDetailsContainer = recordDetailsContainer {
            recordDetailsDecoded0 = [ServiceCatalogClientTypes.RecordDetail]()
            for structure0 in recordDetailsContainer {
                if let structure0 = structure0 {
                    recordDetailsDecoded0?.append(structure0)
                }
            }
        }
        recordDetails = recordDetailsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension ServiceCatalogClientTypes.ListRecordHistorySearchFilter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceCatalogClientTypes.ListRecordHistorySearchFilter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRecordHistorySearchFilter(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension ServiceCatalogClientTypes {
    /// The search filter to use when listing history records.
    public struct ListRecordHistorySearchFilter: Swift.Equatable {
        /// The filter key.
        ///
        ///
        ///
        ///                   product - Filter results based on the specified product identifier.
        ///
        ///
        ///
        ///                   provisionedproduct - Filter results based on the provisioned product identifier.
        ///
        ///
        public var key: Swift.String?
        /// The filter value.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ListResourcesForTagOptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourcesForTagOptionInput(pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)), resourceType: \(Swift.String(describing: resourceType)), tagOptionId: \(Swift.String(describing: tagOptionId)))"}
}

extension ListResourcesForTagOptionInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListResourcesForTagOptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourcesForTagOptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourcesForTagOptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourcesForTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourcesForTagOptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourcesForTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourcesForTagOptionOutputError>
}

public struct ListResourcesForTagOptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourcesForTagOptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListResourcesForTagOptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourcesForTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListResourcesForTagOptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourcesForTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourcesForTagOptionOutputError>
}

public struct ListResourcesForTagOptionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListResourcesForTagOptionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListResourcesForTagOptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListResourcesForTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListResourcesForTagOptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListResourcesForTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListResourcesForTagOptionOutputError>
}

public struct ListResourcesForTagOptionInput: Swift.Equatable {
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The resource type.
    ///
    ///
    ///
    ///                   Portfolio
    ///
    ///
    ///
    ///
    ///                   Product
    ///
    ///
    ///
    public var resourceType: Swift.String?
    /// The TagOption identifier.
    /// This member is required.
    public var tagOptionId: Swift.String?

    public init (
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        tagOptionId: Swift.String? = nil
    )
    {
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.resourceType = resourceType
        self.tagOptionId = tagOptionId
    }
}

struct ListResourcesForTagOptionInputBody: Swift.Equatable {
}

extension ListResourcesForTagOptionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListResourcesForTagOptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResourcesForTagOptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResourcesForTagOptionOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResourcesForTagOptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourcesForTagOptionOutputResponse(pageToken: \(Swift.String(describing: pageToken)), resourceDetails: \(Swift.String(describing: resourceDetails)))"}
}

extension ListResourcesForTagOptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListResourcesForTagOptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pageToken = output.pageToken
            self.resourceDetails = output.resourceDetails
        } else {
            self.pageToken = nil
            self.resourceDetails = nil
        }
    }
}

public struct ListResourcesForTagOptionOutputResponse: Swift.Equatable {
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// Information about the resources.
    public var resourceDetails: [ServiceCatalogClientTypes.ResourceDetail]?

    public init (
        pageToken: Swift.String? = nil,
        resourceDetails: [ServiceCatalogClientTypes.ResourceDetail]? = nil
    )
    {
        self.pageToken = pageToken
        self.resourceDetails = resourceDetails
    }
}

struct ListResourcesForTagOptionOutputResponseBody: Swift.Equatable {
    public let resourceDetails: [ServiceCatalogClientTypes.ResourceDetail]?
    public let pageToken: Swift.String?
}

extension ListResourcesForTagOptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pageToken = "PageToken"
        case resourceDetails = "ResourceDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDetailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ResourceDetail?].self, forKey: .resourceDetails)
        var resourceDetailsDecoded0:[ServiceCatalogClientTypes.ResourceDetail]? = nil
        if let resourceDetailsContainer = resourceDetailsContainer {
            resourceDetailsDecoded0 = [ServiceCatalogClientTypes.ResourceDetail]()
            for structure0 in resourceDetailsContainer {
                if let structure0 = structure0 {
                    resourceDetailsDecoded0?.append(structure0)
                }
            }
        }
        resourceDetails = resourceDetailsDecoded0
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

public struct ListServiceActionsForProvisioningArtifactInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceActionsForProvisioningArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceActionsForProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceActionsForProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceActionsForProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceActionsForProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceActionsForProvisioningArtifactOutputError>
}

extension ListServiceActionsForProvisioningArtifactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServiceActionsForProvisioningArtifactInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)), productId: \(Swift.String(describing: productId)), provisioningArtifactId: \(Swift.String(describing: provisioningArtifactId)))"}
}

extension ListServiceActionsForProvisioningArtifactInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
    }
}

public struct ListServiceActionsForProvisioningArtifactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceActionsForProvisioningArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceActionsForProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceActionsForProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceActionsForProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceActionsForProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceActionsForProvisioningArtifactOutputError>
}

public struct ListServiceActionsForProvisioningArtifactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceActionsForProvisioningArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceActionsForProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceActionsForProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceActionsForProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceActionsForProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceActionsForProvisioningArtifactOutputError>
}

public struct ListServiceActionsForProvisioningArtifactInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceActionsForProvisioningArtifactInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListServiceActionsForProvisioningArtifactInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceActionsForProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListServiceActionsForProvisioningArtifactInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceActionsForProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceActionsForProvisioningArtifactOutputError>
}

public struct ListServiceActionsForProvisioningArtifactInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The product identifier. For example, prod-abcdzk7xy33qa.
    /// This member is required.
    public var productId: Swift.String?
    /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
    /// This member is required.
    public var provisioningArtifactId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil,
        productId: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
    }
}

struct ListServiceActionsForProvisioningArtifactInputBody: Swift.Equatable {
    public let productId: Swift.String?
    public let provisioningArtifactId: Swift.String?
    public let pageSize: Swift.Int
    public let pageToken: Swift.String?
    public let acceptLanguage: Swift.String?
}

extension ListServiceActionsForProvisioningArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension ListServiceActionsForProvisioningArtifactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServiceActionsForProvisioningArtifactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServiceActionsForProvisioningArtifactOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceActionsForProvisioningArtifactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServiceActionsForProvisioningArtifactOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), serviceActionSummaries: \(Swift.String(describing: serviceActionSummaries)))"}
}

extension ListServiceActionsForProvisioningArtifactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServiceActionsForProvisioningArtifactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.serviceActionSummaries = output.serviceActionSummaries
        } else {
            self.nextPageToken = nil
            self.serviceActionSummaries = nil
        }
    }
}

public struct ListServiceActionsForProvisioningArtifactOutputResponse: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// An object containing information about the self-service actions associated with the provisioning artifact.
    public var serviceActionSummaries: [ServiceCatalogClientTypes.ServiceActionSummary]?

    public init (
        nextPageToken: Swift.String? = nil,
        serviceActionSummaries: [ServiceCatalogClientTypes.ServiceActionSummary]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.serviceActionSummaries = serviceActionSummaries
    }
}

struct ListServiceActionsForProvisioningArtifactOutputResponseBody: Swift.Equatable {
    public let serviceActionSummaries: [ServiceCatalogClientTypes.ServiceActionSummary]?
    public let nextPageToken: Swift.String?
}

extension ListServiceActionsForProvisioningArtifactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case serviceActionSummaries = "ServiceActionSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionSummariesContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ServiceActionSummary?].self, forKey: .serviceActionSummaries)
        var serviceActionSummariesDecoded0:[ServiceCatalogClientTypes.ServiceActionSummary]? = nil
        if let serviceActionSummariesContainer = serviceActionSummariesContainer {
            serviceActionSummariesDecoded0 = [ServiceCatalogClientTypes.ServiceActionSummary]()
            for structure0 in serviceActionSummariesContainer {
                if let structure0 = structure0 {
                    serviceActionSummariesDecoded0?.append(structure0)
                }
            }
        }
        serviceActionSummaries = serviceActionSummariesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListServiceActionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceActionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceActionsOutputError>
}

extension ListServiceActionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServiceActionsInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)))"}
}

extension ListServiceActionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
    }
}

public struct ListServiceActionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceActionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceActionsOutputError>
}

public struct ListServiceActionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceActionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListServiceActionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListServiceActionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceActionsOutputError>
}

public struct ListServiceActionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListServiceActionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListServiceActionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListServiceActionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListServiceActionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListServiceActionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListServiceActionsOutputError>
}

public struct ListServiceActionsInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
    }
}

struct ListServiceActionsInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let pageSize: Swift.Int
    public let pageToken: Swift.String?
}

extension ListServiceActionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ListServiceActionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServiceActionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServiceActionsOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceActionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListServiceActionsOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), serviceActionSummaries: \(Swift.String(describing: serviceActionSummaries)))"}
}

extension ListServiceActionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListServiceActionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.serviceActionSummaries = output.serviceActionSummaries
        } else {
            self.nextPageToken = nil
            self.serviceActionSummaries = nil
        }
    }
}

public struct ListServiceActionsOutputResponse: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// An object containing information about the service actions associated with the provisioning artifact.
    public var serviceActionSummaries: [ServiceCatalogClientTypes.ServiceActionSummary]?

    public init (
        nextPageToken: Swift.String? = nil,
        serviceActionSummaries: [ServiceCatalogClientTypes.ServiceActionSummary]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.serviceActionSummaries = serviceActionSummaries
    }
}

struct ListServiceActionsOutputResponseBody: Swift.Equatable {
    public let serviceActionSummaries: [ServiceCatalogClientTypes.ServiceActionSummary]?
    public let nextPageToken: Swift.String?
}

extension ListServiceActionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case serviceActionSummaries = "ServiceActionSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionSummariesContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ServiceActionSummary?].self, forKey: .serviceActionSummaries)
        var serviceActionSummariesDecoded0:[ServiceCatalogClientTypes.ServiceActionSummary]? = nil
        if let serviceActionSummariesContainer = serviceActionSummariesContainer {
            serviceActionSummariesDecoded0 = [ServiceCatalogClientTypes.ServiceActionSummary]()
            for structure0 in serviceActionSummariesContainer {
                if let structure0 = structure0 {
                    serviceActionSummariesDecoded0?.append(structure0)
                }
            }
        }
        serviceActionSummaries = serviceActionSummariesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct ListStackInstancesForProvisionedProductInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStackInstancesForProvisionedProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStackInstancesForProvisionedProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStackInstancesForProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStackInstancesForProvisionedProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStackInstancesForProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStackInstancesForProvisionedProductOutputError>
}

extension ListStackInstancesForProvisionedProductInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStackInstancesForProvisionedProductInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)), provisionedProductId: \(Swift.String(describing: provisionedProductId)))"}
}

extension ListStackInstancesForProvisionedProductInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case provisionedProductId = "ProvisionedProductId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let provisionedProductId = provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
    }
}

public struct ListStackInstancesForProvisionedProductInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStackInstancesForProvisionedProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStackInstancesForProvisionedProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStackInstancesForProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStackInstancesForProvisionedProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStackInstancesForProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStackInstancesForProvisionedProductOutputError>
}

public struct ListStackInstancesForProvisionedProductInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStackInstancesForProvisionedProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListStackInstancesForProvisionedProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStackInstancesForProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListStackInstancesForProvisionedProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListStackInstancesForProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStackInstancesForProvisionedProductOutputError>
}

public struct ListStackInstancesForProvisionedProductInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListStackInstancesForProvisionedProductInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListStackInstancesForProvisionedProductInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListStackInstancesForProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListStackInstancesForProvisionedProductInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListStackInstancesForProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListStackInstancesForProvisionedProductOutputError>
}

public struct ListStackInstancesForProvisionedProductInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The identifier of the provisioned product.
    /// This member is required.
    public var provisionedProductId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil,
        provisionedProductId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.provisionedProductId = provisionedProductId
    }
}

struct ListStackInstancesForProvisionedProductInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let provisionedProductId: Swift.String?
    public let pageToken: Swift.String?
    public let pageSize: Swift.Int
}

extension ListStackInstancesForProvisionedProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case provisionedProductId = "ProvisionedProductId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
    }
}

extension ListStackInstancesForProvisionedProductOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStackInstancesForProvisionedProductOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListStackInstancesForProvisionedProductOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStackInstancesForProvisionedProductOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListStackInstancesForProvisionedProductOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), stackInstances: \(Swift.String(describing: stackInstances)))"}
}

extension ListStackInstancesForProvisionedProductOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListStackInstancesForProvisionedProductOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.stackInstances = output.stackInstances
        } else {
            self.nextPageToken = nil
            self.stackInstances = nil
        }
    }
}

public struct ListStackInstancesForProvisionedProductOutputResponse: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// List of stack instances.
    public var stackInstances: [ServiceCatalogClientTypes.StackInstance]?

    public init (
        nextPageToken: Swift.String? = nil,
        stackInstances: [ServiceCatalogClientTypes.StackInstance]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.stackInstances = stackInstances
    }
}

struct ListStackInstancesForProvisionedProductOutputResponseBody: Swift.Equatable {
    public let stackInstances: [ServiceCatalogClientTypes.StackInstance]?
    public let nextPageToken: Swift.String?
}

extension ListStackInstancesForProvisionedProductOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case stackInstances = "StackInstances"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackInstancesContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.StackInstance?].self, forKey: .stackInstances)
        var stackInstancesDecoded0:[ServiceCatalogClientTypes.StackInstance]? = nil
        if let stackInstancesContainer = stackInstancesContainer {
            stackInstancesDecoded0 = [ServiceCatalogClientTypes.StackInstance]()
            for structure0 in stackInstancesContainer {
                if let structure0 = structure0 {
                    stackInstancesDecoded0?.append(structure0)
                }
            }
        }
        stackInstances = stackInstancesDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension ServiceCatalogClientTypes.ListTagOptionsFilters: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active = "Active"
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
    }
}

extension ServiceCatalogClientTypes.ListTagOptionsFilters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagOptionsFilters(active: \(Swift.String(describing: active)), key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension ServiceCatalogClientTypes {
    /// Filters to use when listing TagOptions.
    public struct ListTagOptionsFilters: Swift.Equatable {
        /// The active state.
        public var active: Swift.Bool?
        /// The TagOption key.
        public var key: Swift.String?
        /// The TagOption value.
        public var value: Swift.String?

        public init (
            active: Swift.Bool? = nil,
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.active = active
            self.key = key
            self.value = value
        }
    }

}

public struct ListTagOptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagOptionsOutputError>
}

extension ListTagOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagOptionsInput(filters: \(Swift.String(describing: filters)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)))"}
}

extension ListTagOptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
    }
}

public struct ListTagOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagOptionsOutputError>
}

public struct ListTagOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagOptionsOutputError>
}

public struct ListTagOptionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagOptionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagOptionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagOptionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagOptionsOutputError>
}

public struct ListTagOptionsInput: Swift.Equatable {
    /// The search filters. If no search filters are specified, the output includes all TagOptions.
    public var filters: ServiceCatalogClientTypes.ListTagOptionsFilters?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?

    public init (
        filters: ServiceCatalogClientTypes.ListTagOptionsFilters? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.pageSize = pageSize
        self.pageToken = pageToken
    }
}

struct ListTagOptionsInputBody: Swift.Equatable {
    public let filters: ServiceCatalogClientTypes.ListTagOptionsFilters?
    public let pageSize: Swift.Int
    public let pageToken: Swift.String?
}

extension ListTagOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ListTagOptionsFilters.self, forKey: .filters)
        filters = filtersDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ListTagOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagOptionsOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagOptionsOutputResponse(pageToken: \(Swift.String(describing: pageToken)), tagOptionDetails: \(Swift.String(describing: tagOptionDetails)))"}
}

extension ListTagOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.pageToken = output.pageToken
            self.tagOptionDetails = output.tagOptionDetails
        } else {
            self.pageToken = nil
            self.tagOptionDetails = nil
        }
    }
}

public struct ListTagOptionsOutputResponse: Swift.Equatable {
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// Information about the TagOptions.
    public var tagOptionDetails: [ServiceCatalogClientTypes.TagOptionDetail]?

    public init (
        pageToken: Swift.String? = nil,
        tagOptionDetails: [ServiceCatalogClientTypes.TagOptionDetail]? = nil
    )
    {
        self.pageToken = pageToken
        self.tagOptionDetails = tagOptionDetails
    }
}

struct ListTagOptionsOutputResponseBody: Swift.Equatable {
    public let tagOptionDetails: [ServiceCatalogClientTypes.TagOptionDetail]?
    public let pageToken: Swift.String?
}

extension ListTagOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pageToken = "PageToken"
        case tagOptionDetails = "TagOptionDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagOptionDetailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.TagOptionDetail?].self, forKey: .tagOptionDetails)
        var tagOptionDetailsDecoded0:[ServiceCatalogClientTypes.TagOptionDetail]? = nil
        if let tagOptionDetailsContainer = tagOptionDetailsContainer {
            tagOptionDetailsDecoded0 = [ServiceCatalogClientTypes.TagOptionDetail]()
            for structure0 in tagOptionDetailsContainer {
                if let structure0 = structure0 {
                    tagOptionDetailsDecoded0?.append(structure0)
                }
            }
        }
        tagOptionDetails = tagOptionDetailsDecoded0
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension OperationNotSupportedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OperationNotSupportedException(message: \(Swift.String(describing: message)))"}
}

extension OperationNotSupportedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: OperationNotSupportedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The operation is not supported.
public struct OperationNotSupportedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct OperationNotSupportedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension OperationNotSupportedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceCatalogClientTypes.OrganizationNode: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.OrganizationNodeType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceCatalogClientTypes.OrganizationNode: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OrganizationNode(type: \(Swift.String(describing: type)), value: \(Swift.String(describing: value)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about the organization node.
    public struct OrganizationNode: Swift.Equatable {
        /// The organization node type.
        public var type: ServiceCatalogClientTypes.OrganizationNodeType?
        /// The identifier of the organization node.
        public var value: Swift.String?

        public init (
            type: ServiceCatalogClientTypes.OrganizationNodeType? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum OrganizationNodeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case organization
        case organizationalUnit
        case sdkUnknown(Swift.String)

        public static var allCases: [OrganizationNodeType] {
            return [
                .account,
                .organization,
                .organizationalUnit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case .organization: return "ORGANIZATION"
            case .organizationalUnit: return "ORGANIZATIONAL_UNIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrganizationNodeType(rawValue: rawValue) ?? OrganizationNodeType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.ParameterConstraints: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedPattern = "AllowedPattern"
        case allowedValues = "AllowedValues"
        case constraintDescription = "ConstraintDescription"
        case maxLength = "MaxLength"
        case maxValue = "MaxValue"
        case minLength = "MinLength"
        case minValue = "MinValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPattern = allowedPattern {
            try encodeContainer.encode(allowedPattern, forKey: .allowedPattern)
        }
        if let allowedValues = allowedValues {
            var allowedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedValues)
            for allowedvalues0 in allowedValues {
                try allowedValuesContainer.encode(allowedvalues0)
            }
        }
        if let constraintDescription = constraintDescription {
            try encodeContainer.encode(constraintDescription, forKey: .constraintDescription)
        }
        if let maxLength = maxLength {
            try encodeContainer.encode(maxLength, forKey: .maxLength)
        }
        if let maxValue = maxValue {
            try encodeContainer.encode(maxValue, forKey: .maxValue)
        }
        if let minLength = minLength {
            try encodeContainer.encode(minLength, forKey: .minLength)
        }
        if let minValue = minValue {
            try encodeContainer.encode(minValue, forKey: .minValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedValues)
        var allowedValuesDecoded0:[Swift.String]? = nil
        if let allowedValuesContainer = allowedValuesContainer {
            allowedValuesDecoded0 = [Swift.String]()
            for string0 in allowedValuesContainer {
                if let string0 = string0 {
                    allowedValuesDecoded0?.append(string0)
                }
            }
        }
        allowedValues = allowedValuesDecoded0
        let allowedPatternDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .allowedPattern)
        allowedPattern = allowedPatternDecoded
        let constraintDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constraintDescription)
        constraintDescription = constraintDescriptionDecoded
        let maxLengthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxLength)
        maxLength = maxLengthDecoded
        let minLengthDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minLength)
        minLength = minLengthDecoded
        let maxValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .maxValue)
        maxValue = maxValueDecoded
        let minValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .minValue)
        minValue = minValueDecoded
    }
}

extension ServiceCatalogClientTypes.ParameterConstraints: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ParameterConstraints(allowedPattern: \(Swift.String(describing: allowedPattern)), allowedValues: \(Swift.String(describing: allowedValues)), constraintDescription: \(Swift.String(describing: constraintDescription)), maxLength: \(Swift.String(describing: maxLength)), maxValue: \(Swift.String(describing: maxValue)), minLength: \(Swift.String(describing: minLength)), minValue: \(Swift.String(describing: minValue)))"}
}

extension ServiceCatalogClientTypes {
    /// The constraints that the administrator has put on the parameter.
    public struct ParameterConstraints: Swift.Equatable {
        /// A regular expression that represents the patterns that allow for String types. The pattern must match the entire parameter value provided.
        public var allowedPattern: Swift.String?
        /// The values that the administrator has allowed for the parameter.
        public var allowedValues: [Swift.String]?
        /// A string that explains a constraint when the constraint is violated. For example, without a constraint description, a parameter that has an allowed pattern of [A-Za-z0-9]+ displays the following error message when the user specifies an invalid value:
        ///
        ///
        ///             Malformed input-Parameter MyParameter must match pattern [A-Za-z0-9]+
        ///
        ///
        ///          By adding a constraint description, such as must only contain letters (uppercase and lowercase) and numbers, you can display the following customized error message:
        ///
        ///
        ///             Malformed input-Parameter MyParameter must only contain uppercase and lowercase letters and numbers.
        ///
        public var constraintDescription: Swift.String?
        /// An integer value that determines the largest number of characters you want to allow for String types.
        public var maxLength: Swift.String?
        /// A numeric value that determines the largest numeric value you want to allow for Number types.
        public var maxValue: Swift.String?
        /// An integer value that determines the smallest number of characters you want to allow for String types.
        public var minLength: Swift.String?
        /// A numeric value that determines the smallest numeric value you want to allow for Number types.
        public var minValue: Swift.String?

        public init (
            allowedPattern: Swift.String? = nil,
            allowedValues: [Swift.String]? = nil,
            constraintDescription: Swift.String? = nil,
            maxLength: Swift.String? = nil,
            maxValue: Swift.String? = nil,
            minLength: Swift.String? = nil,
            minValue: Swift.String? = nil
        )
        {
            self.allowedPattern = allowedPattern
            self.allowedValues = allowedValues
            self.constraintDescription = constraintDescription
            self.maxLength = maxLength
            self.maxValue = maxValue
            self.minLength = minLength
            self.minValue = minValue
        }
    }

}

extension ServiceCatalogClientTypes.PortfolioDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case createdTime = "CreatedTime"
        case description = "Description"
        case displayName = "DisplayName"
        case id = "Id"
        case providerName = "ProviderName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
    }
}

extension ServiceCatalogClientTypes.PortfolioDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PortfolioDetail(aRN: \(Swift.String(describing: aRN)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), id: \(Swift.String(describing: id)), providerName: \(Swift.String(describing: providerName)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a portfolio.
    public struct PortfolioDetail: Swift.Equatable {
        /// The ARN assigned to the portfolio.
        public var aRN: Swift.String?
        /// The UTC time stamp of the creation time.
        public var createdTime: ClientRuntime.Date?
        /// The description of the portfolio.
        public var description: Swift.String?
        /// The name to use for display purposes.
        public var displayName: Swift.String?
        /// The portfolio identifier.
        public var id: Swift.String?
        /// The name of the portfolio provider.
        public var providerName: Swift.String?

        public init (
            aRN: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            id: Swift.String? = nil,
            providerName: Swift.String? = nil
        )
        {
            self.aRN = aRN
            self.createdTime = createdTime
            self.description = description
            self.displayName = displayName
            self.id = id
            self.providerName = providerName
        }
    }

}

extension ServiceCatalogClientTypes.PortfolioShareDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accepted = "Accepted"
        case principalId = "PrincipalId"
        case shareTagOptions = "ShareTagOptions"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if accepted != false {
            try encodeContainer.encode(accepted, forKey: .accepted)
        }
        if let principalId = principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if shareTagOptions != false {
            try encodeContainer.encode(shareTagOptions, forKey: .shareTagOptions)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.DescribePortfolioShareType.self, forKey: .type)
        type = typeDecoded
        let acceptedDecoded = try containerValues.decode(Swift.Bool.self, forKey: .accepted)
        accepted = acceptedDecoded
        let shareTagOptionsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .shareTagOptions)
        shareTagOptions = shareTagOptionsDecoded
    }
}

extension ServiceCatalogClientTypes.PortfolioShareDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PortfolioShareDetail(accepted: \(Swift.String(describing: accepted)), principalId: \(Swift.String(describing: principalId)), shareTagOptions: \(Swift.String(describing: shareTagOptions)), type: \(Swift.String(describing: type)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about the portfolio share.
    public struct PortfolioShareDetail: Swift.Equatable {
        /// Indicates whether the shared portfolio is imported by the recipient account. If the recipient is in an organization node, the share is automatically imported, and the field is always set to true.
        public var accepted: Swift.Bool
        /// The identifier of the recipient entity that received the portfolio share.
        ///          The recipient entities can be one of the following:
        ///
        ///          1. An external account.
        ///          2. An organziation member account.
        ///          3. An organzational unit (OU).
        ///          4. The organization itself. (This shares with every account in the organization).
        public var principalId: Swift.String?
        /// Indicates whether TagOptions sharing is enabled or disabled for the portfolio share.
        public var shareTagOptions: Swift.Bool
        /// The type of the portfolio share.
        public var type: ServiceCatalogClientTypes.DescribePortfolioShareType?

        public init (
            accepted: Swift.Bool = false,
            principalId: Swift.String? = nil,
            shareTagOptions: Swift.Bool = false,
            type: ServiceCatalogClientTypes.DescribePortfolioShareType? = nil
        )
        {
            self.accepted = accepted
            self.principalId = principalId
            self.shareTagOptions = shareTagOptions
            self.type = type
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum PortfolioShareType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsOrganizations
        case awsServicecatalog
        case imported
        case sdkUnknown(Swift.String)

        public static var allCases: [PortfolioShareType] {
            return [
                .awsOrganizations,
                .awsServicecatalog,
                .imported,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsOrganizations: return "AWS_ORGANIZATIONS"
            case .awsServicecatalog: return "AWS_SERVICECATALOG"
            case .imported: return "IMPORTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PortfolioShareType(rawValue: rawValue) ?? PortfolioShareType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.Principal: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case principalARN = "PrincipalARN"
        case principalType = "PrincipalType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let principalARN = principalARN {
            try encodeContainer.encode(principalARN, forKey: .principalARN)
        }
        if let principalType = principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalARN)
        principalARN = principalARNDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
    }
}

extension ServiceCatalogClientTypes.Principal: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Principal(principalARN: \(Swift.String(describing: principalARN)), principalType: \(Swift.String(describing: principalType)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a principal.
    public struct Principal: Swift.Equatable {
        /// The ARN of the principal (IAM user, role, or group).
        public var principalARN: Swift.String?
        /// The principal type. The supported value is IAM.
        public var principalType: ServiceCatalogClientTypes.PrincipalType?

        public init (
            principalARN: Swift.String? = nil,
            principalType: ServiceCatalogClientTypes.PrincipalType? = nil
        )
        {
            self.principalARN = principalARN
            self.principalType = principalType
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum PrincipalType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iam
        case sdkUnknown(Swift.String)

        public static var allCases: [PrincipalType] {
            return [
                .iam,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iam: return "IAM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrincipalType(rawValue: rawValue) ?? PrincipalType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum ProductSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case account
        case sdkUnknown(Swift.String)

        public static var allCases: [ProductSource] {
            return [
                .account,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .account: return "ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProductSource(rawValue: rawValue) ?? ProductSource.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum ProductType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudFormationTemplate
        case marketplace
        case sdkUnknown(Swift.String)

        public static var allCases: [ProductType] {
            return [
                .cloudFormationTemplate,
                .marketplace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudFormationTemplate: return "CLOUD_FORMATION_TEMPLATE"
            case .marketplace: return "MARKETPLACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProductType(rawValue: rawValue) ?? ProductType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.ProductViewAggregationValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case approximateCount = "ApproximateCount"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if approximateCount != 0 {
            try encodeContainer.encode(approximateCount, forKey: .approximateCount)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let approximateCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .approximateCount)
        approximateCount = approximateCountDecoded
    }
}

extension ServiceCatalogClientTypes.ProductViewAggregationValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProductViewAggregationValue(approximateCount: \(Swift.String(describing: approximateCount)), value: \(Swift.String(describing: value)))"}
}

extension ServiceCatalogClientTypes {
    /// A single product view aggregation value/count pair, containing metadata about each
    ///          product to which the calling user has access.
    public struct ProductViewAggregationValue: Swift.Equatable {
        /// An approximate count of the products that match the value.
        public var approximateCount: Swift.Int
        /// The value of the product view aggregation.
        public var value: Swift.String?

        public init (
            approximateCount: Swift.Int = 0,
            value: Swift.String? = nil
        )
        {
            self.approximateCount = approximateCount
            self.value = value
        }
    }

}

extension ServiceCatalogClientTypes.ProductViewDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case productARN = "ProductARN"
        case productViewSummary = "ProductViewSummary"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let productARN = productARN {
            try encodeContainer.encode(productARN, forKey: .productARN)
        }
        if let productViewSummary = productViewSummary {
            try encodeContainer.encode(productViewSummary, forKey: .productViewSummary)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewSummaryDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductViewSummary.self, forKey: .productViewSummary)
        productViewSummary = productViewSummaryDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let productARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productARN)
        productARN = productARNDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension ServiceCatalogClientTypes.ProductViewDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProductViewDetail(createdTime: \(Swift.String(describing: createdTime)), productARN: \(Swift.String(describing: productARN)), productViewSummary: \(Swift.String(describing: productViewSummary)), status: \(Swift.String(describing: status)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a product view.
    public struct ProductViewDetail: Swift.Equatable {
        /// The UTC time stamp of the creation time.
        public var createdTime: ClientRuntime.Date?
        /// The ARN of the product.
        public var productARN: Swift.String?
        /// Summary information about the product view.
        public var productViewSummary: ServiceCatalogClientTypes.ProductViewSummary?
        /// The status of the product.
        ///
        ///
        ///
        ///                   AVAILABLE - The product is ready for use.
        ///
        ///
        ///
        ///                   CREATING - Product creation has started; the product is not ready for use.
        ///
        ///
        ///
        ///                   FAILED - An action failed.
        ///
        ///
        public var status: ServiceCatalogClientTypes.Status?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            productARN: Swift.String? = nil,
            productViewSummary: ServiceCatalogClientTypes.ProductViewSummary? = nil,
            status: ServiceCatalogClientTypes.Status? = nil
        )
        {
            self.createdTime = createdTime
            self.productARN = productARN
            self.productViewSummary = productViewSummary
            self.status = status
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum ProductViewFilterBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fulltextsearch
        case owner
        case producttype
        case sourceproductid
        case sdkUnknown(Swift.String)

        public static var allCases: [ProductViewFilterBy] {
            return [
                .fulltextsearch,
                .owner,
                .producttype,
                .sourceproductid,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fulltextsearch: return "FullTextSearch"
            case .owner: return "Owner"
            case .producttype: return "ProductType"
            case .sourceproductid: return "SourceProductId"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProductViewFilterBy(rawValue: rawValue) ?? ProductViewFilterBy.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum ProductViewSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creationdate
        case title
        case versioncount
        case sdkUnknown(Swift.String)

        public static var allCases: [ProductViewSortBy] {
            return [
                .creationdate,
                .title,
                .versioncount,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creationdate: return "CreationDate"
            case .title: return "Title"
            case .versioncount: return "VersionCount"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProductViewSortBy(rawValue: rawValue) ?? ProductViewSortBy.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.ProductViewSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case distributor = "Distributor"
        case hasDefaultPath = "HasDefaultPath"
        case id = "Id"
        case name = "Name"
        case owner = "Owner"
        case productId = "ProductId"
        case shortDescription = "ShortDescription"
        case supportDescription = "SupportDescription"
        case supportEmail = "SupportEmail"
        case supportUrl = "SupportUrl"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let distributor = distributor {
            try encodeContainer.encode(distributor, forKey: .distributor)
        }
        if hasDefaultPath != false {
            try encodeContainer.encode(hasDefaultPath, forKey: .hasDefaultPath)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let shortDescription = shortDescription {
            try encodeContainer.encode(shortDescription, forKey: .shortDescription)
        }
        if let supportDescription = supportDescription {
            try encodeContainer.encode(supportDescription, forKey: .supportDescription)
        }
        if let supportEmail = supportEmail {
            try encodeContainer.encode(supportEmail, forKey: .supportEmail)
        }
        if let supportUrl = supportUrl {
            try encodeContainer.encode(supportUrl, forKey: .supportUrl)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let shortDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortDescription)
        shortDescription = shortDescriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductType.self, forKey: .type)
        type = typeDecoded
        let distributorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributor)
        distributor = distributorDecoded
        let hasDefaultPathDecoded = try containerValues.decode(Swift.Bool.self, forKey: .hasDefaultPath)
        hasDefaultPath = hasDefaultPathDecoded
        let supportEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportEmail)
        supportEmail = supportEmailDecoded
        let supportDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportDescription)
        supportDescription = supportDescriptionDecoded
        let supportUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportUrl)
        supportUrl = supportUrlDecoded
    }
}

extension ServiceCatalogClientTypes.ProductViewSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProductViewSummary(distributor: \(Swift.String(describing: distributor)), hasDefaultPath: \(Swift.String(describing: hasDefaultPath)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), productId: \(Swift.String(describing: productId)), shortDescription: \(Swift.String(describing: shortDescription)), supportDescription: \(Swift.String(describing: supportDescription)), supportEmail: \(Swift.String(describing: supportEmail)), supportUrl: \(Swift.String(describing: supportUrl)), type: \(Swift.String(describing: type)))"}
}

extension ServiceCatalogClientTypes {
    /// Summary information about a product view.
    public struct ProductViewSummary: Swift.Equatable {
        /// The distributor of the product. Contact the product administrator for the
        ///          significance of this value.
        public var distributor: Swift.String?
        /// Indicates whether the product has a default path.
        ///          If the product does not have a default path, call ListLaunchPaths
        ///          to disambiguate between paths. Otherwise, ListLaunchPaths is not
        ///          required, and the output of ProductViewSummary can be used directly with
        ///          DescribeProvisioningParameters.
        public var hasDefaultPath: Swift.Bool
        /// The product view identifier.
        public var id: Swift.String?
        /// The name of the product.
        public var name: Swift.String?
        /// The owner of the product. Contact the product administrator for the significance of
        ///          this value.
        public var owner: Swift.String?
        /// The product identifier.
        public var productId: Swift.String?
        /// Short description of the product.
        public var shortDescription: Swift.String?
        /// The description of the support for this Product.
        public var supportDescription: Swift.String?
        /// The email contact information to obtain support for this Product.
        public var supportEmail: Swift.String?
        /// The URL information to obtain support for this Product.
        public var supportUrl: Swift.String?
        /// The product type. Contact the product administrator for the significance of this
        ///          value. If this value is MARKETPLACE, the product was created by AWS
        ///          Marketplace.
        public var type: ServiceCatalogClientTypes.ProductType?

        public init (
            distributor: Swift.String? = nil,
            hasDefaultPath: Swift.Bool = false,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            productId: Swift.String? = nil,
            shortDescription: Swift.String? = nil,
            supportDescription: Swift.String? = nil,
            supportEmail: Swift.String? = nil,
            supportUrl: Swift.String? = nil,
            type: ServiceCatalogClientTypes.ProductType? = nil
        )
        {
            self.distributor = distributor
            self.hasDefaultPath = hasDefaultPath
            self.id = id
            self.name = name
            self.owner = owner
            self.productId = productId
            self.shortDescription = shortDescription
            self.supportDescription = supportDescription
            self.supportEmail = supportEmail
            self.supportUrl = supportUrl
            self.type = type
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum PropertyKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case launchrole
        case owner
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyKey] {
            return [
                .launchrole,
                .owner,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .launchrole: return "LAUNCH_ROLE"
            case .owner: return "OWNER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PropertyKey(rawValue: rawValue) ?? PropertyKey.sdkUnknown(rawValue)
        }
    }
}

public struct ProvisionProductInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ProvisionProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ProvisionProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ProvisionProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ProvisionProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ProvisionProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ProvisionProductOutputError>
}

extension ProvisionProductInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisionProductInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), notificationArns: \(Swift.String(describing: notificationArns)), pathId: \(Swift.String(describing: pathId)), pathName: \(Swift.String(describing: pathName)), productId: \(Swift.String(describing: productId)), productName: \(Swift.String(describing: productName)), provisionToken: \(Swift.String(describing: provisionToken)), provisionedProductName: \(Swift.String(describing: provisionedProductName)), provisioningArtifactId: \(Swift.String(describing: provisioningArtifactId)), provisioningArtifactName: \(Swift.String(describing: provisioningArtifactName)), provisioningParameters: \(Swift.String(describing: provisioningParameters)), provisioningPreferences: \(Swift.String(describing: provisioningPreferences)), tags: \(Swift.String(describing: tags)))"}
}

extension ProvisionProductInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case notificationArns = "NotificationArns"
        case pathId = "PathId"
        case pathName = "PathName"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisionToken = "ProvisionToken"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
        case provisioningParameters = "ProvisioningParameters"
        case provisioningPreferences = "ProvisioningPreferences"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let notificationArns = notificationArns {
            var notificationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationArns)
            for notificationarns0 in notificationArns {
                try notificationArnsContainer.encode(notificationarns0)
            }
        }
        if let pathId = pathId {
            try encodeContainer.encode(pathId, forKey: .pathId)
        }
        if let pathName = pathName {
            try encodeContainer.encode(pathName, forKey: .pathName)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let productName = productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let provisionToken = provisionToken {
            try encodeContainer.encode(provisionToken, forKey: .provisionToken)
        }
        if let provisionedProductName = provisionedProductName {
            try encodeContainer.encode(provisionedProductName, forKey: .provisionedProductName)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let provisioningArtifactName = provisioningArtifactName {
            try encodeContainer.encode(provisioningArtifactName, forKey: .provisioningArtifactName)
        }
        if let provisioningParameters = provisioningParameters {
            var provisioningParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .provisioningParameters)
            for provisioningparameters0 in provisioningParameters {
                try provisioningParametersContainer.encode(provisioningparameters0)
            }
        }
        if let provisioningPreferences = provisioningPreferences {
            try encodeContainer.encode(provisioningPreferences, forKey: .provisioningPreferences)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }
}

public struct ProvisionProductInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ProvisionProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ProvisionProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ProvisionProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ProvisionProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ProvisionProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ProvisionProductOutputError>
}

public struct ProvisionProductInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ProvisionProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ProvisionProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ProvisionProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ProvisionProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ProvisionProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ProvisionProductOutputError>
}

public struct ProvisionProductInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ProvisionProductInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ProvisionProductInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ProvisionProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ProvisionProductInput
    public typealias MOutput = ClientRuntime.OperationOutput<ProvisionProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ProvisionProductOutputError>
}

public struct ProvisionProductInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// Passed to CloudFormation. The SNS topic ARNs to which to publish stack-related
    ///          events.
    public var notificationArns: [Swift.String]?
    /// The path identifier of the product. This value is optional if the product
    ///          has a default path, and required if the product has more than one path.
    ///          To list the paths for a product, use ListLaunchPaths. You must provide the name or ID, but not both.
    public var pathId: Swift.String?
    /// The name of the path. You must provide the name or ID, but not both.
    public var pathName: Swift.String?
    /// The product identifier. You must provide the name or ID, but not both.
    public var productId: Swift.String?
    /// The name of the product. You must provide the name or ID, but not both.
    public var productName: Swift.String?
    /// An idempotency token that uniquely identifies the provisioning request.
    /// This member is required.
    public var provisionToken: Swift.String?
    /// A user-friendly name for the provisioned product. This value must be
    ///          unique for the AWS account and cannot be updated after the product is provisioned.
    /// This member is required.
    public var provisionedProductName: Swift.String?
    /// The identifier of the provisioning artifact. You must provide the name or ID, but not both.
    public var provisioningArtifactId: Swift.String?
    /// The name of the provisioning artifact. You must provide the name or ID, but not both.
    public var provisioningArtifactName: Swift.String?
    /// Parameters specified by the administrator that are required for provisioning the
    ///          product.
    public var provisioningParameters: [ServiceCatalogClientTypes.ProvisioningParameter]?
    /// An object that contains information about the provisioning preferences for a stack set.
    public var provisioningPreferences: ServiceCatalogClientTypes.ProvisioningPreferences?
    /// One or more tags.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init (
        acceptLanguage: Swift.String? = nil,
        notificationArns: [Swift.String]? = nil,
        pathId: Swift.String? = nil,
        pathName: Swift.String? = nil,
        productId: Swift.String? = nil,
        productName: Swift.String? = nil,
        provisionToken: Swift.String? = nil,
        provisionedProductName: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil,
        provisioningArtifactName: Swift.String? = nil,
        provisioningParameters: [ServiceCatalogClientTypes.ProvisioningParameter]? = nil,
        provisioningPreferences: ServiceCatalogClientTypes.ProvisioningPreferences? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.notificationArns = notificationArns
        self.pathId = pathId
        self.pathName = pathName
        self.productId = productId
        self.productName = productName
        self.provisionToken = provisionToken
        self.provisionedProductName = provisionedProductName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningArtifactName = provisioningArtifactName
        self.provisioningParameters = provisioningParameters
        self.provisioningPreferences = provisioningPreferences
        self.tags = tags
    }
}

struct ProvisionProductInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let productId: Swift.String?
    public let productName: Swift.String?
    public let provisioningArtifactId: Swift.String?
    public let provisioningArtifactName: Swift.String?
    public let pathId: Swift.String?
    public let pathName: Swift.String?
    public let provisionedProductName: Swift.String?
    public let provisioningParameters: [ServiceCatalogClientTypes.ProvisioningParameter]?
    public let provisioningPreferences: ServiceCatalogClientTypes.ProvisioningPreferences?
    public let tags: [ServiceCatalogClientTypes.Tag]?
    public let notificationArns: [Swift.String]?
    public let provisionToken: Swift.String?
}

extension ProvisionProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case notificationArns = "NotificationArns"
        case pathId = "PathId"
        case pathName = "PathName"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisionToken = "ProvisionToken"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
        case provisioningParameters = "ProvisioningParameters"
        case provisioningPreferences = "ProvisioningPreferences"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let provisioningArtifactNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactName)
        provisioningArtifactName = provisioningArtifactNameDecoded
        let pathIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathId)
        pathId = pathIdDecoded
        let pathNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathName)
        pathName = pathNameDecoded
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let provisioningParametersContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisioningParameter?].self, forKey: .provisioningParameters)
        var provisioningParametersDecoded0:[ServiceCatalogClientTypes.ProvisioningParameter]? = nil
        if let provisioningParametersContainer = provisioningParametersContainer {
            provisioningParametersDecoded0 = [ServiceCatalogClientTypes.ProvisioningParameter]()
            for structure0 in provisioningParametersContainer {
                if let structure0 = structure0 {
                    provisioningParametersDecoded0?.append(structure0)
                }
            }
        }
        provisioningParameters = provisioningParametersDecoded0
        let provisioningPreferencesDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningPreferences.self, forKey: .provisioningPreferences)
        provisioningPreferences = provisioningPreferencesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let notificationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notificationArns)
        var notificationArnsDecoded0:[Swift.String]? = nil
        if let notificationArnsContainer = notificationArnsContainer {
            notificationArnsDecoded0 = [Swift.String]()
            for string0 in notificationArnsContainer {
                if let string0 = string0 {
                    notificationArnsDecoded0?.append(string0)
                }
            }
        }
        notificationArns = notificationArnsDecoded0
        let provisionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionToken)
        provisionToken = provisionTokenDecoded
    }
}

extension ProvisionProductOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ProvisionProductOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ProvisionProductOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ProvisionProductOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisionProductOutputResponse(recordDetail: \(Swift.String(describing: recordDetail)))"}
}

extension ProvisionProductOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ProvisionProductOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recordDetail = output.recordDetail
        } else {
            self.recordDetail = nil
        }
    }
}

public struct ProvisionProductOutputResponse: Swift.Equatable {
    /// Information about the result of provisioning the product.
    public var recordDetail: ServiceCatalogClientTypes.RecordDetail?

    public init (
        recordDetail: ServiceCatalogClientTypes.RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

struct ProvisionProductOutputResponseBody: Swift.Equatable {
    public let recordDetail: ServiceCatalogClientTypes.RecordDetail?
}

extension ProvisionProductOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordDetail = "RecordDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.RecordDetail.self, forKey: .recordDetail)
        recordDetail = recordDetailDecoded
    }
}

extension ServiceCatalogClientTypes.ProvisionedProductAttribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case id = "Id"
        case idempotencyToken = "IdempotencyToken"
        case lastProvisioningRecordId = "LastProvisioningRecordId"
        case lastRecordId = "LastRecordId"
        case lastSuccessfulProvisioningRecordId = "LastSuccessfulProvisioningRecordId"
        case name = "Name"
        case physicalId = "PhysicalId"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case tags = "Tags"
        case type = "Type"
        case userArn = "UserArn"
        case userArnSession = "UserArnSession"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let lastProvisioningRecordId = lastProvisioningRecordId {
            try encodeContainer.encode(lastProvisioningRecordId, forKey: .lastProvisioningRecordId)
        }
        if let lastRecordId = lastRecordId {
            try encodeContainer.encode(lastRecordId, forKey: .lastRecordId)
        }
        if let lastSuccessfulProvisioningRecordId = lastSuccessfulProvisioningRecordId {
            try encodeContainer.encode(lastSuccessfulProvisioningRecordId, forKey: .lastSuccessfulProvisioningRecordId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let physicalId = physicalId {
            try encodeContainer.encode(physicalId, forKey: .physicalId)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let productName = productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let provisioningArtifactName = provisioningArtifactName {
            try encodeContainer.encode(provisioningArtifactName, forKey: .provisioningArtifactName)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
        if let userArnSession = userArnSession {
            try encodeContainer.encode(userArnSession, forKey: .userArnSession)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisionedProductStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let lastRecordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastRecordId)
        lastRecordId = lastRecordIdDecoded
        let lastProvisioningRecordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastProvisioningRecordId)
        lastProvisioningRecordId = lastProvisioningRecordIdDecoded
        let lastSuccessfulProvisioningRecordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSuccessfulProvisioningRecordId)
        lastSuccessfulProvisioningRecordId = lastSuccessfulProvisioningRecordIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let physicalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .physicalId)
        physicalId = physicalIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let provisioningArtifactNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactName)
        provisioningArtifactName = provisioningArtifactNameDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let userArnSessionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArnSession)
        userArnSession = userArnSessionDecoded
    }
}

extension ServiceCatalogClientTypes.ProvisionedProductAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisionedProductAttribute(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), id: \(Swift.String(describing: id)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), lastProvisioningRecordId: \(Swift.String(describing: lastProvisioningRecordId)), lastRecordId: \(Swift.String(describing: lastRecordId)), lastSuccessfulProvisioningRecordId: \(Swift.String(describing: lastSuccessfulProvisioningRecordId)), name: \(Swift.String(describing: name)), physicalId: \(Swift.String(describing: physicalId)), productId: \(Swift.String(describing: productId)), productName: \(Swift.String(describing: productName)), provisioningArtifactId: \(Swift.String(describing: provisioningArtifactId)), provisioningArtifactName: \(Swift.String(describing: provisioningArtifactName)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)), tags: \(Swift.String(describing: tags)), type: \(Swift.String(describing: type)), userArn: \(Swift.String(describing: userArn)), userArnSession: \(Swift.String(describing: userArnSession)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a provisioned product.
    public struct ProvisionedProductAttribute: Swift.Equatable {
        /// The ARN of the provisioned product.
        public var arn: Swift.String?
        /// The UTC time stamp of the creation time.
        public var createdTime: ClientRuntime.Date?
        /// The identifier of the provisioned product.
        public var id: Swift.String?
        /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
        ///   the same response is returned for each repeated request.
        public var idempotencyToken: Swift.String?
        /// The record identifier of the last request performed on this provisioned product of the following types:
        ///
        ///
        ///
        ///                ProvisionedProduct
        ///
        ///
        ///
        ///
        ///                UpdateProvisionedProduct
        ///
        ///
        ///
        ///
        ///                ExecuteProvisionedProductPlan
        ///
        ///
        ///
        ///
        ///                TerminateProvisionedProduct
        ///
        ///
        ///
        public var lastProvisioningRecordId: Swift.String?
        /// The record identifier of the last request performed on this provisioned product.
        public var lastRecordId: Swift.String?
        /// The record identifier of the last successful request performed on this provisioned product of the following types:
        ///
        ///
        ///
        ///                ProvisionedProduct
        ///
        ///
        ///
        ///
        ///                UpdateProvisionedProduct
        ///
        ///
        ///
        ///
        ///                ExecuteProvisionedProductPlan
        ///
        ///
        ///
        ///
        ///                TerminateProvisionedProduct
        ///
        ///
        ///
        public var lastSuccessfulProvisioningRecordId: Swift.String?
        /// The user-friendly name of the provisioned product.
        public var name: Swift.String?
        /// The assigned identifier for the resource, such as an EC2 instance ID or an S3 bucket name.
        public var physicalId: Swift.String?
        /// The product identifier.
        public var productId: Swift.String?
        /// The name of the product.
        public var productName: Swift.String?
        /// The identifier of the provisioning artifact.
        public var provisioningArtifactId: Swift.String?
        /// The name of the provisioning artifact.
        public var provisioningArtifactName: Swift.String?
        /// The current status of the provisioned product.
        ///
        ///
        ///
        ///                   AVAILABLE - Stable state, ready to perform any operation. The most
        ///                recent operation succeeded and completed.
        ///
        ///
        ///
        ///                   UNDER_CHANGE - Transitive state. Operations performed might not have valid results.
        ///                Wait for an AVAILABLE status before performing operations.
        ///
        ///
        ///
        ///                   TAINTED - Stable state, ready to perform any operation. The stack has
        ///                completed the requested operation but is not exactly what was requested. For example, a
        ///                request to update to a new version failed and the stack rolled back to the current version.
        ///
        ///
        ///
        ///                   ERROR - An unexpected error occurred. The provisioned product exists but the stack is not running.
        ///                For example, CloudFormation received a parameter value that was not valid and could not launch the stack.
        ///
        ///
        ///
        ///                   PLAN_IN_PROGRESS - Transitive state. The plan operations were performed to provision a new product,
        ///                 but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an AVAILABLE status before performing operations.
        ///
        ///
        public var status: ServiceCatalogClientTypes.ProvisionedProductStatus?
        /// The current status message of the provisioned product.
        public var statusMessage: Swift.String?
        /// One or more tags.
        public var tags: [ServiceCatalogClientTypes.Tag]?
        /// The type of provisioned product. The supported values are CFN_STACK and CFN_STACKSET.
        public var type: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM user.
        public var userArn: Swift.String?
        /// The ARN of the IAM user in the session. This ARN might contain a session ID.
        public var userArnSession: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            idempotencyToken: Swift.String? = nil,
            lastProvisioningRecordId: Swift.String? = nil,
            lastRecordId: Swift.String? = nil,
            lastSuccessfulProvisioningRecordId: Swift.String? = nil,
            name: Swift.String? = nil,
            physicalId: Swift.String? = nil,
            productId: Swift.String? = nil,
            productName: Swift.String? = nil,
            provisioningArtifactId: Swift.String? = nil,
            provisioningArtifactName: Swift.String? = nil,
            status: ServiceCatalogClientTypes.ProvisionedProductStatus? = nil,
            statusMessage: Swift.String? = nil,
            tags: [ServiceCatalogClientTypes.Tag]? = nil,
            type: Swift.String? = nil,
            userArn: Swift.String? = nil,
            userArnSession: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.id = id
            self.idempotencyToken = idempotencyToken
            self.lastProvisioningRecordId = lastProvisioningRecordId
            self.lastRecordId = lastRecordId
            self.lastSuccessfulProvisioningRecordId = lastSuccessfulProvisioningRecordId
            self.name = name
            self.physicalId = physicalId
            self.productId = productId
            self.productName = productName
            self.provisioningArtifactId = provisioningArtifactId
            self.provisioningArtifactName = provisioningArtifactName
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
            self.type = type
            self.userArn = userArn
            self.userArnSession = userArnSession
        }
    }

}

extension ServiceCatalogClientTypes.ProvisionedProductDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case createdTime = "CreatedTime"
        case id = "Id"
        case idempotencyToken = "IdempotencyToken"
        case lastProvisioningRecordId = "LastProvisioningRecordId"
        case lastRecordId = "LastRecordId"
        case lastSuccessfulProvisioningRecordId = "LastSuccessfulProvisioningRecordId"
        case launchRoleArn = "LaunchRoleArn"
        case name = "Name"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let lastProvisioningRecordId = lastProvisioningRecordId {
            try encodeContainer.encode(lastProvisioningRecordId, forKey: .lastProvisioningRecordId)
        }
        if let lastRecordId = lastRecordId {
            try encodeContainer.encode(lastRecordId, forKey: .lastRecordId)
        }
        if let lastSuccessfulProvisioningRecordId = lastSuccessfulProvisioningRecordId {
            try encodeContainer.encode(lastSuccessfulProvisioningRecordId, forKey: .lastSuccessfulProvisioningRecordId)
        }
        if let launchRoleArn = launchRoleArn {
            try encodeContainer.encode(launchRoleArn, forKey: .launchRoleArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisionedProductStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
        let lastRecordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastRecordId)
        lastRecordId = lastRecordIdDecoded
        let lastProvisioningRecordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastProvisioningRecordId)
        lastProvisioningRecordId = lastProvisioningRecordIdDecoded
        let lastSuccessfulProvisioningRecordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSuccessfulProvisioningRecordId)
        lastSuccessfulProvisioningRecordId = lastSuccessfulProvisioningRecordIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let launchRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchRoleArn)
        launchRoleArn = launchRoleArnDecoded
    }
}

extension ServiceCatalogClientTypes.ProvisionedProductDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisionedProductDetail(arn: \(Swift.String(describing: arn)), createdTime: \(Swift.String(describing: createdTime)), id: \(Swift.String(describing: id)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), lastProvisioningRecordId: \(Swift.String(describing: lastProvisioningRecordId)), lastRecordId: \(Swift.String(describing: lastRecordId)), lastSuccessfulProvisioningRecordId: \(Swift.String(describing: lastSuccessfulProvisioningRecordId)), launchRoleArn: \(Swift.String(describing: launchRoleArn)), name: \(Swift.String(describing: name)), productId: \(Swift.String(describing: productId)), provisioningArtifactId: \(Swift.String(describing: provisioningArtifactId)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)), type: \(Swift.String(describing: type)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a provisioned product.
    public struct ProvisionedProductDetail: Swift.Equatable {
        /// The ARN of the provisioned product.
        public var arn: Swift.String?
        /// The UTC time stamp of the creation time.
        public var createdTime: ClientRuntime.Date?
        /// The identifier of the provisioned product.
        public var id: Swift.String?
        /// A unique identifier that you provide to ensure idempotency. If multiple requests differ only by the idempotency token,
        ///   the same response is returned for each repeated request.
        public var idempotencyToken: Swift.String?
        /// The record identifier of the last request performed on this provisioned product of the following types:
        ///
        ///
        ///
        ///                ProvisionedProduct
        ///
        ///
        ///
        ///
        ///                UpdateProvisionedProduct
        ///
        ///
        ///
        ///
        ///                ExecuteProvisionedProductPlan
        ///
        ///
        ///
        ///
        ///                TerminateProvisionedProduct
        ///
        ///
        ///
        public var lastProvisioningRecordId: Swift.String?
        /// The record identifier of the last request performed on this provisioned product.
        public var lastRecordId: Swift.String?
        /// The record identifier of the last successful request performed on this provisioned product of the following types:
        ///
        ///
        ///
        ///                ProvisionedProduct
        ///
        ///
        ///
        ///
        ///                UpdateProvisionedProduct
        ///
        ///
        ///
        ///
        ///                ExecuteProvisionedProductPlan
        ///
        ///
        ///
        ///
        ///                TerminateProvisionedProduct
        ///
        ///
        ///
        public var lastSuccessfulProvisioningRecordId: Swift.String?
        /// The ARN of the launch role associated with the provisioned product.
        public var launchRoleArn: Swift.String?
        /// The user-friendly name of the provisioned product.
        public var name: Swift.String?
        /// The product identifier. For example, prod-abcdzk7xy33qa.
        public var productId: Swift.String?
        /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
        public var provisioningArtifactId: Swift.String?
        /// The current status of the provisioned product.
        ///
        ///
        ///
        ///                   AVAILABLE - Stable state, ready to perform any operation. The most
        ///                recent operation succeeded and completed.
        ///
        ///
        ///
        ///                   UNDER_CHANGE - Transitive state. Operations performed might not have valid results.
        ///                Wait for an AVAILABLE status before performing operations.
        ///
        ///
        ///
        ///                   TAINTED - Stable state, ready to perform any operation. The stack has
        ///                completed the requested operation but is not exactly what was requested. For example, a
        ///                request to update to a new version failed and the stack rolled back to the current version.
        ///
        ///
        ///
        ///                   ERROR - An unexpected error occurred. The provisioned product exists but the stack is not running.
        ///                For example, CloudFormation received a parameter value that was not valid and could not launch the stack.
        ///
        ///
        ///
        ///                   PLAN_IN_PROGRESS - Transitive state. The plan operations were performed to provision a new product,
        ///                but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an AVAILABLE status before performing operations.
        ///
        ///
        public var status: ServiceCatalogClientTypes.ProvisionedProductStatus?
        /// The current status message of the provisioned product.
        public var statusMessage: Swift.String?
        /// The type of provisioned product. The supported values are CFN_STACK and CFN_STACKSET.
        public var type: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            idempotencyToken: Swift.String? = nil,
            lastProvisioningRecordId: Swift.String? = nil,
            lastRecordId: Swift.String? = nil,
            lastSuccessfulProvisioningRecordId: Swift.String? = nil,
            launchRoleArn: Swift.String? = nil,
            name: Swift.String? = nil,
            productId: Swift.String? = nil,
            provisioningArtifactId: Swift.String? = nil,
            status: ServiceCatalogClientTypes.ProvisionedProductStatus? = nil,
            statusMessage: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdTime = createdTime
            self.id = id
            self.idempotencyToken = idempotencyToken
            self.lastProvisioningRecordId = lastProvisioningRecordId
            self.lastRecordId = lastRecordId
            self.lastSuccessfulProvisioningRecordId = lastSuccessfulProvisioningRecordId
            self.launchRoleArn = launchRoleArn
            self.name = name
            self.productId = productId
            self.provisioningArtifactId = provisioningArtifactId
            self.status = status
            self.statusMessage = statusMessage
            self.type = type
        }
    }

}

extension ServiceCatalogClientTypes.ProvisionedProductPlanDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case notificationArns = "NotificationArns"
        case pathId = "PathId"
        case planId = "PlanId"
        case planName = "PlanName"
        case planType = "PlanType"
        case productId = "ProductId"
        case provisionProductId = "ProvisionProductId"
        case provisionProductName = "ProvisionProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningParameters = "ProvisioningParameters"
        case status = "Status"
        case statusMessage = "StatusMessage"
        case tags = "Tags"
        case updatedTime = "UpdatedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let notificationArns = notificationArns {
            var notificationArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationArns)
            for notificationarns0 in notificationArns {
                try notificationArnsContainer.encode(notificationarns0)
            }
        }
        if let pathId = pathId {
            try encodeContainer.encode(pathId, forKey: .pathId)
        }
        if let planId = planId {
            try encodeContainer.encode(planId, forKey: .planId)
        }
        if let planName = planName {
            try encodeContainer.encode(planName, forKey: .planName)
        }
        if let planType = planType {
            try encodeContainer.encode(planType.rawValue, forKey: .planType)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisionProductId = provisionProductId {
            try encodeContainer.encode(provisionProductId, forKey: .provisionProductId)
        }
        if let provisionProductName = provisionProductName {
            try encodeContainer.encode(provisionProductName, forKey: .provisionProductName)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let provisioningParameters = provisioningParameters {
            var provisioningParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .provisioningParameters)
            for updateprovisioningparameters0 in provisioningParameters {
                try provisioningParametersContainer.encode(updateprovisioningparameters0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let updatedTime = updatedTime {
            try encodeContainer.encode(updatedTime.timeIntervalSince1970, forKey: .updatedTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let pathIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathId)
        pathId = pathIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let planNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .planName)
        planName = planNameDecoded
        let planIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .planId)
        planId = planIdDecoded
        let provisionProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionProductId)
        provisionProductId = provisionProductIdDecoded
        let provisionProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionProductName)
        provisionProductName = provisionProductNameDecoded
        let planTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisionedProductPlanType.self, forKey: .planType)
        planType = planTypeDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisionedProductPlanStatus.self, forKey: .status)
        status = statusDecoded
        let updatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedTime)
        updatedTime = updatedTimeDecoded
        let notificationArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notificationArns)
        var notificationArnsDecoded0:[Swift.String]? = nil
        if let notificationArnsContainer = notificationArnsContainer {
            notificationArnsDecoded0 = [Swift.String]()
            for string0 in notificationArnsContainer {
                if let string0 = string0 {
                    notificationArnsDecoded0?.append(string0)
                }
            }
        }
        notificationArns = notificationArnsDecoded0
        let provisioningParametersContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.UpdateProvisioningParameter?].self, forKey: .provisioningParameters)
        var provisioningParametersDecoded0:[ServiceCatalogClientTypes.UpdateProvisioningParameter]? = nil
        if let provisioningParametersContainer = provisioningParametersContainer {
            provisioningParametersDecoded0 = [ServiceCatalogClientTypes.UpdateProvisioningParameter]()
            for structure0 in provisioningParametersContainer {
                if let structure0 = structure0 {
                    provisioningParametersDecoded0?.append(structure0)
                }
            }
        }
        provisioningParameters = provisioningParametersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension ServiceCatalogClientTypes.ProvisionedProductPlanDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisionedProductPlanDetails(createdTime: \(Swift.String(describing: createdTime)), notificationArns: \(Swift.String(describing: notificationArns)), pathId: \(Swift.String(describing: pathId)), planId: \(Swift.String(describing: planId)), planName: \(Swift.String(describing: planName)), planType: \(Swift.String(describing: planType)), productId: \(Swift.String(describing: productId)), provisionProductId: \(Swift.String(describing: provisionProductId)), provisionProductName: \(Swift.String(describing: provisionProductName)), provisioningArtifactId: \(Swift.String(describing: provisioningArtifactId)), provisioningParameters: \(Swift.String(describing: provisioningParameters)), status: \(Swift.String(describing: status)), statusMessage: \(Swift.String(describing: statusMessage)), tags: \(Swift.String(describing: tags)), updatedTime: \(Swift.String(describing: updatedTime)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a plan.
    public struct ProvisionedProductPlanDetails: Swift.Equatable {
        /// The UTC time stamp of the creation time.
        public var createdTime: ClientRuntime.Date?
        /// Passed to CloudFormation. The SNS topic ARNs to which to publish stack-related
        ///          events.
        public var notificationArns: [Swift.String]?
        /// The path identifier of the product. This value is optional if the product
        ///          has a default path, and required if the product has more than one path.
        ///          To list the paths for a product, use ListLaunchPaths.
        public var pathId: Swift.String?
        /// The plan identifier.
        public var planId: Swift.String?
        /// The name of the plan.
        public var planName: Swift.String?
        /// The plan type.
        public var planType: ServiceCatalogClientTypes.ProvisionedProductPlanType?
        /// The product identifier.
        public var productId: Swift.String?
        /// The product identifier.
        public var provisionProductId: Swift.String?
        /// The user-friendly name of the provisioned product.
        public var provisionProductName: Swift.String?
        /// The identifier of the provisioning artifact.
        public var provisioningArtifactId: Swift.String?
        /// Parameters specified by the administrator that are required for provisioning the
        ///          product.
        public var provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]?
        /// The status.
        public var status: ServiceCatalogClientTypes.ProvisionedProductPlanStatus?
        /// The status message.
        public var statusMessage: Swift.String?
        /// One or more tags.
        public var tags: [ServiceCatalogClientTypes.Tag]?
        /// The time when the plan was last updated.
        public var updatedTime: ClientRuntime.Date?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            notificationArns: [Swift.String]? = nil,
            pathId: Swift.String? = nil,
            planId: Swift.String? = nil,
            planName: Swift.String? = nil,
            planType: ServiceCatalogClientTypes.ProvisionedProductPlanType? = nil,
            productId: Swift.String? = nil,
            provisionProductId: Swift.String? = nil,
            provisionProductName: Swift.String? = nil,
            provisioningArtifactId: Swift.String? = nil,
            provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]? = nil,
            status: ServiceCatalogClientTypes.ProvisionedProductPlanStatus? = nil,
            statusMessage: Swift.String? = nil,
            tags: [ServiceCatalogClientTypes.Tag]? = nil,
            updatedTime: ClientRuntime.Date? = nil
        )
        {
            self.createdTime = createdTime
            self.notificationArns = notificationArns
            self.pathId = pathId
            self.planId = planId
            self.planName = planName
            self.planType = planType
            self.productId = productId
            self.provisionProductId = provisionProductId
            self.provisionProductName = provisionProductName
            self.provisioningArtifactId = provisioningArtifactId
            self.provisioningParameters = provisioningParameters
            self.status = status
            self.statusMessage = statusMessage
            self.tags = tags
            self.updatedTime = updatedTime
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum ProvisionedProductPlanStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createFailed
        case createInProgress
        case createSuccess
        case executeFailed
        case executeInProgress
        case executeSuccess
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedProductPlanStatus] {
            return [
                .createFailed,
                .createInProgress,
                .createSuccess,
                .executeFailed,
                .executeInProgress,
                .executeSuccess,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createFailed: return "CREATE_FAILED"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .createSuccess: return "CREATE_SUCCESS"
            case .executeFailed: return "EXECUTE_FAILED"
            case .executeInProgress: return "EXECUTE_IN_PROGRESS"
            case .executeSuccess: return "EXECUTE_SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisionedProductPlanStatus(rawValue: rawValue) ?? ProvisionedProductPlanStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.ProvisionedProductPlanSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case planId = "PlanId"
        case planName = "PlanName"
        case planType = "PlanType"
        case provisionProductId = "ProvisionProductId"
        case provisionProductName = "ProvisionProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let planId = planId {
            try encodeContainer.encode(planId, forKey: .planId)
        }
        if let planName = planName {
            try encodeContainer.encode(planName, forKey: .planName)
        }
        if let planType = planType {
            try encodeContainer.encode(planType.rawValue, forKey: .planType)
        }
        if let provisionProductId = provisionProductId {
            try encodeContainer.encode(provisionProductId, forKey: .provisionProductId)
        }
        if let provisionProductName = provisionProductName {
            try encodeContainer.encode(provisionProductName, forKey: .provisionProductName)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let planNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .planName)
        planName = planNameDecoded
        let planIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .planId)
        planId = planIdDecoded
        let provisionProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionProductId)
        provisionProductId = provisionProductIdDecoded
        let provisionProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionProductName)
        provisionProductName = provisionProductNameDecoded
        let planTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisionedProductPlanType.self, forKey: .planType)
        planType = planTypeDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
    }
}

extension ServiceCatalogClientTypes.ProvisionedProductPlanSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisionedProductPlanSummary(planId: \(Swift.String(describing: planId)), planName: \(Swift.String(describing: planName)), planType: \(Swift.String(describing: planType)), provisionProductId: \(Swift.String(describing: provisionProductId)), provisionProductName: \(Swift.String(describing: provisionProductName)), provisioningArtifactId: \(Swift.String(describing: provisioningArtifactId)))"}
}

extension ServiceCatalogClientTypes {
    /// Summary information about a plan.
    public struct ProvisionedProductPlanSummary: Swift.Equatable {
        /// The plan identifier.
        public var planId: Swift.String?
        /// The name of the plan.
        public var planName: Swift.String?
        /// The plan type.
        public var planType: ServiceCatalogClientTypes.ProvisionedProductPlanType?
        /// The product identifier.
        public var provisionProductId: Swift.String?
        /// The user-friendly name of the provisioned product.
        public var provisionProductName: Swift.String?
        /// The identifier of the provisioning artifact.
        public var provisioningArtifactId: Swift.String?

        public init (
            planId: Swift.String? = nil,
            planName: Swift.String? = nil,
            planType: ServiceCatalogClientTypes.ProvisionedProductPlanType? = nil,
            provisionProductId: Swift.String? = nil,
            provisionProductName: Swift.String? = nil,
            provisioningArtifactId: Swift.String? = nil
        )
        {
            self.planId = planId
            self.planName = planName
            self.planType = planType
            self.provisionProductId = provisionProductId
            self.provisionProductName = provisionProductName
            self.provisioningArtifactId = provisioningArtifactId
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum ProvisionedProductPlanType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudformation
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedProductPlanType] {
            return [
                .cloudformation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudformation: return "CLOUDFORMATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisionedProductPlanType(rawValue: rawValue) ?? ProvisionedProductPlanType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum ProvisionedProductStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case error
        case planInProgress
        case tainted
        case underChange
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedProductStatus] {
            return [
                .available,
                .error,
                .planInProgress,
                .tainted,
                .underChange,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .error: return "ERROR"
            case .planInProgress: return "PLAN_IN_PROGRESS"
            case .tainted: return "TAINTED"
            case .underChange: return "UNDER_CHANGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisionedProductStatus(rawValue: rawValue) ?? ProvisionedProductStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum ProvisionedProductViewFilterBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case searchquery
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionedProductViewFilterBy] {
            return [
                .searchquery,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .searchquery: return "SearchQuery"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisionedProductViewFilterBy(rawValue: rawValue) ?? ProvisionedProductViewFilterBy.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifact: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case description = "Description"
        case guidance = "Guidance"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let guidance = guidance {
            try encodeContainer.encode(guidance.rawValue, forKey: .guidance)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let guidanceDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactGuidance.self, forKey: .guidance)
        guidance = guidanceDecoded
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisioningArtifact(createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), guidance: \(Swift.String(describing: guidance)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a provisioning artifact. A provisioning artifact is also known as a product version.
    public struct ProvisioningArtifact: Swift.Equatable {
        /// The UTC time stamp of the creation time.
        public var createdTime: ClientRuntime.Date?
        /// The description of the provisioning artifact.
        public var description: Swift.String?
        /// Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.
        public var guidance: ServiceCatalogClientTypes.ProvisioningArtifactGuidance?
        /// The identifier of the provisioning artifact.
        public var id: Swift.String?
        /// The name of the provisioning artifact.
        public var name: Swift.String?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            guidance: ServiceCatalogClientTypes.ProvisioningArtifactGuidance? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.createdTime = createdTime
            self.description = description
            self.guidance = guidance
            self.id = id
            self.name = name
        }
    }

}

extension ServiceCatalogClientTypes.ProvisioningArtifactDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active = "Active"
        case createdTime = "CreatedTime"
        case description = "Description"
        case guidance = "Guidance"
        case id = "Id"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let guidance = guidance {
            try encodeContainer.encode(guidance.rawValue, forKey: .guidance)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactType.self, forKey: .type)
        type = typeDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let guidanceDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactGuidance.self, forKey: .guidance)
        guidance = guidanceDecoded
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifactDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisioningArtifactDetail(active: \(Swift.String(describing: active)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), guidance: \(Swift.String(describing: guidance)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a provisioning artifact (also known as a version) for a product.
    public struct ProvisioningArtifactDetail: Swift.Equatable {
        /// Indicates whether the product version is active.
        public var active: Swift.Bool?
        /// The UTC time stamp of the creation time.
        public var createdTime: ClientRuntime.Date?
        /// The description of the provisioning artifact.
        public var description: Swift.String?
        /// Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.
        public var guidance: ServiceCatalogClientTypes.ProvisioningArtifactGuidance?
        /// The identifier of the provisioning artifact.
        public var id: Swift.String?
        /// The name of the provisioning artifact.
        public var name: Swift.String?
        /// The type of provisioning artifact.
        ///
        ///
        ///
        ///                   CLOUD_FORMATION_TEMPLATE - AWS CloudFormation template
        ///
        ///
        ///
        ///                   MARKETPLACE_AMI - AWS Marketplace AMI
        ///
        ///
        ///
        ///                   MARKETPLACE_CAR - AWS Marketplace Clusters and AWS Resources
        ///
        ///
        public var type: ServiceCatalogClientTypes.ProvisioningArtifactType?

        public init (
            active: Swift.Bool? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            guidance: ServiceCatalogClientTypes.ProvisioningArtifactGuidance? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            type: ServiceCatalogClientTypes.ProvisioningArtifactType? = nil
        )
        {
            self.active = active
            self.createdTime = createdTime
            self.description = description
            self.guidance = guidance
            self.id = id
            self.name = name
            self.type = type
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum ProvisioningArtifactGuidance: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `default`
        case deprecated
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisioningArtifactGuidance] {
            return [
                .default,
                .deprecated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .default: return "DEFAULT"
            case .deprecated: return "DEPRECATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisioningArtifactGuidance(rawValue: rawValue) ?? ProvisioningArtifactGuidance.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifactOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case key = "Key"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifactOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisioningArtifactOutput(description: \(Swift.String(describing: description)), key: \(Swift.String(describing: key)))"}
}

extension ServiceCatalogClientTypes {
    /// Provisioning artifact output.
    public struct ProvisioningArtifactOutput: Swift.Equatable {
        /// Description of the provisioning artifact output key.
        public var description: Swift.String?
        /// The provisioning artifact output key.
        public var key: Swift.String?

        public init (
            description: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.description = description
            self.key = key
        }
    }

}

extension ServiceCatalogClientTypes.ProvisioningArtifactParameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue = "DefaultValue"
        case description = "Description"
        case isNoEcho = "IsNoEcho"
        case parameterConstraints = "ParameterConstraints"
        case parameterKey = "ParameterKey"
        case parameterType = "ParameterType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if isNoEcho != false {
            try encodeContainer.encode(isNoEcho, forKey: .isNoEcho)
        }
        if let parameterConstraints = parameterConstraints {
            try encodeContainer.encode(parameterConstraints, forKey: .parameterConstraints)
        }
        if let parameterKey = parameterKey {
            try encodeContainer.encode(parameterKey, forKey: .parameterKey)
        }
        if let parameterType = parameterType {
            try encodeContainer.encode(parameterType, forKey: .parameterType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterKey)
        parameterKey = parameterKeyDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
        let parameterTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterType)
        parameterType = parameterTypeDecoded
        let isNoEchoDecoded = try containerValues.decode(Swift.Bool.self, forKey: .isNoEcho)
        isNoEcho = isNoEchoDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parameterConstraintsDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ParameterConstraints.self, forKey: .parameterConstraints)
        parameterConstraints = parameterConstraintsDecoded
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifactParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisioningArtifactParameter(defaultValue: \(Swift.String(describing: defaultValue)), description: \(Swift.String(describing: description)), isNoEcho: \(Swift.String(describing: isNoEcho)), parameterConstraints: \(Swift.String(describing: parameterConstraints)), parameterKey: \(Swift.String(describing: parameterKey)), parameterType: \(Swift.String(describing: parameterType)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a parameter used to provision a product.
    public struct ProvisioningArtifactParameter: Swift.Equatable {
        /// The default value.
        public var defaultValue: Swift.String?
        /// The description of the parameter.
        public var description: Swift.String?
        /// If this value is true, the value for this parameter is obfuscated from view when the
        ///          parameter is retrieved. This parameter is used to hide sensitive information.
        public var isNoEcho: Swift.Bool
        /// Constraints that the administrator has put on a parameter.
        public var parameterConstraints: ServiceCatalogClientTypes.ParameterConstraints?
        /// The parameter key.
        public var parameterKey: Swift.String?
        /// The parameter type.
        public var parameterType: Swift.String?

        public init (
            defaultValue: Swift.String? = nil,
            description: Swift.String? = nil,
            isNoEcho: Swift.Bool = false,
            parameterConstraints: ServiceCatalogClientTypes.ParameterConstraints? = nil,
            parameterKey: Swift.String? = nil,
            parameterType: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
            self.description = description
            self.isNoEcho = isNoEcho
            self.parameterConstraints = parameterConstraints
            self.parameterKey = parameterKey
            self.parameterType = parameterType
        }
    }

}

extension ServiceCatalogClientTypes.ProvisioningArtifactPreferences: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackSetAccounts = "StackSetAccounts"
        case stackSetRegions = "StackSetRegions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackSetAccounts = stackSetAccounts {
            var stackSetAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackSetAccounts)
            for stacksetaccounts0 in stackSetAccounts {
                try stackSetAccountsContainer.encode(stacksetaccounts0)
            }
        }
        if let stackSetRegions = stackSetRegions {
            var stackSetRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackSetRegions)
            for stacksetregions0 in stackSetRegions {
                try stackSetRegionsContainer.encode(stacksetregions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackSetAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackSetAccounts)
        var stackSetAccountsDecoded0:[Swift.String]? = nil
        if let stackSetAccountsContainer = stackSetAccountsContainer {
            stackSetAccountsDecoded0 = [Swift.String]()
            for string0 in stackSetAccountsContainer {
                if let string0 = string0 {
                    stackSetAccountsDecoded0?.append(string0)
                }
            }
        }
        stackSetAccounts = stackSetAccountsDecoded0
        let stackSetRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackSetRegions)
        var stackSetRegionsDecoded0:[Swift.String]? = nil
        if let stackSetRegionsContainer = stackSetRegionsContainer {
            stackSetRegionsDecoded0 = [Swift.String]()
            for string0 in stackSetRegionsContainer {
                if let string0 = string0 {
                    stackSetRegionsDecoded0?.append(string0)
                }
            }
        }
        stackSetRegions = stackSetRegionsDecoded0
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifactPreferences: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisioningArtifactPreferences(stackSetAccounts: \(Swift.String(describing: stackSetAccounts)), stackSetRegions: \(Swift.String(describing: stackSetRegions)))"}
}

extension ServiceCatalogClientTypes {
    /// The user-defined preferences that will be applied during product provisioning, unless overridden by ProvisioningPreferences or UpdateProvisioningPreferences.
    ///          For more information on maximum concurrent accounts and failure tolerance, see <a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/stacksets-concepts.html#stackset-ops-options">Stack set operation options in the AWS CloudFormation User Guide.
    public struct ProvisioningArtifactPreferences: Swift.Equatable {
        /// One or more AWS accounts where stack instances are deployed from the stack set. These accounts can be scoped in ProvisioningPreferences$StackSetAccounts and UpdateProvisioningPreferences$StackSetAccounts.
        ///          Applicable only to a CFN_STACKSET provisioned product type.
        public var stackSetAccounts: [Swift.String]?
        /// One or more AWS Regions where stack instances are deployed from the stack set. These regions can be scoped in ProvisioningPreferences$StackSetRegions and UpdateProvisioningPreferences$StackSetRegions.
        ///          Applicable only to a CFN_STACKSET provisioned product type.
        public var stackSetRegions: [Swift.String]?

        public init (
            stackSetAccounts: [Swift.String]? = nil,
            stackSetRegions: [Swift.String]? = nil
        )
        {
            self.stackSetAccounts = stackSetAccounts
            self.stackSetRegions = stackSetRegions
        }
    }

}

extension ServiceCatalogClientTypes.ProvisioningArtifactProperties: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case disableTemplateValidation = "DisableTemplateValidation"
        case info = "Info"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if disableTemplateValidation != false {
            try encodeContainer.encode(disableTemplateValidation, forKey: .disableTemplateValidation)
        }
        if let info = info {
            var infoContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .info)
            for (dictKey0, provisioningartifactinfo0) in info {
                try infoContainer.encode(provisioningartifactinfo0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let infoContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .info)
        var infoDecoded0: [Swift.String:Swift.String]? = nil
        if let infoContainer = infoContainer {
            infoDecoded0 = [Swift.String:Swift.String]()
            for (key0, provisioningartifactinfovalue0) in infoContainer {
                if let provisioningartifactinfovalue0 = provisioningartifactinfovalue0 {
                    infoDecoded0?[key0] = provisioningartifactinfovalue0
                }
            }
        }
        info = infoDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactType.self, forKey: .type)
        type = typeDecoded
        let disableTemplateValidationDecoded = try containerValues.decode(Swift.Bool.self, forKey: .disableTemplateValidation)
        disableTemplateValidation = disableTemplateValidationDecoded
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifactProperties: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisioningArtifactProperties(description: \(Swift.String(describing: description)), disableTemplateValidation: \(Swift.String(describing: disableTemplateValidation)), info: \(Swift.String(describing: info)), name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a provisioning artifact (also known as a version) for a product.
    public struct ProvisioningArtifactProperties: Swift.Equatable {
        /// The description of the provisioning artifact, including how it differs from the previous provisioning artifact.
        public var description: Swift.String?
        /// If set to true, AWS Service Catalog stops validating the specified provisioning artifact even if it is invalid.
        public var disableTemplateValidation: Swift.Bool
        /// Specify the template source with one of the following options, but not both.
        ///          Keys accepted: [ LoadTemplateFromURL, ImportFromPhysicalId ]
        ///          The URL of the CloudFormation template in Amazon S3. Specify the URL in JSON format as follows:
        ///
        ///             "LoadTemplateFromURL": "https://s3.amazonaws.com/cf-templates-ozkq9d3hgiq2-us-east-1/..."
        ///
        ///
        ///             ImportFromPhysicalId: The physical id of the resource that contains the
        ///          template. Currently only supports CloudFormation stack arn. Specify the physical id in JSON
        ///          format as follows: ImportFromPhysicalId: arn:aws:cloudformation:[us-east-1]:[accountId]:stack/[StackName]/[resourceId]
        ///
        /// This member is required.
        public var info: [Swift.String:Swift.String]?
        /// The name of the provisioning artifact (for example, v1 v2beta). No spaces are allowed.
        public var name: Swift.String?
        /// The type of provisioning artifact.
        ///
        ///
        ///
        ///                   CLOUD_FORMATION_TEMPLATE - AWS CloudFormation template
        ///
        ///
        ///
        ///                   MARKETPLACE_AMI - AWS Marketplace AMI
        ///
        ///
        ///
        ///                   MARKETPLACE_CAR - AWS Marketplace Clusters and AWS Resources
        ///
        ///
        public var type: ServiceCatalogClientTypes.ProvisioningArtifactType?

        public init (
            description: Swift.String? = nil,
            disableTemplateValidation: Swift.Bool = false,
            info: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            type: ServiceCatalogClientTypes.ProvisioningArtifactType? = nil
        )
        {
            self.description = description
            self.disableTemplateValidation = disableTemplateValidation
            self.info = info
            self.name = name
            self.type = type
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum ProvisioningArtifactPropertyName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case id
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisioningArtifactPropertyName] {
            return [
                .id,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .id: return "Id"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisioningArtifactPropertyName(rawValue: rawValue) ?? ProvisioningArtifactPropertyName.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifactSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case description = "Description"
        case id = "Id"
        case name = "Name"
        case provisioningArtifactMetadata = "ProvisioningArtifactMetadata"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provisioningArtifactMetadata = provisioningArtifactMetadata {
            var provisioningArtifactMetadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .provisioningArtifactMetadata)
            for (dictKey0, provisioningartifactinfo0) in provisioningArtifactMetadata {
                try provisioningArtifactMetadataContainer.encode(provisioningartifactinfo0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let provisioningArtifactMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .provisioningArtifactMetadata)
        var provisioningArtifactMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let provisioningArtifactMetadataContainer = provisioningArtifactMetadataContainer {
            provisioningArtifactMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, provisioningartifactinfovalue0) in provisioningArtifactMetadataContainer {
                if let provisioningartifactinfovalue0 = provisioningartifactinfovalue0 {
                    provisioningArtifactMetadataDecoded0?[key0] = provisioningartifactinfovalue0
                }
            }
        }
        provisioningArtifactMetadata = provisioningArtifactMetadataDecoded0
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifactSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisioningArtifactSummary(createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), provisioningArtifactMetadata: \(Swift.String(describing: provisioningArtifactMetadata)))"}
}

extension ServiceCatalogClientTypes {
    /// Summary information about a provisioning artifact (also known as a version) for a product.
    public struct ProvisioningArtifactSummary: Swift.Equatable {
        /// The UTC time stamp of the creation time.
        public var createdTime: ClientRuntime.Date?
        /// The description of the provisioning artifact.
        public var description: Swift.String?
        /// The identifier of the provisioning artifact.
        public var id: Swift.String?
        /// The name of the provisioning artifact.
        public var name: Swift.String?
        /// The metadata for the provisioning artifact. This is used with AWS Marketplace products.
        public var provisioningArtifactMetadata: [Swift.String:Swift.String]?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            provisioningArtifactMetadata: [Swift.String:Swift.String]? = nil
        )
        {
            self.createdTime = createdTime
            self.description = description
            self.id = id
            self.name = name
            self.provisioningArtifactMetadata = provisioningArtifactMetadata
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum ProvisioningArtifactType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudFormationTemplate
        case marketplaceAmi
        case marketplaceCar
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisioningArtifactType] {
            return [
                .cloudFormationTemplate,
                .marketplaceAmi,
                .marketplaceCar,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudFormationTemplate: return "CLOUD_FORMATION_TEMPLATE"
            case .marketplaceAmi: return "MARKETPLACE_AMI"
            case .marketplaceCar: return "MARKETPLACE_CAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisioningArtifactType(rawValue: rawValue) ?? ProvisioningArtifactType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifactView: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productViewSummary = "ProductViewSummary"
        case provisioningArtifact = "ProvisioningArtifact"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productViewSummary = productViewSummary {
            try encodeContainer.encode(productViewSummary, forKey: .productViewSummary)
        }
        if let provisioningArtifact = provisioningArtifact {
            try encodeContainer.encode(provisioningArtifact, forKey: .provisioningArtifact)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewSummaryDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductViewSummary.self, forKey: .productViewSummary)
        productViewSummary = productViewSummaryDecoded
        let provisioningArtifactDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifact.self, forKey: .provisioningArtifact)
        provisioningArtifact = provisioningArtifactDecoded
    }
}

extension ServiceCatalogClientTypes.ProvisioningArtifactView: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisioningArtifactView(productViewSummary: \(Swift.String(describing: productViewSummary)), provisioningArtifact: \(Swift.String(describing: provisioningArtifact)))"}
}

extension ServiceCatalogClientTypes {
    /// An object that contains summary information about a product view and a provisioning artifact.
    public struct ProvisioningArtifactView: Swift.Equatable {
        /// Summary information about a product view.
        public var productViewSummary: ServiceCatalogClientTypes.ProductViewSummary?
        /// Information about a provisioning artifact. A provisioning artifact is also known as a product version.
        public var provisioningArtifact: ServiceCatalogClientTypes.ProvisioningArtifact?

        public init (
            productViewSummary: ServiceCatalogClientTypes.ProductViewSummary? = nil,
            provisioningArtifact: ServiceCatalogClientTypes.ProvisioningArtifact? = nil
        )
        {
            self.productViewSummary = productViewSummary
            self.provisioningArtifact = provisioningArtifact
        }
    }

}

extension ServiceCatalogClientTypes.ProvisioningParameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceCatalogClientTypes.ProvisioningParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisioningParameter(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a parameter used to provision a product.
    public struct ProvisioningParameter: Swift.Equatable {
        /// The parameter key.
        public var key: Swift.String?
        /// The parameter value.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ServiceCatalogClientTypes.ProvisioningPreferences: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackSetAccounts = "StackSetAccounts"
        case stackSetFailureToleranceCount = "StackSetFailureToleranceCount"
        case stackSetFailureTolerancePercentage = "StackSetFailureTolerancePercentage"
        case stackSetMaxConcurrencyCount = "StackSetMaxConcurrencyCount"
        case stackSetMaxConcurrencyPercentage = "StackSetMaxConcurrencyPercentage"
        case stackSetRegions = "StackSetRegions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackSetAccounts = stackSetAccounts {
            var stackSetAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackSetAccounts)
            for stacksetaccounts0 in stackSetAccounts {
                try stackSetAccountsContainer.encode(stacksetaccounts0)
            }
        }
        if let stackSetFailureToleranceCount = stackSetFailureToleranceCount {
            try encodeContainer.encode(stackSetFailureToleranceCount, forKey: .stackSetFailureToleranceCount)
        }
        if let stackSetFailureTolerancePercentage = stackSetFailureTolerancePercentage {
            try encodeContainer.encode(stackSetFailureTolerancePercentage, forKey: .stackSetFailureTolerancePercentage)
        }
        if let stackSetMaxConcurrencyCount = stackSetMaxConcurrencyCount {
            try encodeContainer.encode(stackSetMaxConcurrencyCount, forKey: .stackSetMaxConcurrencyCount)
        }
        if let stackSetMaxConcurrencyPercentage = stackSetMaxConcurrencyPercentage {
            try encodeContainer.encode(stackSetMaxConcurrencyPercentage, forKey: .stackSetMaxConcurrencyPercentage)
        }
        if let stackSetRegions = stackSetRegions {
            var stackSetRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackSetRegions)
            for stacksetregions0 in stackSetRegions {
                try stackSetRegionsContainer.encode(stacksetregions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackSetAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackSetAccounts)
        var stackSetAccountsDecoded0:[Swift.String]? = nil
        if let stackSetAccountsContainer = stackSetAccountsContainer {
            stackSetAccountsDecoded0 = [Swift.String]()
            for string0 in stackSetAccountsContainer {
                if let string0 = string0 {
                    stackSetAccountsDecoded0?.append(string0)
                }
            }
        }
        stackSetAccounts = stackSetAccountsDecoded0
        let stackSetRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackSetRegions)
        var stackSetRegionsDecoded0:[Swift.String]? = nil
        if let stackSetRegionsContainer = stackSetRegionsContainer {
            stackSetRegionsDecoded0 = [Swift.String]()
            for string0 in stackSetRegionsContainer {
                if let string0 = string0 {
                    stackSetRegionsDecoded0?.append(string0)
                }
            }
        }
        stackSetRegions = stackSetRegionsDecoded0
        let stackSetFailureToleranceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stackSetFailureToleranceCount)
        stackSetFailureToleranceCount = stackSetFailureToleranceCountDecoded
        let stackSetFailureTolerancePercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stackSetFailureTolerancePercentage)
        stackSetFailureTolerancePercentage = stackSetFailureTolerancePercentageDecoded
        let stackSetMaxConcurrencyCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stackSetMaxConcurrencyCount)
        stackSetMaxConcurrencyCount = stackSetMaxConcurrencyCountDecoded
        let stackSetMaxConcurrencyPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stackSetMaxConcurrencyPercentage)
        stackSetMaxConcurrencyPercentage = stackSetMaxConcurrencyPercentageDecoded
    }
}

extension ServiceCatalogClientTypes.ProvisioningPreferences: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProvisioningPreferences(stackSetAccounts: \(Swift.String(describing: stackSetAccounts)), stackSetFailureToleranceCount: \(Swift.String(describing: stackSetFailureToleranceCount)), stackSetFailureTolerancePercentage: \(Swift.String(describing: stackSetFailureTolerancePercentage)), stackSetMaxConcurrencyCount: \(Swift.String(describing: stackSetMaxConcurrencyCount)), stackSetMaxConcurrencyPercentage: \(Swift.String(describing: stackSetMaxConcurrencyPercentage)), stackSetRegions: \(Swift.String(describing: stackSetRegions)))"}
}

extension ServiceCatalogClientTypes {
    /// The user-defined preferences that will be applied when updating a provisioned
    ///          product. Not all preferences are applicable to all provisioned product type
    ///          One or more AWS accounts that will have access to the provisioned product.
    ///          Applicable only to a CFN_STACKSET provisioned product type.
    ///          The AWS accounts specified should be within the list of accounts in the
    ///             STACKSET constraint. To get the list of accounts in the
    ///             STACKSET constraint, use the DescribeProvisioningParameters
    ///          operation.
    ///          If no values are specified, the default value is all accounts from the
    ///             STACKSET constraint.
    public struct ProvisioningPreferences: Swift.Equatable {
        /// One or more AWS accounts where the provisioned product will be available.
        ///          Applicable only to a CFN_STACKSET provisioned product type.
        ///          The specified accounts should be within the list of accounts from the STACKSET constraint. To get the list of accounts in the STACKSET constraint, use the DescribeProvisioningParameters operation.
        ///          If no values are specified, the default value is all acounts from the STACKSET constraint.
        public var stackSetAccounts: [Swift.String]?
        /// The number of accounts, per region, for which this operation can fail before AWS Service Catalog stops the operation in that region. If the operation is stopped in a region, AWS Service Catalog doesn't attempt the operation in any subsequent regions.
        ///          Applicable only to a CFN_STACKSET provisioned product type.
        ///          Conditional: You must specify either StackSetFailureToleranceCount or StackSetFailureTolerancePercentage, but not both.
        ///          The default value is 0 if no value is specified.
        public var stackSetFailureToleranceCount: Swift.Int?
        /// The percentage of accounts, per region, for which this stack operation can fail before AWS Service Catalog stops the operation in that region. If the operation is stopped in a region, AWS Service Catalog doesn't attempt the operation in any subsequent regions.
        ///          When calculating the number of accounts based on the specified percentage, AWS Service Catalog rounds down to the next whole number.
        ///          Applicable only to a CFN_STACKSET provisioned product type.
        ///          Conditional: You must specify either StackSetFailureToleranceCount or StackSetFailureTolerancePercentage, but not both.
        public var stackSetFailureTolerancePercentage: Swift.Int?
        /// The maximum number of accounts in which to perform this operation at one time. This is dependent on the value of StackSetFailureToleranceCount. StackSetMaxConcurrentCount is at most one more than the StackSetFailureToleranceCount.
        ///          Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.
        ///          Applicable only to a CFN_STACKSET provisioned product type.
        ///          Conditional: You must specify either StackSetMaxConcurrentCount or StackSetMaxConcurrentPercentage, but not both.
        public var stackSetMaxConcurrencyCount: Swift.Int?
        /// The maximum percentage of accounts in which to perform this operation at one time.
        ///          When calculating the number of accounts based on the specified percentage, AWS Service Catalog rounds down to the next whole number. This is true except in cases where rounding down would result is zero. In this case, AWS Service Catalog sets the number as 1 instead.
        ///          Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.
        ///          Applicable only to a CFN_STACKSET provisioned product type.
        ///          Conditional: You must specify either StackSetMaxConcurrentCount or StackSetMaxConcurrentPercentage, but not both.
        public var stackSetMaxConcurrencyPercentage: Swift.Int?
        /// One or more AWS Regions where the provisioned product will be available.
        ///          Applicable only to a CFN_STACKSET provisioned product type.
        ///          The specified regions should be within the list of regions from the STACKSET constraint. To get the list of regions in the STACKSET constraint, use the DescribeProvisioningParameters operation.
        ///          If no values are specified, the default value is all regions from the STACKSET constraint.
        public var stackSetRegions: [Swift.String]?

        public init (
            stackSetAccounts: [Swift.String]? = nil,
            stackSetFailureToleranceCount: Swift.Int? = nil,
            stackSetFailureTolerancePercentage: Swift.Int? = nil,
            stackSetMaxConcurrencyCount: Swift.Int? = nil,
            stackSetMaxConcurrencyPercentage: Swift.Int? = nil,
            stackSetRegions: [Swift.String]? = nil
        )
        {
            self.stackSetAccounts = stackSetAccounts
            self.stackSetFailureToleranceCount = stackSetFailureToleranceCount
            self.stackSetFailureTolerancePercentage = stackSetFailureTolerancePercentage
            self.stackSetMaxConcurrencyCount = stackSetMaxConcurrencyCount
            self.stackSetMaxConcurrencyPercentage = stackSetMaxConcurrencyPercentage
            self.stackSetRegions = stackSetRegions
        }
    }

}

extension ServiceCatalogClientTypes.RecordDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case launchRoleArn = "LaunchRoleArn"
        case pathId = "PathId"
        case productId = "ProductId"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisionedProductType = "ProvisionedProductType"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case recordErrors = "RecordErrors"
        case recordId = "RecordId"
        case recordTags = "RecordTags"
        case recordType = "RecordType"
        case status = "Status"
        case updatedTime = "UpdatedTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let launchRoleArn = launchRoleArn {
            try encodeContainer.encode(launchRoleArn, forKey: .launchRoleArn)
        }
        if let pathId = pathId {
            try encodeContainer.encode(pathId, forKey: .pathId)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisionedProductId = provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
        if let provisionedProductName = provisionedProductName {
            try encodeContainer.encode(provisionedProductName, forKey: .provisionedProductName)
        }
        if let provisionedProductType = provisionedProductType {
            try encodeContainer.encode(provisionedProductType, forKey: .provisionedProductType)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let recordErrors = recordErrors {
            var recordErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordErrors)
            for recorderrors0 in recordErrors {
                try recordErrorsContainer.encode(recorderrors0)
            }
        }
        if let recordId = recordId {
            try encodeContainer.encode(recordId, forKey: .recordId)
        }
        if let recordTags = recordTags {
            var recordTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recordTags)
            for recordtags0 in recordTags {
                try recordTagsContainer.encode(recordtags0)
            }
        }
        if let recordType = recordType {
            try encodeContainer.encode(recordType, forKey: .recordType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedTime = updatedTime {
            try encodeContainer.encode(updatedTime.timeIntervalSince1970, forKey: .updatedTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordId)
        recordId = recordIdDecoded
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.RecordStatus.self, forKey: .status)
        status = statusDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let updatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .updatedTime)
        updatedTime = updatedTimeDecoded
        let provisionedProductTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductType)
        provisionedProductType = provisionedProductTypeDecoded
        let recordTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordType)
        recordType = recordTypeDecoded
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let pathIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathId)
        pathId = pathIdDecoded
        let recordErrorsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.RecordError?].self, forKey: .recordErrors)
        var recordErrorsDecoded0:[ServiceCatalogClientTypes.RecordError]? = nil
        if let recordErrorsContainer = recordErrorsContainer {
            recordErrorsDecoded0 = [ServiceCatalogClientTypes.RecordError]()
            for structure0 in recordErrorsContainer {
                if let structure0 = structure0 {
                    recordErrorsDecoded0?.append(structure0)
                }
            }
        }
        recordErrors = recordErrorsDecoded0
        let recordTagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.RecordTag?].self, forKey: .recordTags)
        var recordTagsDecoded0:[ServiceCatalogClientTypes.RecordTag]? = nil
        if let recordTagsContainer = recordTagsContainer {
            recordTagsDecoded0 = [ServiceCatalogClientTypes.RecordTag]()
            for structure0 in recordTagsContainer {
                if let structure0 = structure0 {
                    recordTagsDecoded0?.append(structure0)
                }
            }
        }
        recordTags = recordTagsDecoded0
        let launchRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchRoleArn)
        launchRoleArn = launchRoleArnDecoded
    }
}

extension ServiceCatalogClientTypes.RecordDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecordDetail(createdTime: \(Swift.String(describing: createdTime)), launchRoleArn: \(Swift.String(describing: launchRoleArn)), pathId: \(Swift.String(describing: pathId)), productId: \(Swift.String(describing: productId)), provisionedProductId: \(Swift.String(describing: provisionedProductId)), provisionedProductName: \(Swift.String(describing: provisionedProductName)), provisionedProductType: \(Swift.String(describing: provisionedProductType)), provisioningArtifactId: \(Swift.String(describing: provisioningArtifactId)), recordErrors: \(Swift.String(describing: recordErrors)), recordId: \(Swift.String(describing: recordId)), recordTags: \(Swift.String(describing: recordTags)), recordType: \(Swift.String(describing: recordType)), status: \(Swift.String(describing: status)), updatedTime: \(Swift.String(describing: updatedTime)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a request operation.
    public struct RecordDetail: Swift.Equatable {
        /// The UTC time stamp of the creation time.
        public var createdTime: ClientRuntime.Date?
        /// The ARN of the launch role associated with the provisioned product.
        public var launchRoleArn: Swift.String?
        /// The path identifier.
        public var pathId: Swift.String?
        /// The product identifier.
        public var productId: Swift.String?
        /// The identifier of the provisioned product.
        public var provisionedProductId: Swift.String?
        /// The user-friendly name of the provisioned product.
        public var provisionedProductName: Swift.String?
        /// The type of provisioned product. The supported values are CFN_STACK and CFN_STACKSET.
        public var provisionedProductType: Swift.String?
        /// The identifier of the provisioning artifact.
        public var provisioningArtifactId: Swift.String?
        /// The errors that occurred.
        public var recordErrors: [ServiceCatalogClientTypes.RecordError]?
        /// The identifier of the record.
        public var recordId: Swift.String?
        /// One or more tags.
        public var recordTags: [ServiceCatalogClientTypes.RecordTag]?
        /// The record type.
        ///
        ///
        ///
        ///                   PROVISION_PRODUCT
        ///
        ///
        ///
        ///
        ///                   UPDATE_PROVISIONED_PRODUCT
        ///
        ///
        ///
        ///
        ///                   TERMINATE_PROVISIONED_PRODUCT
        ///
        ///
        ///
        public var recordType: Swift.String?
        /// The status of the provisioned product.
        ///
        ///
        ///
        ///                   CREATED - The request was created but the operation has not started.
        ///
        ///
        ///
        ///                   IN_PROGRESS - The requested operation is in progress.
        ///
        ///
        ///
        ///                   IN_PROGRESS_IN_ERROR - The provisioned product is under change but the
        ///             requested operation failed and some remediation is occurring. For example, a rollback.
        ///
        ///
        ///
        ///                   SUCCEEDED - The requested operation has successfully completed.
        ///
        ///
        ///
        ///                   FAILED - The requested operation has unsuccessfully completed.
        ///             Investigate using the error messages returned.
        ///
        ///
        public var status: ServiceCatalogClientTypes.RecordStatus?
        /// The time when the record was last updated.
        public var updatedTime: ClientRuntime.Date?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            launchRoleArn: Swift.String? = nil,
            pathId: Swift.String? = nil,
            productId: Swift.String? = nil,
            provisionedProductId: Swift.String? = nil,
            provisionedProductName: Swift.String? = nil,
            provisionedProductType: Swift.String? = nil,
            provisioningArtifactId: Swift.String? = nil,
            recordErrors: [ServiceCatalogClientTypes.RecordError]? = nil,
            recordId: Swift.String? = nil,
            recordTags: [ServiceCatalogClientTypes.RecordTag]? = nil,
            recordType: Swift.String? = nil,
            status: ServiceCatalogClientTypes.RecordStatus? = nil,
            updatedTime: ClientRuntime.Date? = nil
        )
        {
            self.createdTime = createdTime
            self.launchRoleArn = launchRoleArn
            self.pathId = pathId
            self.productId = productId
            self.provisionedProductId = provisionedProductId
            self.provisionedProductName = provisionedProductName
            self.provisionedProductType = provisionedProductType
            self.provisioningArtifactId = provisioningArtifactId
            self.recordErrors = recordErrors
            self.recordId = recordId
            self.recordTags = recordTags
            self.recordType = recordType
            self.status = status
            self.updatedTime = updatedTime
        }
    }

}

extension ServiceCatalogClientTypes.RecordError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case description = "Description"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ServiceCatalogClientTypes.RecordError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecordError(code: \(Swift.String(describing: code)), description: \(Swift.String(describing: description)))"}
}

extension ServiceCatalogClientTypes {
    /// The error code and description resulting from an operation.
    public struct RecordError: Swift.Equatable {
        /// The numeric value of the error.
        public var code: Swift.String?
        /// The description of the error.
        public var description: Swift.String?

        public init (
            code: Swift.String? = nil,
            description: Swift.String? = nil
        )
        {
            self.code = code
            self.description = description
        }
    }

}

extension ServiceCatalogClientTypes.RecordOutput: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case outputKey = "OutputKey"
        case outputValue = "OutputValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let outputKey = outputKey {
            try encodeContainer.encode(outputKey, forKey: .outputKey)
        }
        if let outputValue = outputValue {
            try encodeContainer.encode(outputValue, forKey: .outputValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputKey)
        outputKey = outputKeyDecoded
        let outputValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputValue)
        outputValue = outputValueDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ServiceCatalogClientTypes.RecordOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecordOutput(description: \(Swift.String(describing: description)), outputKey: \(Swift.String(describing: outputKey)), outputValue: \(Swift.String(describing: outputValue)))"}
}

extension ServiceCatalogClientTypes {
    /// The output for the product created as the result of a request. For example, the output for
    ///          a CloudFormation-backed product that creates an S3 bucket would include the S3 bucket URL.
    public struct RecordOutput: Swift.Equatable {
        /// The description of the output.
        public var description: Swift.String?
        /// The output key.
        public var outputKey: Swift.String?
        /// The output value.
        public var outputValue: Swift.String?

        public init (
            description: Swift.String? = nil,
            outputKey: Swift.String? = nil,
            outputValue: Swift.String? = nil
        )
        {
            self.description = description
            self.outputKey = outputKey
            self.outputValue = outputValue
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum RecordStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case failed
        case inProgress
        case inProgressInError
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordStatus] {
            return [
                .created,
                .failed,
                .inProgress,
                .inProgressInError,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .inProgressInError: return "IN_PROGRESS_IN_ERROR"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecordStatus(rawValue: rawValue) ?? RecordStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.RecordTag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceCatalogClientTypes.RecordTag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecordTag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a tag, which is a key-value pair.
    public struct RecordTag: Swift.Equatable {
        /// The key for this tag.
        public var key: Swift.String?
        /// The value for this tag.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct RejectPortfolioShareInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectPortfolioShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectPortfolioShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectPortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectPortfolioShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectPortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectPortfolioShareOutputError>
}

extension RejectPortfolioShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectPortfolioShareInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), portfolioId: \(Swift.String(describing: portfolioId)), portfolioShareType: \(Swift.String(describing: portfolioShareType)))"}
}

extension RejectPortfolioShareInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case portfolioShareType = "PortfolioShareType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let portfolioShareType = portfolioShareType {
            try encodeContainer.encode(portfolioShareType.rawValue, forKey: .portfolioShareType)
        }
    }
}

public struct RejectPortfolioShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectPortfolioShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectPortfolioShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectPortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectPortfolioShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectPortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectPortfolioShareOutputError>
}

public struct RejectPortfolioShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectPortfolioShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RejectPortfolioShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectPortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RejectPortfolioShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RejectPortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectPortfolioShareOutputError>
}

public struct RejectPortfolioShareInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RejectPortfolioShareInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: RejectPortfolioShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RejectPortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = RejectPortfolioShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<RejectPortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RejectPortfolioShareOutputError>
}

public struct RejectPortfolioShareInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// The type of shared portfolios to reject. The default is to reject imported portfolios.
    ///
    ///
    ///
    ///                   AWS_ORGANIZATIONS - Reject portfolios shared by the management account of your
    ///                organization.
    ///
    ///
    ///
    ///                   IMPORTED - Reject imported portfolios.
    ///
    ///
    ///
    ///                   AWS_SERVICECATALOG - Not supported. (Throws ResourceNotFoundException.)
    ///
    ///
    ///          For example, aws servicecatalog reject-portfolio-share --portfolio-id "port-2qwzkwxt3y5fk" --portfolio-share-type AWS_ORGANIZATIONS
    ///
    public var portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType?

    public init (
        acceptLanguage: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.portfolioId = portfolioId
        self.portfolioShareType = portfolioShareType
    }
}

struct RejectPortfolioShareInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let portfolioId: Swift.String?
    public let portfolioShareType: ServiceCatalogClientTypes.PortfolioShareType?
}

extension RejectPortfolioShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case portfolioId = "PortfolioId"
        case portfolioShareType = "PortfolioShareType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let portfolioShareTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.PortfolioShareType.self, forKey: .portfolioShareType)
        portfolioShareType = portfolioShareTypeDecoded
    }
}

extension RejectPortfolioShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectPortfolioShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RejectPortfolioShareOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectPortfolioShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectPortfolioShareOutputResponse()"}
}

extension RejectPortfolioShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RejectPortfolioShareOutputResponse: Swift.Equatable {

    public init() {}
}

struct RejectPortfolioShareOutputResponseBody: Swift.Equatable {
}

extension RejectPortfolioShareOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ServiceCatalogClientTypes {
    public enum Replacement: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case conditional
        case `false`
        case `true`
        case sdkUnknown(Swift.String)

        public static var allCases: [Replacement] {
            return [
                .conditional,
                .false,
                .true,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .conditional: return "CONDITIONAL"
            case .false: return "FALSE"
            case .true: return "TRUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Replacement(rawValue: rawValue) ?? Replacement.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum RequiresRecreation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case always
        case conditionally
        case never
        case sdkUnknown(Swift.String)

        public static var allCases: [RequiresRecreation] {
            return [
                .always,
                .conditionally,
                .never,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .always: return "ALWAYS"
            case .conditionally: return "CONDITIONALLY"
            case .never: return "NEVER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RequiresRecreation(rawValue: rawValue) ?? RequiresRecreation.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum ResourceAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creationpolicy
        case deletionpolicy
        case metadata
        case properties
        case tags
        case updatepolicy
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceAttribute] {
            return [
                .creationpolicy,
                .deletionpolicy,
                .metadata,
                .properties,
                .tags,
                .updatepolicy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creationpolicy: return "CREATIONPOLICY"
            case .deletionpolicy: return "DELETIONPOLICY"
            case .metadata: return "METADATA"
            case .properties: return "PROPERTIES"
            case .tags: return "TAGS"
            case .updatepolicy: return "UPDATEPOLICY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceAttribute(rawValue: rawValue) ?? ResourceAttribute.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.ResourceChange: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case details = "Details"
        case logicalResourceId = "LogicalResourceId"
        case physicalResourceId = "PhysicalResourceId"
        case replacement = "Replacement"
        case resourceType = "ResourceType"
        case scope = "Scope"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let details = details {
            var detailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .details)
            for resourcechangedetails0 in details {
                try detailsContainer.encode(resourcechangedetails0)
            }
        }
        if let logicalResourceId = logicalResourceId {
            try encodeContainer.encode(logicalResourceId, forKey: .logicalResourceId)
        }
        if let physicalResourceId = physicalResourceId {
            try encodeContainer.encode(physicalResourceId, forKey: .physicalResourceId)
        }
        if let replacement = replacement {
            try encodeContainer.encode(replacement.rawValue, forKey: .replacement)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let scope = scope {
            var scopeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scope)
            for scope0 in scope {
                try scopeContainer.encode(scope0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ChangeAction.self, forKey: .action)
        action = actionDecoded
        let logicalResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logicalResourceId)
        logicalResourceId = logicalResourceIdDecoded
        let physicalResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .physicalResourceId)
        physicalResourceId = physicalResourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let replacementDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.Replacement.self, forKey: .replacement)
        replacement = replacementDecoded
        let scopeContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ResourceAttribute?].self, forKey: .scope)
        var scopeDecoded0:[ServiceCatalogClientTypes.ResourceAttribute]? = nil
        if let scopeContainer = scopeContainer {
            scopeDecoded0 = [ServiceCatalogClientTypes.ResourceAttribute]()
            for string0 in scopeContainer {
                if let string0 = string0 {
                    scopeDecoded0?.append(string0)
                }
            }
        }
        scope = scopeDecoded0
        let detailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ResourceChangeDetail?].self, forKey: .details)
        var detailsDecoded0:[ServiceCatalogClientTypes.ResourceChangeDetail]? = nil
        if let detailsContainer = detailsContainer {
            detailsDecoded0 = [ServiceCatalogClientTypes.ResourceChangeDetail]()
            for structure0 in detailsContainer {
                if let structure0 = structure0 {
                    detailsDecoded0?.append(structure0)
                }
            }
        }
        details = detailsDecoded0
    }
}

extension ServiceCatalogClientTypes.ResourceChange: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceChange(action: \(Swift.String(describing: action)), details: \(Swift.String(describing: details)), logicalResourceId: \(Swift.String(describing: logicalResourceId)), physicalResourceId: \(Swift.String(describing: physicalResourceId)), replacement: \(Swift.String(describing: replacement)), resourceType: \(Swift.String(describing: resourceType)), scope: \(Swift.String(describing: scope)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a resource change that will occur when a plan is executed.
    public struct ResourceChange: Swift.Equatable {
        /// The change action.
        public var action: ServiceCatalogClientTypes.ChangeAction?
        /// Information about the resource changes.
        public var details: [ServiceCatalogClientTypes.ResourceChangeDetail]?
        /// The ID of the resource, as defined in the CloudFormation template.
        public var logicalResourceId: Swift.String?
        /// The ID of the resource, if it was already created.
        public var physicalResourceId: Swift.String?
        /// If the change type is Modify, indicates whether the existing resource
        ///          is deleted and replaced with a new one.
        public var replacement: ServiceCatalogClientTypes.Replacement?
        /// The type of resource.
        public var resourceType: Swift.String?
        /// The change scope.
        public var scope: [ServiceCatalogClientTypes.ResourceAttribute]?

        public init (
            action: ServiceCatalogClientTypes.ChangeAction? = nil,
            details: [ServiceCatalogClientTypes.ResourceChangeDetail]? = nil,
            logicalResourceId: Swift.String? = nil,
            physicalResourceId: Swift.String? = nil,
            replacement: ServiceCatalogClientTypes.Replacement? = nil,
            resourceType: Swift.String? = nil,
            scope: [ServiceCatalogClientTypes.ResourceAttribute]? = nil
        )
        {
            self.action = action
            self.details = details
            self.logicalResourceId = logicalResourceId
            self.physicalResourceId = physicalResourceId
            self.replacement = replacement
            self.resourceType = resourceType
            self.scope = scope
        }
    }

}

extension ServiceCatalogClientTypes.ResourceChangeDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case causingEntity = "CausingEntity"
        case evaluation = "Evaluation"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let causingEntity = causingEntity {
            try encodeContainer.encode(causingEntity, forKey: .causingEntity)
        }
        if let evaluation = evaluation {
            try encodeContainer.encode(evaluation.rawValue, forKey: .evaluation)
        }
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ResourceTargetDefinition.self, forKey: .target)
        target = targetDecoded
        let evaluationDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.EvaluationType.self, forKey: .evaluation)
        evaluation = evaluationDecoded
        let causingEntityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .causingEntity)
        causingEntity = causingEntityDecoded
    }
}

extension ServiceCatalogClientTypes.ResourceChangeDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceChangeDetail(causingEntity: \(Swift.String(describing: causingEntity)), evaluation: \(Swift.String(describing: evaluation)), target: \(Swift.String(describing: target)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a change to a resource attribute.
    public struct ResourceChangeDetail: Swift.Equatable {
        /// The ID of the entity that caused the change.
        public var causingEntity: Swift.String?
        /// For static evaluations, the value of the resource attribute will change and the new value is known.
        ///          For dynamic evaluations, the value might change, and any new value will be determined when the plan is updated.
        public var evaluation: ServiceCatalogClientTypes.EvaluationType?
        /// Information about the resource attribute to be modified.
        public var target: ServiceCatalogClientTypes.ResourceTargetDefinition?

        public init (
            causingEntity: Swift.String? = nil,
            evaluation: ServiceCatalogClientTypes.EvaluationType? = nil,
            target: ServiceCatalogClientTypes.ResourceTargetDefinition? = nil
        )
        {
            self.causingEntity = causingEntity
            self.evaluation = evaluation
            self.target = target
        }
    }

}

extension ServiceCatalogClientTypes.ResourceDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aRN = "ARN"
        case createdTime = "CreatedTime"
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aRN = aRN {
            try encodeContainer.encode(aRN, forKey: .aRN)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let aRNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aRN)
        aRN = aRNDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension ServiceCatalogClientTypes.ResourceDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceDetail(aRN: \(Swift.String(describing: aRN)), createdTime: \(Swift.String(describing: createdTime)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a resource.
    public struct ResourceDetail: Swift.Equatable {
        /// The ARN of the resource.
        public var aRN: Swift.String?
        /// The creation time of the resource.
        public var createdTime: ClientRuntime.Date?
        /// The description of the resource.
        public var description: Swift.String?
        /// The identifier of the resource.
        public var id: Swift.String?
        /// The name of the resource.
        public var name: Swift.String?

        public init (
            aRN: Swift.String? = nil,
            createdTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.aRN = aRN
            self.createdTime = createdTime
            self.description = description
            self.id = id
            self.name = name
        }
    }

}

extension ResourceInUseException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceInUseException(message: \(Swift.String(describing: message)))"}
}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A resource that is currently in use. Ensure that the resource is not in use and retry the operation.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceCatalogClientTypes.ResourceTargetDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute = "Attribute"
        case name = "Name"
        case requiresRecreation = "RequiresRecreation"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute.rawValue, forKey: .attribute)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let requiresRecreation = requiresRecreation {
            try encodeContainer.encode(requiresRecreation.rawValue, forKey: .requiresRecreation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ResourceAttribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let requiresRecreationDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.RequiresRecreation.self, forKey: .requiresRecreation)
        requiresRecreation = requiresRecreationDecoded
    }
}

extension ServiceCatalogClientTypes.ResourceTargetDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceTargetDefinition(attribute: \(Swift.String(describing: attribute)), name: \(Swift.String(describing: name)), requiresRecreation: \(Swift.String(describing: requiresRecreation)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a change to a resource attribute.
    public struct ResourceTargetDefinition: Swift.Equatable {
        /// The attribute to be changed.
        public var attribute: ServiceCatalogClientTypes.ResourceAttribute?
        /// If the attribute is Properties, the value is the name of the property.
        ///          Otherwise, the value is null.
        public var name: Swift.String?
        /// If the attribute is Properties, indicates whether a change to this property
        ///          causes the resource to be re-created.
        public var requiresRecreation: ServiceCatalogClientTypes.RequiresRecreation?

        public init (
            attribute: ServiceCatalogClientTypes.ResourceAttribute? = nil,
            name: Swift.String? = nil,
            requiresRecreation: ServiceCatalogClientTypes.RequiresRecreation? = nil
        )
        {
            self.attribute = attribute
            self.name = name
            self.requiresRecreation = requiresRecreation
        }
    }

}

public struct ScanProvisionedProductsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ScanProvisionedProductsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ScanProvisionedProductsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ScanProvisionedProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ScanProvisionedProductsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ScanProvisionedProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ScanProvisionedProductsOutputError>
}

extension ScanProvisionedProductsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScanProvisionedProductsInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), accessLevelFilter: \(Swift.String(describing: accessLevelFilter)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)))"}
}

extension ScanProvisionedProductsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let accessLevelFilter = accessLevelFilter {
            try encodeContainer.encode(accessLevelFilter, forKey: .accessLevelFilter)
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
    }
}

public struct ScanProvisionedProductsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ScanProvisionedProductsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ScanProvisionedProductsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ScanProvisionedProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ScanProvisionedProductsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ScanProvisionedProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ScanProvisionedProductsOutputError>
}

public struct ScanProvisionedProductsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ScanProvisionedProductsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ScanProvisionedProductsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ScanProvisionedProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ScanProvisionedProductsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ScanProvisionedProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ScanProvisionedProductsOutputError>
}

public struct ScanProvisionedProductsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ScanProvisionedProductsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ScanProvisionedProductsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ScanProvisionedProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ScanProvisionedProductsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ScanProvisionedProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ScanProvisionedProductsOutputError>
}

public struct ScanProvisionedProductsInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The access level to use to obtain results. The default is User.
    public var accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accessLevelFilter = accessLevelFilter
        self.pageSize = pageSize
        self.pageToken = pageToken
    }
}

struct ScanProvisionedProductsInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter?
    public let pageSize: Swift.Int
    public let pageToken: Swift.String?
}

extension ScanProvisionedProductsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let accessLevelFilterDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.AccessLevelFilter.self, forKey: .accessLevelFilter)
        accessLevelFilter = accessLevelFilterDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension ScanProvisionedProductsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ScanProvisionedProductsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ScanProvisionedProductsOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ScanProvisionedProductsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ScanProvisionedProductsOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), provisionedProducts: \(Swift.String(describing: provisionedProducts)))"}
}

extension ScanProvisionedProductsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ScanProvisionedProductsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.provisionedProducts = output.provisionedProducts
        } else {
            self.nextPageToken = nil
            self.provisionedProducts = nil
        }
    }
}

public struct ScanProvisionedProductsOutputResponse: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the provisioned products.
    public var provisionedProducts: [ServiceCatalogClientTypes.ProvisionedProductDetail]?

    public init (
        nextPageToken: Swift.String? = nil,
        provisionedProducts: [ServiceCatalogClientTypes.ProvisionedProductDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.provisionedProducts = provisionedProducts
    }
}

struct ScanProvisionedProductsOutputResponseBody: Swift.Equatable {
    public let provisionedProducts: [ServiceCatalogClientTypes.ProvisionedProductDetail]?
    public let nextPageToken: Swift.String?
}

extension ScanProvisionedProductsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case provisionedProducts = "ProvisionedProducts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisionedProductDetail?].self, forKey: .provisionedProducts)
        var provisionedProductsDecoded0:[ServiceCatalogClientTypes.ProvisionedProductDetail]? = nil
        if let provisionedProductsContainer = provisionedProductsContainer {
            provisionedProductsDecoded0 = [ServiceCatalogClientTypes.ProvisionedProductDetail]()
            for structure0 in provisionedProductsContainer {
                if let structure0 = structure0 {
                    provisionedProductsDecoded0?.append(structure0)
                }
            }
        }
        provisionedProducts = provisionedProductsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct SearchProductsAsAdminInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchProductsAsAdminInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchProductsAsAdminInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchProductsAsAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchProductsAsAdminInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchProductsAsAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchProductsAsAdminOutputError>
}

extension SearchProductsAsAdminInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchProductsAsAdminInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), filters: \(Swift.String(describing: filters)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)), portfolioId: \(Swift.String(describing: portfolioId)), productSource: \(Swift.String(describing: productSource)), sortBy: \(Swift.String(describing: sortBy)), sortOrder: \(Swift.String(describing: sortOrder)))"}
}

extension SearchProductsAsAdminInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
        case productSource = "ProductSource"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filters)
            for (dictKey0, productviewfilters0) in filters {
                try filtersContainer.encode(productviewfilters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let productSource = productSource {
            try encodeContainer.encode(productSource.rawValue, forKey: .productSource)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct SearchProductsAsAdminInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchProductsAsAdminInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchProductsAsAdminInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchProductsAsAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchProductsAsAdminInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchProductsAsAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchProductsAsAdminOutputError>
}

public struct SearchProductsAsAdminInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchProductsAsAdminInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchProductsAsAdminInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchProductsAsAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchProductsAsAdminInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchProductsAsAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchProductsAsAdminOutputError>
}

public struct SearchProductsAsAdminInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchProductsAsAdminInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SearchProductsAsAdminInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchProductsAsAdminOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SearchProductsAsAdminInput
    public typealias MOutput = ClientRuntime.OperationOutput<SearchProductsAsAdminOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchProductsAsAdminOutputError>
}

public struct SearchProductsAsAdminInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The search filters. If no search filters are specified, the output includes all products
    ///          to which the administrator has access.
    public var filters: [Swift.String:[Swift.String]]?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The portfolio identifier.
    public var portfolioId: Swift.String?
    /// Access level of the source of the product.
    public var productSource: ServiceCatalogClientTypes.ProductSource?
    /// The sort field. If no value is specified, the results are not sorted.
    public var sortBy: ServiceCatalogClientTypes.ProductViewSortBy?
    /// The sort order. If no value is specified, the results are not sorted.
    public var sortOrder: ServiceCatalogClientTypes.SortOrder?

    public init (
        acceptLanguage: Swift.String? = nil,
        filters: [Swift.String:[Swift.String]]? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil,
        portfolioId: Swift.String? = nil,
        productSource: ServiceCatalogClientTypes.ProductSource? = nil,
        sortBy: ServiceCatalogClientTypes.ProductViewSortBy? = nil,
        sortOrder: ServiceCatalogClientTypes.SortOrder? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.filters = filters
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.portfolioId = portfolioId
        self.productSource = productSource
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct SearchProductsAsAdminInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let portfolioId: Swift.String?
    public let filters: [Swift.String:[Swift.String]]?
    public let sortBy: ServiceCatalogClientTypes.ProductViewSortBy?
    public let sortOrder: ServiceCatalogClientTypes.SortOrder?
    public let pageToken: Swift.String?
    public let pageSize: Swift.Int
    public let productSource: ServiceCatalogClientTypes.ProductSource?
}

extension SearchProductsAsAdminInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case portfolioId = "PortfolioId"
        case productSource = "ProductSource"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .filters)
        var filtersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, productviewfiltervalues0) in filtersContainer {
                var productviewfiltervalues0Decoded0: [Swift.String]? = nil
                if let productviewfiltervalues0 = productviewfiltervalues0 {
                    productviewfiltervalues0Decoded0 = [Swift.String]()
                    for string1 in productviewfiltervalues0 {
                        if let string1 = string1 {
                            productviewfiltervalues0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = productviewfiltervalues0Decoded0
            }
        }
        filters = filtersDecoded0
        let sortByDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductViewSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let productSourceDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductSource.self, forKey: .productSource)
        productSource = productSourceDecoded
    }
}

extension SearchProductsAsAdminOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchProductsAsAdminOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchProductsAsAdminOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchProductsAsAdminOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchProductsAsAdminOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), productViewDetails: \(Swift.String(describing: productViewDetails)))"}
}

extension SearchProductsAsAdminOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchProductsAsAdminOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.productViewDetails = output.productViewDetails
        } else {
            self.nextPageToken = nil
            self.productViewDetails = nil
        }
    }
}

public struct SearchProductsAsAdminOutputResponse: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the product views.
    public var productViewDetails: [ServiceCatalogClientTypes.ProductViewDetail]?

    public init (
        nextPageToken: Swift.String? = nil,
        productViewDetails: [ServiceCatalogClientTypes.ProductViewDetail]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.productViewDetails = productViewDetails
    }
}

struct SearchProductsAsAdminOutputResponseBody: Swift.Equatable {
    public let productViewDetails: [ServiceCatalogClientTypes.ProductViewDetail]?
    public let nextPageToken: Swift.String?
}

extension SearchProductsAsAdminOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case productViewDetails = "ProductViewDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewDetailsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProductViewDetail?].self, forKey: .productViewDetails)
        var productViewDetailsDecoded0:[ServiceCatalogClientTypes.ProductViewDetail]? = nil
        if let productViewDetailsContainer = productViewDetailsContainer {
            productViewDetailsDecoded0 = [ServiceCatalogClientTypes.ProductViewDetail]()
            for structure0 in productViewDetailsContainer {
                if let structure0 = structure0 {
                    productViewDetailsDecoded0?.append(structure0)
                }
            }
        }
        productViewDetails = productViewDetailsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct SearchProductsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchProductsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchProductsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchProductsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchProductsOutputError>
}

extension SearchProductsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchProductsInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), filters: \(Swift.String(describing: filters)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)), sortBy: \(Swift.String(describing: sortBy)), sortOrder: \(Swift.String(describing: sortOrder)))"}
}

extension SearchProductsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filters)
            for (dictKey0, productviewfilters0) in filters {
                try filtersContainer.encode(productviewfilters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct SearchProductsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchProductsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchProductsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchProductsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchProductsOutputError>
}

public struct SearchProductsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchProductsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchProductsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchProductsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchProductsOutputError>
}

public struct SearchProductsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchProductsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SearchProductsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SearchProductsInput
    public typealias MOutput = ClientRuntime.OperationOutput<SearchProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchProductsOutputError>
}

public struct SearchProductsInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The search filters. If no search filters are specified, the output includes
    ///          all products to which the caller has access.
    public var filters: [Swift.String:[Swift.String]]?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The sort field. If no value is specified, the results are not sorted.
    public var sortBy: ServiceCatalogClientTypes.ProductViewSortBy?
    /// The sort order. If no value is specified, the results are not sorted.
    public var sortOrder: ServiceCatalogClientTypes.SortOrder?

    public init (
        acceptLanguage: Swift.String? = nil,
        filters: [Swift.String:[Swift.String]]? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil,
        sortBy: ServiceCatalogClientTypes.ProductViewSortBy? = nil,
        sortOrder: ServiceCatalogClientTypes.SortOrder? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.filters = filters
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct SearchProductsInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let filters: [Swift.String:[Swift.String]]?
    public let pageSize: Swift.Int
    public let sortBy: ServiceCatalogClientTypes.ProductViewSortBy?
    public let sortOrder: ServiceCatalogClientTypes.SortOrder?
    public let pageToken: Swift.String?
}

extension SearchProductsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .filters)
        var filtersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, productviewfiltervalues0) in filtersContainer {
                var productviewfiltervalues0Decoded0: [Swift.String]? = nil
                if let productviewfiltervalues0 = productviewfiltervalues0 {
                    productviewfiltervalues0Decoded0 = [Swift.String]()
                    for string1 in productviewfiltervalues0 {
                        if let string1 = string1 {
                            productviewfiltervalues0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = productviewfiltervalues0Decoded0
            }
        }
        filters = filtersDecoded0
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let sortByDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductViewSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension SearchProductsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchProductsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchProductsOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchProductsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchProductsOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), productViewAggregations: \(Swift.String(describing: productViewAggregations)), productViewSummaries: \(Swift.String(describing: productViewSummaries)))"}
}

extension SearchProductsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchProductsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.productViewAggregations = output.productViewAggregations
            self.productViewSummaries = output.productViewSummaries
        } else {
            self.nextPageToken = nil
            self.productViewAggregations = nil
            self.productViewSummaries = nil
        }
    }
}

public struct SearchProductsOutputResponse: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// The product view aggregations.
    public var productViewAggregations: [Swift.String:[ServiceCatalogClientTypes.ProductViewAggregationValue]]?
    /// Information about the product views.
    public var productViewSummaries: [ServiceCatalogClientTypes.ProductViewSummary]?

    public init (
        nextPageToken: Swift.String? = nil,
        productViewAggregations: [Swift.String:[ServiceCatalogClientTypes.ProductViewAggregationValue]]? = nil,
        productViewSummaries: [ServiceCatalogClientTypes.ProductViewSummary]? = nil
    )
    {
        self.nextPageToken = nextPageToken
        self.productViewAggregations = productViewAggregations
        self.productViewSummaries = productViewSummaries
    }
}

struct SearchProductsOutputResponseBody: Swift.Equatable {
    public let productViewSummaries: [ServiceCatalogClientTypes.ProductViewSummary]?
    public let productViewAggregations: [Swift.String:[ServiceCatalogClientTypes.ProductViewAggregationValue]]?
    public let nextPageToken: Swift.String?
}

extension SearchProductsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case productViewAggregations = "ProductViewAggregations"
        case productViewSummaries = "ProductViewSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewSummariesContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProductViewSummary?].self, forKey: .productViewSummaries)
        var productViewSummariesDecoded0:[ServiceCatalogClientTypes.ProductViewSummary]? = nil
        if let productViewSummariesContainer = productViewSummariesContainer {
            productViewSummariesDecoded0 = [ServiceCatalogClientTypes.ProductViewSummary]()
            for structure0 in productViewSummariesContainer {
                if let structure0 = structure0 {
                    productViewSummariesDecoded0?.append(structure0)
                }
            }
        }
        productViewSummaries = productViewSummariesDecoded0
        let productViewAggregationsContainer = try containerValues.decodeIfPresent([Swift.String: [ServiceCatalogClientTypes.ProductViewAggregationValue?]?].self, forKey: .productViewAggregations)
        var productViewAggregationsDecoded0: [Swift.String:[ServiceCatalogClientTypes.ProductViewAggregationValue]]? = nil
        if let productViewAggregationsContainer = productViewAggregationsContainer {
            productViewAggregationsDecoded0 = [Swift.String:[ServiceCatalogClientTypes.ProductViewAggregationValue]]()
            for (key0, productviewaggregationvalues0) in productViewAggregationsContainer {
                var productviewaggregationvalues0Decoded0: [ServiceCatalogClientTypes.ProductViewAggregationValue]? = nil
                if let productviewaggregationvalues0 = productviewaggregationvalues0 {
                    productviewaggregationvalues0Decoded0 = [ServiceCatalogClientTypes.ProductViewAggregationValue]()
                    for structure1 in productviewaggregationvalues0 {
                        if let structure1 = structure1 {
                            productviewaggregationvalues0Decoded0?.append(structure1)
                        }
                    }
                }
                productViewAggregationsDecoded0?[key0] = productviewaggregationvalues0Decoded0
            }
        }
        productViewAggregations = productViewAggregationsDecoded0
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

public struct SearchProvisionedProductsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchProvisionedProductsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchProvisionedProductsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchProvisionedProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchProvisionedProductsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchProvisionedProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchProvisionedProductsOutputError>
}

extension SearchProvisionedProductsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchProvisionedProductsInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), accessLevelFilter: \(Swift.String(describing: accessLevelFilter)), filters: \(Swift.String(describing: filters)), pageSize: \(Swift.String(describing: pageSize)), pageToken: \(Swift.String(describing: pageToken)), sortBy: \(Swift.String(describing: sortBy)), sortOrder: \(Swift.String(describing: sortOrder)))"}
}

extension SearchProvisionedProductsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let accessLevelFilter = accessLevelFilter {
            try encodeContainer.encode(accessLevelFilter, forKey: .accessLevelFilter)
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .filters)
            for (dictKey0, provisionedproductfilters0) in filters {
                try filtersContainer.encode(provisionedproductfilters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if pageSize != 0 {
            try encodeContainer.encode(pageSize, forKey: .pageSize)
        }
        if let pageToken = pageToken {
            try encodeContainer.encode(pageToken, forKey: .pageToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct SearchProvisionedProductsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchProvisionedProductsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchProvisionedProductsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchProvisionedProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchProvisionedProductsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchProvisionedProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchProvisionedProductsOutputError>
}

public struct SearchProvisionedProductsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchProvisionedProductsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<SearchProvisionedProductsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchProvisionedProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<SearchProvisionedProductsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<SearchProvisionedProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchProvisionedProductsOutputError>
}

public struct SearchProvisionedProductsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "SearchProvisionedProductsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SearchProvisionedProductsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<SearchProvisionedProductsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = SearchProvisionedProductsInput
    public typealias MOutput = ClientRuntime.OperationOutput<SearchProvisionedProductsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<SearchProvisionedProductsOutputError>
}

public struct SearchProvisionedProductsInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The access level to use to obtain results. The default is User.
    public var accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter?
    /// The search filters.
    ///          When the key is SearchQuery, the searchable fields are arn,
    ///          createdTime, id, lastRecordId,
    ///          idempotencyToken, name, physicalId, productId,
    ///          provisioningArtifact, type, status,
    ///          tags, userArn, userArnSession, lastProvisioningRecordId, lastSuccessfulProvisioningRecordId,
    ///          productName, and provisioningArtifactName.
    ///          Example: "SearchQuery":["status:AVAILABLE"]
    ///
    public var filters: [Swift.String:[Swift.String]]?
    /// The maximum number of items to return with this call.
    public var pageSize: Swift.Int
    /// The page token for the next set of results. To retrieve the first set of results, use null.
    public var pageToken: Swift.String?
    /// The sort field. If no value is specified, the results are not sorted. The valid values are arn, id, name,
    ///          and lastRecordId.
    public var sortBy: Swift.String?
    /// The sort order. If no value is specified, the results are not sorted.
    public var sortOrder: ServiceCatalogClientTypes.SortOrder?

    public init (
        acceptLanguage: Swift.String? = nil,
        accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter? = nil,
        filters: [Swift.String:[Swift.String]]? = nil,
        pageSize: Swift.Int = 0,
        pageToken: Swift.String? = nil,
        sortBy: Swift.String? = nil,
        sortOrder: ServiceCatalogClientTypes.SortOrder? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accessLevelFilter = accessLevelFilter
        self.filters = filters
        self.pageSize = pageSize
        self.pageToken = pageToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct SearchProvisionedProductsInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let accessLevelFilter: ServiceCatalogClientTypes.AccessLevelFilter?
    public let filters: [Swift.String:[Swift.String]]?
    public let sortBy: Swift.String?
    public let sortOrder: ServiceCatalogClientTypes.SortOrder?
    public let pageSize: Swift.Int
    public let pageToken: Swift.String?
}

extension SearchProvisionedProductsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accessLevelFilter = "AccessLevelFilter"
        case filters = "Filters"
        case pageSize = "PageSize"
        case pageToken = "PageToken"
        case sortBy = "SortBy"
        case sortOrder = "SortOrder"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let accessLevelFilterDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.AccessLevelFilter.self, forKey: .accessLevelFilter)
        accessLevelFilter = accessLevelFilterDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .filters)
        var filtersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, provisionedproductviewfiltervalues0) in filtersContainer {
                var provisionedproductviewfiltervalues0Decoded0: [Swift.String]? = nil
                if let provisionedproductviewfiltervalues0 = provisionedproductviewfiltervalues0 {
                    provisionedproductviewfiltervalues0Decoded0 = [Swift.String]()
                    for string1 in provisionedproductviewfiltervalues0 {
                        if let string1 = string1 {
                            provisionedproductviewfiltervalues0Decoded0?.append(string1)
                        }
                    }
                }
                filtersDecoded0?[key0] = provisionedproductviewfiltervalues0Decoded0
            }
        }
        filters = filtersDecoded0
        let sortByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let pageSizeDecoded = try containerValues.decode(Swift.Int.self, forKey: .pageSize)
        pageSize = pageSizeDecoded
        let pageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageToken)
        pageToken = pageTokenDecoded
    }
}

extension SearchProvisionedProductsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchProvisionedProductsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchProvisionedProductsOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchProvisionedProductsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SearchProvisionedProductsOutputResponse(nextPageToken: \(Swift.String(describing: nextPageToken)), provisionedProducts: \(Swift.String(describing: provisionedProducts)), totalResultsCount: \(Swift.String(describing: totalResultsCount)))"}
}

extension SearchProvisionedProductsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchProvisionedProductsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextPageToken = output.nextPageToken
            self.provisionedProducts = output.provisionedProducts
            self.totalResultsCount = output.totalResultsCount
        } else {
            self.nextPageToken = nil
            self.provisionedProducts = nil
            self.totalResultsCount = 0
        }
    }
}

public struct SearchProvisionedProductsOutputResponse: Swift.Equatable {
    /// The page token to use to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextPageToken: Swift.String?
    /// Information about the provisioned products.
    public var provisionedProducts: [ServiceCatalogClientTypes.ProvisionedProductAttribute]?
    /// The number of provisioned products found.
    public var totalResultsCount: Swift.Int

    public init (
        nextPageToken: Swift.String? = nil,
        provisionedProducts: [ServiceCatalogClientTypes.ProvisionedProductAttribute]? = nil,
        totalResultsCount: Swift.Int = 0
    )
    {
        self.nextPageToken = nextPageToken
        self.provisionedProducts = provisionedProducts
        self.totalResultsCount = totalResultsCount
    }
}

struct SearchProvisionedProductsOutputResponseBody: Swift.Equatable {
    public let provisionedProducts: [ServiceCatalogClientTypes.ProvisionedProductAttribute]?
    public let totalResultsCount: Swift.Int
    public let nextPageToken: Swift.String?
}

extension SearchProvisionedProductsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextPageToken = "NextPageToken"
        case provisionedProducts = "ProvisionedProducts"
        case totalResultsCount = "TotalResultsCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ProvisionedProductAttribute?].self, forKey: .provisionedProducts)
        var provisionedProductsDecoded0:[ServiceCatalogClientTypes.ProvisionedProductAttribute]? = nil
        if let provisionedProductsContainer = provisionedProductsContainer {
            provisionedProductsDecoded0 = [ServiceCatalogClientTypes.ProvisionedProductAttribute]()
            for structure0 in provisionedProductsContainer {
                if let structure0 = structure0 {
                    provisionedProductsDecoded0?.append(structure0)
                }
            }
        }
        provisionedProducts = provisionedProductsDecoded0
        let totalResultsCountDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalResultsCount)
        totalResultsCount = totalResultsCountDecoded
        let nextPageTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPageToken)
        nextPageToken = nextPageTokenDecoded
    }
}

extension ServiceCatalogClientTypes.ServiceActionAssociation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case serviceActionId = "ServiceActionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let serviceActionId = serviceActionId {
            try encodeContainer.encode(serviceActionId, forKey: .serviceActionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceActionId)
        serviceActionId = serviceActionIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
    }
}

extension ServiceCatalogClientTypes.ServiceActionAssociation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceActionAssociation(productId: \(Swift.String(describing: productId)), provisioningArtifactId: \(Swift.String(describing: provisioningArtifactId)), serviceActionId: \(Swift.String(describing: serviceActionId)))"}
}

extension ServiceCatalogClientTypes {
    /// A self-service action association consisting of the Action ID, the Product ID, and the Provisioning Artifact ID.
    public struct ServiceActionAssociation: Swift.Equatable {
        /// The product identifier. For example, prod-abcdzk7xy33qa.
        /// This member is required.
        public var productId: Swift.String?
        /// The identifier of the provisioning artifact. For example, pa-4abcdjnxjj6ne.
        /// This member is required.
        public var provisioningArtifactId: Swift.String?
        /// The self-service action identifier. For example, act-fs7abcd89wxyz.
        /// This member is required.
        public var serviceActionId: Swift.String?

        public init (
            productId: Swift.String? = nil,
            provisioningArtifactId: Swift.String? = nil,
            serviceActionId: Swift.String? = nil
        )
        {
            self.productId = productId
            self.provisioningArtifactId = provisioningArtifactId
            self.serviceActionId = serviceActionId
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum ServiceActionAssociationErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case duplicateresourceexception
        case internalfailure
        case limitexceededexception
        case resourcenotfoundexception
        case throttlingexception
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceActionAssociationErrorCode] {
            return [
                .duplicateresourceexception,
                .internalfailure,
                .limitexceededexception,
                .resourcenotfoundexception,
                .throttlingexception,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .duplicateresourceexception: return "DUPLICATE_RESOURCE"
            case .internalfailure: return "INTERNAL_FAILURE"
            case .limitexceededexception: return "LIMIT_EXCEEDED"
            case .resourcenotfoundexception: return "RESOURCE_NOT_FOUND"
            case .throttlingexception: return "THROTTLING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceActionAssociationErrorCode(rawValue: rawValue) ?? ServiceActionAssociationErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum ServiceActionDefinitionKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case assumerole
        case name
        case parameters
        case version
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceActionDefinitionKey] {
            return [
                .assumerole,
                .name,
                .parameters,
                .version,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .assumerole: return "AssumeRole"
            case .name: return "Name"
            case .parameters: return "Parameters"
            case .version: return "Version"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceActionDefinitionKey(rawValue: rawValue) ?? ServiceActionDefinitionKey.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum ServiceActionDefinitionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ssmautomation
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceActionDefinitionType] {
            return [
                .ssmautomation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ssmautomation: return "SSM_AUTOMATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServiceActionDefinitionType(rawValue: rawValue) ?? ServiceActionDefinitionType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.ServiceActionDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definition = "Definition"
        case serviceActionSummary = "ServiceActionSummary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definition = definition {
            var definitionContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .definition)
            for (dictKey0, serviceactiondefinitionmap0) in definition {
                try definitionContainer.encode(serviceactiondefinitionmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let serviceActionSummary = serviceActionSummary {
            try encodeContainer.encode(serviceActionSummary, forKey: .serviceActionSummary)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionSummaryDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ServiceActionSummary.self, forKey: .serviceActionSummary)
        serviceActionSummary = serviceActionSummaryDecoded
        let definitionContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .definition)
        var definitionDecoded0: [Swift.String:Swift.String]? = nil
        if let definitionContainer = definitionContainer {
            definitionDecoded0 = [Swift.String:Swift.String]()
            for (key0, serviceactiondefinitionvalue0) in definitionContainer {
                if let serviceactiondefinitionvalue0 = serviceactiondefinitionvalue0 {
                    definitionDecoded0?[key0] = serviceactiondefinitionvalue0
                }
            }
        }
        definition = definitionDecoded0
    }
}

extension ServiceCatalogClientTypes.ServiceActionDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceActionDetail(definition: \(Swift.String(describing: definition)), serviceActionSummary: \(Swift.String(describing: serviceActionSummary)))"}
}

extension ServiceCatalogClientTypes {
    /// An object containing detailed information about the self-service action.
    public struct ServiceActionDetail: Swift.Equatable {
        /// A map that defines the self-service action.
        public var definition: [Swift.String:Swift.String]?
        /// Summary information about the self-service action.
        public var serviceActionSummary: ServiceCatalogClientTypes.ServiceActionSummary?

        public init (
            definition: [Swift.String:Swift.String]? = nil,
            serviceActionSummary: ServiceCatalogClientTypes.ServiceActionSummary? = nil
        )
        {
            self.definition = definition
            self.serviceActionSummary = serviceActionSummary
        }
    }

}

extension ServiceCatalogClientTypes.ServiceActionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definitionType = "DefinitionType"
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let definitionType = definitionType {
            try encodeContainer.encode(definitionType.rawValue, forKey: .definitionType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let definitionTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ServiceActionDefinitionType.self, forKey: .definitionType)
        definitionType = definitionTypeDecoded
    }
}

extension ServiceCatalogClientTypes.ServiceActionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceActionSummary(definitionType: \(Swift.String(describing: definitionType)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)))"}
}

extension ServiceCatalogClientTypes {
    /// Detailed information about the self-service action.
    public struct ServiceActionSummary: Swift.Equatable {
        /// The self-service action definition type. For example, SSM_AUTOMATION.
        public var definitionType: ServiceCatalogClientTypes.ServiceActionDefinitionType?
        /// The self-service action description.
        public var description: Swift.String?
        /// The self-service action identifier.
        public var id: Swift.String?
        /// The self-service action name.
        public var name: Swift.String?

        public init (
            definitionType: ServiceCatalogClientTypes.ServiceActionDefinitionType? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.definitionType = definitionType
            self.description = description
            self.id = id
            self.name = name
        }
    }

}

extension ServiceCatalogClientTypes.ShareDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case shareErrors = "ShareErrors"
        case successfulShares = "SuccessfulShares"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let shareErrors = shareErrors {
            var shareErrorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .shareErrors)
            for shareerrors0 in shareErrors {
                try shareErrorsContainer.encode(shareerrors0)
            }
        }
        if let successfulShares = successfulShares {
            var successfulSharesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .successfulShares)
            for successfulshares0 in successfulShares {
                try successfulSharesContainer.encode(successfulshares0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulSharesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .successfulShares)
        var successfulSharesDecoded0:[Swift.String]? = nil
        if let successfulSharesContainer = successfulSharesContainer {
            successfulSharesDecoded0 = [Swift.String]()
            for string0 in successfulSharesContainer {
                if let string0 = string0 {
                    successfulSharesDecoded0?.append(string0)
                }
            }
        }
        successfulShares = successfulSharesDecoded0
        let shareErrorsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.ShareError?].self, forKey: .shareErrors)
        var shareErrorsDecoded0:[ServiceCatalogClientTypes.ShareError]? = nil
        if let shareErrorsContainer = shareErrorsContainer {
            shareErrorsDecoded0 = [ServiceCatalogClientTypes.ShareError]()
            for structure0 in shareErrorsContainer {
                if let structure0 = structure0 {
                    shareErrorsDecoded0?.append(structure0)
                }
            }
        }
        shareErrors = shareErrorsDecoded0
    }
}

extension ServiceCatalogClientTypes.ShareDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ShareDetails(shareErrors: \(Swift.String(describing: shareErrors)), successfulShares: \(Swift.String(describing: successfulShares)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about the portfolio share operation.
    public struct ShareDetails: Swift.Equatable {
        /// List of errors.
        public var shareErrors: [ServiceCatalogClientTypes.ShareError]?
        /// List of accounts for whom the operation succeeded.
        public var successfulShares: [Swift.String]?

        public init (
            shareErrors: [ServiceCatalogClientTypes.ShareError]? = nil,
            successfulShares: [Swift.String]? = nil
        )
        {
            self.shareErrors = shareErrors
            self.successfulShares = successfulShares
        }
    }

}

extension ServiceCatalogClientTypes.ShareError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts = "Accounts"
        case error = "Error"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accounts = accounts {
            var accountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accounts)
            for namespaces0 in accounts {
                try accountsContainer.encode(namespaces0)
            }
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accounts)
        var accountsDecoded0:[Swift.String]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [Swift.String]()
            for string0 in accountsContainer {
                if let string0 = string0 {
                    accountsDecoded0?.append(string0)
                }
            }
        }
        accounts = accountsDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .error)
        error = errorDecoded
    }
}

extension ServiceCatalogClientTypes.ShareError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ShareError(accounts: \(Swift.String(describing: accounts)), error: \(Swift.String(describing: error)), message: \(Swift.String(describing: message)))"}
}

extension ServiceCatalogClientTypes {
    /// Errors that occurred during the portfolio share operation.
    public struct ShareError: Swift.Equatable {
        /// List of accounts impacted by the error.
        public var accounts: [Swift.String]?
        /// Error type that happened when processing the operation.
        public var error: Swift.String?
        /// Information about the error.
        public var message: Swift.String?

        public init (
            accounts: [Swift.String]? = nil,
            error: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.accounts = accounts
            self.error = error
            self.message = message
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum ShareStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case completedWithErrors
        case error
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ShareStatus] {
            return [
                .completed,
                .completedWithErrors,
                .error,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
            case .error: return "ERROR"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShareStatus(rawValue: rawValue) ?? ShareStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.StackInstance: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case account = "Account"
        case region = "Region"
        case stackInstanceStatus = "StackInstanceStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let account = account {
            try encodeContainer.encode(account, forKey: .account)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let stackInstanceStatus = stackInstanceStatus {
            try encodeContainer.encode(stackInstanceStatus.rawValue, forKey: .stackInstanceStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .account)
        account = accountDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let stackInstanceStatusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.StackInstanceStatus.self, forKey: .stackInstanceStatus)
        stackInstanceStatus = stackInstanceStatusDecoded
    }
}

extension ServiceCatalogClientTypes.StackInstance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StackInstance(account: \(Swift.String(describing: account)), region: \(Swift.String(describing: region)), stackInstanceStatus: \(Swift.String(describing: stackInstanceStatus)))"}
}

extension ServiceCatalogClientTypes {
    /// An AWS CloudFormation stack, in a specific account and region, that's part of a stack set operation. A stack instance is a reference to an attempted or actual stack in a given account within a given region. A stack instance can exist without a stackfor example, if the stack couldn't be created for some reason. A stack instance is associated with only one stack set. Each stack instance contains the ID of its associated stack set, as well as the ID of the actual stack and the stack status.
    public struct StackInstance: Swift.Equatable {
        /// The name of the AWS account that the stack instance is associated with.
        public var account: Swift.String?
        /// The name of the AWS region that the stack instance is associated with.
        public var region: Swift.String?
        /// The status of the stack instance, in terms of its synchronization with its associated stack set.
        ///
        ///
        ///
        ///                   INOPERABLE: A DeleteStackInstances operation has failed and left the stack in an unstable state. Stacks in this state are excluded from further UpdateStackSet operations. You might need to perform a DeleteStackInstances operation, with RetainStacks set to true, to delete the stack instance, and then delete the stack manually.
        ///
        ///
        ///
        ///                   OUTDATED: The stack isn't currently up to date with the stack set because either
        ///             the associated stack failed during a CreateStackSet or UpdateStackSet operation,
        ///             or the stack was part of a CreateStackSet or UpdateStackSet operation that failed or was stopped before the stack was created or updated.
        ///
        ///
        ///
        ///                   CURRENT: The stack is currently up to date with the stack set.
        ///
        ///
        public var stackInstanceStatus: ServiceCatalogClientTypes.StackInstanceStatus?

        public init (
            account: Swift.String? = nil,
            region: Swift.String? = nil,
            stackInstanceStatus: ServiceCatalogClientTypes.StackInstanceStatus? = nil
        )
        {
            self.account = account
            self.region = region
            self.stackInstanceStatus = stackInstanceStatus
        }
    }

}

extension ServiceCatalogClientTypes {
    public enum StackInstanceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case current
        case inoperable
        case outdated
        case sdkUnknown(Swift.String)

        public static var allCases: [StackInstanceStatus] {
            return [
                .current,
                .inoperable,
                .outdated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .current: return "CURRENT"
            case .inoperable: return "INOPERABLE"
            case .outdated: return "OUTDATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StackInstanceStatus(rawValue: rawValue) ?? StackInstanceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum StackSetOperationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case create
        case delete
        case update
        case sdkUnknown(Swift.String)

        public static var allCases: [StackSetOperationType] {
            return [
                .create,
                .delete,
                .update,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .create: return "CREATE"
            case .delete: return "DELETE"
            case .update: return "UPDATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StackSetOperationType(rawValue: rawValue) ?? StackSetOperationType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case creating
        case failed
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .available,
                .creating,
                .failed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .creating: return "CREATING"
            case .failed: return "FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension ServiceCatalogClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceCatalogClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a tag. A tag is a key-value pair. Tags are propagated
    ///          to the resources created when provisioning a product.
    public struct Tag: Swift.Equatable {
        /// The tag key.
        /// This member is required.
        public var key: Swift.String?
        /// The value for this key.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ServiceCatalogClientTypes.TagOptionDetail: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active = "Active"
        case id = "Id"
        case key = "Key"
        case owner = "Owner"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
    }
}

extension ServiceCatalogClientTypes.TagOptionDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagOptionDetail(active: \(Swift.String(describing: active)), id: \(Swift.String(describing: id)), key: \(Swift.String(describing: key)), owner: \(Swift.String(describing: owner)), value: \(Swift.String(describing: value)))"}
}

extension ServiceCatalogClientTypes {
    /// Information about a TagOption.
    public struct TagOptionDetail: Swift.Equatable {
        /// The TagOption active state.
        public var active: Swift.Bool?
        /// The TagOption identifier.
        public var id: Swift.String?
        /// The TagOption key.
        public var key: Swift.String?
        /// The AWS account Id of the owner account that created the TagOption.
        public var owner: Swift.String?
        /// The TagOption value.
        public var value: Swift.String?

        public init (
            active: Swift.Bool? = nil,
            id: Swift.String? = nil,
            key: Swift.String? = nil,
            owner: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.active = active
            self.id = id
            self.key = key
            self.owner = owner
            self.value = value
        }
    }

}

extension TagOptionNotMigratedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagOptionNotMigratedException(message: \(Swift.String(describing: message)))"}
}

extension TagOptionNotMigratedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TagOptionNotMigratedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An operation requiring TagOptions failed because the TagOptions migration process has
///          not been performed for this account. Please use the AWS console to perform the migration
///          process before retrying the operation.
public struct TagOptionNotMigratedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagOptionNotMigratedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension TagOptionNotMigratedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceCatalogClientTypes.TagOptionSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for tagoptionvalues0 in values {
                try valuesContainer.encode(tagoptionvalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ServiceCatalogClientTypes.TagOptionSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagOptionSummary(key: \(Swift.String(describing: key)), values: \(Swift.String(describing: values)))"}
}

extension ServiceCatalogClientTypes {
    /// Summary information about a TagOption.
    public struct TagOptionSummary: Swift.Equatable {
        /// The TagOption key.
        public var key: Swift.String?
        /// The TagOption value.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

public struct TerminateProvisionedProductInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TerminateProvisionedProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TerminateProvisionedProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TerminateProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TerminateProvisionedProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TerminateProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TerminateProvisionedProductOutputError>
}

extension TerminateProvisionedProductInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TerminateProvisionedProductInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), ignoreErrors: \(Swift.String(describing: ignoreErrors)), provisionedProductId: \(Swift.String(describing: provisionedProductId)), provisionedProductName: \(Swift.String(describing: provisionedProductName)), retainPhysicalResources: \(Swift.String(describing: retainPhysicalResources)), terminateToken: \(Swift.String(describing: terminateToken)))"}
}

extension TerminateProvisionedProductInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case ignoreErrors = "IgnoreErrors"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductName = "ProvisionedProductName"
        case retainPhysicalResources = "RetainPhysicalResources"
        case terminateToken = "TerminateToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if ignoreErrors != false {
            try encodeContainer.encode(ignoreErrors, forKey: .ignoreErrors)
        }
        if let provisionedProductId = provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
        if let provisionedProductName = provisionedProductName {
            try encodeContainer.encode(provisionedProductName, forKey: .provisionedProductName)
        }
        if retainPhysicalResources != false {
            try encodeContainer.encode(retainPhysicalResources, forKey: .retainPhysicalResources)
        }
        if let terminateToken = terminateToken {
            try encodeContainer.encode(terminateToken, forKey: .terminateToken)
        }
    }
}

public struct TerminateProvisionedProductInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TerminateProvisionedProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TerminateProvisionedProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TerminateProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TerminateProvisionedProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TerminateProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TerminateProvisionedProductOutputError>
}

public struct TerminateProvisionedProductInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TerminateProvisionedProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TerminateProvisionedProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TerminateProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TerminateProvisionedProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TerminateProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TerminateProvisionedProductOutputError>
}

public struct TerminateProvisionedProductInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TerminateProvisionedProductInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TerminateProvisionedProductInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TerminateProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TerminateProvisionedProductInput
    public typealias MOutput = ClientRuntime.OperationOutput<TerminateProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TerminateProvisionedProductOutputError>
}

public struct TerminateProvisionedProductInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// If set to true, AWS Service Catalog stops managing the specified provisioned product even
    ///          if it cannot delete the underlying resources.
    public var ignoreErrors: Swift.Bool
    /// The identifier of the provisioned product. You cannot specify both
    ///          ProvisionedProductName and ProvisionedProductId.
    public var provisionedProductId: Swift.String?
    /// The name of the provisioned product. You cannot specify both
    ///          ProvisionedProductName and ProvisionedProductId.
    public var provisionedProductName: Swift.String?
    /// When this boolean parameter is set to true, the TerminateProvisionedProduct API deletes
    ///          the Service Catalog provisioned product. However, it does not remove the CloudFormation
    ///          stack, stack set, or the underlying resources of the deleted provisioned product. The
    ///          default value is false.
    public var retainPhysicalResources: Swift.Bool
    /// An idempotency token that uniquely identifies the termination request. This token is
    ///          only valid during the termination process. After the provisioned product is terminated,
    ///          subsequent requests to terminate the same provisioned product always return
    ///          ResourceNotFound.
    /// This member is required.
    public var terminateToken: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        ignoreErrors: Swift.Bool = false,
        provisionedProductId: Swift.String? = nil,
        provisionedProductName: Swift.String? = nil,
        retainPhysicalResources: Swift.Bool = false,
        terminateToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.ignoreErrors = ignoreErrors
        self.provisionedProductId = provisionedProductId
        self.provisionedProductName = provisionedProductName
        self.retainPhysicalResources = retainPhysicalResources
        self.terminateToken = terminateToken
    }
}

struct TerminateProvisionedProductInputBody: Swift.Equatable {
    public let provisionedProductName: Swift.String?
    public let provisionedProductId: Swift.String?
    public let terminateToken: Swift.String?
    public let ignoreErrors: Swift.Bool
    public let acceptLanguage: Swift.String?
    public let retainPhysicalResources: Swift.Bool
}

extension TerminateProvisionedProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case ignoreErrors = "IgnoreErrors"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductName = "ProvisionedProductName"
        case retainPhysicalResources = "RetainPhysicalResources"
        case terminateToken = "TerminateToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let terminateTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .terminateToken)
        terminateToken = terminateTokenDecoded
        let ignoreErrorsDecoded = try containerValues.decode(Swift.Bool.self, forKey: .ignoreErrors)
        ignoreErrors = ignoreErrorsDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let retainPhysicalResourcesDecoded = try containerValues.decode(Swift.Bool.self, forKey: .retainPhysicalResources)
        retainPhysicalResources = retainPhysicalResourcesDecoded
    }
}

extension TerminateProvisionedProductOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TerminateProvisionedProductOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TerminateProvisionedProductOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TerminateProvisionedProductOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TerminateProvisionedProductOutputResponse(recordDetail: \(Swift.String(describing: recordDetail)))"}
}

extension TerminateProvisionedProductOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TerminateProvisionedProductOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recordDetail = output.recordDetail
        } else {
            self.recordDetail = nil
        }
    }
}

public struct TerminateProvisionedProductOutputResponse: Swift.Equatable {
    /// Information about the result of this request.
    public var recordDetail: ServiceCatalogClientTypes.RecordDetail?

    public init (
        recordDetail: ServiceCatalogClientTypes.RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

struct TerminateProvisionedProductOutputResponseBody: Swift.Equatable {
    public let recordDetail: ServiceCatalogClientTypes.RecordDetail?
}

extension TerminateProvisionedProductOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordDetail = "RecordDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.RecordDetail.self, forKey: .recordDetail)
        recordDetail = recordDetailDecoded
    }
}

public struct UpdateConstraintInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConstraintInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConstraintInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConstraintInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConstraintOutputError>
}

extension UpdateConstraintInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConstraintInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), parameters: \(Swift.String(describing: parameters)))"}
}

extension UpdateConstraintInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case id = "Id"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let parameters = parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
    }
}

public struct UpdateConstraintInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConstraintInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConstraintInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConstraintInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConstraintOutputError>
}

public struct UpdateConstraintInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConstraintInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateConstraintInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateConstraintInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConstraintOutputError>
}

public struct UpdateConstraintInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateConstraintInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateConstraintInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateConstraintOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateConstraintInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateConstraintOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateConstraintOutputError>
}

public struct UpdateConstraintInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The updated description of the constraint.
    public var description: Swift.String?
    /// The identifier of the constraint.
    /// This member is required.
    public var id: Swift.String?
    /// The constraint parameters, in JSON format. The syntax depends on the constraint type as follows:
    ///
    ///             LAUNCH
    ///
    ///                You are required to specify either the RoleArn or the LocalRoleName but can't use both.
    ///                Specify the RoleArn property as follows:
    ///
    ///                   {"RoleArn" : "arn:aws:iam::123456789012:role/LaunchRole"}
    ///
    ///                Specify the LocalRoleName property as follows:
    ///
    ///                   {"LocalRoleName": "SCBasicLaunchRole"}
    ///
    ///                If you specify the LocalRoleName property, when an account uses the launch constraint, the IAM role with that name in the account will be used. This allows launch-role constraints to be
    ///                   account-agnostic so the administrator can create fewer resources per shared account.
    ///
    ///                   The given role name must exist in the account used to create the launch constraint and the account of the user who launches a product with this launch constraint.
    ///
    ///                You cannot have both a LAUNCH and a STACKSET constraint.
    ///                You also cannot have more than one LAUNCH constraint on a product and portfolio.
    ///
    ///             NOTIFICATION
    ///
    ///                Specify the NotificationArns property as follows:
    ///
    ///                   {"NotificationArns" : ["arn:aws:sns:us-east-1:123456789012:Topic"]}
    ///
    ///
    ///             RESOURCE_UPDATE
    ///
    ///                Specify the TagUpdatesOnProvisionedProduct property as follows:
    ///
    ///                   {"Version":"2.0","Properties":{"TagUpdateOnProvisionedProduct":"String"}}
    ///
    ///                The TagUpdatesOnProvisionedProduct property accepts a string value of ALLOWED or NOT_ALLOWED.
    ///
    ///             STACKSET
    ///
    ///                Specify the Parameters property as follows:
    ///
    ///                   {"Version": "String", "Properties": {"AccountList": [ "String" ], "RegionList": [ "String" ], "AdminRole": "String", "ExecutionRole": "String"}}
    ///
    ///                You cannot have both a LAUNCH and a STACKSET constraint.
    ///                You also cannot have more than one STACKSET constraint on a product and portfolio.
    ///                Products with a STACKSET constraint will launch an AWS CloudFormation stack set.
    ///
    ///             TEMPLATE
    ///
    ///                Specify the Rules property. For more information, see
    ///                   <a href="http://docs.aws.amazon.com/servicecatalog/latest/adminguide/reference-template_constraint_rules.html">Template Constraint Rules.
    ///
    ///
    public var parameters: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        parameters: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.description = description
        self.id = id
        self.parameters = parameters
    }
}

struct UpdateConstraintInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let id: Swift.String?
    public let description: Swift.String?
    public let parameters: Swift.String?
}

extension UpdateConstraintInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case description = "Description"
        case id = "Id"
        case parameters = "Parameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameters)
        parameters = parametersDecoded
    }
}

extension UpdateConstraintOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConstraintOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConstraintOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConstraintOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateConstraintOutputResponse(constraintDetail: \(Swift.String(describing: constraintDetail)), constraintParameters: \(Swift.String(describing: constraintParameters)), status: \(Swift.String(describing: status)))"}
}

extension UpdateConstraintOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateConstraintOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.constraintDetail = output.constraintDetail
            self.constraintParameters = output.constraintParameters
            self.status = output.status
        } else {
            self.constraintDetail = nil
            self.constraintParameters = nil
            self.status = nil
        }
    }
}

public struct UpdateConstraintOutputResponse: Swift.Equatable {
    /// Information about the constraint.
    public var constraintDetail: ServiceCatalogClientTypes.ConstraintDetail?
    /// The constraint parameters.
    public var constraintParameters: Swift.String?
    /// The status of the current request.
    public var status: ServiceCatalogClientTypes.Status?

    public init (
        constraintDetail: ServiceCatalogClientTypes.ConstraintDetail? = nil,
        constraintParameters: Swift.String? = nil,
        status: ServiceCatalogClientTypes.Status? = nil
    )
    {
        self.constraintDetail = constraintDetail
        self.constraintParameters = constraintParameters
        self.status = status
    }
}

struct UpdateConstraintOutputResponseBody: Swift.Equatable {
    public let constraintDetail: ServiceCatalogClientTypes.ConstraintDetail?
    public let constraintParameters: Swift.String?
    public let status: ServiceCatalogClientTypes.Status?
}

extension UpdateConstraintOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case constraintDetail = "ConstraintDetail"
        case constraintParameters = "ConstraintParameters"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let constraintDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ConstraintDetail.self, forKey: .constraintDetail)
        constraintDetail = constraintDetailDecoded
        let constraintParametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .constraintParameters)
        constraintParameters = constraintParametersDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdatePortfolioInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePortfolioInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePortfolioOutputError>
}

extension UpdatePortfolioInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePortfolioInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), addTags: \(Swift.String(describing: addTags)), description: \(Swift.String(describing: description)), displayName: \(Swift.String(describing: displayName)), id: \(Swift.String(describing: id)), providerName: \(Swift.String(describing: providerName)), removeTags: \(Swift.String(describing: removeTags)))"}
}

extension UpdatePortfolioInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case addTags = "AddTags"
        case description = "Description"
        case displayName = "DisplayName"
        case id = "Id"
        case providerName = "ProviderName"
        case removeTags = "RemoveTags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let addTags = addTags {
            var addTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addTags)
            for addtags0 in addTags {
                try addTagsContainer.encode(addtags0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if let removeTags = removeTags {
            var removeTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeTags)
            for tagkeys0 in removeTags {
                try removeTagsContainer.encode(tagkeys0)
            }
        }
    }
}

public struct UpdatePortfolioInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePortfolioInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePortfolioOutputError>
}

public struct UpdatePortfolioInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePortfolioInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePortfolioInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePortfolioInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePortfolioOutputError>
}

public struct UpdatePortfolioInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePortfolioInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdatePortfolioInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePortfolioOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdatePortfolioInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePortfolioOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePortfolioOutputError>
}

public struct UpdatePortfolioInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The tags to add.
    public var addTags: [ServiceCatalogClientTypes.Tag]?
    /// The updated description of the portfolio.
    public var description: Swift.String?
    /// The name to use for display purposes.
    public var displayName: Swift.String?
    /// The portfolio identifier.
    /// This member is required.
    public var id: Swift.String?
    /// The updated name of the portfolio provider.
    public var providerName: Swift.String?
    /// The tags to remove.
    public var removeTags: [Swift.String]?

    public init (
        acceptLanguage: Swift.String? = nil,
        addTags: [ServiceCatalogClientTypes.Tag]? = nil,
        description: Swift.String? = nil,
        displayName: Swift.String? = nil,
        id: Swift.String? = nil,
        providerName: Swift.String? = nil,
        removeTags: [Swift.String]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.addTags = addTags
        self.description = description
        self.displayName = displayName
        self.id = id
        self.providerName = providerName
        self.removeTags = removeTags
    }
}

struct UpdatePortfolioInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let id: Swift.String?
    public let displayName: Swift.String?
    public let description: Swift.String?
    public let providerName: Swift.String?
    public let addTags: [ServiceCatalogClientTypes.Tag]?
    public let removeTags: [Swift.String]?
}

extension UpdatePortfolioInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case addTags = "AddTags"
        case description = "Description"
        case displayName = "DisplayName"
        case id = "Id"
        case providerName = "ProviderName"
        case removeTags = "RemoveTags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let providerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let addTagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .addTags)
        var addTagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let addTagsContainer = addTagsContainer {
            addTagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in addTagsContainer {
                if let structure0 = structure0 {
                    addTagsDecoded0?.append(structure0)
                }
            }
        }
        addTags = addTagsDecoded0
        let removeTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .removeTags)
        var removeTagsDecoded0:[Swift.String]? = nil
        if let removeTagsContainer = removeTagsContainer {
            removeTagsDecoded0 = [Swift.String]()
            for string0 in removeTagsContainer {
                if let string0 = string0 {
                    removeTagsDecoded0?.append(string0)
                }
            }
        }
        removeTags = removeTagsDecoded0
    }
}

extension UpdatePortfolioOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePortfolioOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePortfolioOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePortfolioOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePortfolioOutputResponse(portfolioDetail: \(Swift.String(describing: portfolioDetail)), tags: \(Swift.String(describing: tags)))"}
}

extension UpdatePortfolioOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePortfolioOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portfolioDetail = output.portfolioDetail
            self.tags = output.tags
        } else {
            self.portfolioDetail = nil
            self.tags = nil
        }
    }
}

public struct UpdatePortfolioOutputResponse: Swift.Equatable {
    /// Information about the portfolio.
    public var portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail?
    /// Information about the tags associated with the portfolio.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init (
        portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.portfolioDetail = portfolioDetail
        self.tags = tags
    }
}

struct UpdatePortfolioOutputResponseBody: Swift.Equatable {
    public let portfolioDetail: ServiceCatalogClientTypes.PortfolioDetail?
    public let tags: [ServiceCatalogClientTypes.Tag]?
}

extension UpdatePortfolioOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portfolioDetail = "PortfolioDetail"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.PortfolioDetail.self, forKey: .portfolioDetail)
        portfolioDetail = portfolioDetailDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdatePortfolioShareInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePortfolioShareInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePortfolioShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePortfolioShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePortfolioShareOutputError>
}

extension UpdatePortfolioShareInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePortfolioShareInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), accountId: \(Swift.String(describing: accountId)), organizationNode: \(Swift.String(describing: organizationNode)), portfolioId: \(Swift.String(describing: portfolioId)), shareTagOptions: \(Swift.String(describing: shareTagOptions)))"}
}

extension UpdatePortfolioShareInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accountId = "AccountId"
        case organizationNode = "OrganizationNode"
        case portfolioId = "PortfolioId"
        case shareTagOptions = "ShareTagOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let organizationNode = organizationNode {
            try encodeContainer.encode(organizationNode, forKey: .organizationNode)
        }
        if let portfolioId = portfolioId {
            try encodeContainer.encode(portfolioId, forKey: .portfolioId)
        }
        if let shareTagOptions = shareTagOptions {
            try encodeContainer.encode(shareTagOptions, forKey: .shareTagOptions)
        }
    }
}

public struct UpdatePortfolioShareInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePortfolioShareInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePortfolioShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePortfolioShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePortfolioShareOutputError>
}

public struct UpdatePortfolioShareInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePortfolioShareInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePortfolioShareInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePortfolioShareInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePortfolioShareOutputError>
}

public struct UpdatePortfolioShareInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePortfolioShareInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdatePortfolioShareInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePortfolioShareOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdatePortfolioShareInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePortfolioShareOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePortfolioShareOutputError>
}

public struct UpdatePortfolioShareInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The AWS Account Id of the recipient account. This field is required when updating an external account to account type share.
    public var accountId: Swift.String?
    /// Information about the organization node.
    public var organizationNode: ServiceCatalogClientTypes.OrganizationNode?
    /// The unique identifier of the portfolio for which the share will be updated.
    /// This member is required.
    public var portfolioId: Swift.String?
    /// A flag to enable or disable TagOptions sharing for the portfolio share. If this field is not provided, the current state of TagOptions sharing on the portfolio share will not be modified.
    public var shareTagOptions: Swift.Bool?

    public init (
        acceptLanguage: Swift.String? = nil,
        accountId: Swift.String? = nil,
        organizationNode: ServiceCatalogClientTypes.OrganizationNode? = nil,
        portfolioId: Swift.String? = nil,
        shareTagOptions: Swift.Bool? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.accountId = accountId
        self.organizationNode = organizationNode
        self.portfolioId = portfolioId
        self.shareTagOptions = shareTagOptions
    }
}

struct UpdatePortfolioShareInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let portfolioId: Swift.String?
    public let accountId: Swift.String?
    public let organizationNode: ServiceCatalogClientTypes.OrganizationNode?
    public let shareTagOptions: Swift.Bool?
}

extension UpdatePortfolioShareInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case accountId = "AccountId"
        case organizationNode = "OrganizationNode"
        case portfolioId = "PortfolioId"
        case shareTagOptions = "ShareTagOptions"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let portfolioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioId)
        portfolioId = portfolioIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let organizationNodeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.OrganizationNode.self, forKey: .organizationNode)
        organizationNode = organizationNodeDecoded
        let shareTagOptionsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .shareTagOptions)
        shareTagOptions = shareTagOptionsDecoded
    }
}

extension UpdatePortfolioShareOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePortfolioShareOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "OperationNotSupportedException" : self = .operationNotSupportedException(try OperationNotSupportedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePortfolioShareOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case invalidStateException(InvalidStateException)
    case operationNotSupportedException(OperationNotSupportedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePortfolioShareOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePortfolioShareOutputResponse(portfolioShareToken: \(Swift.String(describing: portfolioShareToken)), status: \(Swift.String(describing: status)))"}
}

extension UpdatePortfolioShareOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePortfolioShareOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portfolioShareToken = output.portfolioShareToken
            self.status = output.status
        } else {
            self.portfolioShareToken = nil
            self.status = nil
        }
    }
}

public struct UpdatePortfolioShareOutputResponse: Swift.Equatable {
    /// The token that tracks the status of the UpdatePortfolioShare operation for external account to account or  organizational type sharing.
    public var portfolioShareToken: Swift.String?
    /// The status of UpdatePortfolioShare operation.
    ///          You can also obtain the operation status using DescribePortfolioShareStatus API.
    ///
    public var status: ServiceCatalogClientTypes.ShareStatus?

    public init (
        portfolioShareToken: Swift.String? = nil,
        status: ServiceCatalogClientTypes.ShareStatus? = nil
    )
    {
        self.portfolioShareToken = portfolioShareToken
        self.status = status
    }
}

struct UpdatePortfolioShareOutputResponseBody: Swift.Equatable {
    public let portfolioShareToken: Swift.String?
    public let status: ServiceCatalogClientTypes.ShareStatus?
}

extension UpdatePortfolioShareOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portfolioShareToken = "PortfolioShareToken"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portfolioShareTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portfolioShareToken)
        portfolioShareToken = portfolioShareTokenDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ShareStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdateProductInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProductOutputError>
}

extension UpdateProductInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProductInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), addTags: \(Swift.String(describing: addTags)), description: \(Swift.String(describing: description)), distributor: \(Swift.String(describing: distributor)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), owner: \(Swift.String(describing: owner)), removeTags: \(Swift.String(describing: removeTags)), supportDescription: \(Swift.String(describing: supportDescription)), supportEmail: \(Swift.String(describing: supportEmail)), supportUrl: \(Swift.String(describing: supportUrl)))"}
}

extension UpdateProductInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case addTags = "AddTags"
        case description = "Description"
        case distributor = "Distributor"
        case id = "Id"
        case name = "Name"
        case owner = "Owner"
        case removeTags = "RemoveTags"
        case supportDescription = "SupportDescription"
        case supportEmail = "SupportEmail"
        case supportUrl = "SupportUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let addTags = addTags {
            var addTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .addTags)
            for addtags0 in addTags {
                try addTagsContainer.encode(addtags0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let distributor = distributor {
            try encodeContainer.encode(distributor, forKey: .distributor)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let removeTags = removeTags {
            var removeTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .removeTags)
            for tagkeys0 in removeTags {
                try removeTagsContainer.encode(tagkeys0)
            }
        }
        if let supportDescription = supportDescription {
            try encodeContainer.encode(supportDescription, forKey: .supportDescription)
        }
        if let supportEmail = supportEmail {
            try encodeContainer.encode(supportEmail, forKey: .supportEmail)
        }
        if let supportUrl = supportUrl {
            try encodeContainer.encode(supportUrl, forKey: .supportUrl)
        }
    }
}

public struct UpdateProductInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProductOutputError>
}

public struct UpdateProductInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProductOutputError>
}

public struct UpdateProductInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProductInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateProductInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateProductInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProductOutputError>
}

public struct UpdateProductInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The tags to add to the product.
    public var addTags: [ServiceCatalogClientTypes.Tag]?
    /// The updated description of the product.
    public var description: Swift.String?
    /// The updated distributor of the product.
    public var distributor: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var id: Swift.String?
    /// The updated product name.
    public var name: Swift.String?
    /// The updated owner of the product.
    public var owner: Swift.String?
    /// The tags to remove from the product.
    public var removeTags: [Swift.String]?
    /// The updated support description for the product.
    public var supportDescription: Swift.String?
    /// The updated support email for the product.
    public var supportEmail: Swift.String?
    /// The updated support URL for the product.
    public var supportUrl: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        addTags: [ServiceCatalogClientTypes.Tag]? = nil,
        description: Swift.String? = nil,
        distributor: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        owner: Swift.String? = nil,
        removeTags: [Swift.String]? = nil,
        supportDescription: Swift.String? = nil,
        supportEmail: Swift.String? = nil,
        supportUrl: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.addTags = addTags
        self.description = description
        self.distributor = distributor
        self.id = id
        self.name = name
        self.owner = owner
        self.removeTags = removeTags
        self.supportDescription = supportDescription
        self.supportEmail = supportEmail
        self.supportUrl = supportUrl
    }
}

struct UpdateProductInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let id: Swift.String?
    public let name: Swift.String?
    public let owner: Swift.String?
    public let description: Swift.String?
    public let distributor: Swift.String?
    public let supportDescription: Swift.String?
    public let supportEmail: Swift.String?
    public let supportUrl: Swift.String?
    public let addTags: [ServiceCatalogClientTypes.Tag]?
    public let removeTags: [Swift.String]?
}

extension UpdateProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case addTags = "AddTags"
        case description = "Description"
        case distributor = "Distributor"
        case id = "Id"
        case name = "Name"
        case owner = "Owner"
        case removeTags = "RemoveTags"
        case supportDescription = "SupportDescription"
        case supportEmail = "SupportEmail"
        case supportUrl = "SupportUrl"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .owner)
        owner = ownerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let distributorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .distributor)
        distributor = distributorDecoded
        let supportDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportDescription)
        supportDescription = supportDescriptionDecoded
        let supportEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportEmail)
        supportEmail = supportEmailDecoded
        let supportUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .supportUrl)
        supportUrl = supportUrlDecoded
        let addTagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .addTags)
        var addTagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let addTagsContainer = addTagsContainer {
            addTagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in addTagsContainer {
                if let structure0 = structure0 {
                    addTagsDecoded0?.append(structure0)
                }
            }
        }
        addTags = addTagsDecoded0
        let removeTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .removeTags)
        var removeTagsDecoded0:[Swift.String]? = nil
        if let removeTagsContainer = removeTagsContainer {
            removeTagsDecoded0 = [Swift.String]()
            for string0 in removeTagsContainer {
                if let string0 = string0 {
                    removeTagsDecoded0?.append(string0)
                }
            }
        }
        removeTags = removeTagsDecoded0
    }
}

extension UpdateProductOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProductOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProductOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProductOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProductOutputResponse(productViewDetail: \(Swift.String(describing: productViewDetail)), tags: \(Swift.String(describing: tags)))"}
}

extension UpdateProductOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateProductOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.productViewDetail = output.productViewDetail
            self.tags = output.tags
        } else {
            self.productViewDetail = nil
            self.tags = nil
        }
    }
}

public struct UpdateProductOutputResponse: Swift.Equatable {
    /// Information about the product view.
    public var productViewDetail: ServiceCatalogClientTypes.ProductViewDetail?
    /// Information about the tags associated with the product.
    public var tags: [ServiceCatalogClientTypes.Tag]?

    public init (
        productViewDetail: ServiceCatalogClientTypes.ProductViewDetail? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil
    )
    {
        self.productViewDetail = productViewDetail
        self.tags = tags
    }
}

struct UpdateProductOutputResponseBody: Swift.Equatable {
    public let productViewDetail: ServiceCatalogClientTypes.ProductViewDetail?
    public let tags: [ServiceCatalogClientTypes.Tag]?
}

extension UpdateProductOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case productViewDetail = "ProductViewDetail"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productViewDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProductViewDetail.self, forKey: .productViewDetail)
        productViewDetail = productViewDetailDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct UpdateProvisionedProductInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProvisionedProductInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProvisionedProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProvisionedProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProvisionedProductOutputError>
}

extension UpdateProvisionedProductInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProvisionedProductInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), pathId: \(Swift.String(describing: pathId)), pathName: \(Swift.String(describing: pathName)), productId: \(Swift.String(describing: productId)), productName: \(Swift.String(describing: productName)), provisionedProductId: \(Swift.String(describing: provisionedProductId)), provisionedProductName: \(Swift.String(describing: provisionedProductName)), provisioningArtifactId: \(Swift.String(describing: provisioningArtifactId)), provisioningArtifactName: \(Swift.String(describing: provisioningArtifactName)), provisioningParameters: \(Swift.String(describing: provisioningParameters)), provisioningPreferences: \(Swift.String(describing: provisioningPreferences)), tags: \(Swift.String(describing: tags)), updateToken: \(Swift.String(describing: updateToken)))"}
}

extension UpdateProvisionedProductInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pathId = "PathId"
        case pathName = "PathName"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
        case provisioningParameters = "ProvisioningParameters"
        case provisioningPreferences = "ProvisioningPreferences"
        case tags = "Tags"
        case updateToken = "UpdateToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let pathId = pathId {
            try encodeContainer.encode(pathId, forKey: .pathId)
        }
        if let pathName = pathName {
            try encodeContainer.encode(pathName, forKey: .pathName)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let productName = productName {
            try encodeContainer.encode(productName, forKey: .productName)
        }
        if let provisionedProductId = provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
        if let provisionedProductName = provisionedProductName {
            try encodeContainer.encode(provisionedProductName, forKey: .provisionedProductName)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
        if let provisioningArtifactName = provisioningArtifactName {
            try encodeContainer.encode(provisioningArtifactName, forKey: .provisioningArtifactName)
        }
        if let provisioningParameters = provisioningParameters {
            var provisioningParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .provisioningParameters)
            for updateprovisioningparameters0 in provisioningParameters {
                try provisioningParametersContainer.encode(updateprovisioningparameters0)
            }
        }
        if let provisioningPreferences = provisioningPreferences {
            try encodeContainer.encode(provisioningPreferences, forKey: .provisioningPreferences)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
        if let updateToken = updateToken {
            try encodeContainer.encode(updateToken, forKey: .updateToken)
        }
    }
}

public struct UpdateProvisionedProductInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProvisionedProductInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProvisionedProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProvisionedProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProvisionedProductOutputError>
}

public struct UpdateProvisionedProductInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProvisionedProductInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProvisionedProductInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProvisionedProductInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProvisionedProductOutputError>
}

public struct UpdateProvisionedProductInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProvisionedProductInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateProvisionedProductInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProvisionedProductOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateProvisionedProductInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProvisionedProductOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProvisionedProductOutputError>
}

public struct UpdateProvisionedProductInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The path identifier. This value is optional if the product
    ///          has a default path, and required if the product has more than one path. You must provide the name or ID, but not both.
    public var pathId: Swift.String?
    /// The name of the path. You must provide the name or ID, but not both.
    public var pathName: Swift.String?
    /// The identifier of the product. You must provide the name or ID, but not both.
    public var productId: Swift.String?
    /// The name of the product. You must provide the name or ID, but not both.
    public var productName: Swift.String?
    /// The identifier of the provisioned product. You must provide the name or ID, but not both.
    public var provisionedProductId: Swift.String?
    /// The name of the provisioned product. You cannot specify both
    ///          ProvisionedProductName and ProvisionedProductId.
    public var provisionedProductName: Swift.String?
    /// The identifier of the provisioning artifact.
    public var provisioningArtifactId: Swift.String?
    /// The name of the provisioning artifact. You must provide the name or ID, but not both.
    public var provisioningArtifactName: Swift.String?
    /// The new parameters.
    public var provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]?
    /// An object that contains information about the provisioning preferences for a stack set.
    public var provisioningPreferences: ServiceCatalogClientTypes.UpdateProvisioningPreferences?
    /// One or more tags. Requires the product to have RESOURCE_UPDATE constraint with TagUpdatesOnProvisionedProduct set to ALLOWED to allow tag updates.
    public var tags: [ServiceCatalogClientTypes.Tag]?
    /// The idempotency token that uniquely identifies the provisioning update request.
    /// This member is required.
    public var updateToken: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        pathId: Swift.String? = nil,
        pathName: Swift.String? = nil,
        productId: Swift.String? = nil,
        productName: Swift.String? = nil,
        provisionedProductId: Swift.String? = nil,
        provisionedProductName: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil,
        provisioningArtifactName: Swift.String? = nil,
        provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]? = nil,
        provisioningPreferences: ServiceCatalogClientTypes.UpdateProvisioningPreferences? = nil,
        tags: [ServiceCatalogClientTypes.Tag]? = nil,
        updateToken: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.pathId = pathId
        self.pathName = pathName
        self.productId = productId
        self.productName = productName
        self.provisionedProductId = provisionedProductId
        self.provisionedProductName = provisionedProductName
        self.provisioningArtifactId = provisioningArtifactId
        self.provisioningArtifactName = provisioningArtifactName
        self.provisioningParameters = provisioningParameters
        self.provisioningPreferences = provisioningPreferences
        self.tags = tags
        self.updateToken = updateToken
    }
}

struct UpdateProvisionedProductInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let provisionedProductName: Swift.String?
    public let provisionedProductId: Swift.String?
    public let productId: Swift.String?
    public let productName: Swift.String?
    public let provisioningArtifactId: Swift.String?
    public let provisioningArtifactName: Swift.String?
    public let pathId: Swift.String?
    public let pathName: Swift.String?
    public let provisioningParameters: [ServiceCatalogClientTypes.UpdateProvisioningParameter]?
    public let provisioningPreferences: ServiceCatalogClientTypes.UpdateProvisioningPreferences?
    public let tags: [ServiceCatalogClientTypes.Tag]?
    public let updateToken: Swift.String?
}

extension UpdateProvisionedProductInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case pathId = "PathId"
        case pathName = "PathName"
        case productId = "ProductId"
        case productName = "ProductName"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductName = "ProvisionedProductName"
        case provisioningArtifactId = "ProvisioningArtifactId"
        case provisioningArtifactName = "ProvisioningArtifactName"
        case provisioningParameters = "ProvisioningParameters"
        case provisioningPreferences = "ProvisioningPreferences"
        case tags = "Tags"
        case updateToken = "UpdateToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let provisionedProductNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductName)
        provisionedProductName = provisionedProductNameDecoded
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let productNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productName)
        productName = productNameDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let provisioningArtifactNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactName)
        provisioningArtifactName = provisioningArtifactNameDecoded
        let pathIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathId)
        pathId = pathIdDecoded
        let pathNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pathName)
        pathName = pathNameDecoded
        let provisioningParametersContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.UpdateProvisioningParameter?].self, forKey: .provisioningParameters)
        var provisioningParametersDecoded0:[ServiceCatalogClientTypes.UpdateProvisioningParameter]? = nil
        if let provisioningParametersContainer = provisioningParametersContainer {
            provisioningParametersDecoded0 = [ServiceCatalogClientTypes.UpdateProvisioningParameter]()
            for structure0 in provisioningParametersContainer {
                if let structure0 = structure0 {
                    provisioningParametersDecoded0?.append(structure0)
                }
            }
        }
        provisioningParameters = provisioningParametersDecoded0
        let provisioningPreferencesDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.UpdateProvisioningPreferences.self, forKey: .provisioningPreferences)
        provisioningPreferences = provisioningPreferencesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ServiceCatalogClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ServiceCatalogClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ServiceCatalogClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let updateTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateToken)
        updateToken = updateTokenDecoded
    }
}

extension UpdateProvisionedProductOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProvisionedProductOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProvisionedProductOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProvisionedProductOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProvisionedProductOutputResponse(recordDetail: \(Swift.String(describing: recordDetail)))"}
}

extension UpdateProvisionedProductOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateProvisionedProductOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recordDetail = output.recordDetail
        } else {
            self.recordDetail = nil
        }
    }
}

public struct UpdateProvisionedProductOutputResponse: Swift.Equatable {
    /// Information about the result of the request.
    public var recordDetail: ServiceCatalogClientTypes.RecordDetail?

    public init (
        recordDetail: ServiceCatalogClientTypes.RecordDetail? = nil
    )
    {
        self.recordDetail = recordDetail
    }
}

struct UpdateProvisionedProductOutputResponseBody: Swift.Equatable {
    public let recordDetail: ServiceCatalogClientTypes.RecordDetail?
}

extension UpdateProvisionedProductOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordDetail = "RecordDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.RecordDetail.self, forKey: .recordDetail)
        recordDetail = recordDetailDecoded
    }
}

public struct UpdateProvisionedProductPropertiesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProvisionedProductPropertiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProvisionedProductPropertiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProvisionedProductPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProvisionedProductPropertiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProvisionedProductPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProvisionedProductPropertiesOutputError>
}

extension UpdateProvisionedProductPropertiesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProvisionedProductPropertiesInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), idempotencyToken: \(Swift.String(describing: idempotencyToken)), provisionedProductId: \(Swift.String(describing: provisionedProductId)), provisionedProductProperties: \(Swift.String(describing: provisionedProductProperties)))"}
}

extension UpdateProvisionedProductPropertiesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductProperties = "ProvisionedProductProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let idempotencyToken = idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let provisionedProductId = provisionedProductId {
            try encodeContainer.encode(provisionedProductId, forKey: .provisionedProductId)
        }
        if let provisionedProductProperties = provisionedProductProperties {
            var provisionedProductPropertiesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .provisionedProductProperties)
            for (dictKey0, provisionedproductproperties0) in provisionedProductProperties {
                try provisionedProductPropertiesContainer.encode(provisionedproductproperties0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdateProvisionedProductPropertiesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProvisionedProductPropertiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProvisionedProductPropertiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProvisionedProductPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProvisionedProductPropertiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProvisionedProductPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProvisionedProductPropertiesOutputError>
}

public struct UpdateProvisionedProductPropertiesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProvisionedProductPropertiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProvisionedProductPropertiesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProvisionedProductPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProvisionedProductPropertiesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProvisionedProductPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProvisionedProductPropertiesOutputError>
}

public struct UpdateProvisionedProductPropertiesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProvisionedProductPropertiesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateProvisionedProductPropertiesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProvisionedProductPropertiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateProvisionedProductPropertiesInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProvisionedProductPropertiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProvisionedProductPropertiesOutputError>
}

public struct UpdateProvisionedProductPropertiesInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// The idempotency token that uniquely identifies the provisioning product update request.
    /// This member is required.
    public var idempotencyToken: Swift.String?
    /// The identifier of the provisioned product.
    /// This member is required.
    public var provisionedProductId: Swift.String?
    /// A map that contains the provisioned product properties to be updated.
    ///          The LAUNCH_ROLE key accepts role ARNs. This key allows an
    ///          administrator to call UpdateProvisionedProductProperties to update the launch
    ///          role that is associated with a provisioned product. This role is used when an end user
    ///          calls a provisioning operation such as UpdateProvisionedProduct,
    ///             TerminateProvisionedProduct, or
    ///             ExecuteProvisionedProductServiceAction. Only a role ARN is valid. A user ARN is invalid.
    ///
    ///          The OWNER key accepts user ARNs and role ARNs. The owner is the user
    ///          that has permission to see, update, terminate, and execute service actions in the
    ///          provisioned product.
    ///          The administrator can change the owner of a provisioned product to another IAM user within the same account. Both end user owners and
    ///          administrators can see ownership history of the provisioned product using the ListRecordHistory API. The new owner can
    ///       describe all past records for the provisioned product using the DescribeRecord API. The previous owner can no longer use DescribeRecord,
    ///       but can still see the product's history from when he was an owner using ListRecordHistory.
    ///          If a provisioned product ownership is assigned to an end user, they can see and perform any action through the API or
    ///          Service Catalog console such as update, terminate, and execute service actions.
    ///          If an end user provisions a product and the owner is updated to someone else, they will no longer be able to see or perform any actions through
    ///          API or the Service Catalog console on that provisioned product.
    /// This member is required.
    public var provisionedProductProperties: [Swift.String:Swift.String]?

    public init (
        acceptLanguage: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        provisionedProductId: Swift.String? = nil,
        provisionedProductProperties: [Swift.String:Swift.String]? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.idempotencyToken = idempotencyToken
        self.provisionedProductId = provisionedProductId
        self.provisionedProductProperties = provisionedProductProperties
    }
}

struct UpdateProvisionedProductPropertiesInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let provisionedProductId: Swift.String?
    public let provisionedProductProperties: [Swift.String:Swift.String]?
    public let idempotencyToken: Swift.String?
}

extension UpdateProvisionedProductPropertiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case idempotencyToken = "IdempotencyToken"
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductProperties = "ProvisionedProductProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let provisionedProductPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .provisionedProductProperties)
        var provisionedProductPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let provisionedProductPropertiesContainer = provisionedProductPropertiesContainer {
            provisionedProductPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, propertyvalue0) in provisionedProductPropertiesContainer {
                if let propertyvalue0 = propertyvalue0 {
                    provisionedProductPropertiesDecoded0?[key0] = propertyvalue0
                }
            }
        }
        provisionedProductProperties = provisionedProductPropertiesDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension UpdateProvisionedProductPropertiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProvisionedProductPropertiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProvisionedProductPropertiesOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProvisionedProductPropertiesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProvisionedProductPropertiesOutputResponse(provisionedProductId: \(Swift.String(describing: provisionedProductId)), provisionedProductProperties: \(Swift.String(describing: provisionedProductProperties)), recordId: \(Swift.String(describing: recordId)), status: \(Swift.String(describing: status)))"}
}

extension UpdateProvisionedProductPropertiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateProvisionedProductPropertiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.provisionedProductId = output.provisionedProductId
            self.provisionedProductProperties = output.provisionedProductProperties
            self.recordId = output.recordId
            self.status = output.status
        } else {
            self.provisionedProductId = nil
            self.provisionedProductProperties = nil
            self.recordId = nil
            self.status = nil
        }
    }
}

public struct UpdateProvisionedProductPropertiesOutputResponse: Swift.Equatable {
    /// The provisioned product identifier.
    public var provisionedProductId: Swift.String?
    /// A map that contains the properties updated.
    public var provisionedProductProperties: [Swift.String:Swift.String]?
    /// The identifier of the record.
    public var recordId: Swift.String?
    /// The status of the request.
    public var status: ServiceCatalogClientTypes.RecordStatus?

    public init (
        provisionedProductId: Swift.String? = nil,
        provisionedProductProperties: [Swift.String:Swift.String]? = nil,
        recordId: Swift.String? = nil,
        status: ServiceCatalogClientTypes.RecordStatus? = nil
    )
    {
        self.provisionedProductId = provisionedProductId
        self.provisionedProductProperties = provisionedProductProperties
        self.recordId = recordId
        self.status = status
    }
}

struct UpdateProvisionedProductPropertiesOutputResponseBody: Swift.Equatable {
    public let provisionedProductId: Swift.String?
    public let provisionedProductProperties: [Swift.String:Swift.String]?
    public let recordId: Swift.String?
    public let status: ServiceCatalogClientTypes.RecordStatus?
}

extension UpdateProvisionedProductPropertiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case provisionedProductId = "ProvisionedProductId"
        case provisionedProductProperties = "ProvisionedProductProperties"
        case recordId = "RecordId"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedProductIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionedProductId)
        provisionedProductId = provisionedProductIdDecoded
        let provisionedProductPropertiesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .provisionedProductProperties)
        var provisionedProductPropertiesDecoded0: [Swift.String:Swift.String]? = nil
        if let provisionedProductPropertiesContainer = provisionedProductPropertiesContainer {
            provisionedProductPropertiesDecoded0 = [Swift.String:Swift.String]()
            for (key0, propertyvalue0) in provisionedProductPropertiesContainer {
                if let propertyvalue0 = propertyvalue0 {
                    provisionedProductPropertiesDecoded0?[key0] = propertyvalue0
                }
            }
        }
        provisionedProductProperties = provisionedProductPropertiesDecoded0
        let recordIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordId)
        recordId = recordIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.RecordStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct UpdateProvisioningArtifactInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProvisioningArtifactInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProvisioningArtifactOutputError>
}

extension UpdateProvisioningArtifactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProvisioningArtifactInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), active: \(Swift.String(describing: active)), description: \(Swift.String(describing: description)), guidance: \(Swift.String(describing: guidance)), name: \(Swift.String(describing: name)), productId: \(Swift.String(describing: productId)), provisioningArtifactId: \(Swift.String(describing: provisioningArtifactId)))"}
}

extension UpdateProvisioningArtifactInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case active = "Active"
        case description = "Description"
        case guidance = "Guidance"
        case name = "Name"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let active = active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let guidance = guidance {
            try encodeContainer.encode(guidance.rawValue, forKey: .guidance)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let provisioningArtifactId = provisioningArtifactId {
            try encodeContainer.encode(provisioningArtifactId, forKey: .provisioningArtifactId)
        }
    }
}

public struct UpdateProvisioningArtifactInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProvisioningArtifactInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProvisioningArtifactOutputError>
}

public struct UpdateProvisioningArtifactInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProvisioningArtifactInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProvisioningArtifactInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProvisioningArtifactInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProvisioningArtifactOutputError>
}

public struct UpdateProvisioningArtifactInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProvisioningArtifactInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateProvisioningArtifactInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProvisioningArtifactOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateProvisioningArtifactInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProvisioningArtifactOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProvisioningArtifactOutputError>
}

public struct UpdateProvisioningArtifactInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// Indicates whether the product version is active.
    ///          Inactive provisioning artifacts are invisible to end users. End users cannot launch or update a provisioned product from an inactive provisioning artifact.
    public var active: Swift.Bool?
    /// The updated description of the provisioning artifact.
    public var description: Swift.String?
    /// Information set by the administrator to provide guidance to end users about which provisioning artifacts to use.
    ///          The DEFAULT value indicates that the product version is active.
    ///          The administrator can set the guidance to DEPRECATED to inform
    ///           users that the product version is deprecated. Users are able to make updates to a provisioned product
    ///           of a deprecated version but cannot launch new provisioned products using a deprecated version.
    public var guidance: ServiceCatalogClientTypes.ProvisioningArtifactGuidance?
    /// The updated name of the provisioning artifact.
    public var name: Swift.String?
    /// The product identifier.
    /// This member is required.
    public var productId: Swift.String?
    /// The identifier of the provisioning artifact.
    /// This member is required.
    public var provisioningArtifactId: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        active: Swift.Bool? = nil,
        description: Swift.String? = nil,
        guidance: ServiceCatalogClientTypes.ProvisioningArtifactGuidance? = nil,
        name: Swift.String? = nil,
        productId: Swift.String? = nil,
        provisioningArtifactId: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.active = active
        self.description = description
        self.guidance = guidance
        self.name = name
        self.productId = productId
        self.provisioningArtifactId = provisioningArtifactId
    }
}

struct UpdateProvisioningArtifactInputBody: Swift.Equatable {
    public let acceptLanguage: Swift.String?
    public let productId: Swift.String?
    public let provisioningArtifactId: Swift.String?
    public let name: Swift.String?
    public let description: Swift.String?
    public let active: Swift.Bool?
    public let guidance: ServiceCatalogClientTypes.ProvisioningArtifactGuidance?
}

extension UpdateProvisioningArtifactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case active = "Active"
        case description = "Description"
        case guidance = "Guidance"
        case name = "Name"
        case productId = "ProductId"
        case provisioningArtifactId = "ProvisioningArtifactId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let provisioningArtifactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisioningArtifactId)
        provisioningArtifactId = provisioningArtifactIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let guidanceDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactGuidance.self, forKey: .guidance)
        guidance = guidanceDecoded
    }
}

extension UpdateProvisioningArtifactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProvisioningArtifactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProvisioningArtifactOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProvisioningArtifactOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProvisioningArtifactOutputResponse(info: \(Swift.String(describing: info)), provisioningArtifactDetail: \(Swift.String(describing: provisioningArtifactDetail)), status: \(Swift.String(describing: status)))"}
}

extension UpdateProvisioningArtifactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateProvisioningArtifactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.info = output.info
            self.provisioningArtifactDetail = output.provisioningArtifactDetail
            self.status = output.status
        } else {
            self.info = nil
            self.provisioningArtifactDetail = nil
            self.status = nil
        }
    }
}

public struct UpdateProvisioningArtifactOutputResponse: Swift.Equatable {
    /// The URL of the CloudFormation template in Amazon S3.
    public var info: [Swift.String:Swift.String]?
    /// Information about the provisioning artifact.
    public var provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail?
    /// The status of the current request.
    public var status: ServiceCatalogClientTypes.Status?

    public init (
        info: [Swift.String:Swift.String]? = nil,
        provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail? = nil,
        status: ServiceCatalogClientTypes.Status? = nil
    )
    {
        self.info = info
        self.provisioningArtifactDetail = provisioningArtifactDetail
        self.status = status
    }
}

struct UpdateProvisioningArtifactOutputResponseBody: Swift.Equatable {
    public let provisioningArtifactDetail: ServiceCatalogClientTypes.ProvisioningArtifactDetail?
    public let info: [Swift.String:Swift.String]?
    public let status: ServiceCatalogClientTypes.Status?
}

extension UpdateProvisioningArtifactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case info = "Info"
        case provisioningArtifactDetail = "ProvisioningArtifactDetail"
        case status = "Status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisioningArtifactDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ProvisioningArtifactDetail.self, forKey: .provisioningArtifactDetail)
        provisioningArtifactDetail = provisioningArtifactDetailDecoded
        let infoContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .info)
        var infoDecoded0: [Swift.String:Swift.String]? = nil
        if let infoContainer = infoContainer {
            infoDecoded0 = [Swift.String:Swift.String]()
            for (key0, provisioningartifactinfovalue0) in infoContainer {
                if let provisioningartifactinfovalue0 = provisioningartifactinfovalue0 {
                    infoDecoded0?[key0] = provisioningartifactinfovalue0
                }
            }
        }
        info = infoDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.Status.self, forKey: .status)
        status = statusDecoded
    }
}

extension ServiceCatalogClientTypes.UpdateProvisioningParameter: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case usePreviousValue = "UsePreviousValue"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if usePreviousValue != false {
            try encodeContainer.encode(usePreviousValue, forKey: .usePreviousValue)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let usePreviousValueDecoded = try containerValues.decode(Swift.Bool.self, forKey: .usePreviousValue)
        usePreviousValue = usePreviousValueDecoded
    }
}

extension ServiceCatalogClientTypes.UpdateProvisioningParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProvisioningParameter(key: \(Swift.String(describing: key)), usePreviousValue: \(Swift.String(describing: usePreviousValue)), value: \(Swift.String(describing: value)))"}
}

extension ServiceCatalogClientTypes {
    /// The parameter key-value pair used to update a provisioned product.
    public struct UpdateProvisioningParameter: Swift.Equatable {
        /// The parameter key.
        public var key: Swift.String?
        /// If set to true, Value is ignored and the previous parameter value is kept.
        public var usePreviousValue: Swift.Bool
        /// The parameter value.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            usePreviousValue: Swift.Bool = false,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.usePreviousValue = usePreviousValue
            self.value = value
        }
    }

}

extension ServiceCatalogClientTypes.UpdateProvisioningPreferences: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stackSetAccounts = "StackSetAccounts"
        case stackSetFailureToleranceCount = "StackSetFailureToleranceCount"
        case stackSetFailureTolerancePercentage = "StackSetFailureTolerancePercentage"
        case stackSetMaxConcurrencyCount = "StackSetMaxConcurrencyCount"
        case stackSetMaxConcurrencyPercentage = "StackSetMaxConcurrencyPercentage"
        case stackSetOperationType = "StackSetOperationType"
        case stackSetRegions = "StackSetRegions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stackSetAccounts = stackSetAccounts {
            var stackSetAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackSetAccounts)
            for stacksetaccounts0 in stackSetAccounts {
                try stackSetAccountsContainer.encode(stacksetaccounts0)
            }
        }
        if let stackSetFailureToleranceCount = stackSetFailureToleranceCount {
            try encodeContainer.encode(stackSetFailureToleranceCount, forKey: .stackSetFailureToleranceCount)
        }
        if let stackSetFailureTolerancePercentage = stackSetFailureTolerancePercentage {
            try encodeContainer.encode(stackSetFailureTolerancePercentage, forKey: .stackSetFailureTolerancePercentage)
        }
        if let stackSetMaxConcurrencyCount = stackSetMaxConcurrencyCount {
            try encodeContainer.encode(stackSetMaxConcurrencyCount, forKey: .stackSetMaxConcurrencyCount)
        }
        if let stackSetMaxConcurrencyPercentage = stackSetMaxConcurrencyPercentage {
            try encodeContainer.encode(stackSetMaxConcurrencyPercentage, forKey: .stackSetMaxConcurrencyPercentage)
        }
        if let stackSetOperationType = stackSetOperationType {
            try encodeContainer.encode(stackSetOperationType.rawValue, forKey: .stackSetOperationType)
        }
        if let stackSetRegions = stackSetRegions {
            var stackSetRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stackSetRegions)
            for stacksetregions0 in stackSetRegions {
                try stackSetRegionsContainer.encode(stacksetregions0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stackSetAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackSetAccounts)
        var stackSetAccountsDecoded0:[Swift.String]? = nil
        if let stackSetAccountsContainer = stackSetAccountsContainer {
            stackSetAccountsDecoded0 = [Swift.String]()
            for string0 in stackSetAccountsContainer {
                if let string0 = string0 {
                    stackSetAccountsDecoded0?.append(string0)
                }
            }
        }
        stackSetAccounts = stackSetAccountsDecoded0
        let stackSetRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stackSetRegions)
        var stackSetRegionsDecoded0:[Swift.String]? = nil
        if let stackSetRegionsContainer = stackSetRegionsContainer {
            stackSetRegionsDecoded0 = [Swift.String]()
            for string0 in stackSetRegionsContainer {
                if let string0 = string0 {
                    stackSetRegionsDecoded0?.append(string0)
                }
            }
        }
        stackSetRegions = stackSetRegionsDecoded0
        let stackSetFailureToleranceCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stackSetFailureToleranceCount)
        stackSetFailureToleranceCount = stackSetFailureToleranceCountDecoded
        let stackSetFailureTolerancePercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stackSetFailureTolerancePercentage)
        stackSetFailureTolerancePercentage = stackSetFailureTolerancePercentageDecoded
        let stackSetMaxConcurrencyCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stackSetMaxConcurrencyCount)
        stackSetMaxConcurrencyCount = stackSetMaxConcurrencyCountDecoded
        let stackSetMaxConcurrencyPercentageDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stackSetMaxConcurrencyPercentage)
        stackSetMaxConcurrencyPercentage = stackSetMaxConcurrencyPercentageDecoded
        let stackSetOperationTypeDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.StackSetOperationType.self, forKey: .stackSetOperationType)
        stackSetOperationType = stackSetOperationTypeDecoded
    }
}

extension ServiceCatalogClientTypes.UpdateProvisioningPreferences: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProvisioningPreferences(stackSetAccounts: \(Swift.String(describing: stackSetAccounts)), stackSetFailureToleranceCount: \(Swift.String(describing: stackSetFailureToleranceCount)), stackSetFailureTolerancePercentage: \(Swift.String(describing: stackSetFailureTolerancePercentage)), stackSetMaxConcurrencyCount: \(Swift.String(describing: stackSetMaxConcurrencyCount)), stackSetMaxConcurrencyPercentage: \(Swift.String(describing: stackSetMaxConcurrencyPercentage)), stackSetOperationType: \(Swift.String(describing: stackSetOperationType)), stackSetRegions: \(Swift.String(describing: stackSetRegions)))"}
}

extension ServiceCatalogClientTypes {
    /// The user-defined preferences that will be applied when updating a provisioned product. Not all preferences are applicable to all provisioned product types.
    public struct UpdateProvisioningPreferences: Swift.Equatable {
        /// One or more AWS accounts that will have access to the provisioned product.
        ///          Applicable only to a CFN_STACKSET provisioned product type.
        ///          The AWS accounts specified should be within the list of accounts in the STACKSET constraint. To get the list of accounts in the STACKSET constraint, use the DescribeProvisioningParameters operation.
        ///          If no values are specified, the default value is all accounts from the STACKSET constraint.
        public var stackSetAccounts: [Swift.String]?
        /// The number of accounts, per region, for which this operation can fail before AWS Service Catalog stops the operation in that region. If the operation is stopped in a region, AWS Service Catalog doesn't attempt the operation in any subsequent regions.
        ///          Applicable only to a CFN_STACKSET provisioned product type.
        ///          Conditional: You must specify either StackSetFailureToleranceCount or StackSetFailureTolerancePercentage, but not both.
        ///          The default value is 0 if no value is specified.
        public var stackSetFailureToleranceCount: Swift.Int?
        /// The percentage of accounts, per region, for which this stack operation can fail before AWS Service Catalog stops the operation in that region. If the operation is stopped in a region, AWS Service Catalog doesn't attempt the operation in any subsequent regions.
        ///          When calculating the number of accounts based on the specified percentage, AWS Service Catalog rounds down to the next whole number.
        ///          Applicable only to a CFN_STACKSET provisioned product type.
        ///          Conditional: You must specify either StackSetFailureToleranceCount or StackSetFailureTolerancePercentage, but not both.
        public var stackSetFailureTolerancePercentage: Swift.Int?
        /// The maximum number of accounts in which to perform this operation at one time. This is dependent on the value of StackSetFailureToleranceCount. StackSetMaxConcurrentCount is at most one more than the StackSetFailureToleranceCount.
        ///          Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.
        ///          Applicable only to a CFN_STACKSET provisioned product type.
        ///          Conditional: You must specify either StackSetMaxConcurrentCount or StackSetMaxConcurrentPercentage, but not both.
        public var stackSetMaxConcurrencyCount: Swift.Int?
        /// The maximum percentage of accounts in which to perform this operation at one time.
        ///          When calculating the number of accounts based on the specified percentage, AWS Service Catalog rounds down to the next whole number. This is true except in cases where rounding down would result is zero. In this case, AWS Service Catalog sets the number as 1 instead.
        ///          Note that this setting lets you specify the maximum for operations. For large deployments, under certain circumstances the actual number of accounts acted upon concurrently may be lower due to service throttling.
        ///          Applicable only to a CFN_STACKSET provisioned product type.
        ///          Conditional: You must specify either StackSetMaxConcurrentCount or StackSetMaxConcurrentPercentage, but not both.
        public var stackSetMaxConcurrencyPercentage: Swift.Int?
        /// Determines what action AWS Service Catalog performs to a stack set or a stack instance represented by the provisioned product. The default value is UPDATE if nothing is specified.
        ///          Applicable only to a CFN_STACKSET provisioned product type.
        ///
        ///             CREATE
        ///
        ///                Creates a new stack instance in the stack set represented by the provisioned product. In this case, only new stack instances are created based on accounts and regions; if new ProductId or ProvisioningArtifactID are passed, they will be ignored.
        ///
        ///             UPDATE
        ///
        ///                Updates the stack set represented by the provisioned product and also its stack instances.
        ///
        ///             DELETE
        ///
        ///                Deletes a stack instance in the stack set represented by the provisioned product.
        ///
        ///
        public var stackSetOperationType: ServiceCatalogClientTypes.StackSetOperationType?
        /// One or more AWS Regions where the provisioned product will be available.
        ///          Applicable only to a CFN_STACKSET provisioned product type.
        ///          The specified regions should be within the list of regions from the STACKSET constraint. To get the list of regions in the STACKSET constraint, use the DescribeProvisioningParameters operation.
        ///          If no values are specified, the default value is all regions from the STACKSET constraint.
        public var stackSetRegions: [Swift.String]?

        public init (
            stackSetAccounts: [Swift.String]? = nil,
            stackSetFailureToleranceCount: Swift.Int? = nil,
            stackSetFailureTolerancePercentage: Swift.Int? = nil,
            stackSetMaxConcurrencyCount: Swift.Int? = nil,
            stackSetMaxConcurrencyPercentage: Swift.Int? = nil,
            stackSetOperationType: ServiceCatalogClientTypes.StackSetOperationType? = nil,
            stackSetRegions: [Swift.String]? = nil
        )
        {
            self.stackSetAccounts = stackSetAccounts
            self.stackSetFailureToleranceCount = stackSetFailureToleranceCount
            self.stackSetFailureTolerancePercentage = stackSetFailureTolerancePercentage
            self.stackSetMaxConcurrencyCount = stackSetMaxConcurrencyCount
            self.stackSetMaxConcurrencyPercentage = stackSetMaxConcurrencyPercentage
            self.stackSetOperationType = stackSetOperationType
            self.stackSetRegions = stackSetRegions
        }
    }

}

public struct UpdateServiceActionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceActionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceActionOutputError>
}

extension UpdateServiceActionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceActionInput(acceptLanguage: \(Swift.String(describing: acceptLanguage)), definition: \(Swift.String(describing: definition)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)))"}
}

extension UpdateServiceActionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case definition = "Definition"
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptLanguage = acceptLanguage {
            try encodeContainer.encode(acceptLanguage, forKey: .acceptLanguage)
        }
        if let definition = definition {
            var definitionContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .definition)
            for (dictKey0, serviceactiondefinitionmap0) in definition {
                try definitionContainer.encode(serviceactiondefinitionmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateServiceActionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceActionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceActionOutputError>
}

public struct UpdateServiceActionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceActionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServiceActionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServiceActionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceActionOutputError>
}

public struct UpdateServiceActionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServiceActionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateServiceActionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServiceActionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateServiceActionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServiceActionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServiceActionOutputError>
}

public struct UpdateServiceActionInput: Swift.Equatable {
    /// The language code.
    ///
    ///
    ///
    ///                   en - English (default)
    ///
    ///
    ///
    ///                   jp - Japanese
    ///
    ///
    ///
    ///                   zh - Chinese
    ///
    ///
    public var acceptLanguage: Swift.String?
    /// A map that defines the self-service action.
    public var definition: [Swift.String:Swift.String]?
    /// The self-service action description.
    public var description: Swift.String?
    /// The self-service action identifier.
    /// This member is required.
    public var id: Swift.String?
    /// The self-service action name.
    public var name: Swift.String?

    public init (
        acceptLanguage: Swift.String? = nil,
        definition: [Swift.String:Swift.String]? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.acceptLanguage = acceptLanguage
        self.definition = definition
        self.description = description
        self.id = id
        self.name = name
    }
}

struct UpdateServiceActionInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let name: Swift.String?
    public let definition: [Swift.String:Swift.String]?
    public let description: Swift.String?
    public let acceptLanguage: Swift.String?
}

extension UpdateServiceActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptLanguage = "AcceptLanguage"
        case definition = "Definition"
        case description = "Description"
        case id = "Id"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let definitionContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .definition)
        var definitionDecoded0: [Swift.String:Swift.String]? = nil
        if let definitionContainer = definitionContainer {
            definitionDecoded0 = [Swift.String:Swift.String]()
            for (key0, serviceactiondefinitionvalue0) in definitionContainer {
                if let serviceactiondefinitionvalue0 = serviceactiondefinitionvalue0 {
                    definitionDecoded0?[key0] = serviceactiondefinitionvalue0
                }
            }
        }
        definition = definitionDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let acceptLanguageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptLanguage)
        acceptLanguage = acceptLanguageDecoded
    }
}

extension UpdateServiceActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServiceActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServiceActionOutputError: Swift.Error, Swift.Equatable {
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServiceActionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServiceActionOutputResponse(serviceActionDetail: \(Swift.String(describing: serviceActionDetail)))"}
}

extension UpdateServiceActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateServiceActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.serviceActionDetail = output.serviceActionDetail
        } else {
            self.serviceActionDetail = nil
        }
    }
}

public struct UpdateServiceActionOutputResponse: Swift.Equatable {
    /// Detailed information about the self-service action.
    public var serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail?

    public init (
        serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail? = nil
    )
    {
        self.serviceActionDetail = serviceActionDetail
    }
}

struct UpdateServiceActionOutputResponseBody: Swift.Equatable {
    public let serviceActionDetail: ServiceCatalogClientTypes.ServiceActionDetail?
}

extension UpdateServiceActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serviceActionDetail = "ServiceActionDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceActionDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.ServiceActionDetail.self, forKey: .serviceActionDetail)
        serviceActionDetail = serviceActionDetailDecoded
    }
}

public struct UpdateTagOptionInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTagOptionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTagOptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTagOptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTagOptionOutputError>
}

extension UpdateTagOptionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateTagOptionInput(active: \(Swift.String(describing: active)), id: \(Swift.String(describing: id)), value: \(Swift.String(describing: value)))"}
}

extension UpdateTagOptionInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active = "Active"
        case id = "Id"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let active = active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }
}

public struct UpdateTagOptionInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTagOptionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTagOptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTagOptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTagOptionOutputError>
}

public struct UpdateTagOptionInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTagOptionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateTagOptionInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateTagOptionInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTagOptionOutputError>
}

public struct UpdateTagOptionInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateTagOptionInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateTagOptionInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateTagOptionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateTagOptionInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateTagOptionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateTagOptionOutputError>
}

public struct UpdateTagOptionInput: Swift.Equatable {
    /// The updated active state.
    public var active: Swift.Bool?
    /// The TagOption identifier.
    /// This member is required.
    public var id: Swift.String?
    /// The updated value.
    public var value: Swift.String?

    public init (
        active: Swift.Bool? = nil,
        id: Swift.String? = nil,
        value: Swift.String? = nil
    )
    {
        self.active = active
        self.id = id
        self.value = value
    }
}

struct UpdateTagOptionInputBody: Swift.Equatable {
    public let id: Swift.String?
    public let value: Swift.String?
    public let active: Swift.Bool?
}

extension UpdateTagOptionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case active = "Active"
        case id = "Id"
        case value = "Value"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
    }
}

extension UpdateTagOptionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTagOptionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DuplicateResourceException" : self = .duplicateResourceException(try DuplicateResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParametersException" : self = .invalidParametersException(try InvalidParametersException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagOptionNotMigratedException" : self = .tagOptionNotMigratedException(try TagOptionNotMigratedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTagOptionOutputError: Swift.Error, Swift.Equatable {
    case duplicateResourceException(DuplicateResourceException)
    case invalidParametersException(InvalidParametersException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagOptionNotMigratedException(TagOptionNotMigratedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTagOptionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateTagOptionOutputResponse(tagOptionDetail: \(Swift.String(describing: tagOptionDetail)))"}
}

extension UpdateTagOptionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateTagOptionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tagOptionDetail = output.tagOptionDetail
        } else {
            self.tagOptionDetail = nil
        }
    }
}

public struct UpdateTagOptionOutputResponse: Swift.Equatable {
    /// Information about the TagOption.
    public var tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail?

    public init (
        tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail? = nil
    )
    {
        self.tagOptionDetail = tagOptionDetail
    }
}

struct UpdateTagOptionOutputResponseBody: Swift.Equatable {
    public let tagOptionDetail: ServiceCatalogClientTypes.TagOptionDetail?
}

extension UpdateTagOptionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagOptionDetail = "TagOptionDetail"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagOptionDetailDecoded = try containerValues.decodeIfPresent(ServiceCatalogClientTypes.TagOptionDetail.self, forKey: .tagOptionDetail)
        tagOptionDetail = tagOptionDetailDecoded
    }
}

extension ServiceCatalogClientTypes.UsageInstruction: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ServiceCatalogClientTypes.UsageInstruction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UsageInstruction(type: \(Swift.String(describing: type)), value: \(Swift.String(describing: value)))"}
}

extension ServiceCatalogClientTypes {
    /// Additional information provided by the administrator.
    public struct UsageInstruction: Swift.Equatable {
        /// The usage instruction type for the value.
        public var type: Swift.String?
        /// The usage instruction value for this type.
        public var value: Swift.String?

        public init (
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}
