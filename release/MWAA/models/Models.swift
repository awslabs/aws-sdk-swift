// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Access to the Airflow Web UI or CLI has been Denied. Please follow the MWAA user guide to setup permissions to access the Web UI and CLI functionality.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateCliTokenInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCliTokenInput(name: \(String(describing: name)))"}
}

extension CreateCliTokenInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CreateCliTokenInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCliTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCliTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCliTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCliTokenInput>
    public typealias MOutput = OperationOutput<CreateCliTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCliTokenOutputError>
}

public struct CreateCliTokenInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCliTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCliTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCliTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCliTokenInput>
    public typealias MOutput = OperationOutput<CreateCliTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCliTokenOutputError>
}

public struct CreateCliTokenInput: Equatable {
    /// <p>Create a CLI token request for a MWAA environment.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct CreateCliTokenInputBody: Equatable {
}

extension CreateCliTokenInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CreateCliTokenOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCliTokenOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCliTokenOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCliTokenOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCliTokenOutputResponse(webServerHostname: \(String(describing: webServerHostname)), cliToken: \"CONTENT_REDACTED\")"}
}

extension CreateCliTokenOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCliTokenOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.cliToken = output.cliToken
            self.webServerHostname = output.webServerHostname
        } else {
            self.cliToken = nil
            self.webServerHostname = nil
        }
    }
}

public struct CreateCliTokenOutputResponse: Equatable {
    /// <p>Create an Airflow CLI login token response for the provided JWT token.</p>
    public let cliToken: String?
    /// <p>Create an Airflow CLI login token response for the provided webserver hostname.</p>
    public let webServerHostname: String?

    public init (
        cliToken: String? = nil,
        webServerHostname: String? = nil
    )
    {
        self.cliToken = cliToken
        self.webServerHostname = webServerHostname
    }
}

struct CreateCliTokenOutputResponseBody: Equatable {
    public let cliToken: String?
    public let webServerHostname: String?
}

extension CreateCliTokenOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cliToken = "CliToken"
        case webServerHostname = "WebServerHostname"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cliTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cliToken)
        cliToken = cliTokenDecoded
        let webServerHostnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webServerHostname)
        webServerHostname = webServerHostnameDecoded
    }
}

public struct CreateEnvironmentInputBodyMiddleware: Middleware {
    public let id: String = "CreateEnvironmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEnvironmentInput>
    public typealias MOutput = OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEnvironmentOutputError>
}

extension CreateEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEnvironmentInput(airflowVersion: \(String(describing: airflowVersion)), dagS3Path: \(String(describing: dagS3Path)), environmentClass: \(String(describing: environmentClass)), executionRoleArn: \(String(describing: executionRoleArn)), kmsKey: \(String(describing: kmsKey)), loggingConfiguration: \(String(describing: loggingConfiguration)), maxWorkers: \(String(describing: maxWorkers)), minWorkers: \(String(describing: minWorkers)), name: \(String(describing: name)), networkConfiguration: \(String(describing: networkConfiguration)), pluginsS3ObjectVersion: \(String(describing: pluginsS3ObjectVersion)), pluginsS3Path: \(String(describing: pluginsS3Path)), requirementsS3ObjectVersion: \(String(describing: requirementsS3ObjectVersion)), requirementsS3Path: \(String(describing: requirementsS3Path)), schedulers: \(String(describing: schedulers)), sourceBucketArn: \(String(describing: sourceBucketArn)), tags: \(String(describing: tags)), webserverAccessMode: \(String(describing: webserverAccessMode)), weeklyMaintenanceWindowStart: \(String(describing: weeklyMaintenanceWindowStart)), airflowConfigurationOptions: \"CONTENT_REDACTED\")"}
}

extension CreateEnvironmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case airflowConfigurationOptions = "AirflowConfigurationOptions"
        case airflowVersion = "AirflowVersion"
        case dagS3Path = "DagS3Path"
        case environmentClass = "EnvironmentClass"
        case executionRoleArn = "ExecutionRoleArn"
        case kmsKey = "KmsKey"
        case loggingConfiguration = "LoggingConfiguration"
        case maxWorkers = "MaxWorkers"
        case minWorkers = "MinWorkers"
        case networkConfiguration = "NetworkConfiguration"
        case pluginsS3ObjectVersion = "PluginsS3ObjectVersion"
        case pluginsS3Path = "PluginsS3Path"
        case requirementsS3ObjectVersion = "RequirementsS3ObjectVersion"
        case requirementsS3Path = "RequirementsS3Path"
        case schedulers = "Schedulers"
        case sourceBucketArn = "SourceBucketArn"
        case tags = "Tags"
        case webserverAccessMode = "WebserverAccessMode"
        case weeklyMaintenanceWindowStart = "WeeklyMaintenanceWindowStart"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let airflowConfigurationOptions = airflowConfigurationOptions {
            var airflowConfigurationOptionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .airflowConfigurationOptions)
            for (dictKey0, airflowconfigurationoptions0) in airflowConfigurationOptions {
                try airflowConfigurationOptionsContainer.encode(airflowconfigurationoptions0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let airflowVersion = airflowVersion {
            try encodeContainer.encode(airflowVersion, forKey: .airflowVersion)
        }
        if let dagS3Path = dagS3Path {
            try encodeContainer.encode(dagS3Path, forKey: .dagS3Path)
        }
        if let environmentClass = environmentClass {
            try encodeContainer.encode(environmentClass, forKey: .environmentClass)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let kmsKey = kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let loggingConfiguration = loggingConfiguration {
            try encodeContainer.encode(loggingConfiguration, forKey: .loggingConfiguration)
        }
        if let maxWorkers = maxWorkers {
            try encodeContainer.encode(maxWorkers, forKey: .maxWorkers)
        }
        if let minWorkers = minWorkers {
            try encodeContainer.encode(minWorkers, forKey: .minWorkers)
        }
        if let networkConfiguration = networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let pluginsS3ObjectVersion = pluginsS3ObjectVersion {
            try encodeContainer.encode(pluginsS3ObjectVersion, forKey: .pluginsS3ObjectVersion)
        }
        if let pluginsS3Path = pluginsS3Path {
            try encodeContainer.encode(pluginsS3Path, forKey: .pluginsS3Path)
        }
        if let requirementsS3ObjectVersion = requirementsS3ObjectVersion {
            try encodeContainer.encode(requirementsS3ObjectVersion, forKey: .requirementsS3ObjectVersion)
        }
        if let requirementsS3Path = requirementsS3Path {
            try encodeContainer.encode(requirementsS3Path, forKey: .requirementsS3Path)
        }
        if let schedulers = schedulers {
            try encodeContainer.encode(schedulers, forKey: .schedulers)
        }
        if let sourceBucketArn = sourceBucketArn {
            try encodeContainer.encode(sourceBucketArn, forKey: .sourceBucketArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let webserverAccessMode = webserverAccessMode {
            try encodeContainer.encode(webserverAccessMode.rawValue, forKey: .webserverAccessMode)
        }
        if let weeklyMaintenanceWindowStart = weeklyMaintenanceWindowStart {
            try encodeContainer.encode(weeklyMaintenanceWindowStart, forKey: .weeklyMaintenanceWindowStart)
        }
    }
}

public struct CreateEnvironmentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEnvironmentInput>
    public typealias MOutput = OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEnvironmentOutputError>
}

public struct CreateEnvironmentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEnvironmentInput>
    public typealias MOutput = OperationOutput<CreateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEnvironmentOutputError>
}

/// <p>This section contains the Amazon Managed Workflows for Apache Airflow (MWAA) API reference documentation to create an environment. For more information, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/get-started.html">Get started with Amazon Managed Workflows for Apache Airflow</a>.</p>
public struct CreateEnvironmentInput: Equatable {
    /// <p>A list of key-value pairs containing the Apache Airflow configuration options you want to attach to your environment. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-env-variables.html">Apache Airflow configuration options</a>.</p>
    public let airflowConfigurationOptions: [String:String]?
    /// <p>The Apache Airflow version for your environment. For example, <code>v1.10.12</code>. If no value is specified, defaults to the latest version. Valid values: <code>v1.10.12</code>.</p>
    public let airflowVersion: String?
    /// <p>The relative path to the DAGs folder on your Amazon S3 bucket. For example, <code>dags</code>. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-dag-folder.html">Adding or updating DAGs</a>.</p>
    public let dagS3Path: String?
    /// <p>The environment class type. Valid values: <code>mw1.small</code>, <code>mw1.medium</code>, <code>mw1.large</code>. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/environment-class.html">Amazon MWAA environment class</a>.</p>
    public let environmentClass: String?
    /// <p>The Amazon Resource Name (ARN) of the execution role for your environment. An execution role is an AWS Identity and Access Management (IAM) role that grants MWAA permission to access AWS services and resources used by your environment. For example, <code>arn:aws:iam::123456789:role/my-execution-role</code>. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/mwaa-create-role.html">Amazon MWAA Execution role</a>.</p>
    public let executionRoleArn: String?
    /// <p>The AWS Key Management Service (KMS) key to encrypt the data in your environment. You can use an AWS owned CMK, or a Customer managed CMK (advanced). To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/get-started.html">Get started with Amazon Managed Workflows for Apache Airflow</a>.</p>
    public let kmsKey: String?
    /// <p>Defines the Apache Airflow logs to send to CloudWatch Logs: <code>DagProcessingLogs</code>, <code>SchedulerLogs</code>, <code>TaskLogs</code>, <code>WebserverLogs</code>, <code>WorkerLogs</code>.</p>
    public let loggingConfiguration: LoggingConfigurationInput?
    /// <p>The maximum number of workers that you want to run in your environment. MWAA scales the number of Apache Airflow workers up to the number you specify in the <code>MaxWorkers</code> field. For example, <code>20</code>. When there are no more tasks running, and no more in the queue, MWAA disposes of the extra workers leaving the one worker that is included with your environment, or the number you specify in <code>MinWorkers</code>.</p>
    public let maxWorkers: Int?
    /// <p>The minimum number of workers that you want to run in your environment. MWAA scales the number of Apache Airflow workers up to the number you specify in the <code>MaxWorkers</code> field. When there are no more tasks running, and no more in the queue, MWAA disposes of the extra workers leaving the worker count you specify in the <code>MinWorkers</code> field. For example, <code>2</code>.</p>
    public let minWorkers: Int?
    /// <p>The name of the Amazon MWAA environment. For example, <code>MyMWAAEnvironment</code>.</p>
    public let name: String?
    /// <p>The VPC networking components used to secure and enable network traffic between the AWS resources for your environment. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/networking-about.html">About networking on Amazon MWAA</a>.</p>
    public let networkConfiguration: NetworkConfiguration?
    /// <p>The version of the plugins.zip file on your Amazon S3 bucket. A version must be specified each time a plugins.zip file is updated. To learn more, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/versioning-workflows.html">How S3 Versioning works</a>.</p>
    public let pluginsS3ObjectVersion: String?
    /// <p>The relative path to the <code>plugins.zip</code> file on your Amazon S3 bucket. For example, <code>plugins.zip</code>. If specified, then the plugins.zip version is required. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-dag-import-plugins.html">Installing custom plugins</a>.</p>
    public let pluginsS3Path: String?
    /// <p>The version of the requirements.txt file on your Amazon S3 bucket. A version must be specified each time a requirements.txt file is updated. To learn more, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/versioning-workflows.html">How S3 Versioning works</a>.</p>
    public let requirementsS3ObjectVersion: String?
    /// <p>The relative path to the <code>requirements.txt</code> file on your Amazon S3 bucket. For example, <code>requirements.txt</code>. If specified, then a file version is required. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/working-dags-dependencies.html">Installing Python dependencies</a>.</p>
    public let requirementsS3Path: String?
    /// <p>The number of Apache Airflow schedulers to run in your environment.</p>
    public let schedulers: Int?
    /// <p>The Amazon Resource Name (ARN) of the Amazon S3 bucket where your DAG code and supporting files are stored. For example, <code>arn:aws:s3:::my-airflow-bucket-unique-name</code>. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/mwaa-s3-bucket.html">Create an Amazon S3 bucket for Amazon MWAA</a>.</p>
    public let sourceBucketArn: String?
    /// <p>The key-value tag pairs you want to associate to your environment. For example, <code>"Environment": "Staging"</code>. To learn more, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS resources</a>.</p>
    public let tags: [String:String]?
    /// <p>The Apache Airflow <i>Web server</i> access mode. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-networking.html">Apache Airflow access modes</a>.</p>
    public let webserverAccessMode: WebserverAccessMode?
    /// <p>The day and time of the week to start weekly maintenance updates of your environment in the following format: <code>DAY:HH:MM</code>. For example: <code>TUE:03:30</code>. You can specify a start time in 30 minute increments only. Supported input includes the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>MON|TUE|WED|THU|FRI|SAT|SUN:([01]\\d|2[0-3]):(00|30)</p>
    ///             </li>
    ///          </ul>
    public let weeklyMaintenanceWindowStart: String?

    public init (
        airflowConfigurationOptions: [String:String]? = nil,
        airflowVersion: String? = nil,
        dagS3Path: String? = nil,
        environmentClass: String? = nil,
        executionRoleArn: String? = nil,
        kmsKey: String? = nil,
        loggingConfiguration: LoggingConfigurationInput? = nil,
        maxWorkers: Int? = nil,
        minWorkers: Int? = nil,
        name: String? = nil,
        networkConfiguration: NetworkConfiguration? = nil,
        pluginsS3ObjectVersion: String? = nil,
        pluginsS3Path: String? = nil,
        requirementsS3ObjectVersion: String? = nil,
        requirementsS3Path: String? = nil,
        schedulers: Int? = nil,
        sourceBucketArn: String? = nil,
        tags: [String:String]? = nil,
        webserverAccessMode: WebserverAccessMode? = nil,
        weeklyMaintenanceWindowStart: String? = nil
    )
    {
        self.airflowConfigurationOptions = airflowConfigurationOptions
        self.airflowVersion = airflowVersion
        self.dagS3Path = dagS3Path
        self.environmentClass = environmentClass
        self.executionRoleArn = executionRoleArn
        self.kmsKey = kmsKey
        self.loggingConfiguration = loggingConfiguration
        self.maxWorkers = maxWorkers
        self.minWorkers = minWorkers
        self.name = name
        self.networkConfiguration = networkConfiguration
        self.pluginsS3ObjectVersion = pluginsS3ObjectVersion
        self.pluginsS3Path = pluginsS3Path
        self.requirementsS3ObjectVersion = requirementsS3ObjectVersion
        self.requirementsS3Path = requirementsS3Path
        self.schedulers = schedulers
        self.sourceBucketArn = sourceBucketArn
        self.tags = tags
        self.webserverAccessMode = webserverAccessMode
        self.weeklyMaintenanceWindowStart = weeklyMaintenanceWindowStart
    }
}

struct CreateEnvironmentInputBody: Equatable {
    public let executionRoleArn: String?
    public let sourceBucketArn: String?
    public let dagS3Path: String?
    public let networkConfiguration: NetworkConfiguration?
    public let pluginsS3Path: String?
    public let pluginsS3ObjectVersion: String?
    public let requirementsS3Path: String?
    public let requirementsS3ObjectVersion: String?
    public let airflowConfigurationOptions: [String:String]?
    public let environmentClass: String?
    public let maxWorkers: Int?
    public let kmsKey: String?
    public let airflowVersion: String?
    public let loggingConfiguration: LoggingConfigurationInput?
    public let weeklyMaintenanceWindowStart: String?
    public let tags: [String:String]?
    public let webserverAccessMode: WebserverAccessMode?
    public let minWorkers: Int?
    public let schedulers: Int?
}

extension CreateEnvironmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case airflowConfigurationOptions = "AirflowConfigurationOptions"
        case airflowVersion = "AirflowVersion"
        case dagS3Path = "DagS3Path"
        case environmentClass = "EnvironmentClass"
        case executionRoleArn = "ExecutionRoleArn"
        case kmsKey = "KmsKey"
        case loggingConfiguration = "LoggingConfiguration"
        case maxWorkers = "MaxWorkers"
        case minWorkers = "MinWorkers"
        case networkConfiguration = "NetworkConfiguration"
        case pluginsS3ObjectVersion = "PluginsS3ObjectVersion"
        case pluginsS3Path = "PluginsS3Path"
        case requirementsS3ObjectVersion = "RequirementsS3ObjectVersion"
        case requirementsS3Path = "RequirementsS3Path"
        case schedulers = "Schedulers"
        case sourceBucketArn = "SourceBucketArn"
        case tags = "Tags"
        case webserverAccessMode = "WebserverAccessMode"
        case weeklyMaintenanceWindowStart = "WeeklyMaintenanceWindowStart"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let sourceBucketArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceBucketArn)
        sourceBucketArn = sourceBucketArnDecoded
        let dagS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dagS3Path)
        dagS3Path = dagS3PathDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let pluginsS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pluginsS3Path)
        pluginsS3Path = pluginsS3PathDecoded
        let pluginsS3ObjectVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pluginsS3ObjectVersion)
        pluginsS3ObjectVersion = pluginsS3ObjectVersionDecoded
        let requirementsS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requirementsS3Path)
        requirementsS3Path = requirementsS3PathDecoded
        let requirementsS3ObjectVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requirementsS3ObjectVersion)
        requirementsS3ObjectVersion = requirementsS3ObjectVersionDecoded
        let airflowConfigurationOptionsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .airflowConfigurationOptions)
        var airflowConfigurationOptionsDecoded0: [String:String]? = nil
        if let airflowConfigurationOptionsContainer = airflowConfigurationOptionsContainer {
            airflowConfigurationOptionsDecoded0 = [String:String]()
            for (key0, configvalue0) in airflowConfigurationOptionsContainer {
                if let configvalue0 = configvalue0 {
                    airflowConfigurationOptionsDecoded0?[key0] = configvalue0
                }
            }
        }
        airflowConfigurationOptions = airflowConfigurationOptionsDecoded0
        let environmentClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentClass)
        environmentClass = environmentClassDecoded
        let maxWorkersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxWorkers)
        maxWorkers = maxWorkersDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let airflowVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .airflowVersion)
        airflowVersion = airflowVersionDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(LoggingConfigurationInput.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
        let weeklyMaintenanceWindowStartDecoded = try containerValues.decodeIfPresent(String.self, forKey: .weeklyMaintenanceWindowStart)
        weeklyMaintenanceWindowStart = weeklyMaintenanceWindowStartDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let webserverAccessModeDecoded = try containerValues.decodeIfPresent(WebserverAccessMode.self, forKey: .webserverAccessMode)
        webserverAccessMode = webserverAccessModeDecoded
        let minWorkersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minWorkers)
        minWorkers = minWorkersDecoded
        let schedulersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .schedulers)
        schedulers = schedulersDecoded
    }
}

extension CreateEnvironmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEnvironmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEnvironmentOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEnvironmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEnvironmentOutputResponse(arn: \(String(describing: arn)))"}
}

extension CreateEnvironmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct CreateEnvironmentOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) returned in the response for the environment.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreateEnvironmentOutputResponseBody: Equatable {
    public let arn: String?
}

extension CreateEnvironmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension CreateWebLoginTokenInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWebLoginTokenInput(name: \(String(describing: name)))"}
}

extension CreateWebLoginTokenInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct CreateWebLoginTokenInputHeadersMiddleware: Middleware {
    public let id: String = "CreateWebLoginTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWebLoginTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWebLoginTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWebLoginTokenInput>
    public typealias MOutput = OperationOutput<CreateWebLoginTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWebLoginTokenOutputError>
}

public struct CreateWebLoginTokenInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateWebLoginTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWebLoginTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWebLoginTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWebLoginTokenInput>
    public typealias MOutput = OperationOutput<CreateWebLoginTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWebLoginTokenOutputError>
}

public struct CreateWebLoginTokenInput: Equatable {
    /// <p>Create an Airflow Web UI login token request for a MWAA environment.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct CreateWebLoginTokenInputBody: Equatable {
}

extension CreateWebLoginTokenInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension CreateWebLoginTokenOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWebLoginTokenOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWebLoginTokenOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWebLoginTokenOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWebLoginTokenOutputResponse(webServerHostname: \(String(describing: webServerHostname)), webToken: \"CONTENT_REDACTED\")"}
}

extension CreateWebLoginTokenOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateWebLoginTokenOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.webServerHostname = output.webServerHostname
            self.webToken = output.webToken
        } else {
            self.webServerHostname = nil
            self.webToken = nil
        }
    }
}

public struct CreateWebLoginTokenOutputResponse: Equatable {
    /// <p>Create an Airflow Web UI login token response for the provided webserver hostname.</p>
    public let webServerHostname: String?
    /// <p>Create an Airflow Web UI login token response for the provided JWT token.</p>
    public let webToken: String?

    public init (
        webServerHostname: String? = nil,
        webToken: String? = nil
    )
    {
        self.webServerHostname = webServerHostname
        self.webToken = webToken
    }
}

struct CreateWebLoginTokenOutputResponseBody: Equatable {
    public let webToken: String?
    public let webServerHostname: String?
}

extension CreateWebLoginTokenOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case webServerHostname = "WebServerHostname"
        case webToken = "WebToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let webTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webToken)
        webToken = webTokenDecoded
        let webServerHostnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webServerHostname)
        webServerHostname = webServerHostnameDecoded
    }
}

extension DeleteEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEnvironmentInput(name: \(String(describing: name)))"}
}

extension DeleteEnvironmentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteEnvironmentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEnvironmentInput>
    public typealias MOutput = OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEnvironmentOutputError>
}

public struct DeleteEnvironmentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEnvironmentInput>
    public typealias MOutput = OperationOutput<DeleteEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEnvironmentOutputError>
}

public struct DeleteEnvironmentInput: Equatable {
    /// <p>The name of the Amazon MWAA environment. For example, <code>MyMWAAEnvironment</code>.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteEnvironmentInputBody: Equatable {
}

extension DeleteEnvironmentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteEnvironmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEnvironmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEnvironmentOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEnvironmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEnvironmentOutputResponse()"}
}

extension DeleteEnvironmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteEnvironmentOutputResponse: Equatable {

    public init() {}
}

struct DeleteEnvironmentOutputResponseBody: Equatable {
}

extension DeleteEnvironmentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Dimension: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Dimension: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Dimension(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>Internal only API.</p>
public struct Dimension: Equatable {
    /// <p>Internal only API.</p>
    public let name: String?
    /// <p>Internal only API.</p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

extension Environment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case airflowConfigurationOptions = "AirflowConfigurationOptions"
        case airflowVersion = "AirflowVersion"
        case arn = "Arn"
        case createdAt = "CreatedAt"
        case dagS3Path = "DagS3Path"
        case environmentClass = "EnvironmentClass"
        case executionRoleArn = "ExecutionRoleArn"
        case kmsKey = "KmsKey"
        case lastUpdate = "LastUpdate"
        case loggingConfiguration = "LoggingConfiguration"
        case maxWorkers = "MaxWorkers"
        case minWorkers = "MinWorkers"
        case name = "Name"
        case networkConfiguration = "NetworkConfiguration"
        case pluginsS3ObjectVersion = "PluginsS3ObjectVersion"
        case pluginsS3Path = "PluginsS3Path"
        case requirementsS3ObjectVersion = "RequirementsS3ObjectVersion"
        case requirementsS3Path = "RequirementsS3Path"
        case schedulers = "Schedulers"
        case serviceRoleArn = "ServiceRoleArn"
        case sourceBucketArn = "SourceBucketArn"
        case status = "Status"
        case tags = "Tags"
        case webserverAccessMode = "WebserverAccessMode"
        case webserverUrl = "WebserverUrl"
        case weeklyMaintenanceWindowStart = "WeeklyMaintenanceWindowStart"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let airflowConfigurationOptions = airflowConfigurationOptions {
            var airflowConfigurationOptionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .airflowConfigurationOptions)
            for (dictKey0, airflowconfigurationoptions0) in airflowConfigurationOptions {
                try airflowConfigurationOptionsContainer.encode(airflowconfigurationoptions0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let airflowVersion = airflowVersion {
            try encodeContainer.encode(airflowVersion, forKey: .airflowVersion)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let dagS3Path = dagS3Path {
            try encodeContainer.encode(dagS3Path, forKey: .dagS3Path)
        }
        if let environmentClass = environmentClass {
            try encodeContainer.encode(environmentClass, forKey: .environmentClass)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let kmsKey = kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let lastUpdate = lastUpdate {
            try encodeContainer.encode(lastUpdate, forKey: .lastUpdate)
        }
        if let loggingConfiguration = loggingConfiguration {
            try encodeContainer.encode(loggingConfiguration, forKey: .loggingConfiguration)
        }
        if let maxWorkers = maxWorkers {
            try encodeContainer.encode(maxWorkers, forKey: .maxWorkers)
        }
        if let minWorkers = minWorkers {
            try encodeContainer.encode(minWorkers, forKey: .minWorkers)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let networkConfiguration = networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let pluginsS3ObjectVersion = pluginsS3ObjectVersion {
            try encodeContainer.encode(pluginsS3ObjectVersion, forKey: .pluginsS3ObjectVersion)
        }
        if let pluginsS3Path = pluginsS3Path {
            try encodeContainer.encode(pluginsS3Path, forKey: .pluginsS3Path)
        }
        if let requirementsS3ObjectVersion = requirementsS3ObjectVersion {
            try encodeContainer.encode(requirementsS3ObjectVersion, forKey: .requirementsS3ObjectVersion)
        }
        if let requirementsS3Path = requirementsS3Path {
            try encodeContainer.encode(requirementsS3Path, forKey: .requirementsS3Path)
        }
        if let schedulers = schedulers {
            try encodeContainer.encode(schedulers, forKey: .schedulers)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let sourceBucketArn = sourceBucketArn {
            try encodeContainer.encode(sourceBucketArn, forKey: .sourceBucketArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let webserverAccessMode = webserverAccessMode {
            try encodeContainer.encode(webserverAccessMode.rawValue, forKey: .webserverAccessMode)
        }
        if let webserverUrl = webserverUrl {
            try encodeContainer.encode(webserverUrl, forKey: .webserverUrl)
        }
        if let weeklyMaintenanceWindowStart = weeklyMaintenanceWindowStart {
            try encodeContainer.encode(weeklyMaintenanceWindowStart, forKey: .weeklyMaintenanceWindowStart)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(EnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let webserverUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webserverUrl)
        webserverUrl = webserverUrlDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let airflowVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .airflowVersion)
        airflowVersion = airflowVersionDecoded
        let sourceBucketArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceBucketArn)
        sourceBucketArn = sourceBucketArnDecoded
        let dagS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dagS3Path)
        dagS3Path = dagS3PathDecoded
        let pluginsS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pluginsS3Path)
        pluginsS3Path = pluginsS3PathDecoded
        let pluginsS3ObjectVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pluginsS3ObjectVersion)
        pluginsS3ObjectVersion = pluginsS3ObjectVersionDecoded
        let requirementsS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requirementsS3Path)
        requirementsS3Path = requirementsS3PathDecoded
        let requirementsS3ObjectVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requirementsS3ObjectVersion)
        requirementsS3ObjectVersion = requirementsS3ObjectVersionDecoded
        let airflowConfigurationOptionsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .airflowConfigurationOptions)
        var airflowConfigurationOptionsDecoded0: [String:String]? = nil
        if let airflowConfigurationOptionsContainer = airflowConfigurationOptionsContainer {
            airflowConfigurationOptionsDecoded0 = [String:String]()
            for (key0, configvalue0) in airflowConfigurationOptionsContainer {
                if let configvalue0 = configvalue0 {
                    airflowConfigurationOptionsDecoded0?[key0] = configvalue0
                }
            }
        }
        airflowConfigurationOptions = airflowConfigurationOptionsDecoded0
        let environmentClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentClass)
        environmentClass = environmentClassDecoded
        let maxWorkersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxWorkers)
        maxWorkers = maxWorkersDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(NetworkConfiguration.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(LoggingConfiguration.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
        let lastUpdateDecoded = try containerValues.decodeIfPresent(LastUpdate.self, forKey: .lastUpdate)
        lastUpdate = lastUpdateDecoded
        let weeklyMaintenanceWindowStartDecoded = try containerValues.decodeIfPresent(String.self, forKey: .weeklyMaintenanceWindowStart)
        weeklyMaintenanceWindowStart = weeklyMaintenanceWindowStartDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let webserverAccessModeDecoded = try containerValues.decodeIfPresent(WebserverAccessMode.self, forKey: .webserverAccessMode)
        webserverAccessMode = webserverAccessModeDecoded
        let minWorkersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minWorkers)
        minWorkers = minWorkersDecoded
        let schedulersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .schedulers)
        schedulers = schedulersDecoded
    }
}

extension Environment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Environment(airflowConfigurationOptions: \(String(describing: airflowConfigurationOptions)), airflowVersion: \(String(describing: airflowVersion)), arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), dagS3Path: \(String(describing: dagS3Path)), environmentClass: \(String(describing: environmentClass)), executionRoleArn: \(String(describing: executionRoleArn)), kmsKey: \(String(describing: kmsKey)), lastUpdate: \(String(describing: lastUpdate)), loggingConfiguration: \(String(describing: loggingConfiguration)), maxWorkers: \(String(describing: maxWorkers)), minWorkers: \(String(describing: minWorkers)), name: \(String(describing: name)), networkConfiguration: \(String(describing: networkConfiguration)), pluginsS3ObjectVersion: \(String(describing: pluginsS3ObjectVersion)), pluginsS3Path: \(String(describing: pluginsS3Path)), requirementsS3ObjectVersion: \(String(describing: requirementsS3ObjectVersion)), requirementsS3Path: \(String(describing: requirementsS3Path)), schedulers: \(String(describing: schedulers)), serviceRoleArn: \(String(describing: serviceRoleArn)), sourceBucketArn: \(String(describing: sourceBucketArn)), status: \(String(describing: status)), tags: \(String(describing: tags)), webserverAccessMode: \(String(describing: webserverAccessMode)), webserverUrl: \(String(describing: webserverUrl)), weeklyMaintenanceWindowStart: \(String(describing: weeklyMaintenanceWindowStart)))"}
}

/// <p>The Amazon Managed Workflows for Apache Airflow (MWAA) environment.</p>
public struct Environment: Equatable {
    /// <p>A list of key-value pairs containing the Apache Airflow configuration options attached to your environment. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-env-variables.html">Apache Airflow configuration options</a>.</p>
    public let airflowConfigurationOptions: [String:String]?
    /// <p>The Apache Airflow version on your environment. For example, <code>v1.10.12</code>.</p>
    public let airflowVersion: String?
    /// <p>The Amazon Resource Name (ARN) of the Amazon MWAA environment.</p>
    public let arn: String?
    /// <p>The day and time the environment was created.</p>
    public let createdAt: Date?
    /// <p>The relative path to the DAGs folder on your Amazon S3 bucket. For example, <code>dags</code>. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-dag-folder.html">Adding or updating DAGs</a>.</p>
    public let dagS3Path: String?
    /// <p>The environment class type. Valid values: <code>mw1.small</code>, <code>mw1.medium</code>, <code>mw1.large</code>. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/environment-class.html">Amazon MWAA environment class</a>.</p>
    public let environmentClass: String?
    /// <p>The Amazon Resource Name (ARN) of the execution role in IAM that allows MWAA to access AWS resources in your environment. For example, <code>arn:aws:iam::123456789:role/my-execution-role</code>. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/mwaa-create-role.html">Amazon MWAA Execution role</a>.</p>
    public let executionRoleArn: String?
    /// <p>The Key Management Service (KMS) encryption key used to encrypt the data in your environment.</p>
    public let kmsKey: String?
    /// <p>The status of the last update on the environment, and any errors that were encountered.</p>
    public let lastUpdate: LastUpdate?
    /// <p>The Apache Airflow logs being sent to CloudWatch Logs: <code>DagProcessingLogs</code>, <code>SchedulerLogs</code>, <code>TaskLogs</code>, <code>WebserverLogs</code>, <code>WorkerLogs</code>.</p>
    public let loggingConfiguration: LoggingConfiguration?
    /// <p>The maximum number of workers that run in your environment. For example, <code>20</code>.</p>
    public let maxWorkers: Int?
    /// <p>The minimum number of workers that run in your environment. For example, <code>2</code>.</p>
    public let minWorkers: Int?
    /// <p>The name of the Amazon MWAA environment. For example, <code>MyMWAAEnvironment</code>.</p>
    public let name: String?
    /// <p>The VPC networking components used to secure and enable network traffic between the AWS resources for your environment. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/networking-about.html">About networking on Amazon MWAA</a>.</p>
    public let networkConfiguration: NetworkConfiguration?
    /// <p>The version of the plugins.zip file on your Amazon S3 bucket. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-dag-import-plugins.html">Installing custom plugins</a>.</p>
    public let pluginsS3ObjectVersion: String?
    /// <p>The relative path to the <code>plugins.zip</code> file on your Amazon S3 bucket. For example, <code>plugins.zip</code>. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-dag-import-plugins.html">Installing custom plugins</a>.</p>
    public let pluginsS3Path: String?
    /// <p>The version of the requirements.txt file on your Amazon S3 bucket. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/working-dags-dependencies.html">Installing Python dependencies</a>.</p>
    public let requirementsS3ObjectVersion: String?
    /// <p>The relative path to the <code>requirements.txt</code> file on your Amazon S3 bucket. For example, <code>requirements.txt</code>. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/working-dags-dependencies.html">Installing Python dependencies</a>.</p>
    public let requirementsS3Path: String?
    /// <p>The number of Apache Airflow schedulers that run in your Amazon MWAA environment.</p>
    public let schedulers: Int?
    /// <p>The Amazon Resource Name (ARN) for the service-linked role of the environment. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/mwaa-slr.html">Amazon MWAA Service-linked role</a>.</p>
    public let serviceRoleArn: String?
    /// <p>The Amazon Resource Name (ARN) of the Amazon S3 bucket where your DAG code and supporting files are stored. For example, <code>arn:aws:s3:::my-airflow-bucket-unique-name</code>. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/mwaa-s3-bucket.html">Create an Amazon S3 bucket for Amazon MWAA</a>.</p>
    public let sourceBucketArn: String?
    /// <p>The status of the Amazon MWAA environment. Valid values:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>CREATING</code> - Indicates the request to create the environment is in progress.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>CREATE_FAILED</code> - Indicates the request to create the environment failed, and the environment could not be created.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>AVAILABLE</code> - Indicates the request was successful and the environment is ready to use.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>UPDATING</code> - Indicates the request to update the environment is in progress.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DELETING</code> - Indicates the request to delete the environment is in progress.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>DELETED</code> - Indicates the request to delete the environment is complete, and the environment has been deleted.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>UNAVAILABLE</code> - Indicates the request failed, but the environment was unable to rollback and is not in a stable state.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>UPDATE_FAILED</code> - Indicates the request to update the environment failed, and the environment has rolled back successfully and is ready to use.</p>
    ///             </li>
    ///          </ul>
    ///         <p>We recommend reviewing our troubleshooting guide for a list of common errors and their solutions. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/troubleshooting.html">Amazon MWAA troubleshooting</a>.</p>
    public let status: EnvironmentStatus?
    /// <p>The key-value tag pairs associated to your environment. For example, <code>"Environment": "Staging"</code>. To learn more, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS resources</a>.</p>
    public let tags: [String:String]?
    /// <p>The Apache Airflow <i>Web server</i> access mode. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-networking.html">Apache Airflow access modes</a>.</p>
    public let webserverAccessMode: WebserverAccessMode?
    /// <p>The Apache Airflow <i>Web server</i> host name for the Amazon MWAA environment. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/access-airflow-ui.html">Accessing the Apache Airflow UI</a>.</p>
    public let webserverUrl: String?
    /// <p>The day and time of the week that weekly maintenance updates are scheduled. For example: <code>TUE:03:30</code>.</p>
    public let weeklyMaintenanceWindowStart: String?

    public init (
        airflowConfigurationOptions: [String:String]? = nil,
        airflowVersion: String? = nil,
        arn: String? = nil,
        createdAt: Date? = nil,
        dagS3Path: String? = nil,
        environmentClass: String? = nil,
        executionRoleArn: String? = nil,
        kmsKey: String? = nil,
        lastUpdate: LastUpdate? = nil,
        loggingConfiguration: LoggingConfiguration? = nil,
        maxWorkers: Int? = nil,
        minWorkers: Int? = nil,
        name: String? = nil,
        networkConfiguration: NetworkConfiguration? = nil,
        pluginsS3ObjectVersion: String? = nil,
        pluginsS3Path: String? = nil,
        requirementsS3ObjectVersion: String? = nil,
        requirementsS3Path: String? = nil,
        schedulers: Int? = nil,
        serviceRoleArn: String? = nil,
        sourceBucketArn: String? = nil,
        status: EnvironmentStatus? = nil,
        tags: [String:String]? = nil,
        webserverAccessMode: WebserverAccessMode? = nil,
        webserverUrl: String? = nil,
        weeklyMaintenanceWindowStart: String? = nil
    )
    {
        self.airflowConfigurationOptions = airflowConfigurationOptions
        self.airflowVersion = airflowVersion
        self.arn = arn
        self.createdAt = createdAt
        self.dagS3Path = dagS3Path
        self.environmentClass = environmentClass
        self.executionRoleArn = executionRoleArn
        self.kmsKey = kmsKey
        self.lastUpdate = lastUpdate
        self.loggingConfiguration = loggingConfiguration
        self.maxWorkers = maxWorkers
        self.minWorkers = minWorkers
        self.name = name
        self.networkConfiguration = networkConfiguration
        self.pluginsS3ObjectVersion = pluginsS3ObjectVersion
        self.pluginsS3Path = pluginsS3Path
        self.requirementsS3ObjectVersion = requirementsS3ObjectVersion
        self.requirementsS3Path = requirementsS3Path
        self.schedulers = schedulers
        self.serviceRoleArn = serviceRoleArn
        self.sourceBucketArn = sourceBucketArn
        self.status = status
        self.tags = tags
        self.webserverAccessMode = webserverAccessMode
        self.webserverUrl = webserverUrl
        self.weeklyMaintenanceWindowStart = weeklyMaintenanceWindowStart
    }
}

public enum EnvironmentStatus {
    case available
    case createFailed
    case creating
    case deleted
    case deleting
    case unavailable
    case updateFailed
    case updating
    case sdkUnknown(String)
}

extension EnvironmentStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EnvironmentStatus] {
        return [
            .available,
            .createFailed,
            .creating,
            .deleted,
            .deleting,
            .unavailable,
            .updateFailed,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .createFailed: return "CREATE_FAILED"
        case .creating: return "CREATING"
        case .deleted: return "DELETED"
        case .deleting: return "DELETING"
        case .unavailable: return "UNAVAILABLE"
        case .updateFailed: return "UPDATE_FAILED"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EnvironmentStatus(rawValue: rawValue) ?? EnvironmentStatus.sdkUnknown(rawValue)
    }
}

extension GetEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEnvironmentInput(name: \(String(describing: name)))"}
}

extension GetEnvironmentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetEnvironmentInputHeadersMiddleware: Middleware {
    public let id: String = "GetEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEnvironmentInput>
    public typealias MOutput = OperationOutput<GetEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEnvironmentOutputError>
}

public struct GetEnvironmentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEnvironmentInput>
    public typealias MOutput = OperationOutput<GetEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEnvironmentOutputError>
}

public struct GetEnvironmentInput: Equatable {
    /// <p>The name of the Amazon MWAA environment. For example, <code>MyMWAAEnvironment</code>.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct GetEnvironmentInputBody: Equatable {
}

extension GetEnvironmentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetEnvironmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEnvironmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEnvironmentOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEnvironmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEnvironmentOutputResponse(environment: \(String(describing: environment)))"}
}

extension GetEnvironmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.environment = output.environment
        } else {
            self.environment = nil
        }
    }
}

public struct GetEnvironmentOutputResponse: Equatable {
    /// <p>An object containing all available details about the environment.</p>
    public let environment: Environment?

    public init (
        environment: Environment? = nil
    )
    {
        self.environment = environment
    }
}

struct GetEnvironmentOutputResponseBody: Equatable {
    public let environment: Environment?
}

extension GetEnvironmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case environment = "Environment"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentDecoded = try containerValues.decodeIfPresent(Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>InternalServerException: An internal error has occurred.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LastUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case error = "Error"
        case status = "Status"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(UpdateStatus.self, forKey: .status)
        status = statusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let errorDecoded = try containerValues.decodeIfPresent(UpdateError.self, forKey: .error)
        error = errorDecoded
    }
}

extension LastUpdate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LastUpdate(createdAt: \(String(describing: createdAt)), error: \(String(describing: error)), status: \(String(describing: status)))"}
}

/// <p>The status of the last update on the environment, and any errors that were encountered.</p>
public struct LastUpdate: Equatable {
    /// <p>The day and time of the last update on the environment.</p>
    public let createdAt: Date?
    /// <p>The error that was encountered during the last update of the environment.</p>
    public let error: UpdateError?
    /// <p>The status of the last update on the environment. Valid values: <code>SUCCESS</code>, <code>PENDING</code>, <code>FAILED</code>.</p>
    public let status: UpdateStatus?

    public init (
        createdAt: Date? = nil,
        error: UpdateError? = nil,
        status: UpdateStatus? = nil
    )
    {
        self.createdAt = createdAt
        self.error = error
        self.status = status
    }
}

extension ListEnvironmentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEnvironmentsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEnvironmentsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListEnvironmentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListEnvironmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEnvironmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEnvironmentsInput>
    public typealias MOutput = OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEnvironmentsOutputError>
}

public struct ListEnvironmentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEnvironmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEnvironmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEnvironmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEnvironmentsInput>
    public typealias MOutput = OperationOutput<ListEnvironmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEnvironmentsOutputError>
}

public struct ListEnvironmentsInput: Equatable {
    /// <p>The maximum number of results to retrieve per page. For example, <code>5</code> environments per page.</p>
    public let maxResults: Int?
    /// <p>Retrieves the next page of the results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsInputBody: Equatable {
}

extension ListEnvironmentsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListEnvironmentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEnvironmentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEnvironmentsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEnvironmentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEnvironmentsOutputResponse(environments: \(String(describing: environments)), nextToken: \(String(describing: nextToken)))"}
}

extension ListEnvironmentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEnvironmentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.environments = output.environments
            self.nextToken = output.nextToken
        } else {
            self.environments = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentsOutputResponse: Equatable {
    /// <p>Returns the list of Amazon MWAA environments.</p>
    public let environments: [String]?
    /// <p>Retrieves the next page of the results.</p>
    public let nextToken: String?

    public init (
        environments: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.environments = environments
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsOutputResponseBody: Equatable {
    public let environments: [String]?
    public let nextToken: String?
}

extension ListEnvironmentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case environments = "Environments"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .environments)
        var environmentsDecoded0:[String]? = nil
        if let environmentsContainer = environmentsContainer {
            environmentsDecoded0 = [String]()
            for string0 in environmentsContainer {
                if let string0 = string0 {
                    environmentsDecoded0?.append(string0)
                }
            }
        }
        environments = environmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon MWAA environment. For example, <code>arn:aws:airflow:us-east-1:123456789012:environment/MyMWAAEnvironment</code>.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The key-value tag pairs associated to your environment. To learn more, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS resources</a>.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension LoggingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dagProcessingLogs = "DagProcessingLogs"
        case schedulerLogs = "SchedulerLogs"
        case taskLogs = "TaskLogs"
        case webserverLogs = "WebserverLogs"
        case workerLogs = "WorkerLogs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dagProcessingLogs = dagProcessingLogs {
            try encodeContainer.encode(dagProcessingLogs, forKey: .dagProcessingLogs)
        }
        if let schedulerLogs = schedulerLogs {
            try encodeContainer.encode(schedulerLogs, forKey: .schedulerLogs)
        }
        if let taskLogs = taskLogs {
            try encodeContainer.encode(taskLogs, forKey: .taskLogs)
        }
        if let webserverLogs = webserverLogs {
            try encodeContainer.encode(webserverLogs, forKey: .webserverLogs)
        }
        if let workerLogs = workerLogs {
            try encodeContainer.encode(workerLogs, forKey: .workerLogs)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dagProcessingLogsDecoded = try containerValues.decodeIfPresent(ModuleLoggingConfiguration.self, forKey: .dagProcessingLogs)
        dagProcessingLogs = dagProcessingLogsDecoded
        let schedulerLogsDecoded = try containerValues.decodeIfPresent(ModuleLoggingConfiguration.self, forKey: .schedulerLogs)
        schedulerLogs = schedulerLogsDecoded
        let webserverLogsDecoded = try containerValues.decodeIfPresent(ModuleLoggingConfiguration.self, forKey: .webserverLogs)
        webserverLogs = webserverLogsDecoded
        let workerLogsDecoded = try containerValues.decodeIfPresent(ModuleLoggingConfiguration.self, forKey: .workerLogs)
        workerLogs = workerLogsDecoded
        let taskLogsDecoded = try containerValues.decodeIfPresent(ModuleLoggingConfiguration.self, forKey: .taskLogs)
        taskLogs = taskLogsDecoded
    }
}

extension LoggingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoggingConfiguration(dagProcessingLogs: \(String(describing: dagProcessingLogs)), schedulerLogs: \(String(describing: schedulerLogs)), taskLogs: \(String(describing: taskLogs)), webserverLogs: \(String(describing: webserverLogs)), workerLogs: \(String(describing: workerLogs)))"}
}

/// <p>Defines the Apache Airflow logs to send to CloudWatch Logs: <code>DagProcessingLogs</code>, <code>SchedulerLogs</code>, <code>TaskLogs</code>, <code>WebserverLogs</code>, <code>WorkerLogs</code>.</p>
public struct LoggingConfiguration: Equatable {
    /// <p>Defines the type of logs to send for the Apache Airflow log type (e.g. <code>DagProcessingLogs</code>). Valid values: <code>CloudWatchLogGroupArn</code>, <code>Enabled</code>, <code>LogLevel</code>.</p>
    public let dagProcessingLogs: ModuleLoggingConfiguration?
    /// <p>Defines the type of logs to send for the Apache Airflow log type (e.g. <code>DagProcessingLogs</code>). Valid values: <code>CloudWatchLogGroupArn</code>, <code>Enabled</code>, <code>LogLevel</code>.</p>
    public let schedulerLogs: ModuleLoggingConfiguration?
    /// <p>Defines the type of logs to send for the Apache Airflow log type (e.g. <code>DagProcessingLogs</code>). Valid values: <code>CloudWatchLogGroupArn</code>, <code>Enabled</code>, <code>LogLevel</code>.</p>
    public let taskLogs: ModuleLoggingConfiguration?
    /// <p>Defines the type of logs to send for the Apache Airflow log type (e.g. <code>DagProcessingLogs</code>). Valid values: <code>CloudWatchLogGroupArn</code>, <code>Enabled</code>, <code>LogLevel</code>.</p>
    public let webserverLogs: ModuleLoggingConfiguration?
    /// <p>Defines the type of logs to send for the Apache Airflow log type (e.g. <code>DagProcessingLogs</code>). Valid values: <code>CloudWatchLogGroupArn</code>, <code>Enabled</code>, <code>LogLevel</code>.</p>
    public let workerLogs: ModuleLoggingConfiguration?

    public init (
        dagProcessingLogs: ModuleLoggingConfiguration? = nil,
        schedulerLogs: ModuleLoggingConfiguration? = nil,
        taskLogs: ModuleLoggingConfiguration? = nil,
        webserverLogs: ModuleLoggingConfiguration? = nil,
        workerLogs: ModuleLoggingConfiguration? = nil
    )
    {
        self.dagProcessingLogs = dagProcessingLogs
        self.schedulerLogs = schedulerLogs
        self.taskLogs = taskLogs
        self.webserverLogs = webserverLogs
        self.workerLogs = workerLogs
    }
}

extension LoggingConfigurationInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dagProcessingLogs = "DagProcessingLogs"
        case schedulerLogs = "SchedulerLogs"
        case taskLogs = "TaskLogs"
        case webserverLogs = "WebserverLogs"
        case workerLogs = "WorkerLogs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dagProcessingLogs = dagProcessingLogs {
            try encodeContainer.encode(dagProcessingLogs, forKey: .dagProcessingLogs)
        }
        if let schedulerLogs = schedulerLogs {
            try encodeContainer.encode(schedulerLogs, forKey: .schedulerLogs)
        }
        if let taskLogs = taskLogs {
            try encodeContainer.encode(taskLogs, forKey: .taskLogs)
        }
        if let webserverLogs = webserverLogs {
            try encodeContainer.encode(webserverLogs, forKey: .webserverLogs)
        }
        if let workerLogs = workerLogs {
            try encodeContainer.encode(workerLogs, forKey: .workerLogs)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dagProcessingLogsDecoded = try containerValues.decodeIfPresent(ModuleLoggingConfigurationInput.self, forKey: .dagProcessingLogs)
        dagProcessingLogs = dagProcessingLogsDecoded
        let schedulerLogsDecoded = try containerValues.decodeIfPresent(ModuleLoggingConfigurationInput.self, forKey: .schedulerLogs)
        schedulerLogs = schedulerLogsDecoded
        let webserverLogsDecoded = try containerValues.decodeIfPresent(ModuleLoggingConfigurationInput.self, forKey: .webserverLogs)
        webserverLogs = webserverLogsDecoded
        let workerLogsDecoded = try containerValues.decodeIfPresent(ModuleLoggingConfigurationInput.self, forKey: .workerLogs)
        workerLogs = workerLogsDecoded
        let taskLogsDecoded = try containerValues.decodeIfPresent(ModuleLoggingConfigurationInput.self, forKey: .taskLogs)
        taskLogs = taskLogsDecoded
    }
}

extension LoggingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoggingConfigurationInput(dagProcessingLogs: \(String(describing: dagProcessingLogs)), schedulerLogs: \(String(describing: schedulerLogs)), taskLogs: \(String(describing: taskLogs)), webserverLogs: \(String(describing: webserverLogs)), workerLogs: \(String(describing: workerLogs)))"}
}

/// <p>Defines the Apache Airflow logs to send to CloudWatch Logs: <code>DagProcessingLogs</code>, <code>SchedulerLogs</code>, <code>TaskLogs</code>, <code>WebserverLogs</code>, <code>WorkerLogs</code>.</p>
public struct LoggingConfigurationInput: Equatable {
    /// <p>Defines the type of logs to send for the Apache Airflow log type (e.g. <code>DagProcessingLogs</code>). Valid values: <code>CloudWatchLogGroupArn</code>, <code>Enabled</code>, <code>LogLevel</code>.</p>
    public let dagProcessingLogs: ModuleLoggingConfigurationInput?
    /// <p>Defines the type of logs to send for the Apache Airflow log type (e.g. <code>DagProcessingLogs</code>). Valid values: <code>CloudWatchLogGroupArn</code>, <code>Enabled</code>, <code>LogLevel</code>.</p>
    public let schedulerLogs: ModuleLoggingConfigurationInput?
    /// <p>Defines the type of logs to send for the Apache Airflow log type (e.g. <code>DagProcessingLogs</code>). Valid values: <code>CloudWatchLogGroupArn</code>, <code>Enabled</code>, <code>LogLevel</code>.</p>
    public let taskLogs: ModuleLoggingConfigurationInput?
    /// <p>Defines the type of logs to send for the Apache Airflow log type (e.g. <code>DagProcessingLogs</code>). Valid values: <code>CloudWatchLogGroupArn</code>, <code>Enabled</code>, <code>LogLevel</code>.</p>
    public let webserverLogs: ModuleLoggingConfigurationInput?
    /// <p>Defines the type of logs to send for the Apache Airflow log type (e.g. <code>DagProcessingLogs</code>). Valid values: <code>CloudWatchLogGroupArn</code>, <code>Enabled</code>, <code>LogLevel</code>.</p>
    public let workerLogs: ModuleLoggingConfigurationInput?

    public init (
        dagProcessingLogs: ModuleLoggingConfigurationInput? = nil,
        schedulerLogs: ModuleLoggingConfigurationInput? = nil,
        taskLogs: ModuleLoggingConfigurationInput? = nil,
        webserverLogs: ModuleLoggingConfigurationInput? = nil,
        workerLogs: ModuleLoggingConfigurationInput? = nil
    )
    {
        self.dagProcessingLogs = dagProcessingLogs
        self.schedulerLogs = schedulerLogs
        self.taskLogs = taskLogs
        self.webserverLogs = webserverLogs
        self.workerLogs = workerLogs
    }
}

public enum LoggingLevel {
    case critical
    case debug
    case error
    case info
    case warning
    case sdkUnknown(String)
}

extension LoggingLevel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LoggingLevel] {
        return [
            .critical,
            .debug,
            .error,
            .info,
            .warning,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .critical: return "CRITICAL"
        case .debug: return "DEBUG"
        case .error: return "ERROR"
        case .info: return "INFO"
        case .warning: return "WARNING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LoggingLevel(rawValue: rawValue) ?? LoggingLevel.sdkUnknown(rawValue)
    }
}

extension MetricDatum: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensions = "Dimensions"
        case metricName = "MetricName"
        case statisticValues = "StatisticValues"
        case timestamp = "Timestamp"
        case unit = "Unit"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for dimensions0 in dimensions {
                try dimensionsContainer.encode(dimensions0)
            }
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let statisticValues = statisticValues {
            try encodeContainer.encode(statisticValues, forKey: .statisticValues)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let dimensionsContainer = try containerValues.decodeIfPresent([Dimension?].self, forKey: .dimensions)
        var dimensionsDecoded0:[Dimension]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [Dimension]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
        let valueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Unit.self, forKey: .unit)
        unit = unitDecoded
        let statisticValuesDecoded = try containerValues.decodeIfPresent(StatisticSet.self, forKey: .statisticValues)
        statisticValues = statisticValuesDecoded
    }
}

extension MetricDatum: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricDatum(dimensions: \(String(describing: dimensions)), metricName: \(String(describing: metricName)), statisticValues: \(String(describing: statisticValues)), timestamp: \(String(describing: timestamp)), unit: \(String(describing: unit)), value: \(String(describing: value)))"}
}

/// <p>Internal only API.</p>
public struct MetricDatum: Equatable {
    /// <p>Internal only API.</p>
    public let dimensions: [Dimension]?
    /// <p>Internal only API.</p>
    public let metricName: String?
    /// <p>Internal only API.</p>
    public let statisticValues: StatisticSet?
    /// <p>Internal only API.</p>
    public let timestamp: Date?
    /// Unit
    public let unit: Unit?
    /// <p>Internal only API.</p>
    public let value: Double?

    public init (
        dimensions: [Dimension]? = nil,
        metricName: String? = nil,
        statisticValues: StatisticSet? = nil,
        timestamp: Date? = nil,
        unit: Unit? = nil,
        value: Double? = nil
    )
    {
        self.dimensions = dimensions
        self.metricName = metricName
        self.statisticValues = statisticValues
        self.timestamp = timestamp
        self.unit = unit
        self.value = value
    }
}

extension ModuleLoggingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogGroupArn = "CloudWatchLogGroupArn"
        case enabled = "Enabled"
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogGroupArn = cloudWatchLogGroupArn {
            try encodeContainer.encode(cloudWatchLogGroupArn, forKey: .cloudWatchLogGroupArn)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(LoggingLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
        let cloudWatchLogGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchLogGroupArn)
        cloudWatchLogGroupArn = cloudWatchLogGroupArnDecoded
    }
}

extension ModuleLoggingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModuleLoggingConfiguration(cloudWatchLogGroupArn: \(String(describing: cloudWatchLogGroupArn)), enabled: \(String(describing: enabled)), logLevel: \(String(describing: logLevel)))"}
}

/// <p>Defines the type of logs to send for the Apache Airflow log type (e.g. <code>DagProcessingLogs</code>). Valid values: <code>CloudWatchLogGroupArn</code>, <code>Enabled</code>, <code>LogLevel</code>.</p>
public struct ModuleLoggingConfiguration: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the CloudWatch Logs group where the Apache Airflow log type (e.g. <code>DagProcessingLogs</code>) is published. For example, <code>arn:aws:logs:us-east-1:123456789012:log-group:airflow-MyMWAAEnvironment-MwaaEnvironment-DAGProcessing:*</code>.</p>
    public let cloudWatchLogGroupArn: String?
    /// <p>Indicates whether to enable the Apache Airflow log type (e.g. <code>DagProcessingLogs</code>) in CloudWatch Logs.</p>
    public let enabled: Bool?
    /// <p>Defines the Apache Airflow logs to send for the log type (e.g. <code>DagProcessingLogs</code>) to CloudWatch Logs. Valid values: <code>CRITICAL</code>, <code>ERROR</code>, <code>WARNING</code>, <code>INFO</code>.</p>
    public let logLevel: LoggingLevel?

    public init (
        cloudWatchLogGroupArn: String? = nil,
        enabled: Bool? = nil,
        logLevel: LoggingLevel? = nil
    )
    {
        self.cloudWatchLogGroupArn = cloudWatchLogGroupArn
        self.enabled = enabled
        self.logLevel = logLevel
    }
}

extension ModuleLoggingConfigurationInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(LoggingLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension ModuleLoggingConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ModuleLoggingConfigurationInput(enabled: \(String(describing: enabled)), logLevel: \(String(describing: logLevel)))"}
}

/// <p>Defines the type of logs to send for the Apache Airflow log type (e.g. <code>DagProcessingLogs</code>). Valid values: <code>CloudWatchLogGroupArn</code>, <code>Enabled</code>, <code>LogLevel</code>.</p>
public struct ModuleLoggingConfigurationInput: Equatable {
    /// <p>Indicates whether to enable the Apache Airflow log type (e.g. <code>DagProcessingLogs</code>) in CloudWatch Logs.</p>
    public let enabled: Bool?
    /// <p>Defines the Apache Airflow logs to send for the log type (e.g. <code>DagProcessingLogs</code>) to CloudWatch Logs. Valid values: <code>CRITICAL</code>, <code>ERROR</code>, <code>WARNING</code>, <code>INFO</code>.</p>
    public let logLevel: LoggingLevel?

    public init (
        enabled: Bool? = nil,
        logLevel: LoggingLevel? = nil
    )
    {
        self.enabled = enabled
        self.logLevel = logLevel
    }
}

extension NetworkConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygrouplist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygrouplist0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetlist0 in subnetIds {
                try subnetIdsContainer.encode(subnetlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension NetworkConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkConfiguration(securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)))"}
}

/// <p>The VPC networking components used to secure and enable network traffic between the AWS resources for your environment. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/networking-about.html">About networking on Amazon MWAA</a>.</p>
public struct NetworkConfiguration: Equatable {
    /// <p>A list of 1 or more security group IDs. Accepts up to 5 security group IDs. A security group must be attached to the same VPC as the subnets. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/vpc-security.html">Security in your VPC on Amazon MWAA</a>.</p>
    public let securityGroupIds: [String]?
    /// <p>A list of 2 subnet IDs. <b>Required</b> to create an environment. Must be private subnets in two different availability zones. A subnet must be attached to the same VPC as the security group.</p>
    public let subnetIds: [String]?

    public init (
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
    }
}

public struct PublishMetricsInputBodyMiddleware: Middleware {
    public let id: String = "PublishMetricsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PublishMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<PublishMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PublishMetricsInput>
    public typealias MOutput = OperationOutput<PublishMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PublishMetricsOutputError>
}

extension PublishMetricsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublishMetricsInput(environmentName: \(String(describing: environmentName)), metricData: \(String(describing: metricData)))"}
}

extension PublishMetricsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case metricData = "MetricData"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metricData = metricData {
            var metricDataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metricData)
            for metricdata0 in metricData {
                try metricDataContainer.encode(metricdata0)
            }
        }
    }
}

public struct PublishMetricsInputHeadersMiddleware: Middleware {
    public let id: String = "PublishMetricsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PublishMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<PublishMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PublishMetricsInput>
    public typealias MOutput = OperationOutput<PublishMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PublishMetricsOutputError>
}

public struct PublishMetricsInputQueryItemMiddleware: Middleware {
    public let id: String = "PublishMetricsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PublishMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<PublishMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PublishMetricsInput>
    public typealias MOutput = OperationOutput<PublishMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PublishMetricsOutputError>
}

public struct PublishMetricsInput: Equatable {
    /// <p>Publishes environment metric data to Amazon CloudWatch.</p>
    public let environmentName: String?
    /// <p>Publishes metric data points to Amazon CloudWatch. CloudWatch associates the data points with the specified metrica.</p>
    public let metricData: [MetricDatum]?

    public init (
        environmentName: String? = nil,
        metricData: [MetricDatum]? = nil
    )
    {
        self.environmentName = environmentName
        self.metricData = metricData
    }
}

struct PublishMetricsInputBody: Equatable {
    public let metricData: [MetricDatum]?
}

extension PublishMetricsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case metricData = "MetricData"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDataContainer = try containerValues.decodeIfPresent([MetricDatum?].self, forKey: .metricData)
        var metricDataDecoded0:[MetricDatum]? = nil
        if let metricDataContainer = metricDataContainer {
            metricDataDecoded0 = [MetricDatum]()
            for structure0 in metricDataContainer {
                if let structure0 = structure0 {
                    metricDataDecoded0?.append(structure0)
                }
            }
        }
        metricData = metricDataDecoded0
    }
}

extension PublishMetricsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PublishMetricsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PublishMetricsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PublishMetricsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublishMetricsOutputResponse()"}
}

extension PublishMetricsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PublishMetricsOutputResponse: Equatable {

    public init() {}
}

struct PublishMetricsOutputResponseBody: Equatable {
}

extension PublishMetricsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>ResourceNotFoundException: The resource is not available.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StatisticSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maximum = "Maximum"
        case minimum = "Minimum"
        case sampleCount = "SampleCount"
        case sum = "Sum"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximum = maximum {
            try encodeContainer.encode(maximum, forKey: .maximum)
        }
        if let minimum = minimum {
            try encodeContainer.encode(minimum, forKey: .minimum)
        }
        if let sampleCount = sampleCount {
            try encodeContainer.encode(sampleCount, forKey: .sampleCount)
        }
        if let sum = sum {
            try encodeContainer.encode(sum, forKey: .sum)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sampleCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .sampleCount)
        sampleCount = sampleCountDecoded
        let sumDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .sum)
        sum = sumDecoded
        let minimumDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .minimum)
        minimum = minimumDecoded
        let maximumDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .maximum)
        maximum = maximumDecoded
    }
}

extension StatisticSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StatisticSet(maximum: \(String(describing: maximum)), minimum: \(String(describing: minimum)), sampleCount: \(String(describing: sampleCount)), sum: \(String(describing: sum)))"}
}

/// <p>Internal only API.</p>
public struct StatisticSet: Equatable {
    /// <p>Internal only API.</p>
    public let maximum: Double?
    /// <p>Internal only API.</p>
    public let minimum: Double?
    /// <p>Internal only API.</p>
    public let sampleCount: Int?
    /// <p>Internal only API.</p>
    public let sum: Double?

    public init (
        maximum: Double? = nil,
        minimum: Double? = nil,
        sampleCount: Int? = nil,
        sum: Double? = nil
    )
    {
        self.maximum = maximum
        self.minimum = minimum
        self.sampleCount = sampleCount
        self.sum = sum
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon MWAA environment. For example, <code>arn:aws:airflow:us-east-1:123456789012:environment/MyMWAAEnvironment</code>.</p>
    public let resourceArn: String?
    /// <p>The key-value tag pairs you want to associate to your environment. For example, <code>"Environment": "Staging"</code>. To learn more, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html">Tagging AWS resources</a>.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

/// Unit
public enum Unit {
    case bits
    case bitsPerSecond
    case bytes
    case bytesPerSecond
    case count
    case countPerSecond
    case gigabits
    case gigabitsPerSecond
    case gigabytes
    case gigabytesPerSecond
    case kilobits
    case kilobitsPerSecond
    case kilobytes
    case kilobytesPerSecond
    case megabits
    case megabitsPerSecond
    case megabytes
    case megabytesPerSecond
    case microseconds
    case milliseconds
    case `none`
    case percent
    case seconds
    case terabits
    case terabitsPerSecond
    case terabytes
    case terabytesPerSecond
    case sdkUnknown(String)
}

extension Unit : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Unit] {
        return [
            .bits,
            .bitsPerSecond,
            .bytes,
            .bytesPerSecond,
            .count,
            .countPerSecond,
            .gigabits,
            .gigabitsPerSecond,
            .gigabytes,
            .gigabytesPerSecond,
            .kilobits,
            .kilobitsPerSecond,
            .kilobytes,
            .kilobytesPerSecond,
            .megabits,
            .megabitsPerSecond,
            .megabytes,
            .megabytesPerSecond,
            .microseconds,
            .milliseconds,
            .none,
            .percent,
            .seconds,
            .terabits,
            .terabitsPerSecond,
            .terabytes,
            .terabytesPerSecond,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .bits: return "Bits"
        case .bitsPerSecond: return "Bits/Second"
        case .bytes: return "Bytes"
        case .bytesPerSecond: return "Bytes/Second"
        case .count: return "Count"
        case .countPerSecond: return "Count/Second"
        case .gigabits: return "Gigabits"
        case .gigabitsPerSecond: return "Gigabits/Second"
        case .gigabytes: return "Gigabytes"
        case .gigabytesPerSecond: return "Gigabytes/Second"
        case .kilobits: return "Kilobits"
        case .kilobitsPerSecond: return "Kilobits/Second"
        case .kilobytes: return "Kilobytes"
        case .kilobytesPerSecond: return "Kilobytes/Second"
        case .megabits: return "Megabits"
        case .megabitsPerSecond: return "Megabits/Second"
        case .megabytes: return "Megabytes"
        case .megabytesPerSecond: return "Megabytes/Second"
        case .microseconds: return "Microseconds"
        case .milliseconds: return "Milliseconds"
        case .none: return "None"
        case .percent: return "Percent"
        case .seconds: return "Seconds"
        case .terabits: return "Terabits"
        case .terabitsPerSecond: return "Terabits/Second"
        case .terabytes: return "Terabytes"
        case .terabytesPerSecond: return "Terabytes/Second"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Unit(rawValue: rawValue) ?? Unit.sdkUnknown(rawValue)
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon MWAA environment. For example, <code>arn:aws:airflow:us-east-1:123456789012:environment/MyMWAAEnvironment</code>.</p>
    public let resourceArn: String?
    /// <p>The key-value tag pair you want to remove. For example, <code>"Environment": "Staging"</code>. </p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateEnvironmentInputBodyMiddleware: Middleware {
    public let id: String = "UpdateEnvironmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEnvironmentOutputError>
}

extension UpdateEnvironmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEnvironmentInput(airflowVersion: \(String(describing: airflowVersion)), dagS3Path: \(String(describing: dagS3Path)), environmentClass: \(String(describing: environmentClass)), executionRoleArn: \(String(describing: executionRoleArn)), loggingConfiguration: \(String(describing: loggingConfiguration)), maxWorkers: \(String(describing: maxWorkers)), minWorkers: \(String(describing: minWorkers)), name: \(String(describing: name)), networkConfiguration: \(String(describing: networkConfiguration)), pluginsS3ObjectVersion: \(String(describing: pluginsS3ObjectVersion)), pluginsS3Path: \(String(describing: pluginsS3Path)), requirementsS3ObjectVersion: \(String(describing: requirementsS3ObjectVersion)), requirementsS3Path: \(String(describing: requirementsS3Path)), schedulers: \(String(describing: schedulers)), sourceBucketArn: \(String(describing: sourceBucketArn)), webserverAccessMode: \(String(describing: webserverAccessMode)), weeklyMaintenanceWindowStart: \(String(describing: weeklyMaintenanceWindowStart)), airflowConfigurationOptions: \"CONTENT_REDACTED\")"}
}

extension UpdateEnvironmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case airflowConfigurationOptions = "AirflowConfigurationOptions"
        case airflowVersion = "AirflowVersion"
        case dagS3Path = "DagS3Path"
        case environmentClass = "EnvironmentClass"
        case executionRoleArn = "ExecutionRoleArn"
        case loggingConfiguration = "LoggingConfiguration"
        case maxWorkers = "MaxWorkers"
        case minWorkers = "MinWorkers"
        case networkConfiguration = "NetworkConfiguration"
        case pluginsS3ObjectVersion = "PluginsS3ObjectVersion"
        case pluginsS3Path = "PluginsS3Path"
        case requirementsS3ObjectVersion = "RequirementsS3ObjectVersion"
        case requirementsS3Path = "RequirementsS3Path"
        case schedulers = "Schedulers"
        case sourceBucketArn = "SourceBucketArn"
        case webserverAccessMode = "WebserverAccessMode"
        case weeklyMaintenanceWindowStart = "WeeklyMaintenanceWindowStart"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let airflowConfigurationOptions = airflowConfigurationOptions {
            var airflowConfigurationOptionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .airflowConfigurationOptions)
            for (dictKey0, airflowconfigurationoptions0) in airflowConfigurationOptions {
                try airflowConfigurationOptionsContainer.encode(airflowconfigurationoptions0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let airflowVersion = airflowVersion {
            try encodeContainer.encode(airflowVersion, forKey: .airflowVersion)
        }
        if let dagS3Path = dagS3Path {
            try encodeContainer.encode(dagS3Path, forKey: .dagS3Path)
        }
        if let environmentClass = environmentClass {
            try encodeContainer.encode(environmentClass, forKey: .environmentClass)
        }
        if let executionRoleArn = executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let loggingConfiguration = loggingConfiguration {
            try encodeContainer.encode(loggingConfiguration, forKey: .loggingConfiguration)
        }
        if let maxWorkers = maxWorkers {
            try encodeContainer.encode(maxWorkers, forKey: .maxWorkers)
        }
        if let minWorkers = minWorkers {
            try encodeContainer.encode(minWorkers, forKey: .minWorkers)
        }
        if let networkConfiguration = networkConfiguration {
            try encodeContainer.encode(networkConfiguration, forKey: .networkConfiguration)
        }
        if let pluginsS3ObjectVersion = pluginsS3ObjectVersion {
            try encodeContainer.encode(pluginsS3ObjectVersion, forKey: .pluginsS3ObjectVersion)
        }
        if let pluginsS3Path = pluginsS3Path {
            try encodeContainer.encode(pluginsS3Path, forKey: .pluginsS3Path)
        }
        if let requirementsS3ObjectVersion = requirementsS3ObjectVersion {
            try encodeContainer.encode(requirementsS3ObjectVersion, forKey: .requirementsS3ObjectVersion)
        }
        if let requirementsS3Path = requirementsS3Path {
            try encodeContainer.encode(requirementsS3Path, forKey: .requirementsS3Path)
        }
        if let schedulers = schedulers {
            try encodeContainer.encode(schedulers, forKey: .schedulers)
        }
        if let sourceBucketArn = sourceBucketArn {
            try encodeContainer.encode(sourceBucketArn, forKey: .sourceBucketArn)
        }
        if let webserverAccessMode = webserverAccessMode {
            try encodeContainer.encode(webserverAccessMode.rawValue, forKey: .webserverAccessMode)
        }
        if let weeklyMaintenanceWindowStart = weeklyMaintenanceWindowStart {
            try encodeContainer.encode(weeklyMaintenanceWindowStart, forKey: .weeklyMaintenanceWindowStart)
        }
    }
}

public struct UpdateEnvironmentInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateEnvironmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEnvironmentOutputError>
}

public struct UpdateEnvironmentInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateEnvironmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEnvironmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEnvironmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEnvironmentInput>
    public typealias MOutput = OperationOutput<UpdateEnvironmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEnvironmentOutputError>
}

public struct UpdateEnvironmentInput: Equatable {
    /// <p>A list of key-value pairs containing the Apache Airflow configuration options you want to attach to your environment. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-env-variables.html">Apache Airflow configuration options</a>.</p>
    public let airflowConfigurationOptions: [String:String]?
    /// <p>The Apache Airflow version for your environment. For example, <code>v1.10.12</code>. If no value is specified, defaults to the latest version. Valid values: <code>v1.10.12</code>.</p>
    public let airflowVersion: String?
    /// <p>The relative path to the DAGs folder on your Amazon S3 bucket. For example, <code>dags</code>. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-dag-folder.html">Adding or updating DAGs</a>.</p>
    public let dagS3Path: String?
    /// <p>The environment class type. Valid values: <code>mw1.small</code>, <code>mw1.medium</code>, <code>mw1.large</code>. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/environment-class.html">Amazon MWAA environment class</a>.</p>
    public let environmentClass: String?
    /// <p>The Amazon Resource Name (ARN) of the execution role in IAM that allows MWAA to access AWS resources in your environment. For example, <code>arn:aws:iam::123456789:role/my-execution-role</code>. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/mwaa-create-role.html">Amazon MWAA Execution role</a>.</p>
    public let executionRoleArn: String?
    /// <p>Defines the Apache Airflow logs to send to CloudWatch Logs: <code>DagProcessingLogs</code>, <code>SchedulerLogs</code>, <code>TaskLogs</code>, <code>WebserverLogs</code>, <code>WorkerLogs</code>.</p>
    public let loggingConfiguration: LoggingConfigurationInput?
    /// <p>The maximum number of workers that you want to run in your environment. MWAA scales the number of Apache Airflow workers up to the number you specify in the <code>MaxWorkers</code> field. For example, <code>20</code>. When there are no more tasks running, and no more in the queue, MWAA disposes of the extra workers leaving the one worker that is included with your environment, or the number you specify in <code>MinWorkers</code>.</p>
    public let maxWorkers: Int?
    /// <p>The minimum number of workers that you want to run in your environment. MWAA scales the number of Apache Airflow workers up to the number you specify in the <code>MaxWorkers</code> field. When there are no more tasks running, and no more in the queue, MWAA disposes of the extra workers leaving the worker count you specify in the <code>MinWorkers</code> field. For example, <code>2</code>.</p>
    public let minWorkers: Int?
    /// <p>The name of your Amazon MWAA environment. For example, <code>MyMWAAEnvironment</code>.</p>
    public let name: String?
    /// <p>The VPC networking components used to secure and enable network traffic between the AWS resources for your environment. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/networking-about.html">About networking on Amazon MWAA</a>.</p>
    public let networkConfiguration: UpdateNetworkConfigurationInput?
    /// <p>The version of the plugins.zip file on your Amazon S3 bucket. A version must be specified each time a plugins.zip file is updated. To learn more, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/versioning-workflows.html">How S3 Versioning works</a>.</p>
    public let pluginsS3ObjectVersion: String?
    /// <p>The relative path to the <code>plugins.zip</code> file on your Amazon S3 bucket. For example, <code>plugins.zip</code>. If specified, then the plugins.zip version is required. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-dag-import-plugins.html">Installing custom plugins</a>.</p>
    public let pluginsS3Path: String?
    /// <p>The version of the requirements.txt file on your Amazon S3 bucket. A version must be specified each time a requirements.txt file is updated. To learn more, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/versioning-workflows.html">How S3 Versioning works</a>.</p>
    public let requirementsS3ObjectVersion: String?
    /// <p>The relative path to the <code>requirements.txt</code> file on your Amazon S3 bucket. For example, <code>requirements.txt</code>. If specified, then a file version is required. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/working-dags-dependencies.html">Installing Python dependencies</a>.</p>
    public let requirementsS3Path: String?
    /// <p>The number of Apache Airflow schedulers to run in your Amazon MWAA environment.</p>
    public let schedulers: Int?
    /// <p>The Amazon Resource Name (ARN) of the Amazon S3 bucket where your DAG code and supporting files are stored. For example, <code>arn:aws:s3:::my-airflow-bucket-unique-name</code>. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/mwaa-s3-bucket.html">Create an Amazon S3 bucket for Amazon MWAA</a>.</p>
    public let sourceBucketArn: String?
    /// <p>The Apache Airflow <i>Web server</i> access mode. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/configuring-networking.html">Apache Airflow access modes</a>.</p>
    public let webserverAccessMode: WebserverAccessMode?
    /// <p>The day and time of the week to start weekly maintenance updates of your environment in the following format: <code>DAY:HH:MM</code>. For example: <code>TUE:03:30</code>. You can specify a start time in 30 minute increments only. Supported input includes the following:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>MON|TUE|WED|THU|FRI|SAT|SUN:([01]\\d|2[0-3]):(00|30)</p>
    ///             </li>
    ///          </ul>
    public let weeklyMaintenanceWindowStart: String?

    public init (
        airflowConfigurationOptions: [String:String]? = nil,
        airflowVersion: String? = nil,
        dagS3Path: String? = nil,
        environmentClass: String? = nil,
        executionRoleArn: String? = nil,
        loggingConfiguration: LoggingConfigurationInput? = nil,
        maxWorkers: Int? = nil,
        minWorkers: Int? = nil,
        name: String? = nil,
        networkConfiguration: UpdateNetworkConfigurationInput? = nil,
        pluginsS3ObjectVersion: String? = nil,
        pluginsS3Path: String? = nil,
        requirementsS3ObjectVersion: String? = nil,
        requirementsS3Path: String? = nil,
        schedulers: Int? = nil,
        sourceBucketArn: String? = nil,
        webserverAccessMode: WebserverAccessMode? = nil,
        weeklyMaintenanceWindowStart: String? = nil
    )
    {
        self.airflowConfigurationOptions = airflowConfigurationOptions
        self.airflowVersion = airflowVersion
        self.dagS3Path = dagS3Path
        self.environmentClass = environmentClass
        self.executionRoleArn = executionRoleArn
        self.loggingConfiguration = loggingConfiguration
        self.maxWorkers = maxWorkers
        self.minWorkers = minWorkers
        self.name = name
        self.networkConfiguration = networkConfiguration
        self.pluginsS3ObjectVersion = pluginsS3ObjectVersion
        self.pluginsS3Path = pluginsS3Path
        self.requirementsS3ObjectVersion = requirementsS3ObjectVersion
        self.requirementsS3Path = requirementsS3Path
        self.schedulers = schedulers
        self.sourceBucketArn = sourceBucketArn
        self.webserverAccessMode = webserverAccessMode
        self.weeklyMaintenanceWindowStart = weeklyMaintenanceWindowStart
    }
}

struct UpdateEnvironmentInputBody: Equatable {
    public let executionRoleArn: String?
    public let airflowVersion: String?
    public let sourceBucketArn: String?
    public let dagS3Path: String?
    public let pluginsS3Path: String?
    public let pluginsS3ObjectVersion: String?
    public let requirementsS3Path: String?
    public let requirementsS3ObjectVersion: String?
    public let airflowConfigurationOptions: [String:String]?
    public let environmentClass: String?
    public let maxWorkers: Int?
    public let networkConfiguration: UpdateNetworkConfigurationInput?
    public let loggingConfiguration: LoggingConfigurationInput?
    public let weeklyMaintenanceWindowStart: String?
    public let webserverAccessMode: WebserverAccessMode?
    public let minWorkers: Int?
    public let schedulers: Int?
}

extension UpdateEnvironmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case airflowConfigurationOptions = "AirflowConfigurationOptions"
        case airflowVersion = "AirflowVersion"
        case dagS3Path = "DagS3Path"
        case environmentClass = "EnvironmentClass"
        case executionRoleArn = "ExecutionRoleArn"
        case loggingConfiguration = "LoggingConfiguration"
        case maxWorkers = "MaxWorkers"
        case minWorkers = "MinWorkers"
        case networkConfiguration = "NetworkConfiguration"
        case pluginsS3ObjectVersion = "PluginsS3ObjectVersion"
        case pluginsS3Path = "PluginsS3Path"
        case requirementsS3ObjectVersion = "RequirementsS3ObjectVersion"
        case requirementsS3Path = "RequirementsS3Path"
        case schedulers = "Schedulers"
        case sourceBucketArn = "SourceBucketArn"
        case webserverAccessMode = "WebserverAccessMode"
        case weeklyMaintenanceWindowStart = "WeeklyMaintenanceWindowStart"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let airflowVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .airflowVersion)
        airflowVersion = airflowVersionDecoded
        let sourceBucketArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceBucketArn)
        sourceBucketArn = sourceBucketArnDecoded
        let dagS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dagS3Path)
        dagS3Path = dagS3PathDecoded
        let pluginsS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pluginsS3Path)
        pluginsS3Path = pluginsS3PathDecoded
        let pluginsS3ObjectVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pluginsS3ObjectVersion)
        pluginsS3ObjectVersion = pluginsS3ObjectVersionDecoded
        let requirementsS3PathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requirementsS3Path)
        requirementsS3Path = requirementsS3PathDecoded
        let requirementsS3ObjectVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requirementsS3ObjectVersion)
        requirementsS3ObjectVersion = requirementsS3ObjectVersionDecoded
        let airflowConfigurationOptionsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .airflowConfigurationOptions)
        var airflowConfigurationOptionsDecoded0: [String:String]? = nil
        if let airflowConfigurationOptionsContainer = airflowConfigurationOptionsContainer {
            airflowConfigurationOptionsDecoded0 = [String:String]()
            for (key0, configvalue0) in airflowConfigurationOptionsContainer {
                if let configvalue0 = configvalue0 {
                    airflowConfigurationOptionsDecoded0?[key0] = configvalue0
                }
            }
        }
        airflowConfigurationOptions = airflowConfigurationOptionsDecoded0
        let environmentClassDecoded = try containerValues.decodeIfPresent(String.self, forKey: .environmentClass)
        environmentClass = environmentClassDecoded
        let maxWorkersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxWorkers)
        maxWorkers = maxWorkersDecoded
        let networkConfigurationDecoded = try containerValues.decodeIfPresent(UpdateNetworkConfigurationInput.self, forKey: .networkConfiguration)
        networkConfiguration = networkConfigurationDecoded
        let loggingConfigurationDecoded = try containerValues.decodeIfPresent(LoggingConfigurationInput.self, forKey: .loggingConfiguration)
        loggingConfiguration = loggingConfigurationDecoded
        let weeklyMaintenanceWindowStartDecoded = try containerValues.decodeIfPresent(String.self, forKey: .weeklyMaintenanceWindowStart)
        weeklyMaintenanceWindowStart = weeklyMaintenanceWindowStartDecoded
        let webserverAccessModeDecoded = try containerValues.decodeIfPresent(WebserverAccessMode.self, forKey: .webserverAccessMode)
        webserverAccessMode = webserverAccessModeDecoded
        let minWorkersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minWorkers)
        minWorkers = minWorkersDecoded
        let schedulersDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .schedulers)
        schedulers = schedulersDecoded
    }
}

extension UpdateEnvironmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEnvironmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEnvironmentOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEnvironmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEnvironmentOutputResponse(arn: \(String(describing: arn)))"}
}

extension UpdateEnvironmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateEnvironmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct UpdateEnvironmentOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon MWAA environment. For example, <code>arn:aws:airflow:us-east-1:123456789012:environment/MyMWAAEnvironment</code>.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct UpdateEnvironmentOutputResponseBody: Equatable {
    public let arn: String?
}

extension UpdateEnvironmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension UpdateError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case errorMessage = "ErrorMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension UpdateError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateError(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)))"}
}

/// <p>An object containing the error encountered with the last update: <code>ErrorCode</code>, <code>ErrorMessage</code>.</p>
public struct UpdateError: Equatable {
    /// <p>The error code that corresponds to the error with the last update.</p>
    public let errorCode: String?
    /// <p>The error message that corresponds to the error code.</p>
    public let errorMessage: String?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
    }
}

extension UpdateNetworkConfigurationInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityGroupIds = "SecurityGroupIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygrouplist0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygrouplist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension UpdateNetworkConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateNetworkConfigurationInput(securityGroupIds: \(String(describing: securityGroupIds)))"}
}

/// <p>The VPC networking components used to secure and enable network traffic between the AWS resources for your environment. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/networking-about.html">About networking on Amazon MWAA</a>.</p>
public struct UpdateNetworkConfigurationInput: Equatable {
    /// <p>A list of 1 or more security group IDs. Accepts up to 5 security group IDs. A security group must be attached to the same VPC as the subnets. To learn more, see <a href="https://docs.aws.amazon.com/mwaa/latest/userguide/vpc-security.html">Security in your VPC on Amazon MWAA</a>.</p>
    public let securityGroupIds: [String]?

    public init (
        securityGroupIds: [String]? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
    }
}

public enum UpdateStatus {
    case failed
    case pending
    case success
    case sdkUnknown(String)
}

extension UpdateStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UpdateStatus] {
        return [
            .failed,
            .pending,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .pending: return "PENDING"
        case .success: return "SUCCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UpdateStatus(rawValue: rawValue) ?? UpdateStatus.sdkUnknown(rawValue)
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>ValidationException: The provided input is not valid.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum WebserverAccessMode {
    case privateOnly
    case publicOnly
    case sdkUnknown(String)
}

extension WebserverAccessMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WebserverAccessMode] {
        return [
            .privateOnly,
            .publicOnly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .privateOnly: return "PRIVATE_ONLY"
        case .publicOnly: return "PUBLIC_ONLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WebserverAccessMode(rawValue: rawValue) ?? WebserverAccessMode.sdkUnknown(rawValue)
    }
}
