// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AWSAccount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case emailAddress
        case id
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailAddress = emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

extension AWSAccount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AWSAccount(emailAddress: \(String(describing: emailAddress)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>
///    The wrapper of AWS account details, such as account ID, email address, and so on.
/// </p>
public struct AWSAccount: Equatable {
    /// <p>
    ///    The email address associated with the specified AWS account.
    /// </p>
    public let emailAddress: String?
    /// <p>
    ///    The identifier for the specified AWS account.
    /// </p>
    public let id: String?
    /// <p>
    ///    The name of the specified AWS account.
    /// </p>
    public let name: String?

    public init (
        emailAddress: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.emailAddress = emailAddress
        self.id = id
        self.name = name
    }
}

extension AWSService: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serviceName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension AWSService: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AWSService(serviceName: \(String(describing: serviceName)))"}
}

/// <p>
///    An AWS service such as Amazon S3, AWS CloudTrail, and so on.
/// </p>
public struct AWSService: Equatable {
    /// <p>
    ///    The name of the AWS service.
    /// </p>
    public let serviceName: String?

    public init (
        serviceName: String? = nil
    )
    {
        self.serviceName = serviceName
    }
}

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///    Your account is not registered with AWS Audit Manager. Check the delegated administrator setup on the AWS Audit Manager settings page, and try again.
/// </p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum AccountStatus {
    case active
    case inactive
    case pendingActivation
    case sdkUnknown(String)
}

extension AccountStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AccountStatus] {
        return [
            .active,
            .inactive,
            .pendingActivation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .inactive: return "INACTIVE"
        case .pendingActivation: return "PENDING_ACTIVATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AccountStatus(rawValue: rawValue) ?? AccountStatus.sdkUnknown(rawValue)
    }
}

public enum ActionEnum {
    case active
    case create
    case delete
    case importEvidence
    case inactive
    case reviewed
    case underReview
    case updateMetadata
    case sdkUnknown(String)
}

extension ActionEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ActionEnum] {
        return [
            .active,
            .create,
            .delete,
            .importEvidence,
            .inactive,
            .reviewed,
            .underReview,
            .updateMetadata,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .create: return "CREATE"
        case .delete: return "DELETE"
        case .importEvidence: return "IMPORT_EVIDENCE"
        case .inactive: return "INACTIVE"
        case .reviewed: return "REVIEWED"
        case .underReview: return "UNDER_REVIEW"
        case .updateMetadata: return "UPDATE_METADATA"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ActionEnum(rawValue: rawValue) ?? ActionEnum.sdkUnknown(rawValue)
    }
}

extension Assessment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case awsAccount
        case framework
        case metadata
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let awsAccount = awsAccount {
            try encodeContainer.encode(awsAccount, forKey: .awsAccount)
        }
        if let framework = framework {
            try encodeContainer.encode(framework, forKey: .framework)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let awsAccountDecoded = try containerValues.decodeIfPresent(AWSAccount.self, forKey: .awsAccount)
        awsAccount = awsAccountDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(AssessmentMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let frameworkDecoded = try containerValues.decodeIfPresent(AssessmentFramework.self, forKey: .framework)
        framework = frameworkDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Assessment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Assessment(arn: \(String(describing: arn)), awsAccount: \(String(describing: awsAccount)), framework: \(String(describing: framework)), metadata: \(String(describing: metadata)), tags: \(String(describing: tags)))"}
}

/// <p>
///    An entity that defines the scope of audit evidence collected by AWS Audit Manager. An AWS Audit Manager assessment is an implementation of an AWS Audit Manager framework.
/// </p>
public struct Assessment: Equatable {
    /// <p>
    ///    The Amazon Resource Name (ARN) of the assessment.
    /// </p>
    public let arn: String?
    /// <p>
    ///  The AWS account associated with the assessment.
    /// </p>
    public let awsAccount: AWSAccount?
    /// <p>
    ///    The framework from which the assessment was created.
    /// </p>
    public let framework: AssessmentFramework?
    /// <p>
    ///  The metadata for the specified assessment.
    /// </p>
    public let metadata: AssessmentMetadata?
    /// <p>
    ///  The tags associated with the assessment.
    /// </p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        awsAccount: AWSAccount? = nil,
        framework: AssessmentFramework? = nil,
        metadata: AssessmentMetadata? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.awsAccount = awsAccount
        self.framework = framework
        self.metadata = metadata
        self.tags = tags
    }
}

extension AssessmentControl: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentReportEvidenceCount
        case comments
        case description
        case evidenceCount
        case evidenceSources
        case id
        case name
        case response
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if assessmentReportEvidenceCount != 0 {
            try encodeContainer.encode(assessmentReportEvidenceCount, forKey: .assessmentReportEvidenceCount)
        }
        if let comments = comments {
            var commentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .comments)
            for controlcomments0 in comments {
                try commentsContainer.encode(controlcomments0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if evidenceCount != 0 {
            try encodeContainer.encode(evidenceCount, forKey: .evidenceCount)
        }
        if let evidenceSources = evidenceSources {
            var evidenceSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .evidenceSources)
            for evidencesources0 in evidenceSources {
                try evidenceSourcesContainer.encode(evidencesources0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let response = response {
            try encodeContainer.encode(response.rawValue, forKey: .response)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ControlStatus.self, forKey: .status)
        status = statusDecoded
        let responseDecoded = try containerValues.decodeIfPresent(ControlResponse.self, forKey: .response)
        response = responseDecoded
        let commentsContainer = try containerValues.decodeIfPresent([ControlComment?].self, forKey: .comments)
        var commentsDecoded0:[ControlComment]? = nil
        if let commentsContainer = commentsContainer {
            commentsDecoded0 = [ControlComment]()
            for structure0 in commentsContainer {
                if let structure0 = structure0 {
                    commentsDecoded0?.append(structure0)
                }
            }
        }
        comments = commentsDecoded0
        let evidenceSourcesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .evidenceSources)
        var evidenceSourcesDecoded0:[String]? = nil
        if let evidenceSourcesContainer = evidenceSourcesContainer {
            evidenceSourcesDecoded0 = [String]()
            for string0 in evidenceSourcesContainer {
                if let string0 = string0 {
                    evidenceSourcesDecoded0?.append(string0)
                }
            }
        }
        evidenceSources = evidenceSourcesDecoded0
        let evidenceCountDecoded = try containerValues.decode(Int.self, forKey: .evidenceCount)
        evidenceCount = evidenceCountDecoded
        let assessmentReportEvidenceCountDecoded = try containerValues.decode(Int.self, forKey: .assessmentReportEvidenceCount)
        assessmentReportEvidenceCount = assessmentReportEvidenceCountDecoded
    }
}

extension AssessmentControl: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssessmentControl(assessmentReportEvidenceCount: \(String(describing: assessmentReportEvidenceCount)), comments: \(String(describing: comments)), description: \(String(describing: description)), evidenceCount: \(String(describing: evidenceCount)), evidenceSources: \(String(describing: evidenceSources)), id: \(String(describing: id)), name: \(String(describing: name)), response: \(String(describing: response)), status: \(String(describing: status)))"}
}

/// <p>
///    The control entity that represents a standard or custom control used in an AWS Audit Manager assessment.
/// </p>
public struct AssessmentControl: Equatable {
    /// <p>
    ///    The amount of evidence in the assessment report.
    /// </p>
    public let assessmentReportEvidenceCount: Int
    /// <p>
    ///    The list of comments attached to the specified control.
    /// </p>
    public let comments: [ControlComment]?
    /// <p>
    ///    The description of the specified control.
    /// </p>
    public let description: String?
    /// <p>
    ///    The amount of evidence generated for the control.
    /// </p>
    public let evidenceCount: Int
    /// <p>
    ///    The list of data sources for the specified evidence.
    /// </p>
    public let evidenceSources: [String]?
    /// <p>
    ///    The identifier for the specified control.
    /// </p>
    public let id: String?
    /// <p>
    ///    The name of the specified control.
    /// </p>
    public let name: String?
    /// <p>
    ///    The response of the specified control.
    /// </p>
    public let response: ControlResponse?
    /// <p>
    ///    The status of the specified control.
    /// </p>
    public let status: ControlStatus?

    public init (
        assessmentReportEvidenceCount: Int = 0,
        comments: [ControlComment]? = nil,
        description: String? = nil,
        evidenceCount: Int = 0,
        evidenceSources: [String]? = nil,
        id: String? = nil,
        name: String? = nil,
        response: ControlResponse? = nil,
        status: ControlStatus? = nil
    )
    {
        self.assessmentReportEvidenceCount = assessmentReportEvidenceCount
        self.comments = comments
        self.description = description
        self.evidenceCount = evidenceCount
        self.evidenceSources = evidenceSources
        self.id = id
        self.name = name
        self.response = response
        self.status = status
    }
}

extension AssessmentControlSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case controls
        case delegations
        case description
        case id
        case manualEvidenceCount
        case roles
        case status
        case systemEvidenceCount
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controls = controls {
            var controlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controls)
            for assessmentcontrols0 in controls {
                try controlsContainer.encode(assessmentcontrols0)
            }
        }
        if let delegations = delegations {
            var delegationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .delegations)
            for delegations0 in delegations {
                try delegationsContainer.encode(delegations0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if manualEvidenceCount != 0 {
            try encodeContainer.encode(manualEvidenceCount, forKey: .manualEvidenceCount)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for roles0 in roles {
                try rolesContainer.encode(roles0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if systemEvidenceCount != 0 {
            try encodeContainer.encode(systemEvidenceCount, forKey: .systemEvidenceCount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ControlSetStatus.self, forKey: .status)
        status = statusDecoded
        let rolesContainer = try containerValues.decodeIfPresent([Role?].self, forKey: .roles)
        var rolesDecoded0:[Role]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [Role]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
        let controlsContainer = try containerValues.decodeIfPresent([AssessmentControl?].self, forKey: .controls)
        var controlsDecoded0:[AssessmentControl]? = nil
        if let controlsContainer = controlsContainer {
            controlsDecoded0 = [AssessmentControl]()
            for structure0 in controlsContainer {
                if let structure0 = structure0 {
                    controlsDecoded0?.append(structure0)
                }
            }
        }
        controls = controlsDecoded0
        let delegationsContainer = try containerValues.decodeIfPresent([Delegation?].self, forKey: .delegations)
        var delegationsDecoded0:[Delegation]? = nil
        if let delegationsContainer = delegationsContainer {
            delegationsDecoded0 = [Delegation]()
            for structure0 in delegationsContainer {
                if let structure0 = structure0 {
                    delegationsDecoded0?.append(structure0)
                }
            }
        }
        delegations = delegationsDecoded0
        let systemEvidenceCountDecoded = try containerValues.decode(Int.self, forKey: .systemEvidenceCount)
        systemEvidenceCount = systemEvidenceCountDecoded
        let manualEvidenceCountDecoded = try containerValues.decode(Int.self, forKey: .manualEvidenceCount)
        manualEvidenceCount = manualEvidenceCountDecoded
    }
}

extension AssessmentControlSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssessmentControlSet(controls: \(String(describing: controls)), delegations: \(String(describing: delegations)), description: \(String(describing: description)), id: \(String(describing: id)), manualEvidenceCount: \(String(describing: manualEvidenceCount)), roles: \(String(describing: roles)), status: \(String(describing: status)), systemEvidenceCount: \(String(describing: systemEvidenceCount)))"}
}

/// <p>
/// Represents a set of controls in an AWS Audit Manager assessment.
/// </p>
public struct AssessmentControlSet: Equatable {
    /// <p>
    /// The list of controls contained with the control set.
    /// </p>
    public let controls: [AssessmentControl]?
    /// <p>
    ///    The delegations associated with the control set.
    /// </p>
    public let delegations: [Delegation]?
    /// <p>
    ///    The description for the control set.
    /// </p>
    public let description: String?
    /// <p>
    ///    The identifier of the control set in the assessment. This is the control set name in a plain string format.
    /// </p>
    public let id: String?
    /// <p>
    ///    The total number of evidence objects uploaded manually to the control set.
    /// </p>
    public let manualEvidenceCount: Int
    /// <p>
    ///    The roles associated with the control set.
    /// </p>
    public let roles: [Role]?
    /// <p>
    /// Specifies the current status of the control set.
    /// </p>
    public let status: ControlSetStatus?
    /// <p>
    ///    The total number of evidence objects retrieved automatically for the control set.
    /// </p>
    public let systemEvidenceCount: Int

    public init (
        controls: [AssessmentControl]? = nil,
        delegations: [Delegation]? = nil,
        description: String? = nil,
        id: String? = nil,
        manualEvidenceCount: Int = 0,
        roles: [Role]? = nil,
        status: ControlSetStatus? = nil,
        systemEvidenceCount: Int = 0
    )
    {
        self.controls = controls
        self.delegations = delegations
        self.description = description
        self.id = id
        self.manualEvidenceCount = manualEvidenceCount
        self.roles = roles
        self.status = status
        self.systemEvidenceCount = systemEvidenceCount
    }
}

extension AssessmentEvidenceFolder: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentId
        case assessmentReportSelectionCount
        case author
        case controlId
        case controlName
        case controlSetId
        case dataSource
        case date
        case evidenceAwsServiceSourceCount
        case evidenceByTypeComplianceCheckCount
        case evidenceByTypeComplianceCheckIssuesCount
        case evidenceByTypeConfigurationDataCount
        case evidenceByTypeManualCount
        case evidenceByTypeUserActivityCount
        case evidenceResourcesIncludedCount
        case id
        case name
        case totalEvidence
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentId = assessmentId {
            try encodeContainer.encode(assessmentId, forKey: .assessmentId)
        }
        if assessmentReportSelectionCount != 0 {
            try encodeContainer.encode(assessmentReportSelectionCount, forKey: .assessmentReportSelectionCount)
        }
        if let author = author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let controlId = controlId {
            try encodeContainer.encode(controlId, forKey: .controlId)
        }
        if let controlName = controlName {
            try encodeContainer.encode(controlName, forKey: .controlName)
        }
        if let controlSetId = controlSetId {
            try encodeContainer.encode(controlSetId, forKey: .controlSetId)
        }
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let date = date {
            try encodeContainer.encode(date.timeIntervalSince1970, forKey: .date)
        }
        if evidenceAwsServiceSourceCount != 0 {
            try encodeContainer.encode(evidenceAwsServiceSourceCount, forKey: .evidenceAwsServiceSourceCount)
        }
        if evidenceByTypeComplianceCheckCount != 0 {
            try encodeContainer.encode(evidenceByTypeComplianceCheckCount, forKey: .evidenceByTypeComplianceCheckCount)
        }
        if evidenceByTypeComplianceCheckIssuesCount != 0 {
            try encodeContainer.encode(evidenceByTypeComplianceCheckIssuesCount, forKey: .evidenceByTypeComplianceCheckIssuesCount)
        }
        if evidenceByTypeConfigurationDataCount != 0 {
            try encodeContainer.encode(evidenceByTypeConfigurationDataCount, forKey: .evidenceByTypeConfigurationDataCount)
        }
        if evidenceByTypeManualCount != 0 {
            try encodeContainer.encode(evidenceByTypeManualCount, forKey: .evidenceByTypeManualCount)
        }
        if evidenceByTypeUserActivityCount != 0 {
            try encodeContainer.encode(evidenceByTypeUserActivityCount, forKey: .evidenceByTypeUserActivityCount)
        }
        if evidenceResourcesIncludedCount != 0 {
            try encodeContainer.encode(evidenceResourcesIncludedCount, forKey: .evidenceResourcesIncludedCount)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if totalEvidence != 0 {
            try encodeContainer.encode(totalEvidence, forKey: .totalEvidence)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let dateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .date)
        date = dateDecoded
        let assessmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
        let controlSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .controlSetId)
        controlSetId = controlSetIdDecoded
        let controlIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .controlId)
        controlId = controlIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let authorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .author)
        author = authorDecoded
        let totalEvidenceDecoded = try containerValues.decode(Int.self, forKey: .totalEvidence)
        totalEvidence = totalEvidenceDecoded
        let assessmentReportSelectionCountDecoded = try containerValues.decode(Int.self, forKey: .assessmentReportSelectionCount)
        assessmentReportSelectionCount = assessmentReportSelectionCountDecoded
        let controlNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .controlName)
        controlName = controlNameDecoded
        let evidenceResourcesIncludedCountDecoded = try containerValues.decode(Int.self, forKey: .evidenceResourcesIncludedCount)
        evidenceResourcesIncludedCount = evidenceResourcesIncludedCountDecoded
        let evidenceByTypeConfigurationDataCountDecoded = try containerValues.decode(Int.self, forKey: .evidenceByTypeConfigurationDataCount)
        evidenceByTypeConfigurationDataCount = evidenceByTypeConfigurationDataCountDecoded
        let evidenceByTypeManualCountDecoded = try containerValues.decode(Int.self, forKey: .evidenceByTypeManualCount)
        evidenceByTypeManualCount = evidenceByTypeManualCountDecoded
        let evidenceByTypeComplianceCheckCountDecoded = try containerValues.decode(Int.self, forKey: .evidenceByTypeComplianceCheckCount)
        evidenceByTypeComplianceCheckCount = evidenceByTypeComplianceCheckCountDecoded
        let evidenceByTypeComplianceCheckIssuesCountDecoded = try containerValues.decode(Int.self, forKey: .evidenceByTypeComplianceCheckIssuesCount)
        evidenceByTypeComplianceCheckIssuesCount = evidenceByTypeComplianceCheckIssuesCountDecoded
        let evidenceByTypeUserActivityCountDecoded = try containerValues.decode(Int.self, forKey: .evidenceByTypeUserActivityCount)
        evidenceByTypeUserActivityCount = evidenceByTypeUserActivityCountDecoded
        let evidenceAwsServiceSourceCountDecoded = try containerValues.decode(Int.self, forKey: .evidenceAwsServiceSourceCount)
        evidenceAwsServiceSourceCount = evidenceAwsServiceSourceCountDecoded
    }
}

extension AssessmentEvidenceFolder: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssessmentEvidenceFolder(assessmentId: \(String(describing: assessmentId)), assessmentReportSelectionCount: \(String(describing: assessmentReportSelectionCount)), author: \(String(describing: author)), controlId: \(String(describing: controlId)), controlName: \(String(describing: controlName)), controlSetId: \(String(describing: controlSetId)), dataSource: \(String(describing: dataSource)), date: \(String(describing: date)), evidenceAwsServiceSourceCount: \(String(describing: evidenceAwsServiceSourceCount)), evidenceByTypeComplianceCheckCount: \(String(describing: evidenceByTypeComplianceCheckCount)), evidenceByTypeComplianceCheckIssuesCount: \(String(describing: evidenceByTypeComplianceCheckIssuesCount)), evidenceByTypeConfigurationDataCount: \(String(describing: evidenceByTypeConfigurationDataCount)), evidenceByTypeManualCount: \(String(describing: evidenceByTypeManualCount)), evidenceByTypeUserActivityCount: \(String(describing: evidenceByTypeUserActivityCount)), evidenceResourcesIncludedCount: \(String(describing: evidenceResourcesIncludedCount)), id: \(String(describing: id)), name: \(String(describing: name)), totalEvidence: \(String(describing: totalEvidence)))"}
}

/// <p>
/// The folder in which AWS Audit Manager stores evidence for an assessment.
/// </p>
public struct AssessmentEvidenceFolder: Equatable {
    /// <p>
    ///    The identifier for the specified assessment.
    /// </p>
    public let assessmentId: String?
    /// <p>
    ///          The total count of evidence included in the assessment report.
    ///       </p>
    public let assessmentReportSelectionCount: Int
    /// <p>
    ///    The name of the user who created the evidence folder.
    /// </p>
    public let author: String?
    /// <p>
    ///
    ///    The unique identifier for the specified control.
    /// </p>
    public let controlId: String?
    /// <p>
    ///          The name of the control.
    ///       </p>
    public let controlName: String?
    /// <p>
    ///    The identifier for the control set.
    /// </p>
    public let controlSetId: String?
    /// <p>
    ///    The AWS service from which the evidence was collected.
    /// </p>
    public let dataSource: String?
    /// <p>
    ///          The date when the first evidence was added to the evidence folder.
    ///       </p>
    public let date: Date?
    /// <p>
    ///    The total number of AWS resources assessed to generate the evidence.
    /// </p>
    public let evidenceAwsServiceSourceCount: Int
    /// <p>
    ///          The number of evidence that falls under the compliance check category. This evidence is collected from AWS Config or AWS Security Hub.
    ///       </p>
    public let evidenceByTypeComplianceCheckCount: Int
    /// <p>
    ///          The total number of issues that were reported directly from AWS Security
    ///          Hub, AWS Config, or both.
    ///       </p>
    public let evidenceByTypeComplianceCheckIssuesCount: Int
    /// <p>
    ///          The number of evidence that falls under the configuration data category. This evidence is collected from configuration snapshots of other AWS services such as Amazon EC2, Amazon S3, or IAM.
    ///       </p>
    public let evidenceByTypeConfigurationDataCount: Int
    /// <p>
    ///          The number of evidence that falls under the manual category. This evidence is imported manually.
    ///       </p>
    public let evidenceByTypeManualCount: Int
    /// <p>
    ///          The number of evidence that falls under the user activity category. This evidence is collected from AWS CloudTrail logs.
    ///       </p>
    public let evidenceByTypeUserActivityCount: Int
    /// <p>
    ///          The amount of evidence included in the evidence folder.
    ///       </p>
    public let evidenceResourcesIncludedCount: Int
    /// <p>
    /// The identifier for the folder in which evidence is stored.
    /// </p>
    public let id: String?
    /// <p>
    /// The name of the specified evidence folder.
    /// </p>
    public let name: String?
    /// <p>
    ///          The total amount of evidence in the evidence folder.
    ///       </p>
    public let totalEvidence: Int

    public init (
        assessmentId: String? = nil,
        assessmentReportSelectionCount: Int = 0,
        author: String? = nil,
        controlId: String? = nil,
        controlName: String? = nil,
        controlSetId: String? = nil,
        dataSource: String? = nil,
        date: Date? = nil,
        evidenceAwsServiceSourceCount: Int = 0,
        evidenceByTypeComplianceCheckCount: Int = 0,
        evidenceByTypeComplianceCheckIssuesCount: Int = 0,
        evidenceByTypeConfigurationDataCount: Int = 0,
        evidenceByTypeManualCount: Int = 0,
        evidenceByTypeUserActivityCount: Int = 0,
        evidenceResourcesIncludedCount: Int = 0,
        id: String? = nil,
        name: String? = nil,
        totalEvidence: Int = 0
    )
    {
        self.assessmentId = assessmentId
        self.assessmentReportSelectionCount = assessmentReportSelectionCount
        self.author = author
        self.controlId = controlId
        self.controlName = controlName
        self.controlSetId = controlSetId
        self.dataSource = dataSource
        self.date = date
        self.evidenceAwsServiceSourceCount = evidenceAwsServiceSourceCount
        self.evidenceByTypeComplianceCheckCount = evidenceByTypeComplianceCheckCount
        self.evidenceByTypeComplianceCheckIssuesCount = evidenceByTypeComplianceCheckIssuesCount
        self.evidenceByTypeConfigurationDataCount = evidenceByTypeConfigurationDataCount
        self.evidenceByTypeManualCount = evidenceByTypeManualCount
        self.evidenceByTypeUserActivityCount = evidenceByTypeUserActivityCount
        self.evidenceResourcesIncludedCount = evidenceResourcesIncludedCount
        self.id = id
        self.name = name
        self.totalEvidence = totalEvidence
    }
}

extension AssessmentFramework: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case controlSets
        case id
        case metadata
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let controlSets = controlSets {
            var controlSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlSets)
            for assessmentcontrolsets0 in controlSets {
                try controlSetsContainer.encode(assessmentcontrolsets0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(FrameworkMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let controlSetsContainer = try containerValues.decodeIfPresent([AssessmentControlSet?].self, forKey: .controlSets)
        var controlSetsDecoded0:[AssessmentControlSet]? = nil
        if let controlSetsContainer = controlSetsContainer {
            controlSetsDecoded0 = [AssessmentControlSet]()
            for structure0 in controlSetsContainer {
                if let structure0 = structure0 {
                    controlSetsDecoded0?.append(structure0)
                }
            }
        }
        controlSets = controlSetsDecoded0
    }
}

extension AssessmentFramework: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssessmentFramework(arn: \(String(describing: arn)), controlSets: \(String(describing: controlSets)), id: \(String(describing: id)), metadata: \(String(describing: metadata)))"}
}

/// <p>
///    The file used to structure and automate AWS Audit Manager assessments for a given compliance standard.
/// </p>
public struct AssessmentFramework: Equatable {
    /// <p>
    ///    The Amazon Resource Name (ARN) of the specified framework.
    /// </p>
    public let arn: String?
    /// <p>
    ///    The control sets associated with the framework.
    /// </p>
    public let controlSets: [AssessmentControlSet]?
    /// <p>
    /// The unique identifier for the framework.
    /// </p>
    public let id: String?
    /// <p>
    ///    The metadata of a framework, such as the name, ID, description, and so on.
    /// </p>
    public let metadata: FrameworkMetadata?

    public init (
        arn: String? = nil,
        controlSets: [AssessmentControlSet]? = nil,
        id: String? = nil,
        metadata: FrameworkMetadata? = nil
    )
    {
        self.arn = arn
        self.controlSets = controlSets
        self.id = id
        self.metadata = metadata
    }
}

extension AssessmentFrameworkMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case complianceType
        case controlSetsCount
        case controlsCount
        case createdAt
        case description
        case id
        case lastUpdatedAt
        case logo
        case name
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if controlSetsCount != 0 {
            try encodeContainer.encode(controlSetsCount, forKey: .controlSetsCount)
        }
        if controlsCount != 0 {
            try encodeContainer.encode(controlsCount, forKey: .controlsCount)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let logo = logo {
            try encodeContainer.encode(logo, forKey: .logo)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(FrameworkType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let logoDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logo)
        logo = logoDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let controlsCountDecoded = try containerValues.decode(Int.self, forKey: .controlsCount)
        controlsCount = controlsCountDecoded
        let controlSetsCountDecoded = try containerValues.decode(Int.self, forKey: .controlSetsCount)
        controlSetsCount = controlSetsCountDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension AssessmentFrameworkMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssessmentFrameworkMetadata(arn: \(String(describing: arn)), complianceType: \(String(describing: complianceType)), controlSetsCount: \(String(describing: controlSetsCount)), controlsCount: \(String(describing: controlsCount)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), id: \(String(describing: id)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), logo: \(String(describing: logo)), name: \(String(describing: name)), type: \(String(describing: type)))"}
}

/// <p>
///    The metadata associated with a standard or custom framework.
/// </p>
public struct AssessmentFrameworkMetadata: Equatable {
    /// <p>
    ///    The Amazon Resource Name (ARN) of the framework.
    /// </p>
    public let arn: String?
    /// <p>
    ///    The compliance type that the new custom framework supports, such as CIS or HIPAA.
    /// </p>
    public let complianceType: String?
    /// <p>
    ///    The number of control sets associated with the specified framework.
    /// </p>
    public let controlSetsCount: Int
    /// <p>
    /// The number of controls associated with the specified framework.
    /// </p>
    public let controlsCount: Int
    /// <p>
    ///    Specifies when the framework was created.
    /// </p>
    public let createdAt: Date?
    /// <p>
    ///    The description of the specified framework.
    /// </p>
    public let description: String?
    /// <p>
    /// The unique identified for the specified framework.
    /// </p>
    public let id: String?
    /// <p>
    ///    Specifies when the framework was most recently updated.
    /// </p>
    public let lastUpdatedAt: Date?
    /// <p>
    ///    The logo associated with the framework.
    /// </p>
    public let logo: String?
    /// <p>
    /// The name of the specified framework.
    /// </p>
    public let name: String?
    /// <p>
    /// The framework type, such as standard or custom.
    /// </p>
    public let type: FrameworkType?

    public init (
        arn: String? = nil,
        complianceType: String? = nil,
        controlSetsCount: Int = 0,
        controlsCount: Int = 0,
        createdAt: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        lastUpdatedAt: Date? = nil,
        logo: String? = nil,
        name: String? = nil,
        type: FrameworkType? = nil
    )
    {
        self.arn = arn
        self.complianceType = complianceType
        self.controlSetsCount = controlSetsCount
        self.controlsCount = controlsCount
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.logo = logo
        self.name = name
        self.type = type
    }
}

extension AssessmentMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentReportsDestination
        case complianceType
        case creationTime
        case delegations
        case description
        case id
        case lastUpdated
        case name
        case roles
        case scope
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentReportsDestination = assessmentReportsDestination {
            try encodeContainer.encode(assessmentReportsDestination, forKey: .assessmentReportsDestination)
        }
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let delegations = delegations {
            var delegationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .delegations)
            for delegations0 in delegations {
                try delegationsContainer.encode(delegations0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = lastUpdated {
            try encodeContainer.encode(lastUpdated.timeIntervalSince1970, forKey: .lastUpdated)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for roles0 in roles {
                try rolesContainer.encode(roles0)
            }
        }
        if let scope = scope {
            try encodeContainer.encode(scope, forKey: .scope)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AssessmentStatus.self, forKey: .status)
        status = statusDecoded
        let assessmentReportsDestinationDecoded = try containerValues.decodeIfPresent(AssessmentReportsDestination.self, forKey: .assessmentReportsDestination)
        assessmentReportsDestination = assessmentReportsDestinationDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let rolesContainer = try containerValues.decodeIfPresent([Role?].self, forKey: .roles)
        var rolesDecoded0:[Role]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [Role]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
        let delegationsContainer = try containerValues.decodeIfPresent([Delegation?].self, forKey: .delegations)
        var delegationsDecoded0:[Delegation]? = nil
        if let delegationsContainer = delegationsContainer {
            delegationsDecoded0 = [Delegation]()
            for structure0 in delegationsContainer {
                if let structure0 = structure0 {
                    delegationsDecoded0?.append(structure0)
                }
            }
        }
        delegations = delegationsDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension AssessmentMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssessmentMetadata(assessmentReportsDestination: \(String(describing: assessmentReportsDestination)), complianceType: \(String(describing: complianceType)), creationTime: \(String(describing: creationTime)), delegations: \(String(describing: delegations)), description: \(String(describing: description)), id: \(String(describing: id)), lastUpdated: \(String(describing: lastUpdated)), name: \(String(describing: name)), roles: \(String(describing: roles)), scope: \(String(describing: scope)), status: \(String(describing: status)))"}
}

/// <p>
///    The metadata associated with the specified assessment.
/// </p>
public struct AssessmentMetadata: Equatable {
    /// <p>
    ///    The destination in which evidence reports are stored for the specified assessment.
    /// </p>
    public let assessmentReportsDestination: AssessmentReportsDestination?
    /// <p>
    ///          The name of a compliance standard related to the assessment, such as PCI-DSS.
    ///       </p>
    public let complianceType: String?
    /// <p>
    ///    Specifies when the assessment was created.
    /// </p>
    public let creationTime: Date?
    /// <p>
    ///    The delegations associated with the assessment.
    /// </p>
    public let delegations: [Delegation]?
    /// <p>
    ///    The description of the assessment.
    /// </p>
    public let description: String?
    /// <p>
    ///    The unique identifier for the assessment.
    /// </p>
    public let id: String?
    /// <p>
    ///    The time of the most recent update.
    /// </p>
    public let lastUpdated: Date?
    /// <p>
    ///    The name of the assessment.
    /// </p>
    public let name: String?
    /// <p>
    ///    The roles associated with the assessment.
    /// </p>
    public let roles: [Role]?
    /// <p>
    ///    The wrapper of AWS accounts and services in scope for the assessment.
    /// </p>
    public let scope: Scope?
    /// <p>
    ///    The overall status of the assessment.
    /// </p>
    public let status: AssessmentStatus?

    public init (
        assessmentReportsDestination: AssessmentReportsDestination? = nil,
        complianceType: String? = nil,
        creationTime: Date? = nil,
        delegations: [Delegation]? = nil,
        description: String? = nil,
        id: String? = nil,
        lastUpdated: Date? = nil,
        name: String? = nil,
        roles: [Role]? = nil,
        scope: Scope? = nil,
        status: AssessmentStatus? = nil
    )
    {
        self.assessmentReportsDestination = assessmentReportsDestination
        self.complianceType = complianceType
        self.creationTime = creationTime
        self.delegations = delegations
        self.description = description
        self.id = id
        self.lastUpdated = lastUpdated
        self.name = name
        self.roles = roles
        self.scope = scope
        self.status = status
    }
}

extension AssessmentMetadataItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceType
        case creationTime
        case delegations
        case id
        case lastUpdated
        case name
        case roles
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let delegations = delegations {
            var delegationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .delegations)
            for delegations0 in delegations {
                try delegationsContainer.encode(delegations0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = lastUpdated {
            try encodeContainer.encode(lastUpdated.timeIntervalSince1970, forKey: .lastUpdated)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for roles0 in roles {
                try rolesContainer.encode(roles0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AssessmentStatus.self, forKey: .status)
        status = statusDecoded
        let rolesContainer = try containerValues.decodeIfPresent([Role?].self, forKey: .roles)
        var rolesDecoded0:[Role]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [Role]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
        let delegationsContainer = try containerValues.decodeIfPresent([Delegation?].self, forKey: .delegations)
        var delegationsDecoded0:[Delegation]? = nil
        if let delegationsContainer = delegationsContainer {
            delegationsDecoded0 = [Delegation]()
            for structure0 in delegationsContainer {
                if let structure0 = structure0 {
                    delegationsDecoded0?.append(structure0)
                }
            }
        }
        delegations = delegationsDecoded0
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
    }
}

extension AssessmentMetadataItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssessmentMetadataItem(complianceType: \(String(describing: complianceType)), creationTime: \(String(describing: creationTime)), delegations: \(String(describing: delegations)), id: \(String(describing: id)), lastUpdated: \(String(describing: lastUpdated)), name: \(String(describing: name)), roles: \(String(describing: roles)), status: \(String(describing: status)))"}
}

/// <p>
/// A metadata object associated with an assessment in AWS Audit Manager.
/// </p>
public struct AssessmentMetadataItem: Equatable {
    /// <p>
    ///          The name of the compliance standard related to the assessment, such as PCI-DSS.
    ///       </p>
    public let complianceType: String?
    /// <p>
    ///    Specifies when the assessment was created.
    /// </p>
    public let creationTime: Date?
    /// <p>
    ///    The delegations associated with the assessment.
    /// </p>
    public let delegations: [Delegation]?
    /// <p>
    ///    The unique identifier for the assessment.
    /// </p>
    public let id: String?
    /// <p>
    ///    The time of the most recent update.
    /// </p>
    public let lastUpdated: Date?
    /// <p>
    /// The name of the assessment.
    /// </p>
    public let name: String?
    /// <p>
    ///    The roles associated with the assessment.
    /// </p>
    public let roles: [Role]?
    /// <p>
    /// The current status of the assessment.
    /// </p>
    public let status: AssessmentStatus?

    public init (
        complianceType: String? = nil,
        creationTime: Date? = nil,
        delegations: [Delegation]? = nil,
        id: String? = nil,
        lastUpdated: Date? = nil,
        name: String? = nil,
        roles: [Role]? = nil,
        status: AssessmentStatus? = nil
    )
    {
        self.complianceType = complianceType
        self.creationTime = creationTime
        self.delegations = delegations
        self.id = id
        self.lastUpdated = lastUpdated
        self.name = name
        self.roles = roles
        self.status = status
    }
}

extension AssessmentReport: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentId
        case assessmentName
        case author
        case awsAccountId
        case creationTime
        case description
        case id
        case name
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentId = assessmentId {
            try encodeContainer.encode(assessmentId, forKey: .assessmentId)
        }
        if let assessmentName = assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let author = author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let awsAccountId = awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let assessmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let authorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .author)
        author = authorDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AssessmentReportStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension AssessmentReport: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssessmentReport(assessmentId: \(String(describing: assessmentId)), assessmentName: \(String(describing: assessmentName)), author: \(String(describing: author)), awsAccountId: \(String(describing: awsAccountId)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

/// <p>
///  A finalized document generated from an AWS Audit Manager assessment. These reports summarize the relevant evidence collected for your audit, and link to the relevant evidence folders which are named and organized according to the controls specified in your assessment.
/// </p>
public struct AssessmentReport: Equatable {
    /// <p>
    ///    The identifier for the specified assessment.
    /// </p>
    public let assessmentId: String?
    /// <p>
    /// The name of the associated assessment.
    /// </p>
    public let assessmentName: String?
    /// <p>
    ///    The name of the user who created the assessment report.
    /// </p>
    public let author: String?
    /// <p>
    ///    The identifier for the specified AWS account.
    /// </p>
    public let awsAccountId: String?
    /// <p>
    ///    Specifies when the assessment report was created.
    /// </p>
    public let creationTime: Date?
    /// <p>
    ///    The description of the specified assessment report.
    /// </p>
    public let description: String?
    /// <p>
    /// The unique identifier for the specified assessment report.
    /// </p>
    public let id: String?
    /// <p>
    /// The name given to the assessment report.
    /// </p>
    public let name: String?
    /// <p>
    /// The current status of the specified assessment report.
    /// </p>
    public let status: AssessmentReportStatus?

    public init (
        assessmentId: String? = nil,
        assessmentName: String? = nil,
        author: String? = nil,
        awsAccountId: String? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        status: AssessmentReportStatus? = nil
    )
    {
        self.assessmentId = assessmentId
        self.assessmentName = assessmentName
        self.author = author
        self.awsAccountId = awsAccountId
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.status = status
    }
}

public enum AssessmentReportDestinationType {
    case s3
    case sdkUnknown(String)
}

extension AssessmentReportDestinationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssessmentReportDestinationType] {
        return [
            .s3,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .s3: return "S3"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssessmentReportDestinationType(rawValue: rawValue) ?? AssessmentReportDestinationType.sdkUnknown(rawValue)
    }
}

extension AssessmentReportEvidenceError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode
        case errorMessage
        case evidenceId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let evidenceId = evidenceId {
            try encodeContainer.encode(evidenceId, forKey: .evidenceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .evidenceId)
        evidenceId = evidenceIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension AssessmentReportEvidenceError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssessmentReportEvidenceError(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), evidenceId: \(String(describing: evidenceId)))"}
}

/// <p>
///    An error entity for the <code>AssessmentReportEvidence</code> API. This is used to provide more meaningful errors than a simple string message.
/// </p>
public struct AssessmentReportEvidenceError: Equatable {
    /// <p>
    ///    The error code returned by the <code>AssessmentReportEvidence</code> API.
    /// </p>
    public let errorCode: String?
    /// <p>
    ///    The error message returned by the <code>AssessmentReportEvidence</code> API.
    /// </p>
    public let errorMessage: String?
    /// <p>
    ///    The identifier for the evidence.
    /// </p>
    public let evidenceId: String?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        evidenceId: String? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.evidenceId = evidenceId
    }
}

extension AssessmentReportMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentId
        case assessmentName
        case author
        case creationTime
        case description
        case id
        case name
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentId = assessmentId {
            try encodeContainer.encode(assessmentId, forKey: .assessmentId)
        }
        if let assessmentName = assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let author = author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let assessmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let authorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .author)
        author = authorDecoded
        let statusDecoded = try containerValues.decodeIfPresent(AssessmentReportStatus.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
    }
}

extension AssessmentReportMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssessmentReportMetadata(assessmentId: \(String(describing: assessmentId)), assessmentName: \(String(describing: assessmentName)), author: \(String(describing: author)), creationTime: \(String(describing: creationTime)), description: \(String(describing: description)), id: \(String(describing: id)), name: \(String(describing: name)), status: \(String(describing: status)))"}
}

/// <p>
///    The metadata objects associated with the specified assessment report.
/// </p>
public struct AssessmentReportMetadata: Equatable {
    /// <p>
    ///    The unique identifier for the associated assessment.
    /// </p>
    public let assessmentId: String?
    /// <p>The name of the associated assessment.
    /// </p>
    public let assessmentName: String?
    /// <p>
    ///    The name of the user who created the assessment report.
    /// </p>
    public let author: String?
    /// <p>
    ///    Specifies when the assessment report was created.
    /// </p>
    public let creationTime: Date?
    /// <p>
    /// The description of the specified assessment report.
    /// </p>
    public let description: String?
    /// <p>
    /// The unique identifier for the assessment report.
    /// </p>
    public let id: String?
    /// <p>
    /// The name of the assessment report.
    /// </p>
    public let name: String?
    /// <p>
    /// The current status of the assessment report.
    /// </p>
    public let status: AssessmentReportStatus?

    public init (
        assessmentId: String? = nil,
        assessmentName: String? = nil,
        author: String? = nil,
        creationTime: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        name: String? = nil,
        status: AssessmentReportStatus? = nil
    )
    {
        self.assessmentId = assessmentId
        self.assessmentName = assessmentName
        self.author = author
        self.creationTime = creationTime
        self.description = description
        self.id = id
        self.name = name
        self.status = status
    }
}

public enum AssessmentReportStatus {
    case complete
    case failed
    case inProgress
    case sdkUnknown(String)
}

extension AssessmentReportStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssessmentReportStatus] {
        return [
            .complete,
            .failed,
            .inProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .complete: return "COMPLETE"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssessmentReportStatus(rawValue: rawValue) ?? AssessmentReportStatus.sdkUnknown(rawValue)
    }
}

extension AssessmentReportsDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destination
        case destinationType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let destinationType = destinationType {
            try encodeContainer.encode(destinationType.rawValue, forKey: .destinationType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationTypeDecoded = try containerValues.decodeIfPresent(AssessmentReportDestinationType.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension AssessmentReportsDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssessmentReportsDestination(destination: \(String(describing: destination)), destinationType: \(String(describing: destinationType)))"}
}

/// <p>
///    The location in which AWS Audit Manager saves assessment reports for the given assessment.
/// </p>
public struct AssessmentReportsDestination: Equatable {
    /// <p>
    ///    The destination of the assessment report.
    /// </p>
    public let destination: String?
    /// <p>
    ///    The destination type, such as Amazon S3.
    /// </p>
    public let destinationType: AssessmentReportDestinationType?

    public init (
        destination: String? = nil,
        destinationType: AssessmentReportDestinationType? = nil
    )
    {
        self.destination = destination
        self.destinationType = destinationType
    }
}

public enum AssessmentStatus {
    case active
    case inactive
    case sdkUnknown(String)
}

extension AssessmentStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssessmentStatus] {
        return [
            .active,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssessmentStatus(rawValue: rawValue) ?? AssessmentStatus.sdkUnknown(rawValue)
    }
}

public struct AssociateAssessmentReportEvidenceFolderInputBodyMiddleware: Middleware {
    public let id: String = "AssociateAssessmentReportEvidenceFolderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateAssessmentReportEvidenceFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateAssessmentReportEvidenceFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateAssessmentReportEvidenceFolderInput>
    public typealias MOutput = OperationOutput<AssociateAssessmentReportEvidenceFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateAssessmentReportEvidenceFolderOutputError>
}

extension AssociateAssessmentReportEvidenceFolderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateAssessmentReportEvidenceFolderInput(assessmentId: \(String(describing: assessmentId)), evidenceFolderId: \(String(describing: evidenceFolderId)))"}
}

extension AssociateAssessmentReportEvidenceFolderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case evidenceFolderId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evidenceFolderId = evidenceFolderId {
            try encodeContainer.encode(evidenceFolderId, forKey: .evidenceFolderId)
        }
    }
}

public struct AssociateAssessmentReportEvidenceFolderInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateAssessmentReportEvidenceFolderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateAssessmentReportEvidenceFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateAssessmentReportEvidenceFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateAssessmentReportEvidenceFolderInput>
    public typealias MOutput = OperationOutput<AssociateAssessmentReportEvidenceFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateAssessmentReportEvidenceFolderOutputError>
}

public struct AssociateAssessmentReportEvidenceFolderInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateAssessmentReportEvidenceFolderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateAssessmentReportEvidenceFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateAssessmentReportEvidenceFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateAssessmentReportEvidenceFolderInput>
    public typealias MOutput = OperationOutput<AssociateAssessmentReportEvidenceFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateAssessmentReportEvidenceFolderOutputError>
}

public struct AssociateAssessmentReportEvidenceFolderInput: Equatable {
    /// <p>
    ///          The identifier for the specified assessment.
    ///       </p>
    public let assessmentId: String?
    /// <p>
    ///          The identifier for the folder in which evidence is stored.
    ///       </p>
    public let evidenceFolderId: String?

    public init (
        assessmentId: String? = nil,
        evidenceFolderId: String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.evidenceFolderId = evidenceFolderId
    }
}

struct AssociateAssessmentReportEvidenceFolderInputBody: Equatable {
    public let evidenceFolderId: String?
}

extension AssociateAssessmentReportEvidenceFolderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case evidenceFolderId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFolderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .evidenceFolderId)
        evidenceFolderId = evidenceFolderIdDecoded
    }
}

extension AssociateAssessmentReportEvidenceFolderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateAssessmentReportEvidenceFolderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateAssessmentReportEvidenceFolderOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateAssessmentReportEvidenceFolderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateAssessmentReportEvidenceFolderOutputResponse()"}
}

extension AssociateAssessmentReportEvidenceFolderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateAssessmentReportEvidenceFolderOutputResponse: Equatable {

    public init() {}
}

struct AssociateAssessmentReportEvidenceFolderOutputResponseBody: Equatable {
}

extension AssociateAssessmentReportEvidenceFolderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct BatchAssociateAssessmentReportEvidenceInputBodyMiddleware: Middleware {
    public let id: String = "BatchAssociateAssessmentReportEvidenceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchAssociateAssessmentReportEvidenceInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchAssociateAssessmentReportEvidenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchAssociateAssessmentReportEvidenceInput>
    public typealias MOutput = OperationOutput<BatchAssociateAssessmentReportEvidenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchAssociateAssessmentReportEvidenceOutputError>
}

extension BatchAssociateAssessmentReportEvidenceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAssociateAssessmentReportEvidenceInput(assessmentId: \(String(describing: assessmentId)), evidenceFolderId: \(String(describing: evidenceFolderId)), evidenceIds: \(String(describing: evidenceIds)))"}
}

extension BatchAssociateAssessmentReportEvidenceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case evidenceFolderId
        case evidenceIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evidenceFolderId = evidenceFolderId {
            try encodeContainer.encode(evidenceFolderId, forKey: .evidenceFolderId)
        }
        if let evidenceIds = evidenceIds {
            var evidenceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .evidenceIds)
            for evidenceids0 in evidenceIds {
                try evidenceIdsContainer.encode(evidenceids0)
            }
        }
    }
}

public struct BatchAssociateAssessmentReportEvidenceInputHeadersMiddleware: Middleware {
    public let id: String = "BatchAssociateAssessmentReportEvidenceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchAssociateAssessmentReportEvidenceInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchAssociateAssessmentReportEvidenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchAssociateAssessmentReportEvidenceInput>
    public typealias MOutput = OperationOutput<BatchAssociateAssessmentReportEvidenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchAssociateAssessmentReportEvidenceOutputError>
}

public struct BatchAssociateAssessmentReportEvidenceInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchAssociateAssessmentReportEvidenceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchAssociateAssessmentReportEvidenceInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchAssociateAssessmentReportEvidenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchAssociateAssessmentReportEvidenceInput>
    public typealias MOutput = OperationOutput<BatchAssociateAssessmentReportEvidenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchAssociateAssessmentReportEvidenceOutputError>
}

public struct BatchAssociateAssessmentReportEvidenceInput: Equatable {
    /// <p>
    ///     The unique identifier for the specified assessment.
    ///       </p>
    public let assessmentId: String?
    /// <p>
    ///          The identifier for the folder in which the evidence is stored.
    ///       </p>
    public let evidenceFolderId: String?
    /// <p>
    ///          The list of evidence identifiers.
    ///       </p>
    public let evidenceIds: [String]?

    public init (
        assessmentId: String? = nil,
        evidenceFolderId: String? = nil,
        evidenceIds: [String]? = nil
    )
    {
        self.assessmentId = assessmentId
        self.evidenceFolderId = evidenceFolderId
        self.evidenceIds = evidenceIds
    }
}

struct BatchAssociateAssessmentReportEvidenceInputBody: Equatable {
    public let evidenceFolderId: String?
    public let evidenceIds: [String]?
}

extension BatchAssociateAssessmentReportEvidenceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case evidenceFolderId
        case evidenceIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFolderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .evidenceFolderId)
        evidenceFolderId = evidenceFolderIdDecoded
        let evidenceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .evidenceIds)
        var evidenceIdsDecoded0:[String]? = nil
        if let evidenceIdsContainer = evidenceIdsContainer {
            evidenceIdsDecoded0 = [String]()
            for string0 in evidenceIdsContainer {
                if let string0 = string0 {
                    evidenceIdsDecoded0?.append(string0)
                }
            }
        }
        evidenceIds = evidenceIdsDecoded0
    }
}

extension BatchAssociateAssessmentReportEvidenceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchAssociateAssessmentReportEvidenceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchAssociateAssessmentReportEvidenceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchAssociateAssessmentReportEvidenceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchAssociateAssessmentReportEvidenceOutputResponse(errors: \(String(describing: errors)), evidenceIds: \(String(describing: evidenceIds)))"}
}

extension BatchAssociateAssessmentReportEvidenceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchAssociateAssessmentReportEvidenceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
            self.evidenceIds = output.evidenceIds
        } else {
            self.errors = nil
            self.evidenceIds = nil
        }
    }
}

public struct BatchAssociateAssessmentReportEvidenceOutputResponse: Equatable {
    /// <p>
    ///          A list of errors returned by the <code>BatchAssociateAssessmentReportEvidence</code> API.
    ///       </p>
    public let errors: [AssessmentReportEvidenceError]?
    /// <p>
    ///          The identifier for the evidence.
    ///       </p>
    public let evidenceIds: [String]?

    public init (
        errors: [AssessmentReportEvidenceError]? = nil,
        evidenceIds: [String]? = nil
    )
    {
        self.errors = errors
        self.evidenceIds = evidenceIds
    }
}

struct BatchAssociateAssessmentReportEvidenceOutputResponseBody: Equatable {
    public let evidenceIds: [String]?
    public let errors: [AssessmentReportEvidenceError]?
}

extension BatchAssociateAssessmentReportEvidenceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors
        case evidenceIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .evidenceIds)
        var evidenceIdsDecoded0:[String]? = nil
        if let evidenceIdsContainer = evidenceIdsContainer {
            evidenceIdsDecoded0 = [String]()
            for string0 in evidenceIdsContainer {
                if let string0 = string0 {
                    evidenceIdsDecoded0?.append(string0)
                }
            }
        }
        evidenceIds = evidenceIdsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([AssessmentReportEvidenceError?].self, forKey: .errors)
        var errorsDecoded0:[AssessmentReportEvidenceError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [AssessmentReportEvidenceError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension BatchCreateDelegationByAssessmentError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createDelegationRequest
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createDelegationRequest = createDelegationRequest {
            try encodeContainer.encode(createDelegationRequest, forKey: .createDelegationRequest)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createDelegationRequestDecoded = try containerValues.decodeIfPresent(CreateDelegationRequest.self, forKey: .createDelegationRequest)
        createDelegationRequest = createDelegationRequestDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension BatchCreateDelegationByAssessmentError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchCreateDelegationByAssessmentError(createDelegationRequest: \(String(describing: createDelegationRequest)), errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)))"}
}

/// <p>
///    An error entity for the <code>BatchCreateDelegationByAssessment</code> API. This is used to provide more meaningful errors than a simple string message.
/// </p>
public struct BatchCreateDelegationByAssessmentError: Equatable {
    /// <p>
    /// The API request to batch create delegations in AWS Audit Manager.
    /// </p>
    public let createDelegationRequest: CreateDelegationRequest?
    /// <p>
    ///    The error code returned by the <code>BatchCreateDelegationByAssessment</code> API.
    /// </p>
    public let errorCode: String?
    /// <p>
    ///    The error message returned by the <code>BatchCreateDelegationByAssessment</code> API.
    /// </p>
    public let errorMessage: String?

    public init (
        createDelegationRequest: CreateDelegationRequest? = nil,
        errorCode: String? = nil,
        errorMessage: String? = nil
    )
    {
        self.createDelegationRequest = createDelegationRequest
        self.errorCode = errorCode
        self.errorMessage = errorMessage
    }
}

public struct BatchCreateDelegationByAssessmentInputBodyMiddleware: Middleware {
    public let id: String = "BatchCreateDelegationByAssessmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchCreateDelegationByAssessmentInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchCreateDelegationByAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchCreateDelegationByAssessmentInput>
    public typealias MOutput = OperationOutput<BatchCreateDelegationByAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchCreateDelegationByAssessmentOutputError>
}

extension BatchCreateDelegationByAssessmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchCreateDelegationByAssessmentInput(assessmentId: \(String(describing: assessmentId)), createDelegationRequests: \(String(describing: createDelegationRequests)))"}
}

extension BatchCreateDelegationByAssessmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createDelegationRequests
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createDelegationRequests = createDelegationRequests {
            var createDelegationRequestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .createDelegationRequests)
            for createdelegationrequests0 in createDelegationRequests {
                try createDelegationRequestsContainer.encode(createdelegationrequests0)
            }
        }
    }
}

public struct BatchCreateDelegationByAssessmentInputHeadersMiddleware: Middleware {
    public let id: String = "BatchCreateDelegationByAssessmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchCreateDelegationByAssessmentInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchCreateDelegationByAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchCreateDelegationByAssessmentInput>
    public typealias MOutput = OperationOutput<BatchCreateDelegationByAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchCreateDelegationByAssessmentOutputError>
}

public struct BatchCreateDelegationByAssessmentInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchCreateDelegationByAssessmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchCreateDelegationByAssessmentInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchCreateDelegationByAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchCreateDelegationByAssessmentInput>
    public typealias MOutput = OperationOutput<BatchCreateDelegationByAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchCreateDelegationByAssessmentOutputError>
}

public struct BatchCreateDelegationByAssessmentInput: Equatable {
    /// <p>
    ///          The identifier for the specified assessment.
    ///       </p>
    public let assessmentId: String?
    /// <p>
    ///          The API request to batch create delegations in AWS Audit Manager.
    ///       </p>
    public let createDelegationRequests: [CreateDelegationRequest]?

    public init (
        assessmentId: String? = nil,
        createDelegationRequests: [CreateDelegationRequest]? = nil
    )
    {
        self.assessmentId = assessmentId
        self.createDelegationRequests = createDelegationRequests
    }
}

struct BatchCreateDelegationByAssessmentInputBody: Equatable {
    public let createDelegationRequests: [CreateDelegationRequest]?
}

extension BatchCreateDelegationByAssessmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createDelegationRequests
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createDelegationRequestsContainer = try containerValues.decodeIfPresent([CreateDelegationRequest?].self, forKey: .createDelegationRequests)
        var createDelegationRequestsDecoded0:[CreateDelegationRequest]? = nil
        if let createDelegationRequestsContainer = createDelegationRequestsContainer {
            createDelegationRequestsDecoded0 = [CreateDelegationRequest]()
            for structure0 in createDelegationRequestsContainer {
                if let structure0 = structure0 {
                    createDelegationRequestsDecoded0?.append(structure0)
                }
            }
        }
        createDelegationRequests = createDelegationRequestsDecoded0
    }
}

extension BatchCreateDelegationByAssessmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchCreateDelegationByAssessmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchCreateDelegationByAssessmentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchCreateDelegationByAssessmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchCreateDelegationByAssessmentOutputResponse(delegations: \(String(describing: delegations)), errors: \(String(describing: errors)))"}
}

extension BatchCreateDelegationByAssessmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchCreateDelegationByAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.delegations = output.delegations
            self.errors = output.errors
        } else {
            self.delegations = nil
            self.errors = nil
        }
    }
}

public struct BatchCreateDelegationByAssessmentOutputResponse: Equatable {
    /// <p>
    ///          The delegations associated with the assessment.
    ///       </p>
    public let delegations: [Delegation]?
    /// <p>
    ///          A list of errors returned by the <code>BatchCreateDelegationByAssessment</code> API.
    ///       </p>
    public let errors: [BatchCreateDelegationByAssessmentError]?

    public init (
        delegations: [Delegation]? = nil,
        errors: [BatchCreateDelegationByAssessmentError]? = nil
    )
    {
        self.delegations = delegations
        self.errors = errors
    }
}

struct BatchCreateDelegationByAssessmentOutputResponseBody: Equatable {
    public let delegations: [Delegation]?
    public let errors: [BatchCreateDelegationByAssessmentError]?
}

extension BatchCreateDelegationByAssessmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case delegations
        case errors
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegationsContainer = try containerValues.decodeIfPresent([Delegation?].self, forKey: .delegations)
        var delegationsDecoded0:[Delegation]? = nil
        if let delegationsContainer = delegationsContainer {
            delegationsDecoded0 = [Delegation]()
            for structure0 in delegationsContainer {
                if let structure0 = structure0 {
                    delegationsDecoded0?.append(structure0)
                }
            }
        }
        delegations = delegationsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([BatchCreateDelegationByAssessmentError?].self, forKey: .errors)
        var errorsDecoded0:[BatchCreateDelegationByAssessmentError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [BatchCreateDelegationByAssessmentError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension BatchDeleteDelegationByAssessmentError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case delegationId
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delegationId = delegationId {
            try encodeContainer.encode(delegationId, forKey: .delegationId)
        }
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .delegationId)
        delegationId = delegationIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension BatchDeleteDelegationByAssessmentError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteDelegationByAssessmentError(delegationId: \(String(describing: delegationId)), errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)))"}
}

/// <p>
///    An error entity for the <code>BatchDeleteDelegationByAssessment</code> API. This is used to provide more meaningful errors than a simple string message.
/// </p>
public struct BatchDeleteDelegationByAssessmentError: Equatable {
    /// <p>
    ///    The identifier for the specified delegation.
    /// </p>
    public let delegationId: String?
    /// <p>
    ///    The error code returned by the <code>BatchDeleteDelegationByAssessment</code> API.
    /// </p>
    public let errorCode: String?
    /// <p>
    ///    The error message returned by the <code>BatchDeleteDelegationByAssessment</code> API.
    /// </p>
    public let errorMessage: String?

    public init (
        delegationId: String? = nil,
        errorCode: String? = nil,
        errorMessage: String? = nil
    )
    {
        self.delegationId = delegationId
        self.errorCode = errorCode
        self.errorMessage = errorMessage
    }
}

public struct BatchDeleteDelegationByAssessmentInputBodyMiddleware: Middleware {
    public let id: String = "BatchDeleteDelegationByAssessmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteDelegationByAssessmentInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteDelegationByAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteDelegationByAssessmentInput>
    public typealias MOutput = OperationOutput<BatchDeleteDelegationByAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteDelegationByAssessmentOutputError>
}

extension BatchDeleteDelegationByAssessmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteDelegationByAssessmentInput(assessmentId: \(String(describing: assessmentId)), delegationIds: \(String(describing: delegationIds)))"}
}

extension BatchDeleteDelegationByAssessmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case delegationIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delegationIds = delegationIds {
            var delegationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .delegationIds)
            for delegationids0 in delegationIds {
                try delegationIdsContainer.encode(delegationids0)
            }
        }
    }
}

public struct BatchDeleteDelegationByAssessmentInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDeleteDelegationByAssessmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteDelegationByAssessmentInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteDelegationByAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteDelegationByAssessmentInput>
    public typealias MOutput = OperationOutput<BatchDeleteDelegationByAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteDelegationByAssessmentOutputError>
}

public struct BatchDeleteDelegationByAssessmentInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDeleteDelegationByAssessmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteDelegationByAssessmentInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteDelegationByAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteDelegationByAssessmentInput>
    public typealias MOutput = OperationOutput<BatchDeleteDelegationByAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteDelegationByAssessmentOutputError>
}

public struct BatchDeleteDelegationByAssessmentInput: Equatable {
    /// <p>
    ///          The identifier for the specified assessment.
    ///       </p>
    public let assessmentId: String?
    /// <p>
    ///    The identifiers for the specified delegations.
    ///       </p>
    public let delegationIds: [String]?

    public init (
        assessmentId: String? = nil,
        delegationIds: [String]? = nil
    )
    {
        self.assessmentId = assessmentId
        self.delegationIds = delegationIds
    }
}

struct BatchDeleteDelegationByAssessmentInputBody: Equatable {
    public let delegationIds: [String]?
}

extension BatchDeleteDelegationByAssessmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case delegationIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegationIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .delegationIds)
        var delegationIdsDecoded0:[String]? = nil
        if let delegationIdsContainer = delegationIdsContainer {
            delegationIdsDecoded0 = [String]()
            for string0 in delegationIdsContainer {
                if let string0 = string0 {
                    delegationIdsDecoded0?.append(string0)
                }
            }
        }
        delegationIds = delegationIdsDecoded0
    }
}

extension BatchDeleteDelegationByAssessmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteDelegationByAssessmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeleteDelegationByAssessmentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteDelegationByAssessmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteDelegationByAssessmentOutputResponse(errors: \(String(describing: errors)))"}
}

extension BatchDeleteDelegationByAssessmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDeleteDelegationByAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDeleteDelegationByAssessmentOutputResponse: Equatable {
    /// <p>
    ///          A list of errors returned by the <code>BatchDeleteDelegationByAssessment</code> API.
    ///       </p>
    public let errors: [BatchDeleteDelegationByAssessmentError]?

    public init (
        errors: [BatchDeleteDelegationByAssessmentError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDeleteDelegationByAssessmentOutputResponseBody: Equatable {
    public let errors: [BatchDeleteDelegationByAssessmentError]?
}

extension BatchDeleteDelegationByAssessmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([BatchDeleteDelegationByAssessmentError?].self, forKey: .errors)
        var errorsDecoded0:[BatchDeleteDelegationByAssessmentError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [BatchDeleteDelegationByAssessmentError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct BatchDisassociateAssessmentReportEvidenceInputBodyMiddleware: Middleware {
    public let id: String = "BatchDisassociateAssessmentReportEvidenceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisassociateAssessmentReportEvidenceInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisassociateAssessmentReportEvidenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisassociateAssessmentReportEvidenceInput>
    public typealias MOutput = OperationOutput<BatchDisassociateAssessmentReportEvidenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisassociateAssessmentReportEvidenceOutputError>
}

extension BatchDisassociateAssessmentReportEvidenceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDisassociateAssessmentReportEvidenceInput(assessmentId: \(String(describing: assessmentId)), evidenceFolderId: \(String(describing: evidenceFolderId)), evidenceIds: \(String(describing: evidenceIds)))"}
}

extension BatchDisassociateAssessmentReportEvidenceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case evidenceFolderId
        case evidenceIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evidenceFolderId = evidenceFolderId {
            try encodeContainer.encode(evidenceFolderId, forKey: .evidenceFolderId)
        }
        if let evidenceIds = evidenceIds {
            var evidenceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .evidenceIds)
            for evidenceids0 in evidenceIds {
                try evidenceIdsContainer.encode(evidenceids0)
            }
        }
    }
}

public struct BatchDisassociateAssessmentReportEvidenceInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDisassociateAssessmentReportEvidenceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisassociateAssessmentReportEvidenceInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisassociateAssessmentReportEvidenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisassociateAssessmentReportEvidenceInput>
    public typealias MOutput = OperationOutput<BatchDisassociateAssessmentReportEvidenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisassociateAssessmentReportEvidenceOutputError>
}

public struct BatchDisassociateAssessmentReportEvidenceInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDisassociateAssessmentReportEvidenceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDisassociateAssessmentReportEvidenceInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDisassociateAssessmentReportEvidenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDisassociateAssessmentReportEvidenceInput>
    public typealias MOutput = OperationOutput<BatchDisassociateAssessmentReportEvidenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDisassociateAssessmentReportEvidenceOutputError>
}

public struct BatchDisassociateAssessmentReportEvidenceInput: Equatable {
    /// <p>
    ///          The identifier for the specified assessment.
    ///       </p>
    public let assessmentId: String?
    /// <p>
    ///          The identifier for the folder in which evidence is stored.
    ///       </p>
    public let evidenceFolderId: String?
    /// <p>
    ///          The list of evidence identifiers.
    ///       </p>
    public let evidenceIds: [String]?

    public init (
        assessmentId: String? = nil,
        evidenceFolderId: String? = nil,
        evidenceIds: [String]? = nil
    )
    {
        self.assessmentId = assessmentId
        self.evidenceFolderId = evidenceFolderId
        self.evidenceIds = evidenceIds
    }
}

struct BatchDisassociateAssessmentReportEvidenceInputBody: Equatable {
    public let evidenceFolderId: String?
    public let evidenceIds: [String]?
}

extension BatchDisassociateAssessmentReportEvidenceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case evidenceFolderId
        case evidenceIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFolderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .evidenceFolderId)
        evidenceFolderId = evidenceFolderIdDecoded
        let evidenceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .evidenceIds)
        var evidenceIdsDecoded0:[String]? = nil
        if let evidenceIdsContainer = evidenceIdsContainer {
            evidenceIdsDecoded0 = [String]()
            for string0 in evidenceIdsContainer {
                if let string0 = string0 {
                    evidenceIdsDecoded0?.append(string0)
                }
            }
        }
        evidenceIds = evidenceIdsDecoded0
    }
}

extension BatchDisassociateAssessmentReportEvidenceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDisassociateAssessmentReportEvidenceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDisassociateAssessmentReportEvidenceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDisassociateAssessmentReportEvidenceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDisassociateAssessmentReportEvidenceOutputResponse(errors: \(String(describing: errors)), evidenceIds: \(String(describing: evidenceIds)))"}
}

extension BatchDisassociateAssessmentReportEvidenceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDisassociateAssessmentReportEvidenceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
            self.evidenceIds = output.evidenceIds
        } else {
            self.errors = nil
            self.evidenceIds = nil
        }
    }
}

public struct BatchDisassociateAssessmentReportEvidenceOutputResponse: Equatable {
    /// <p>
    ///          A list of errors returned by the <code>BatchDisassociateAssessmentReportEvidence</code> API.
    ///       </p>
    public let errors: [AssessmentReportEvidenceError]?
    /// <p>
    ///          The identifier for the evidence.
    ///       </p>
    public let evidenceIds: [String]?

    public init (
        errors: [AssessmentReportEvidenceError]? = nil,
        evidenceIds: [String]? = nil
    )
    {
        self.errors = errors
        self.evidenceIds = evidenceIds
    }
}

struct BatchDisassociateAssessmentReportEvidenceOutputResponseBody: Equatable {
    public let evidenceIds: [String]?
    public let errors: [AssessmentReportEvidenceError]?
}

extension BatchDisassociateAssessmentReportEvidenceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors
        case evidenceIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .evidenceIds)
        var evidenceIdsDecoded0:[String]? = nil
        if let evidenceIdsContainer = evidenceIdsContainer {
            evidenceIdsDecoded0 = [String]()
            for string0 in evidenceIdsContainer {
                if let string0 = string0 {
                    evidenceIdsDecoded0?.append(string0)
                }
            }
        }
        evidenceIds = evidenceIdsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([AssessmentReportEvidenceError?].self, forKey: .errors)
        var errorsDecoded0:[AssessmentReportEvidenceError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [AssessmentReportEvidenceError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension BatchImportEvidenceToAssessmentControlError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode
        case errorMessage
        case manualEvidence
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let manualEvidence = manualEvidence {
            try encodeContainer.encode(manualEvidence, forKey: .manualEvidence)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manualEvidenceDecoded = try containerValues.decodeIfPresent(ManualEvidence.self, forKey: .manualEvidence)
        manualEvidence = manualEvidenceDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension BatchImportEvidenceToAssessmentControlError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchImportEvidenceToAssessmentControlError(errorCode: \(String(describing: errorCode)), errorMessage: \(String(describing: errorMessage)), manualEvidence: \(String(describing: manualEvidence)))"}
}

/// <p>
///    An error entity for the <code>BatchImportEvidenceToAssessmentControl</code> API. This is used to provide more meaningful errors than a simple string message.
/// </p>
public struct BatchImportEvidenceToAssessmentControlError: Equatable {
    /// <p>
    ///   The error code returned by the <code>BatchImportEvidenceToAssessmentControl</code> API.
    /// </p>
    public let errorCode: String?
    /// <p>
    ///   The error message returned by the <code>BatchImportEvidenceToAssessmentControl</code> API.
    /// </p>
    public let errorMessage: String?
    /// <p>
    /// Manual evidence that cannot be collected automatically by AWS Audit Manager.
    /// </p>
    public let manualEvidence: ManualEvidence?

    public init (
        errorCode: String? = nil,
        errorMessage: String? = nil,
        manualEvidence: ManualEvidence? = nil
    )
    {
        self.errorCode = errorCode
        self.errorMessage = errorMessage
        self.manualEvidence = manualEvidence
    }
}

public struct BatchImportEvidenceToAssessmentControlInputBodyMiddleware: Middleware {
    public let id: String = "BatchImportEvidenceToAssessmentControlInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchImportEvidenceToAssessmentControlInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchImportEvidenceToAssessmentControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchImportEvidenceToAssessmentControlInput>
    public typealias MOutput = OperationOutput<BatchImportEvidenceToAssessmentControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchImportEvidenceToAssessmentControlOutputError>
}

extension BatchImportEvidenceToAssessmentControlInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchImportEvidenceToAssessmentControlInput(assessmentId: \(String(describing: assessmentId)), controlId: \(String(describing: controlId)), controlSetId: \(String(describing: controlSetId)), manualEvidence: \(String(describing: manualEvidence)))"}
}

extension BatchImportEvidenceToAssessmentControlInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case manualEvidence
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let manualEvidence = manualEvidence {
            var manualEvidenceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .manualEvidence)
            for manualevidencelist0 in manualEvidence {
                try manualEvidenceContainer.encode(manualevidencelist0)
            }
        }
    }
}

public struct BatchImportEvidenceToAssessmentControlInputHeadersMiddleware: Middleware {
    public let id: String = "BatchImportEvidenceToAssessmentControlInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchImportEvidenceToAssessmentControlInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchImportEvidenceToAssessmentControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchImportEvidenceToAssessmentControlInput>
    public typealias MOutput = OperationOutput<BatchImportEvidenceToAssessmentControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchImportEvidenceToAssessmentControlOutputError>
}

public struct BatchImportEvidenceToAssessmentControlInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchImportEvidenceToAssessmentControlInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchImportEvidenceToAssessmentControlInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchImportEvidenceToAssessmentControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchImportEvidenceToAssessmentControlInput>
    public typealias MOutput = OperationOutput<BatchImportEvidenceToAssessmentControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchImportEvidenceToAssessmentControlOutputError>
}

public struct BatchImportEvidenceToAssessmentControlInput: Equatable {
    /// <p>
    ///          The identifier for the specified assessment.
    ///       </p>
    public let assessmentId: String?
    /// <p>
    ///
    ///                The identifier for the specified control.
    ///       </p>
    public let controlId: String?
    /// <p>
    ///          The identifier for the specified control set.
    ///       </p>
    public let controlSetId: String?
    /// <p>
    ///          The list of manual evidence objects.
    ///       </p>
    public let manualEvidence: [ManualEvidence]?

    public init (
        assessmentId: String? = nil,
        controlId: String? = nil,
        controlSetId: String? = nil,
        manualEvidence: [ManualEvidence]? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlId = controlId
        self.controlSetId = controlSetId
        self.manualEvidence = manualEvidence
    }
}

struct BatchImportEvidenceToAssessmentControlInputBody: Equatable {
    public let manualEvidence: [ManualEvidence]?
}

extension BatchImportEvidenceToAssessmentControlInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case manualEvidence
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let manualEvidenceContainer = try containerValues.decodeIfPresent([ManualEvidence?].self, forKey: .manualEvidence)
        var manualEvidenceDecoded0:[ManualEvidence]? = nil
        if let manualEvidenceContainer = manualEvidenceContainer {
            manualEvidenceDecoded0 = [ManualEvidence]()
            for structure0 in manualEvidenceContainer {
                if let structure0 = structure0 {
                    manualEvidenceDecoded0?.append(structure0)
                }
            }
        }
        manualEvidence = manualEvidenceDecoded0
    }
}

extension BatchImportEvidenceToAssessmentControlOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchImportEvidenceToAssessmentControlOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchImportEvidenceToAssessmentControlOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchImportEvidenceToAssessmentControlOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchImportEvidenceToAssessmentControlOutputResponse(errors: \(String(describing: errors)))"}
}

extension BatchImportEvidenceToAssessmentControlOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchImportEvidenceToAssessmentControlOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchImportEvidenceToAssessmentControlOutputResponse: Equatable {
    /// <p>
    ///          A list of errors returned by the <code>BatchImportEvidenceToAssessmentControl</code> API.
    ///       </p>
    public let errors: [BatchImportEvidenceToAssessmentControlError]?

    public init (
        errors: [BatchImportEvidenceToAssessmentControlError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchImportEvidenceToAssessmentControlOutputResponseBody: Equatable {
    public let errors: [BatchImportEvidenceToAssessmentControlError]?
}

extension BatchImportEvidenceToAssessmentControlOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case errors
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([BatchImportEvidenceToAssessmentControlError?].self, forKey: .errors)
        var errorsDecoded0:[BatchImportEvidenceToAssessmentControlError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [BatchImportEvidenceToAssessmentControlError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension ChangeLog: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
        case createdAt
        case createdBy
        case objectName
        case objectType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let objectName = objectName {
            try encodeContainer.encode(objectName, forKey: .objectName)
        }
        if let objectType = objectType {
            try encodeContainer.encode(objectType.rawValue, forKey: .objectType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectTypeDecoded = try containerValues.decodeIfPresent(ObjectTypeEnum.self, forKey: .objectType)
        objectType = objectTypeDecoded
        let objectNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .objectName)
        objectName = objectNameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(ActionEnum.self, forKey: .action)
        action = actionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension ChangeLog: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChangeLog(action: \(String(describing: action)), createdAt: \(String(describing: createdAt)), createdBy: \(String(describing: createdBy)), objectName: \(String(describing: objectName)), objectType: \(String(describing: objectType)))"}
}

/// <p>
///    The record of a change within AWS Audit Manager, such as a modified assessment, a delegated control set, and so on.
/// </p>
public struct ChangeLog: Equatable {
    /// <p>
    ///    The action performed.
    /// </p>
    public let action: ActionEnum?
    /// <p>
    ///  The time of creation for the changelog object.
    /// </p>
    public let createdAt: Date?
    /// <p>
    ///  The IAM user or role that performed the action.
    /// </p>
    public let createdBy: String?
    /// <p>
    ///  The name of the changelog object.
    /// </p>
    public let objectName: String?
    /// <p>
    ///  The changelog object type, such as an assessment, control, or control set.
    /// </p>
    public let objectType: ObjectTypeEnum?

    public init (
        action: ActionEnum? = nil,
        createdAt: Date? = nil,
        createdBy: String? = nil,
        objectName: String? = nil,
        objectType: ObjectTypeEnum? = nil
    )
    {
        self.action = action
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.objectName = objectName
        self.objectType = objectType
    }
}

extension Control: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionPlanInstructions
        case actionPlanTitle
        case arn
        case controlMappingSources
        case controlSources
        case createdAt
        case createdBy
        case description
        case id
        case lastUpdatedAt
        case lastUpdatedBy
        case name
        case tags
        case testingInformation
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionPlanInstructions = actionPlanInstructions {
            try encodeContainer.encode(actionPlanInstructions, forKey: .actionPlanInstructions)
        }
        if let actionPlanTitle = actionPlanTitle {
            try encodeContainer.encode(actionPlanTitle, forKey: .actionPlanTitle)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let controlMappingSources = controlMappingSources {
            var controlMappingSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlMappingSources)
            for controlmappingsources0 in controlMappingSources {
                try controlMappingSourcesContainer.encode(controlmappingsources0)
            }
        }
        if let controlSources = controlSources {
            try encodeContainer.encode(controlSources, forKey: .controlSources)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let lastUpdatedBy = lastUpdatedBy {
            try encodeContainer.encode(lastUpdatedBy, forKey: .lastUpdatedBy)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let testingInformation = testingInformation {
            try encodeContainer.encode(testingInformation, forKey: .testingInformation)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ControlType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let testingInformationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .testingInformation)
        testingInformation = testingInformationDecoded
        let actionPlanTitleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionPlanTitle)
        actionPlanTitle = actionPlanTitleDecoded
        let actionPlanInstructionsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionPlanInstructions)
        actionPlanInstructions = actionPlanInstructionsDecoded
        let controlSourcesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .controlSources)
        controlSources = controlSourcesDecoded
        let controlMappingSourcesContainer = try containerValues.decodeIfPresent([ControlMappingSource?].self, forKey: .controlMappingSources)
        var controlMappingSourcesDecoded0:[ControlMappingSource]? = nil
        if let controlMappingSourcesContainer = controlMappingSourcesContainer {
            controlMappingSourcesDecoded0 = [ControlMappingSource]()
            for structure0 in controlMappingSourcesContainer {
                if let structure0 = structure0 {
                    controlMappingSourcesDecoded0?.append(structure0)
                }
            }
        }
        controlMappingSources = controlMappingSourcesDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Control: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Control(actionPlanInstructions: \(String(describing: actionPlanInstructions)), actionPlanTitle: \(String(describing: actionPlanTitle)), arn: \(String(describing: arn)), controlMappingSources: \(String(describing: controlMappingSources)), controlSources: \(String(describing: controlSources)), createdAt: \(String(describing: createdAt)), createdBy: \(String(describing: createdBy)), description: \(String(describing: description)), id: \(String(describing: id)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), lastUpdatedBy: \(String(describing: lastUpdatedBy)), name: \(String(describing: name)), tags: \(String(describing: tags)), testingInformation: \(String(describing: testingInformation)), type: \(String(describing: type)))"}
}

/// <p>
/// A control in AWS Audit Manager.
/// </p>
public struct Control: Equatable {
    /// <p>
    ///
    ///          The recommended actions to carry out if the control is not fulfilled.
    ///       </p>
    public let actionPlanInstructions: String?
    /// <p>
    ///          The title of the action plan for remediating the control.
    ///       </p>
    public let actionPlanTitle: String?
    /// <p>
    ///    The Amazon Resource Name (ARN) of the specified control.
    /// </p>
    public let arn: String?
    /// <p>
    ///    The data mapping sources for the specified control.
    /// </p>
    public let controlMappingSources: [ControlMappingSource]?
    /// <p>
    ///    The data source that determines from where AWS Audit Manager collects evidence for the control.
    /// </p>
    public let controlSources: String?
    /// <p>
    /// Specifies when the control was created.
    /// </p>
    public let createdAt: Date?
    /// <p>
    ///          The IAM user or role that created the control.
    ///       </p>
    public let createdBy: String?
    /// <p>
    ///    The description of the specified control.
    /// </p>
    public let description: String?
    /// <p>
    /// The unique identifier for the control.
    /// </p>
    public let id: String?
    /// <p>
    /// Specifies when the control was most recently updated.
    /// </p>
    public let lastUpdatedAt: Date?
    /// <p>
    ///          The IAM user or role that most recently updated the control.
    ///       </p>
    public let lastUpdatedBy: String?
    /// <p>
    /// The name of the specified control.
    /// </p>
    public let name: String?
    /// <p>
    ///    The tags associated with the control.
    /// </p>
    public let tags: [String:String]?
    /// <p>
    ///          The steps to follow to determine if the control has been satisfied.
    ///       </p>
    public let testingInformation: String?
    /// <p>
    /// The type of control, such as custom or standard.
    /// </p>
    public let type: ControlType?

    public init (
        actionPlanInstructions: String? = nil,
        actionPlanTitle: String? = nil,
        arn: String? = nil,
        controlMappingSources: [ControlMappingSource]? = nil,
        controlSources: String? = nil,
        createdAt: Date? = nil,
        createdBy: String? = nil,
        description: String? = nil,
        id: String? = nil,
        lastUpdatedAt: Date? = nil,
        lastUpdatedBy: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil,
        testingInformation: String? = nil,
        type: ControlType? = nil
    )
    {
        self.actionPlanInstructions = actionPlanInstructions
        self.actionPlanTitle = actionPlanTitle
        self.arn = arn
        self.controlMappingSources = controlMappingSources
        self.controlSources = controlSources
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.lastUpdatedBy = lastUpdatedBy
        self.name = name
        self.tags = tags
        self.testingInformation = testingInformation
        self.type = type
    }
}

extension ControlComment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case authorName
        case commentBody
        case postedDate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorName = authorName {
            try encodeContainer.encode(authorName, forKey: .authorName)
        }
        if let commentBody = commentBody {
            try encodeContainer.encode(commentBody, forKey: .commentBody)
        }
        if let postedDate = postedDate {
            try encodeContainer.encode(postedDate.timeIntervalSince1970, forKey: .postedDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .authorName)
        authorName = authorNameDecoded
        let commentBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commentBody)
        commentBody = commentBodyDecoded
        let postedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .postedDate)
        postedDate = postedDateDecoded
    }
}

extension ControlComment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ControlComment(authorName: \(String(describing: authorName)), commentBody: \(String(describing: commentBody)), postedDate: \(String(describing: postedDate)))"}
}

/// <p>
///    A comment posted by a user on a control. This includes the author's name, the comment text, and a timestamp.
/// </p>
public struct ControlComment: Equatable {
    /// <p>
    ///  The name of the user who authored the comment.
    /// </p>
    public let authorName: String?
    /// <p>
    ///    The body text of a control comment.
    /// </p>
    public let commentBody: String?
    /// <p>
    ///  The time when the comment was posted.
    /// </p>
    public let postedDate: Date?

    public init (
        authorName: String? = nil,
        commentBody: String? = nil,
        postedDate: Date? = nil
    )
    {
        self.authorName = authorName
        self.commentBody = commentBody
        self.postedDate = postedDate
    }
}

extension ControlMappingSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceDescription
        case sourceFrequency
        case sourceId
        case sourceKeyword
        case sourceName
        case sourceSetUpOption
        case sourceType
        case troubleshootingText
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceDescription = sourceDescription {
            try encodeContainer.encode(sourceDescription, forKey: .sourceDescription)
        }
        if let sourceFrequency = sourceFrequency {
            try encodeContainer.encode(sourceFrequency.rawValue, forKey: .sourceFrequency)
        }
        if let sourceId = sourceId {
            try encodeContainer.encode(sourceId, forKey: .sourceId)
        }
        if let sourceKeyword = sourceKeyword {
            try encodeContainer.encode(sourceKeyword, forKey: .sourceKeyword)
        }
        if let sourceName = sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let sourceSetUpOption = sourceSetUpOption {
            try encodeContainer.encode(sourceSetUpOption.rawValue, forKey: .sourceSetUpOption)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let troubleshootingText = troubleshootingText {
            try encodeContainer.encode(troubleshootingText, forKey: .troubleshootingText)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceId)
        sourceId = sourceIdDecoded
        let sourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceDescription)
        sourceDescription = sourceDescriptionDecoded
        let sourceSetUpOptionDecoded = try containerValues.decodeIfPresent(SourceSetUpOption.self, forKey: .sourceSetUpOption)
        sourceSetUpOption = sourceSetUpOptionDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceKeywordDecoded = try containerValues.decodeIfPresent(SourceKeyword.self, forKey: .sourceKeyword)
        sourceKeyword = sourceKeywordDecoded
        let sourceFrequencyDecoded = try containerValues.decodeIfPresent(SourceFrequency.self, forKey: .sourceFrequency)
        sourceFrequency = sourceFrequencyDecoded
        let troubleshootingTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .troubleshootingText)
        troubleshootingText = troubleshootingTextDecoded
    }
}

extension ControlMappingSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ControlMappingSource(sourceDescription: \(String(describing: sourceDescription)), sourceFrequency: \(String(describing: sourceFrequency)), sourceId: \(String(describing: sourceId)), sourceKeyword: \(String(describing: sourceKeyword)), sourceName: \(String(describing: sourceName)), sourceSetUpOption: \(String(describing: sourceSetUpOption)), sourceType: \(String(describing: sourceType)), troubleshootingText: \(String(describing: troubleshootingText)))"}
}

/// <p>
///    The data source that determines from where AWS Audit Manager collects evidence for the control.
/// </p>
public struct ControlMappingSource: Equatable {
    /// <p>
    /// The description of the specified source.
    /// </p>
    public let sourceDescription: String?
    /// <p>
    ///          The frequency of evidence collection for the specified control mapping source.
    ///       </p>
    public let sourceFrequency: SourceFrequency?
    /// <p>
    /// The unique identifier for the specified source.
    /// </p>
    public let sourceId: String?
    /// <p>
    /// The keyword to search for in AWS CloudTrail logs, AWS Config rules, AWS Security Hub checks, and AWS API names.
    /// </p>
    public let sourceKeyword: SourceKeyword?
    /// <p>
    /// The name of the specified source.
    /// </p>
    public let sourceName: String?
    /// <p>
    ///    The setup option for the data source, which reflects if the evidence collection is automated or manual.
    /// </p>
    public let sourceSetUpOption: SourceSetUpOption?
    /// <p>
    ///    Specifies one of the five types of data sources for evidence collection.
    /// </p>
    public let sourceType: SourceType?
    /// <p>
    ///          The instructions for troubleshooting the specified control.
    ///       </p>
    public let troubleshootingText: String?

    public init (
        sourceDescription: String? = nil,
        sourceFrequency: SourceFrequency? = nil,
        sourceId: String? = nil,
        sourceKeyword: SourceKeyword? = nil,
        sourceName: String? = nil,
        sourceSetUpOption: SourceSetUpOption? = nil,
        sourceType: SourceType? = nil,
        troubleshootingText: String? = nil
    )
    {
        self.sourceDescription = sourceDescription
        self.sourceFrequency = sourceFrequency
        self.sourceId = sourceId
        self.sourceKeyword = sourceKeyword
        self.sourceName = sourceName
        self.sourceSetUpOption = sourceSetUpOption
        self.sourceType = sourceType
        self.troubleshootingText = troubleshootingText
    }
}

extension ControlMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case controlSources
        case createdAt
        case id
        case lastUpdatedAt
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let controlSources = controlSources {
            try encodeContainer.encode(controlSources, forKey: .controlSources)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let controlSourcesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .controlSources)
        controlSources = controlSourcesDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension ControlMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ControlMetadata(arn: \(String(describing: arn)), controlSources: \(String(describing: controlSources)), createdAt: \(String(describing: createdAt)), id: \(String(describing: id)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), name: \(String(describing: name)))"}
}

/// <p>
///    The metadata associated with the specified standard or custom control.
/// </p>
public struct ControlMetadata: Equatable {
    /// <p>
    ///    The Amazon Resource Name (ARN) of the specified control.
    /// </p>
    public let arn: String?
    /// <p>
    ///    The data source that determines from where AWS Audit Manager collects evidence for the control.
    /// </p>
    public let controlSources: String?
    /// <p>
    ///    Specifies when the control was created.
    /// </p>
    public let createdAt: Date?
    /// <p>
    /// The unique identifier for the specified control.
    /// </p>
    public let id: String?
    /// <p>
    ///    Specifies when the control was most recently updated.
    /// </p>
    public let lastUpdatedAt: Date?
    /// <p>
    /// The name of the specified control.
    /// </p>
    public let name: String?

    public init (
        arn: String? = nil,
        controlSources: String? = nil,
        createdAt: Date? = nil,
        id: String? = nil,
        lastUpdatedAt: Date? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.controlSources = controlSources
        self.createdAt = createdAt
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.name = name
    }
}

public enum ControlResponse {
    case automate
    case `defer`
    case ignore
    case manual
    case sdkUnknown(String)
}

extension ControlResponse : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ControlResponse] {
        return [
            .automate,
            .defer,
            .ignore,
            .manual,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .automate: return "AUTOMATE"
        case .defer: return "DEFER"
        case .ignore: return "IGNORE"
        case .manual: return "MANUAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ControlResponse(rawValue: rawValue) ?? ControlResponse.sdkUnknown(rawValue)
    }
}

extension ControlSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case controls
        case id
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controls = controls {
            var controlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controls)
            for controls0 in controls {
                try controlsContainer.encode(controls0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let controlsContainer = try containerValues.decodeIfPresent([Control?].self, forKey: .controls)
        var controlsDecoded0:[Control]? = nil
        if let controlsContainer = controlsContainer {
            controlsDecoded0 = [Control]()
            for structure0 in controlsContainer {
                if let structure0 = structure0 {
                    controlsDecoded0?.append(structure0)
                }
            }
        }
        controls = controlsDecoded0
    }
}

extension ControlSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ControlSet(controls: \(String(describing: controls)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>
/// A set of controls in AWS Audit Manager.
/// </p>
public struct ControlSet: Equatable {
    /// <p>
    ///    The list of controls within the control set.
    /// </p>
    public let controls: [Control]?
    /// <p>
    ///    The identifier of the control set in the assessment. This is the control set name in a plain string format.
    /// </p>
    public let id: String?
    /// <p>
    /// The name of the control set.
    /// </p>
    public let name: String?

    public init (
        controls: [Control]? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.controls = controls
        self.id = id
        self.name = name
    }
}

public enum ControlSetStatus {
    case active
    case reviewed
    case underReview
    case sdkUnknown(String)
}

extension ControlSetStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ControlSetStatus] {
        return [
            .active,
            .reviewed,
            .underReview,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .reviewed: return "REVIEWED"
        case .underReview: return "UNDER_REVIEW"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ControlSetStatus(rawValue: rawValue) ?? ControlSetStatus.sdkUnknown(rawValue)
    }
}

public enum ControlStatus {
    case inactive
    case reviewed
    case underReview
    case sdkUnknown(String)
}

extension ControlStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ControlStatus] {
        return [
            .inactive,
            .reviewed,
            .underReview,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .inactive: return "INACTIVE"
        case .reviewed: return "REVIEWED"
        case .underReview: return "UNDER_REVIEW"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ControlStatus(rawValue: rawValue) ?? ControlStatus.sdkUnknown(rawValue)
    }
}

public enum ControlType {
    case custom
    case standard
    case sdkUnknown(String)
}

extension ControlType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ControlType] {
        return [
            .custom,
            .standard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .custom: return "Custom"
        case .standard: return "Standard"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ControlType(rawValue: rawValue) ?? ControlType.sdkUnknown(rawValue)
    }
}

extension CreateAssessmentFrameworkControl: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension CreateAssessmentFrameworkControl: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssessmentFrameworkControl(id: \(String(describing: id)))"}
}

/// <p>
/// Control entity attributes that uniquely identify an existing control to be added to a framework in AWS Audit Manager.
/// </p>
public struct CreateAssessmentFrameworkControl: Equatable {
    /// <p>
    /// The unique identifier of the control.
    /// </p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

extension CreateAssessmentFrameworkControlSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case controls
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controls = controls {
            var controlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controls)
            for createassessmentframeworkcontrols0 in controls {
                try controlsContainer.encode(createassessmentframeworkcontrols0)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let controlsContainer = try containerValues.decodeIfPresent([CreateAssessmentFrameworkControl?].self, forKey: .controls)
        var controlsDecoded0:[CreateAssessmentFrameworkControl]? = nil
        if let controlsContainer = controlsContainer {
            controlsDecoded0 = [CreateAssessmentFrameworkControl]()
            for structure0 in controlsContainer {
                if let structure0 = structure0 {
                    controlsDecoded0?.append(structure0)
                }
            }
        }
        controls = controlsDecoded0
    }
}

extension CreateAssessmentFrameworkControlSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssessmentFrameworkControlSet(controls: \(String(describing: controls)), name: \(String(describing: name)))"}
}

/// <p>
/// A <code>controlSet</code> entity that represents a collection of controls in AWS Audit Manager. This does not contain the control set ID.
/// </p>
public struct CreateAssessmentFrameworkControlSet: Equatable {
    /// <p>
    ///    The list of controls within the control set. This does not contain the control set ID.
    /// </p>
    public let controls: [CreateAssessmentFrameworkControl]?
    /// <p>
    /// The name of the specified control set.
    /// </p>
    public let name: String?

    public init (
        controls: [CreateAssessmentFrameworkControl]? = nil,
        name: String? = nil
    )
    {
        self.controls = controls
        self.name = name
    }
}

public struct CreateAssessmentFrameworkInputBodyMiddleware: Middleware {
    public let id: String = "CreateAssessmentFrameworkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssessmentFrameworkInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssessmentFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssessmentFrameworkInput>
    public typealias MOutput = OperationOutput<CreateAssessmentFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssessmentFrameworkOutputError>
}

extension CreateAssessmentFrameworkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssessmentFrameworkInput(complianceType: \(String(describing: complianceType)), controlSets: \(String(describing: controlSets)), description: \(String(describing: description)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateAssessmentFrameworkInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceType
        case controlSets
        case description
        case name
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let controlSets = controlSets {
            var controlSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlSets)
            for createassessmentframeworkcontrolsets0 in controlSets {
                try controlSetsContainer.encode(createassessmentframeworkcontrolsets0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateAssessmentFrameworkInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAssessmentFrameworkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssessmentFrameworkInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssessmentFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssessmentFrameworkInput>
    public typealias MOutput = OperationOutput<CreateAssessmentFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssessmentFrameworkOutputError>
}

public struct CreateAssessmentFrameworkInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAssessmentFrameworkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssessmentFrameworkInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssessmentFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssessmentFrameworkInput>
    public typealias MOutput = OperationOutput<CreateAssessmentFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssessmentFrameworkOutputError>
}

public struct CreateAssessmentFrameworkInput: Equatable {
    /// <p>
    /// The compliance type that the new custom framework supports, such as CIS or HIPAA.
    /// </p>
    public let complianceType: String?
    /// <p>
    ///    The control sets to be associated with the framework.
    /// </p>
    public let controlSets: [CreateAssessmentFrameworkControlSet]?
    /// <p>
    /// An optional description for the new custom framework.
    /// </p>
    public let description: String?
    /// <p>
    /// The name of the new custom framework.
    /// </p>
    public let name: String?
    /// <p>
    ///    The tags associated with the framework.
    /// </p>
    public let tags: [String:String]?

    public init (
        complianceType: String? = nil,
        controlSets: [CreateAssessmentFrameworkControlSet]? = nil,
        description: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.complianceType = complianceType
        self.controlSets = controlSets
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateAssessmentFrameworkInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let complianceType: String?
    public let controlSets: [CreateAssessmentFrameworkControlSet]?
    public let tags: [String:String]?
}

extension CreateAssessmentFrameworkInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case complianceType
        case controlSets
        case description
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let controlSetsContainer = try containerValues.decodeIfPresent([CreateAssessmentFrameworkControlSet?].self, forKey: .controlSets)
        var controlSetsDecoded0:[CreateAssessmentFrameworkControlSet]? = nil
        if let controlSetsContainer = controlSetsContainer {
            controlSetsDecoded0 = [CreateAssessmentFrameworkControlSet]()
            for structure0 in controlSetsContainer {
                if let structure0 = structure0 {
                    controlSetsDecoded0?.append(structure0)
                }
            }
        }
        controlSets = controlSetsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAssessmentFrameworkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssessmentFrameworkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAssessmentFrameworkOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssessmentFrameworkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssessmentFrameworkOutputResponse(framework: \(String(describing: framework)))"}
}

extension CreateAssessmentFrameworkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAssessmentFrameworkOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.framework = output.framework
        } else {
            self.framework = nil
        }
    }
}

public struct CreateAssessmentFrameworkOutputResponse: Equatable {
    /// <p>
    ///    The name of the new framework returned by the <code>CreateAssessmentFramework</code> API.
    /// </p>
    public let framework: Framework?

    public init (
        framework: Framework? = nil
    )
    {
        self.framework = framework
    }
}

struct CreateAssessmentFrameworkOutputResponseBody: Equatable {
    public let framework: Framework?
}

extension CreateAssessmentFrameworkOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case framework
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkDecoded = try containerValues.decodeIfPresent(Framework.self, forKey: .framework)
        framework = frameworkDecoded
    }
}

public struct CreateAssessmentInputBodyMiddleware: Middleware {
    public let id: String = "CreateAssessmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssessmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssessmentInput>
    public typealias MOutput = OperationOutput<CreateAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssessmentOutputError>
}

extension CreateAssessmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssessmentInput(assessmentReportsDestination: \(String(describing: assessmentReportsDestination)), description: \(String(describing: description)), frameworkId: \(String(describing: frameworkId)), name: \(String(describing: name)), roles: \(String(describing: roles)), scope: \(String(describing: scope)), tags: \(String(describing: tags)))"}
}

extension CreateAssessmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentReportsDestination
        case description
        case frameworkId
        case name
        case roles
        case scope
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentReportsDestination = assessmentReportsDestination {
            try encodeContainer.encode(assessmentReportsDestination, forKey: .assessmentReportsDestination)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let frameworkId = frameworkId {
            try encodeContainer.encode(frameworkId, forKey: .frameworkId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for roles0 in roles {
                try rolesContainer.encode(roles0)
            }
        }
        if let scope = scope {
            try encodeContainer.encode(scope, forKey: .scope)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateAssessmentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAssessmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssessmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssessmentInput>
    public typealias MOutput = OperationOutput<CreateAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssessmentOutputError>
}

public struct CreateAssessmentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAssessmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssessmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssessmentInput>
    public typealias MOutput = OperationOutput<CreateAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssessmentOutputError>
}

public struct CreateAssessmentInput: Equatable {
    /// <p>
    ///          The assessment report storage destination for the specified assessment that is being created.
    ///       </p>
    public let assessmentReportsDestination: AssessmentReportsDestination?
    /// <p>
    ///          The optional description of the assessment to be created.
    ///       </p>
    public let description: String?
    /// <p>
    ///          The identifier for the specified framework.
    ///       </p>
    public let frameworkId: String?
    /// <p>
    ///          The name of the assessment to be created.
    ///       </p>
    public let name: String?
    /// <p>
    ///          The list of roles for the specified assessment.
    ///       </p>
    public let roles: [Role]?
    /// <p>
    ///    The wrapper that contains the AWS accounts and AWS services in scope for the assessment.
    /// </p>
    public let scope: Scope?
    /// <p>
    ///    The tags associated with the assessment.
    /// </p>
    public let tags: [String:String]?

    public init (
        assessmentReportsDestination: AssessmentReportsDestination? = nil,
        description: String? = nil,
        frameworkId: String? = nil,
        name: String? = nil,
        roles: [Role]? = nil,
        scope: Scope? = nil,
        tags: [String:String]? = nil
    )
    {
        self.assessmentReportsDestination = assessmentReportsDestination
        self.description = description
        self.frameworkId = frameworkId
        self.name = name
        self.roles = roles
        self.scope = scope
        self.tags = tags
    }
}

struct CreateAssessmentInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let assessmentReportsDestination: AssessmentReportsDestination?
    public let scope: Scope?
    public let roles: [Role]?
    public let frameworkId: String?
    public let tags: [String:String]?
}

extension CreateAssessmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentReportsDestination
        case description
        case frameworkId
        case name
        case roles
        case scope
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let assessmentReportsDestinationDecoded = try containerValues.decodeIfPresent(AssessmentReportsDestination.self, forKey: .assessmentReportsDestination)
        assessmentReportsDestination = assessmentReportsDestinationDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let rolesContainer = try containerValues.decodeIfPresent([Role?].self, forKey: .roles)
        var rolesDecoded0:[Role]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [Role]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
        let frameworkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .frameworkId)
        frameworkId = frameworkIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAssessmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssessmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAssessmentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssessmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssessmentOutputResponse(assessment: \(String(describing: assessment)))"}
}

extension CreateAssessmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assessment = output.assessment
        } else {
            self.assessment = nil
        }
    }
}

public struct CreateAssessmentOutputResponse: Equatable {
    /// <p>
    ///    An entity that defines the scope of audit evidence collected by AWS Audit Manager. An AWS Audit Manager assessment is an implementation of an AWS Audit Manager framework.
    /// </p>
    public let assessment: Assessment?

    public init (
        assessment: Assessment? = nil
    )
    {
        self.assessment = assessment
    }
}

struct CreateAssessmentOutputResponseBody: Equatable {
    public let assessment: Assessment?
}

extension CreateAssessmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessment
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentDecoded = try containerValues.decodeIfPresent(Assessment.self, forKey: .assessment)
        assessment = assessmentDecoded
    }
}

public struct CreateAssessmentReportInputBodyMiddleware: Middleware {
    public let id: String = "CreateAssessmentReportInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssessmentReportInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssessmentReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssessmentReportInput>
    public typealias MOutput = OperationOutput<CreateAssessmentReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssessmentReportOutputError>
}

extension CreateAssessmentReportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssessmentReportInput(assessmentId: \(String(describing: assessmentId)), description: \(String(describing: description)), name: \(String(describing: name)))"}
}

extension CreateAssessmentReportInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct CreateAssessmentReportInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAssessmentReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssessmentReportInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssessmentReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssessmentReportInput>
    public typealias MOutput = OperationOutput<CreateAssessmentReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssessmentReportOutputError>
}

public struct CreateAssessmentReportInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAssessmentReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssessmentReportInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssessmentReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssessmentReportInput>
    public typealias MOutput = OperationOutput<CreateAssessmentReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssessmentReportOutputError>
}

public struct CreateAssessmentReportInput: Equatable {
    /// <p>
    ///    The identifier for the specified assessment.
    /// </p>
    public let assessmentId: String?
    /// <p>
    /// The description of the assessment report.
    /// </p>
    public let description: String?
    /// <p>
    /// The name of the new assessment report.
    /// </p>
    public let name: String?

    public init (
        assessmentId: String? = nil,
        description: String? = nil,
        name: String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.description = description
        self.name = name
    }
}

struct CreateAssessmentReportInputBody: Equatable {
    public let name: String?
    public let description: String?
}

extension CreateAssessmentReportInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateAssessmentReportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssessmentReportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAssessmentReportOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssessmentReportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssessmentReportOutputResponse(assessmentReport: \(String(describing: assessmentReport)))"}
}

extension CreateAssessmentReportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAssessmentReportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assessmentReport = output.assessmentReport
        } else {
            self.assessmentReport = nil
        }
    }
}

public struct CreateAssessmentReportOutputResponse: Equatable {
    /// <p>
    ///    The new assessment report returned by the <code>CreateAssessmentReport</code> API.
    /// </p>
    public let assessmentReport: AssessmentReport?

    public init (
        assessmentReport: AssessmentReport? = nil
    )
    {
        self.assessmentReport = assessmentReport
    }
}

struct CreateAssessmentReportOutputResponseBody: Equatable {
    public let assessmentReport: AssessmentReport?
}

extension CreateAssessmentReportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentReport
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentReportDecoded = try containerValues.decodeIfPresent(AssessmentReport.self, forKey: .assessmentReport)
        assessmentReport = assessmentReportDecoded
    }
}

public struct CreateControlInputBodyMiddleware: Middleware {
    public let id: String = "CreateControlInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateControlInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateControlInput>
    public typealias MOutput = OperationOutput<CreateControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateControlOutputError>
}

extension CreateControlInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateControlInput(actionPlanInstructions: \(String(describing: actionPlanInstructions)), actionPlanTitle: \(String(describing: actionPlanTitle)), controlMappingSources: \(String(describing: controlMappingSources)), description: \(String(describing: description)), name: \(String(describing: name)), tags: \(String(describing: tags)), testingInformation: \(String(describing: testingInformation)))"}
}

extension CreateControlInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionPlanInstructions
        case actionPlanTitle
        case controlMappingSources
        case description
        case name
        case tags
        case testingInformation
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionPlanInstructions = actionPlanInstructions {
            try encodeContainer.encode(actionPlanInstructions, forKey: .actionPlanInstructions)
        }
        if let actionPlanTitle = actionPlanTitle {
            try encodeContainer.encode(actionPlanTitle, forKey: .actionPlanTitle)
        }
        if let controlMappingSources = controlMappingSources {
            var controlMappingSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlMappingSources)
            for createcontrolmappingsources0 in controlMappingSources {
                try controlMappingSourcesContainer.encode(createcontrolmappingsources0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let testingInformation = testingInformation {
            try encodeContainer.encode(testingInformation, forKey: .testingInformation)
        }
    }
}

public struct CreateControlInputHeadersMiddleware: Middleware {
    public let id: String = "CreateControlInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateControlInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateControlInput>
    public typealias MOutput = OperationOutput<CreateControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateControlOutputError>
}

public struct CreateControlInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateControlInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateControlInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateControlInput>
    public typealias MOutput = OperationOutput<CreateControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateControlOutputError>
}

public struct CreateControlInput: Equatable {
    /// <p>
    ///          The recommended actions to carry out if the control is not fulfilled.
    ///       </p>
    public let actionPlanInstructions: String?
    /// <p>
    ///          The title of the action plan for remediating the control.
    ///       </p>
    public let actionPlanTitle: String?
    /// <p>
    ///    The data mapping sources for the specified control.
    /// </p>
    public let controlMappingSources: [CreateControlMappingSource]?
    /// <p>
    /// The description of the control.
    /// </p>
    public let description: String?
    /// <p>
    /// The name of the control.
    /// </p>
    public let name: String?
    /// <p>
    ///    The tags associated with the control.
    /// </p>
    public let tags: [String:String]?
    /// <p>
    ///          The steps to follow to determine if the control has been satisfied.
    ///       </p>
    public let testingInformation: String?

    public init (
        actionPlanInstructions: String? = nil,
        actionPlanTitle: String? = nil,
        controlMappingSources: [CreateControlMappingSource]? = nil,
        description: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil,
        testingInformation: String? = nil
    )
    {
        self.actionPlanInstructions = actionPlanInstructions
        self.actionPlanTitle = actionPlanTitle
        self.controlMappingSources = controlMappingSources
        self.description = description
        self.name = name
        self.tags = tags
        self.testingInformation = testingInformation
    }
}

struct CreateControlInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let testingInformation: String?
    public let actionPlanTitle: String?
    public let actionPlanInstructions: String?
    public let controlMappingSources: [CreateControlMappingSource]?
    public let tags: [String:String]?
}

extension CreateControlInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionPlanInstructions
        case actionPlanTitle
        case controlMappingSources
        case description
        case name
        case tags
        case testingInformation
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let testingInformationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .testingInformation)
        testingInformation = testingInformationDecoded
        let actionPlanTitleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionPlanTitle)
        actionPlanTitle = actionPlanTitleDecoded
        let actionPlanInstructionsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionPlanInstructions)
        actionPlanInstructions = actionPlanInstructionsDecoded
        let controlMappingSourcesContainer = try containerValues.decodeIfPresent([CreateControlMappingSource?].self, forKey: .controlMappingSources)
        var controlMappingSourcesDecoded0:[CreateControlMappingSource]? = nil
        if let controlMappingSourcesContainer = controlMappingSourcesContainer {
            controlMappingSourcesDecoded0 = [CreateControlMappingSource]()
            for structure0 in controlMappingSourcesContainer {
                if let structure0 = structure0 {
                    controlMappingSourcesDecoded0?.append(structure0)
                }
            }
        }
        controlMappingSources = controlMappingSourcesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateControlMappingSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sourceDescription
        case sourceFrequency
        case sourceKeyword
        case sourceName
        case sourceSetUpOption
        case sourceType
        case troubleshootingText
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceDescription = sourceDescription {
            try encodeContainer.encode(sourceDescription, forKey: .sourceDescription)
        }
        if let sourceFrequency = sourceFrequency {
            try encodeContainer.encode(sourceFrequency.rawValue, forKey: .sourceFrequency)
        }
        if let sourceKeyword = sourceKeyword {
            try encodeContainer.encode(sourceKeyword, forKey: .sourceKeyword)
        }
        if let sourceName = sourceName {
            try encodeContainer.encode(sourceName, forKey: .sourceName)
        }
        if let sourceSetUpOption = sourceSetUpOption {
            try encodeContainer.encode(sourceSetUpOption.rawValue, forKey: .sourceSetUpOption)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let troubleshootingText = troubleshootingText {
            try encodeContainer.encode(troubleshootingText, forKey: .troubleshootingText)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceName)
        sourceName = sourceNameDecoded
        let sourceDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceDescription)
        sourceDescription = sourceDescriptionDecoded
        let sourceSetUpOptionDecoded = try containerValues.decodeIfPresent(SourceSetUpOption.self, forKey: .sourceSetUpOption)
        sourceSetUpOption = sourceSetUpOptionDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceKeywordDecoded = try containerValues.decodeIfPresent(SourceKeyword.self, forKey: .sourceKeyword)
        sourceKeyword = sourceKeywordDecoded
        let sourceFrequencyDecoded = try containerValues.decodeIfPresent(SourceFrequency.self, forKey: .sourceFrequency)
        sourceFrequency = sourceFrequencyDecoded
        let troubleshootingTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .troubleshootingText)
        troubleshootingText = troubleshootingTextDecoded
    }
}

extension CreateControlMappingSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateControlMappingSource(sourceDescription: \(String(describing: sourceDescription)), sourceFrequency: \(String(describing: sourceFrequency)), sourceKeyword: \(String(describing: sourceKeyword)), sourceName: \(String(describing: sourceName)), sourceSetUpOption: \(String(describing: sourceSetUpOption)), sourceType: \(String(describing: sourceType)), troubleshootingText: \(String(describing: troubleshootingText)))"}
}

/// <p>
///   Control mapping fields that represent the source for evidence collection, along with related parameters and metadata. This does not contain <code>mappingID</code>.
/// </p>
public struct CreateControlMappingSource: Equatable {
    /// <p>
    ///    The description of the data source that determines from where AWS Audit Manager collects evidence for the control.
    /// </p>
    public let sourceDescription: String?
    /// <p>
    ///    The frequency of evidence collection for the specified control mapping source.
    /// </p>
    public let sourceFrequency: SourceFrequency?
    /// <p>
    /// The keyword to search for in AWS CloudTrail logs, AWS Config rules, AWS Security Hub checks, and AWS API names.
    /// </p>
    public let sourceKeyword: SourceKeyword?
    /// <p>
    /// The name of the control mapping data source.
    /// </p>
    public let sourceName: String?
    /// <p>
    ///    The setup option for the data source, which reflects if the evidence collection is automated or manual.
    /// </p>
    public let sourceSetUpOption: SourceSetUpOption?
    /// <p>
    ///    Specifies one of the five types of data sources for evidence collection.
    ///
    /// </p>
    public let sourceType: SourceType?
    /// <p>
    /// The instructions for troubleshooting the specified control.
    /// </p>
    public let troubleshootingText: String?

    public init (
        sourceDescription: String? = nil,
        sourceFrequency: SourceFrequency? = nil,
        sourceKeyword: SourceKeyword? = nil,
        sourceName: String? = nil,
        sourceSetUpOption: SourceSetUpOption? = nil,
        sourceType: SourceType? = nil,
        troubleshootingText: String? = nil
    )
    {
        self.sourceDescription = sourceDescription
        self.sourceFrequency = sourceFrequency
        self.sourceKeyword = sourceKeyword
        self.sourceName = sourceName
        self.sourceSetUpOption = sourceSetUpOption
        self.sourceType = sourceType
        self.troubleshootingText = troubleshootingText
    }
}

extension CreateControlOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateControlOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateControlOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateControlOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateControlOutputResponse(control: \(String(describing: control)))"}
}

extension CreateControlOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateControlOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.control = output.control
        } else {
            self.control = nil
        }
    }
}

public struct CreateControlOutputResponse: Equatable {
    /// <p>
    ///    The new control returned by the <code>CreateControl</code> API.
    /// </p>
    public let control: Control?

    public init (
        control: Control? = nil
    )
    {
        self.control = control
    }
}

struct CreateControlOutputResponseBody: Equatable {
    public let control: Control?
}

extension CreateControlOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case control
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlDecoded = try containerValues.decodeIfPresent(Control.self, forKey: .control)
        control = controlDecoded
    }
}

extension CreateDelegationRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comment
        case controlSetId
        case roleArn
        case roleType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let controlSetId = controlSetId {
            try encodeContainer.encode(controlSetId, forKey: .controlSetId)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let roleType = roleType {
            try encodeContainer.encode(roleType.rawValue, forKey: .roleType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let controlSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .controlSetId)
        controlSetId = controlSetIdDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let roleTypeDecoded = try containerValues.decodeIfPresent(RoleType.self, forKey: .roleType)
        roleType = roleTypeDecoded
    }
}

extension CreateDelegationRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDelegationRequest(comment: \(String(describing: comment)), controlSetId: \(String(describing: controlSetId)), roleArn: \(String(describing: roleArn)), roleType: \(String(describing: roleType)))"}
}

/// <p>
///   A collection of attributes used to create a delegation for an assessment in AWS Audit Manager.
/// </p>
public struct CreateDelegationRequest: Equatable {
    /// <p>
    ///    A comment related to the delegation request.
    /// </p>
    public let comment: String?
    /// <p>
    ///    The unique identifier for the control set.
    /// </p>
    public let controlSetId: String?
    /// <p>
    ///    The Amazon Resource Name (ARN) of the IAM role.
    /// </p>
    public let roleArn: String?
    /// <p>
    ///    The type of customer persona.
    /// </p>
    ///          <note>
    ///             <p>In <code>CreateAssessment</code>, <code>roleType</code> can only be <code>PROCESS_OWNER</code>. </p>
    ///             <p>In <code>UpdateSettings</code>, <code>roleType</code> can only be <code>PROCESS_OWNER</code>.</p>
    ///             <p>In <code>BatchCreateDelegationByAssessment</code>, <code>roleType</code> can only be <code>RESOURCE_OWNER</code>.</p>
    ///          </note>
    public let roleType: RoleType?

    public init (
        comment: String? = nil,
        controlSetId: String? = nil,
        roleArn: String? = nil,
        roleType: RoleType? = nil
    )
    {
        self.comment = comment
        self.controlSetId = controlSetId
        self.roleArn = roleArn
        self.roleType = roleType
    }
}

extension Delegation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentId
        case assessmentName
        case comment
        case controlSetId
        case createdBy
        case creationTime
        case id
        case lastUpdated
        case roleArn
        case roleType
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentId = assessmentId {
            try encodeContainer.encode(assessmentId, forKey: .assessmentId)
        }
        if let assessmentName = assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let controlSetId = controlSetId {
            try encodeContainer.encode(controlSetId, forKey: .controlSetId)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdated = lastUpdated {
            try encodeContainer.encode(lastUpdated.timeIntervalSince1970, forKey: .lastUpdated)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let roleType = roleType {
            try encodeContainer.encode(roleType.rawValue, forKey: .roleType)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let assessmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DelegationStatus.self, forKey: .status)
        status = statusDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let roleTypeDecoded = try containerValues.decodeIfPresent(RoleType.self, forKey: .roleType)
        roleType = roleTypeDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdated)
        lastUpdated = lastUpdatedDecoded
        let controlSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .controlSetId)
        controlSetId = controlSetIdDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
    }
}

extension Delegation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Delegation(assessmentId: \(String(describing: assessmentId)), assessmentName: \(String(describing: assessmentName)), comment: \(String(describing: comment)), controlSetId: \(String(describing: controlSetId)), createdBy: \(String(describing: createdBy)), creationTime: \(String(describing: creationTime)), id: \(String(describing: id)), lastUpdated: \(String(describing: lastUpdated)), roleArn: \(String(describing: roleArn)), roleType: \(String(describing: roleType)), status: \(String(describing: status)))"}
}

/// <p>
///    The assignment of a control set to a delegate for review.
/// </p>
public struct Delegation: Equatable {
    /// <p>
    ///    The identifier for the associated assessment.
    /// </p>
    public let assessmentId: String?
    /// <p>
    ///  The name of the associated assessment.
    /// </p>
    public let assessmentName: String?
    /// <p>
    ///  The comment related to the delegation.
    /// </p>
    public let comment: String?
    /// <p>
    ///    The identifier for the associated control set.
    /// </p>
    public let controlSetId: String?
    /// <p> The IAM user or role that created the delegation. </p>
    public let createdBy: String?
    /// <p> Specifies when the delegation was created. </p>
    public let creationTime: Date?
    /// <p>
    ///  The unique identifier for the delegation.
    /// </p>
    public let id: String?
    /// <p>
    ///  Specifies when the delegation was last updated.
    /// </p>
    public let lastUpdated: Date?
    /// <p>
    ///    The Amazon Resource Name (ARN) of the IAM role.
    /// </p>
    public let roleArn: String?
    /// <p>
    ///    The type of customer persona.
    /// </p>
    ///          <note>
    ///             <p>In <code>CreateAssessment</code>, <code>roleType</code> can only be <code>PROCESS_OWNER</code>. </p>
    ///             <p>In <code>UpdateSettings</code>, <code>roleType</code> can only be <code>PROCESS_OWNER</code>.</p>
    ///             <p>In <code>BatchCreateDelegationByAssessment</code>, <code>roleType</code> can only be <code>RESOURCE_OWNER</code>.</p>
    ///          </note>
    public let roleType: RoleType?
    /// <p>
    ///  The status of the delegation.
    /// </p>
    public let status: DelegationStatus?

    public init (
        assessmentId: String? = nil,
        assessmentName: String? = nil,
        comment: String? = nil,
        controlSetId: String? = nil,
        createdBy: String? = nil,
        creationTime: Date? = nil,
        id: String? = nil,
        lastUpdated: Date? = nil,
        roleArn: String? = nil,
        roleType: RoleType? = nil,
        status: DelegationStatus? = nil
    )
    {
        self.assessmentId = assessmentId
        self.assessmentName = assessmentName
        self.comment = comment
        self.controlSetId = controlSetId
        self.createdBy = createdBy
        self.creationTime = creationTime
        self.id = id
        self.lastUpdated = lastUpdated
        self.roleArn = roleArn
        self.roleType = roleType
        self.status = status
    }
}

extension DelegationMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentId
        case assessmentName
        case controlSetName
        case creationTime
        case id
        case roleArn
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentId = assessmentId {
            try encodeContainer.encode(assessmentId, forKey: .assessmentId)
        }
        if let assessmentName = assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let controlSetName = controlSetName {
            try encodeContainer.encode(controlSetName, forKey: .controlSetName)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let assessmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DelegationStatus.self, forKey: .status)
        status = statusDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let controlSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .controlSetName)
        controlSetName = controlSetNameDecoded
    }
}

extension DelegationMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DelegationMetadata(assessmentId: \(String(describing: assessmentId)), assessmentName: \(String(describing: assessmentName)), controlSetName: \(String(describing: controlSetName)), creationTime: \(String(describing: creationTime)), id: \(String(describing: id)), roleArn: \(String(describing: roleArn)), status: \(String(describing: status)))"}
}

/// <p>
///    The metadata associated with the specified delegation.
/// </p>
public struct DelegationMetadata: Equatable {
    /// <p>
    ///    The unique identifier for the specified assessment.
    /// </p>
    public let assessmentId: String?
    /// <p>
    ///    The name of the associated assessment.
    /// </p>
    public let assessmentName: String?
    /// <p>
    /// Specifies the name of the control set delegated for review.
    /// </p>
    public let controlSetName: String?
    /// <p>
    ///    Specifies when the delegation was created.
    /// </p>
    public let creationTime: Date?
    /// <p>
    ///    The unique identifier for the delegation.
    /// </p>
    public let id: String?
    /// <p>
    ///    The Amazon Resource Name (ARN) of the IAM role.
    /// </p>
    public let roleArn: String?
    /// <p>
    /// The current status of the delgation.
    /// </p>
    public let status: DelegationStatus?

    public init (
        assessmentId: String? = nil,
        assessmentName: String? = nil,
        controlSetName: String? = nil,
        creationTime: Date? = nil,
        id: String? = nil,
        roleArn: String? = nil,
        status: DelegationStatus? = nil
    )
    {
        self.assessmentId = assessmentId
        self.assessmentName = assessmentName
        self.controlSetName = controlSetName
        self.creationTime = creationTime
        self.id = id
        self.roleArn = roleArn
        self.status = status
    }
}

public enum DelegationStatus {
    case complete
    case inProgress
    case underReview
    case sdkUnknown(String)
}

extension DelegationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DelegationStatus] {
        return [
            .complete,
            .inProgress,
            .underReview,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .complete: return "COMPLETE"
        case .inProgress: return "IN_PROGRESS"
        case .underReview: return "UNDER_REVIEW"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DelegationStatus(rawValue: rawValue) ?? DelegationStatus.sdkUnknown(rawValue)
    }
}

extension DeleteAssessmentFrameworkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssessmentFrameworkInput(frameworkId: \(String(describing: frameworkId)))"}
}

extension DeleteAssessmentFrameworkInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAssessmentFrameworkInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAssessmentFrameworkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssessmentFrameworkInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssessmentFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssessmentFrameworkInput>
    public typealias MOutput = OperationOutput<DeleteAssessmentFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssessmentFrameworkOutputError>
}

public struct DeleteAssessmentFrameworkInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAssessmentFrameworkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssessmentFrameworkInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssessmentFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssessmentFrameworkInput>
    public typealias MOutput = OperationOutput<DeleteAssessmentFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssessmentFrameworkOutputError>
}

public struct DeleteAssessmentFrameworkInput: Equatable {
    /// <p>
    ///    The identifier for the specified framework.
    /// </p>
    public let frameworkId: String?

    public init (
        frameworkId: String? = nil
    )
    {
        self.frameworkId = frameworkId
    }
}

struct DeleteAssessmentFrameworkInputBody: Equatable {
}

extension DeleteAssessmentFrameworkInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAssessmentFrameworkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssessmentFrameworkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAssessmentFrameworkOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssessmentFrameworkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssessmentFrameworkOutputResponse()"}
}

extension DeleteAssessmentFrameworkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssessmentFrameworkOutputResponse: Equatable {

    public init() {}
}

struct DeleteAssessmentFrameworkOutputResponseBody: Equatable {
}

extension DeleteAssessmentFrameworkOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAssessmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssessmentInput(assessmentId: \(String(describing: assessmentId)))"}
}

extension DeleteAssessmentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAssessmentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAssessmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssessmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssessmentInput>
    public typealias MOutput = OperationOutput<DeleteAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssessmentOutputError>
}

public struct DeleteAssessmentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAssessmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssessmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssessmentInput>
    public typealias MOutput = OperationOutput<DeleteAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssessmentOutputError>
}

public struct DeleteAssessmentInput: Equatable {
    /// <p>
    ///    The identifier for the specified assessment.
    /// </p>
    public let assessmentId: String?

    public init (
        assessmentId: String? = nil
    )
    {
        self.assessmentId = assessmentId
    }
}

struct DeleteAssessmentInputBody: Equatable {
}

extension DeleteAssessmentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAssessmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssessmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAssessmentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssessmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssessmentOutputResponse()"}
}

extension DeleteAssessmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssessmentOutputResponse: Equatable {

    public init() {}
}

struct DeleteAssessmentOutputResponseBody: Equatable {
}

extension DeleteAssessmentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAssessmentReportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssessmentReportInput(assessmentId: \(String(describing: assessmentId)), assessmentReportId: \(String(describing: assessmentReportId)))"}
}

extension DeleteAssessmentReportInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAssessmentReportInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAssessmentReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssessmentReportInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssessmentReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssessmentReportInput>
    public typealias MOutput = OperationOutput<DeleteAssessmentReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssessmentReportOutputError>
}

public struct DeleteAssessmentReportInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAssessmentReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssessmentReportInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssessmentReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssessmentReportInput>
    public typealias MOutput = OperationOutput<DeleteAssessmentReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssessmentReportOutputError>
}

public struct DeleteAssessmentReportInput: Equatable {
    /// <p>
    ///    The identifier for the specified assessment.
    /// </p>
    public let assessmentId: String?
    /// <p>
    /// The unique identifier for the assessment report.
    /// </p>
    public let assessmentReportId: String?

    public init (
        assessmentId: String? = nil,
        assessmentReportId: String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.assessmentReportId = assessmentReportId
    }
}

struct DeleteAssessmentReportInputBody: Equatable {
}

extension DeleteAssessmentReportInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAssessmentReportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssessmentReportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAssessmentReportOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssessmentReportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssessmentReportOutputResponse()"}
}

extension DeleteAssessmentReportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssessmentReportOutputResponse: Equatable {

    public init() {}
}

struct DeleteAssessmentReportOutputResponseBody: Equatable {
}

extension DeleteAssessmentReportOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteControlInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteControlInput(controlId: \(String(describing: controlId)))"}
}

extension DeleteControlInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteControlInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteControlInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteControlInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteControlInput>
    public typealias MOutput = OperationOutput<DeleteControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteControlOutputError>
}

public struct DeleteControlInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteControlInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteControlInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteControlInput>
    public typealias MOutput = OperationOutput<DeleteControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteControlOutputError>
}

public struct DeleteControlInput: Equatable {
    /// <p>
    ///    The identifier for the specified control.
    /// </p>
    public let controlId: String?

    public init (
        controlId: String? = nil
    )
    {
        self.controlId = controlId
    }
}

struct DeleteControlInputBody: Equatable {
}

extension DeleteControlInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteControlOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteControlOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteControlOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteControlOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteControlOutputResponse()"}
}

extension DeleteControlOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteControlOutputResponse: Equatable {

    public init() {}
}

struct DeleteControlOutputResponseBody: Equatable {
}

extension DeleteControlOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeregisterAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterAccountInput()"}
}

extension DeregisterAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeregisterAccountInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterAccountInput>
    public typealias MOutput = OperationOutput<DeregisterAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterAccountOutputError>
}

public struct DeregisterAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterAccountInput>
    public typealias MOutput = OperationOutput<DeregisterAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterAccountOutputError>
}

public struct DeregisterAccountInput: Equatable {

    public init() {}
}

struct DeregisterAccountInputBody: Equatable {
}

extension DeregisterAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeregisterAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterAccountOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterAccountOutputResponse(status: \(String(describing: status)))"}
}

extension DeregisterAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeregisterAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct DeregisterAccountOutputResponse: Equatable {
    /// <p>
    /// The registration status of the account.
    /// </p>
    public let status: AccountStatus?

    public init (
        status: AccountStatus? = nil
    )
    {
        self.status = status
    }
}

struct DeregisterAccountOutputResponseBody: Equatable {
    public let status: AccountStatus?
}

extension DeregisterAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AccountStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct DeregisterOrganizationAdminAccountInputBodyMiddleware: Middleware {
    public let id: String = "DeregisterOrganizationAdminAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<DeregisterOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterOrganizationAdminAccountOutputError>
}

extension DeregisterOrganizationAdminAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterOrganizationAdminAccountInput(adminAccountId: \(String(describing: adminAccountId)))"}
}

extension DeregisterOrganizationAdminAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adminAccountId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
    }
}

public struct DeregisterOrganizationAdminAccountInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterOrganizationAdminAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<DeregisterOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterOrganizationAdminAccountOutputError>
}

public struct DeregisterOrganizationAdminAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterOrganizationAdminAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<DeregisterOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterOrganizationAdminAccountOutputError>
}

public struct DeregisterOrganizationAdminAccountInput: Equatable {
    /// <p>
    ///  The identifier for the specified administrator account.
    /// </p>
    public let adminAccountId: String?

    public init (
        adminAccountId: String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

struct DeregisterOrganizationAdminAccountInputBody: Equatable {
    public let adminAccountId: String?
}

extension DeregisterOrganizationAdminAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adminAccountId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
    }
}

extension DeregisterOrganizationAdminAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterOrganizationAdminAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterOrganizationAdminAccountOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterOrganizationAdminAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterOrganizationAdminAccountOutputResponse()"}
}

extension DeregisterOrganizationAdminAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeregisterOrganizationAdminAccountOutputResponse: Equatable {

    public init() {}
}

struct DeregisterOrganizationAdminAccountOutputResponseBody: Equatable {
}

extension DeregisterOrganizationAdminAccountOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DisassociateAssessmentReportEvidenceFolderInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateAssessmentReportEvidenceFolderInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateAssessmentReportEvidenceFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateAssessmentReportEvidenceFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateAssessmentReportEvidenceFolderInput>
    public typealias MOutput = OperationOutput<DisassociateAssessmentReportEvidenceFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateAssessmentReportEvidenceFolderOutputError>
}

extension DisassociateAssessmentReportEvidenceFolderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateAssessmentReportEvidenceFolderInput(assessmentId: \(String(describing: assessmentId)), evidenceFolderId: \(String(describing: evidenceFolderId)))"}
}

extension DisassociateAssessmentReportEvidenceFolderInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case evidenceFolderId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let evidenceFolderId = evidenceFolderId {
            try encodeContainer.encode(evidenceFolderId, forKey: .evidenceFolderId)
        }
    }
}

public struct DisassociateAssessmentReportEvidenceFolderInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateAssessmentReportEvidenceFolderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateAssessmentReportEvidenceFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateAssessmentReportEvidenceFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateAssessmentReportEvidenceFolderInput>
    public typealias MOutput = OperationOutput<DisassociateAssessmentReportEvidenceFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateAssessmentReportEvidenceFolderOutputError>
}

public struct DisassociateAssessmentReportEvidenceFolderInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateAssessmentReportEvidenceFolderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateAssessmentReportEvidenceFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateAssessmentReportEvidenceFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateAssessmentReportEvidenceFolderInput>
    public typealias MOutput = OperationOutput<DisassociateAssessmentReportEvidenceFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateAssessmentReportEvidenceFolderOutputError>
}

public struct DisassociateAssessmentReportEvidenceFolderInput: Equatable {
    /// <p>
    ///    The identifier for the specified assessment.
    /// </p>
    public let assessmentId: String?
    /// <p>
    ///    The identifier for the folder in which evidence is stored.
    /// </p>
    public let evidenceFolderId: String?

    public init (
        assessmentId: String? = nil,
        evidenceFolderId: String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.evidenceFolderId = evidenceFolderId
    }
}

struct DisassociateAssessmentReportEvidenceFolderInputBody: Equatable {
    public let evidenceFolderId: String?
}

extension DisassociateAssessmentReportEvidenceFolderInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case evidenceFolderId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFolderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .evidenceFolderId)
        evidenceFolderId = evidenceFolderIdDecoded
    }
}

extension DisassociateAssessmentReportEvidenceFolderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateAssessmentReportEvidenceFolderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateAssessmentReportEvidenceFolderOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateAssessmentReportEvidenceFolderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateAssessmentReportEvidenceFolderOutputResponse()"}
}

extension DisassociateAssessmentReportEvidenceFolderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateAssessmentReportEvidenceFolderOutputResponse: Equatable {

    public init() {}
}

struct DisassociateAssessmentReportEvidenceFolderOutputResponseBody: Equatable {
}

extension DisassociateAssessmentReportEvidenceFolderOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Evidence: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentReportSelection
        case attributes
        case awsAccountId
        case awsOrganization
        case complianceCheck
        case dataSource
        case eventName
        case eventSource
        case evidenceAwsAccountId
        case evidenceByType
        case evidenceFolderId
        case iamId
        case id
        case resourcesIncluded
        case time
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentReportSelection = assessmentReportSelection {
            try encodeContainer.encode(assessmentReportSelection, forKey: .assessmentReportSelection)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, evidenceattributes0) in attributes {
                try attributesContainer.encode(evidenceattributes0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let awsAccountId = awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let awsOrganization = awsOrganization {
            try encodeContainer.encode(awsOrganization, forKey: .awsOrganization)
        }
        if let complianceCheck = complianceCheck {
            try encodeContainer.encode(complianceCheck, forKey: .complianceCheck)
        }
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let eventName = eventName {
            try encodeContainer.encode(eventName, forKey: .eventName)
        }
        if let eventSource = eventSource {
            try encodeContainer.encode(eventSource, forKey: .eventSource)
        }
        if let evidenceAwsAccountId = evidenceAwsAccountId {
            try encodeContainer.encode(evidenceAwsAccountId, forKey: .evidenceAwsAccountId)
        }
        if let evidenceByType = evidenceByType {
            try encodeContainer.encode(evidenceByType, forKey: .evidenceByType)
        }
        if let evidenceFolderId = evidenceFolderId {
            try encodeContainer.encode(evidenceFolderId, forKey: .evidenceFolderId)
        }
        if let iamId = iamId {
            try encodeContainer.encode(iamId, forKey: .iamId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let resourcesIncluded = resourcesIncluded {
            var resourcesIncludedContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourcesIncluded)
            for resources0 in resourcesIncluded {
                try resourcesIncludedContainer.encode(resources0)
            }
        }
        if let time = time {
            try encodeContainer.encode(time.timeIntervalSince1970, forKey: .time)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let evidenceAwsAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .evidenceAwsAccountId)
        evidenceAwsAccountId = evidenceAwsAccountIdDecoded
        let timeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .time)
        time = timeDecoded
        let eventSourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSource)
        eventSource = eventSourceDecoded
        let eventNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventName)
        eventName = eventNameDecoded
        let evidenceByTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .evidenceByType)
        evidenceByType = evidenceByTypeDecoded
        let resourcesIncludedContainer = try containerValues.decodeIfPresent([Resource?].self, forKey: .resourcesIncluded)
        var resourcesIncludedDecoded0:[Resource]? = nil
        if let resourcesIncludedContainer = resourcesIncludedContainer {
            resourcesIncludedDecoded0 = [Resource]()
            for structure0 in resourcesIncludedContainer {
                if let structure0 = structure0 {
                    resourcesIncludedDecoded0?.append(structure0)
                }
            }
        }
        resourcesIncluded = resourcesIncludedDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, evidenceattributevalue0) in attributesContainer {
                if let evidenceattributevalue0 = evidenceattributevalue0 {
                    attributesDecoded0?[key0] = evidenceattributevalue0
                }
            }
        }
        attributes = attributesDecoded0
        let iamIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamId)
        iamId = iamIdDecoded
        let complianceCheckDecoded = try containerValues.decodeIfPresent(String.self, forKey: .complianceCheck)
        complianceCheck = complianceCheckDecoded
        let awsOrganizationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsOrganization)
        awsOrganization = awsOrganizationDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let evidenceFolderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .evidenceFolderId)
        evidenceFolderId = evidenceFolderIdDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let assessmentReportSelectionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentReportSelection)
        assessmentReportSelection = assessmentReportSelectionDecoded
    }
}

extension Evidence: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Evidence(assessmentReportSelection: \(String(describing: assessmentReportSelection)), attributes: \(String(describing: attributes)), awsAccountId: \(String(describing: awsAccountId)), awsOrganization: \(String(describing: awsOrganization)), complianceCheck: \(String(describing: complianceCheck)), dataSource: \(String(describing: dataSource)), eventName: \(String(describing: eventName)), eventSource: \(String(describing: eventSource)), evidenceAwsAccountId: \(String(describing: evidenceAwsAccountId)), evidenceByType: \(String(describing: evidenceByType)), evidenceFolderId: \(String(describing: evidenceFolderId)), iamId: \(String(describing: iamId)), id: \(String(describing: id)), resourcesIncluded: \(String(describing: resourcesIncluded)), time: \(String(describing: time)))"}
}

/// <p>
///    A record that contains the information needed to demonstrate compliance with the requirements specified by a control. Examples of evidence include change activity triggered by a user, or a system configuration snapshot.
/// </p>
public struct Evidence: Equatable {
    /// <p>
    ///          Specifies whether the evidence is included in the assessment report.
    ///       </p>
    public let assessmentReportSelection: String?
    /// <p>
    ///  The names and values used by the evidence event, including an attribute name (such as <code>allowUsersToChangePassword</code>) and value (such as <code>true</code> or <code>false</code>).
    /// </p>
    public let attributes: [String:String]?
    /// <p>
    ///    The identifier for the specified AWS account.
    /// </p>
    public let awsAccountId: String?
    /// <p>
    ///    The AWS account from which the evidence is collected, and its AWS organization path.
    /// </p>
    public let awsOrganization: String?
    /// <p> The evaluation status for evidence that falls under the compliance check category. For
    ///          evidence collected from AWS Security Hub, a <i>Pass</i> or
    ///             <i>Fail</i> result is shown. For evidence collected from AWS Config, a
    ///             <i>Compliant</i> or <i>Noncompliant</i> result is shown. </p>
    public let complianceCheck: String?
    /// <p>
    ///          The data source from which the specified evidence was collected.
    ///       </p>
    public let dataSource: String?
    /// <p>
    ///          The name of the specified evidence event.
    ///       </p>
    public let eventName: String?
    /// <p>
    /// The AWS service from which the evidence is collected.
    /// </p>
    public let eventSource: String?
    /// <p>
    ///    The identifier for the specified AWS account.
    /// </p>
    public let evidenceAwsAccountId: String?
    /// <p>
    ///          The type of automated evidence.
    ///       </p>
    public let evidenceByType: String?
    /// <p>
    ///    The identifier for the folder in which the evidence is stored.
    /// </p>
    public let evidenceFolderId: String?
    /// <p>
    ///          The unique identifier for the IAM user or role associated with the evidence.
    ///       </p>
    public let iamId: String?
    /// <p> The identifier for the evidence.
    /// </p>
    public let id: String?
    /// <p>
    ///    The list of resources assessed to generate the evidence.
    /// </p>
    public let resourcesIncluded: [Resource]?
    /// <p>
    ///          The timestamp that represents when the evidence was collected.
    ///       </p>
    public let time: Date?

    public init (
        assessmentReportSelection: String? = nil,
        attributes: [String:String]? = nil,
        awsAccountId: String? = nil,
        awsOrganization: String? = nil,
        complianceCheck: String? = nil,
        dataSource: String? = nil,
        eventName: String? = nil,
        eventSource: String? = nil,
        evidenceAwsAccountId: String? = nil,
        evidenceByType: String? = nil,
        evidenceFolderId: String? = nil,
        iamId: String? = nil,
        id: String? = nil,
        resourcesIncluded: [Resource]? = nil,
        time: Date? = nil
    )
    {
        self.assessmentReportSelection = assessmentReportSelection
        self.attributes = attributes
        self.awsAccountId = awsAccountId
        self.awsOrganization = awsOrganization
        self.complianceCheck = complianceCheck
        self.dataSource = dataSource
        self.eventName = eventName
        self.eventSource = eventSource
        self.evidenceAwsAccountId = evidenceAwsAccountId
        self.evidenceByType = evidenceByType
        self.evidenceFolderId = evidenceFolderId
        self.iamId = iamId
        self.id = id
        self.resourcesIncluded = resourcesIncluded
        self.time = time
    }
}

extension Framework: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case complianceType
        case controlSets
        case controlSources
        case createdAt
        case createdBy
        case description
        case id
        case lastUpdatedAt
        case lastUpdatedBy
        case logo
        case name
        case tags
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let controlSets = controlSets {
            var controlSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlSets)
            for controlsets0 in controlSets {
                try controlSetsContainer.encode(controlsets0)
            }
        }
        if let controlSources = controlSources {
            try encodeContainer.encode(controlSources, forKey: .controlSources)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let lastUpdatedBy = lastUpdatedBy {
            try encodeContainer.encode(lastUpdatedBy, forKey: .lastUpdatedBy)
        }
        if let logo = logo {
            try encodeContainer.encode(logo, forKey: .logo)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(FrameworkType.self, forKey: .type)
        type = typeDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let logoDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logo)
        logo = logoDecoded
        let controlSourcesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .controlSources)
        controlSources = controlSourcesDecoded
        let controlSetsContainer = try containerValues.decodeIfPresent([ControlSet?].self, forKey: .controlSets)
        var controlSetsDecoded0:[ControlSet]? = nil
        if let controlSetsContainer = controlSetsContainer {
            controlSetsDecoded0 = [ControlSet]()
            for structure0 in controlSetsContainer {
                if let structure0 = structure0 {
                    controlSetsDecoded0?.append(structure0)
                }
            }
        }
        controlSets = controlSetsDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Framework: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Framework(arn: \(String(describing: arn)), complianceType: \(String(describing: complianceType)), controlSets: \(String(describing: controlSets)), controlSources: \(String(describing: controlSources)), createdAt: \(String(describing: createdAt)), createdBy: \(String(describing: createdBy)), description: \(String(describing: description)), id: \(String(describing: id)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), lastUpdatedBy: \(String(describing: lastUpdatedBy)), logo: \(String(describing: logo)), name: \(String(describing: name)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

/// <p>
///    The file used to structure and automate AWS Audit Manager assessments for a given compliance standard.
/// </p>
public struct Framework: Equatable {
    /// <p>
    ///    The Amazon Resource Name (ARN) of the specified framework.
    /// </p>
    public let arn: String?
    /// <p>
    ///    The compliance type that the new custom framework supports, such as CIS or HIPAA.
    /// </p>
    public let complianceType: String?
    /// <p>
    ///    The control sets associated with the framework.
    /// </p>
    public let controlSets: [ControlSet]?
    /// <p>
    /// The sources from which AWS Audit Manager collects evidence for the control.
    /// </p>
    public let controlSources: String?
    /// <p>
    ///    Specifies when the framework was created.
    /// </p>
    public let createdAt: Date?
    /// <p>
    ///    The IAM user or role that created the framework.
    /// </p>
    public let createdBy: String?
    /// <p>
    ///    The description of the specified framework.
    /// </p>
    public let description: String?
    /// <p>
    /// The unique identifier for the specified framework.
    /// </p>
    public let id: String?
    /// <p>
    ///    Specifies when the framework was most recently updated.
    /// </p>
    public let lastUpdatedAt: Date?
    /// <p>
    ///    The IAM user or role that most recently updated the framework.
    /// </p>
    public let lastUpdatedBy: String?
    /// <p>
    ///    The logo associated with the framework.
    /// </p>
    public let logo: String?
    /// <p>
    /// The name of the specified framework.
    /// </p>
    public let name: String?
    /// <p>
    ///          The tags associated with the framework.
    ///       </p>
    public let tags: [String:String]?
    /// <p>
    /// The framework type, such as custom or standard.
    /// </p>
    public let type: FrameworkType?

    public init (
        arn: String? = nil,
        complianceType: String? = nil,
        controlSets: [ControlSet]? = nil,
        controlSources: String? = nil,
        createdAt: Date? = nil,
        createdBy: String? = nil,
        description: String? = nil,
        id: String? = nil,
        lastUpdatedAt: Date? = nil,
        lastUpdatedBy: String? = nil,
        logo: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil,
        type: FrameworkType? = nil
    )
    {
        self.arn = arn
        self.complianceType = complianceType
        self.controlSets = controlSets
        self.controlSources = controlSources
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.lastUpdatedBy = lastUpdatedBy
        self.logo = logo
        self.name = name
        self.tags = tags
        self.type = type
    }
}

extension FrameworkMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceType
        case description
        case logo
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let logo = logo {
            try encodeContainer.encode(logo, forKey: .logo)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let logoDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logo)
        logo = logoDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
    }
}

extension FrameworkMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FrameworkMetadata(complianceType: \(String(describing: complianceType)), description: \(String(describing: description)), logo: \(String(describing: logo)), name: \(String(describing: name)))"}
}

/// <p>
///    The metadata of a framework, such as the name, ID, description, and so on.
/// </p>
public struct FrameworkMetadata: Equatable {
    /// <p>
    ///          The compliance standard associated with the framework, such as PCI-DSS or HIPAA.
    ///       </p>
    public let complianceType: String?
    /// <p>
    ///    The description of the framework.
    /// </p>
    public let description: String?
    /// <p>
    ///    The logo associated with the framework.
    /// </p>
    public let logo: String?
    /// <p>
    ///    The name of the framework.
    /// </p>
    public let name: String?

    public init (
        complianceType: String? = nil,
        description: String? = nil,
        logo: String? = nil,
        name: String? = nil
    )
    {
        self.complianceType = complianceType
        self.description = description
        self.logo = logo
        self.name = name
    }
}

public enum FrameworkType {
    case custom
    case standard
    case sdkUnknown(String)
}

extension FrameworkType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FrameworkType] {
        return [
            .custom,
            .standard,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .custom: return "Custom"
        case .standard: return "Standard"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FrameworkType(rawValue: rawValue) ?? FrameworkType.sdkUnknown(rawValue)
    }
}

extension GetAccountStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountStatusInput()"}
}

extension GetAccountStatusInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAccountStatusInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccountStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountStatusInput>
    public typealias MOutput = OperationOutput<GetAccountStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountStatusOutputError>
}

public struct GetAccountStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccountStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountStatusInput>
    public typealias MOutput = OperationOutput<GetAccountStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountStatusOutputError>
}

public struct GetAccountStatusInput: Equatable {

    public init() {}
}

struct GetAccountStatusInputBody: Equatable {
}

extension GetAccountStatusInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAccountStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccountStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccountStatusOutputError: Equatable {
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountStatusOutputResponse(status: \(String(describing: status)))"}
}

extension GetAccountStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccountStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct GetAccountStatusOutputResponse: Equatable {
    /// <p>
    /// The status of the specified AWS account.
    /// </p>
    public let status: AccountStatus?

    public init (
        status: AccountStatus? = nil
    )
    {
        self.status = status
    }
}

struct GetAccountStatusOutputResponseBody: Equatable {
    public let status: AccountStatus?
}

extension GetAccountStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AccountStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GetAssessmentFrameworkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssessmentFrameworkInput(frameworkId: \(String(describing: frameworkId)))"}
}

extension GetAssessmentFrameworkInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAssessmentFrameworkInputHeadersMiddleware: Middleware {
    public let id: String = "GetAssessmentFrameworkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssessmentFrameworkInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssessmentFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssessmentFrameworkInput>
    public typealias MOutput = OperationOutput<GetAssessmentFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssessmentFrameworkOutputError>
}

public struct GetAssessmentFrameworkInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAssessmentFrameworkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssessmentFrameworkInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssessmentFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssessmentFrameworkInput>
    public typealias MOutput = OperationOutput<GetAssessmentFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssessmentFrameworkOutputError>
}

public struct GetAssessmentFrameworkInput: Equatable {
    /// <p>
    ///    The identifier for the specified framework.
    /// </p>
    public let frameworkId: String?

    public init (
        frameworkId: String? = nil
    )
    {
        self.frameworkId = frameworkId
    }
}

struct GetAssessmentFrameworkInputBody: Equatable {
}

extension GetAssessmentFrameworkInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAssessmentFrameworkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssessmentFrameworkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAssessmentFrameworkOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssessmentFrameworkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssessmentFrameworkOutputResponse(framework: \(String(describing: framework)))"}
}

extension GetAssessmentFrameworkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAssessmentFrameworkOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.framework = output.framework
        } else {
            self.framework = nil
        }
    }
}

public struct GetAssessmentFrameworkOutputResponse: Equatable {
    /// <p>
    ///    The framework returned by the <code>GetAssessmentFramework</code> API.
    /// </p>
    public let framework: Framework?

    public init (
        framework: Framework? = nil
    )
    {
        self.framework = framework
    }
}

struct GetAssessmentFrameworkOutputResponseBody: Equatable {
    public let framework: Framework?
}

extension GetAssessmentFrameworkOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case framework
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkDecoded = try containerValues.decodeIfPresent(Framework.self, forKey: .framework)
        framework = frameworkDecoded
    }
}

extension GetAssessmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssessmentInput(assessmentId: \(String(describing: assessmentId)))"}
}

extension GetAssessmentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAssessmentInputHeadersMiddleware: Middleware {
    public let id: String = "GetAssessmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssessmentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssessmentInput>
    public typealias MOutput = OperationOutput<GetAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssessmentOutputError>
}

public struct GetAssessmentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAssessmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssessmentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssessmentInput>
    public typealias MOutput = OperationOutput<GetAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssessmentOutputError>
}

public struct GetAssessmentInput: Equatable {
    /// <p>
    ///    The identifier for the specified assessment.
    /// </p>
    public let assessmentId: String?

    public init (
        assessmentId: String? = nil
    )
    {
        self.assessmentId = assessmentId
    }
}

struct GetAssessmentInputBody: Equatable {
}

extension GetAssessmentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAssessmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssessmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAssessmentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssessmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssessmentOutputResponse(assessment: \(String(describing: assessment)), userRole: \(String(describing: userRole)))"}
}

extension GetAssessmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assessment = output.assessment
            self.userRole = output.userRole
        } else {
            self.assessment = nil
            self.userRole = nil
        }
    }
}

public struct GetAssessmentOutputResponse: Equatable {
    /// <p>
    ///    An entity that defines the scope of audit evidence collected by AWS Audit Manager. An AWS Audit Manager assessment is an implementation of an AWS Audit Manager framework.
    /// </p>
    public let assessment: Assessment?
    /// <p>
    ///      The wrapper that contains the AWS Audit Manager role information of the current user, such as the role type and IAM Amazon Resource Name (ARN).
    ///   </p>
    public let userRole: Role?

    public init (
        assessment: Assessment? = nil,
        userRole: Role? = nil
    )
    {
        self.assessment = assessment
        self.userRole = userRole
    }
}

struct GetAssessmentOutputResponseBody: Equatable {
    public let assessment: Assessment?
    public let userRole: Role?
}

extension GetAssessmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessment
        case userRole
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentDecoded = try containerValues.decodeIfPresent(Assessment.self, forKey: .assessment)
        assessment = assessmentDecoded
        let userRoleDecoded = try containerValues.decodeIfPresent(Role.self, forKey: .userRole)
        userRole = userRoleDecoded
    }
}

extension GetAssessmentReportUrlInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssessmentReportUrlInput(assessmentId: \(String(describing: assessmentId)), assessmentReportId: \(String(describing: assessmentReportId)))"}
}

extension GetAssessmentReportUrlInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAssessmentReportUrlInputHeadersMiddleware: Middleware {
    public let id: String = "GetAssessmentReportUrlInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssessmentReportUrlInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssessmentReportUrlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssessmentReportUrlInput>
    public typealias MOutput = OperationOutput<GetAssessmentReportUrlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssessmentReportUrlOutputError>
}

public struct GetAssessmentReportUrlInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAssessmentReportUrlInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssessmentReportUrlInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssessmentReportUrlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssessmentReportUrlInput>
    public typealias MOutput = OperationOutput<GetAssessmentReportUrlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssessmentReportUrlOutputError>
}

public struct GetAssessmentReportUrlInput: Equatable {
    /// <p>
    ///    The identifier for the specified assessment.
    /// </p>
    public let assessmentId: String?
    /// <p>
    /// The identifier for the assessment report.
    /// </p>
    public let assessmentReportId: String?

    public init (
        assessmentId: String? = nil,
        assessmentReportId: String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.assessmentReportId = assessmentReportId
    }
}

struct GetAssessmentReportUrlInputBody: Equatable {
}

extension GetAssessmentReportUrlInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAssessmentReportUrlOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssessmentReportUrlOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAssessmentReportUrlOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssessmentReportUrlOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssessmentReportUrlOutputResponse(preSignedUrl: \(String(describing: preSignedUrl)))"}
}

extension GetAssessmentReportUrlOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAssessmentReportUrlOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.preSignedUrl = output.preSignedUrl
        } else {
            self.preSignedUrl = nil
        }
    }
}

public struct GetAssessmentReportUrlOutputResponse: Equatable {
    /// <p>
    ///    A uniform resource locator, used as a unique identifier to locate a resource on the internet.
    /// </p>
    public let preSignedUrl: URL?

    public init (
        preSignedUrl: URL? = nil
    )
    {
        self.preSignedUrl = preSignedUrl
    }
}

struct GetAssessmentReportUrlOutputResponseBody: Equatable {
    public let preSignedUrl: URL?
}

extension GetAssessmentReportUrlOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case preSignedUrl
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preSignedUrlDecoded = try containerValues.decodeIfPresent(URL.self, forKey: .preSignedUrl)
        preSignedUrl = preSignedUrlDecoded
    }
}

extension GetChangeLogsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetChangeLogsInput(assessmentId: \(String(describing: assessmentId)), controlId: \(String(describing: controlId)), controlSetId: \(String(describing: controlSetId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetChangeLogsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetChangeLogsInputHeadersMiddleware: Middleware {
    public let id: String = "GetChangeLogsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetChangeLogsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetChangeLogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetChangeLogsInput>
    public typealias MOutput = OperationOutput<GetChangeLogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetChangeLogsOutputError>
}

public struct GetChangeLogsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetChangeLogsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetChangeLogsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetChangeLogsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let controlSetId = input.operationInput.controlSetId {
            let controlSetIdQueryItem = URLQueryItem(name: "controlSetId".urlPercentEncoding(), value: String(controlSetId).urlPercentEncoding())
            input.builder.withQueryItem(controlSetIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let controlId = input.operationInput.controlId {
            let controlIdQueryItem = URLQueryItem(name: "controlId".urlPercentEncoding(), value: String(controlId).urlPercentEncoding())
            input.builder.withQueryItem(controlIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetChangeLogsInput>
    public typealias MOutput = OperationOutput<GetChangeLogsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetChangeLogsOutputError>
}

public struct GetChangeLogsInput: Equatable {
    /// <p>
    ///    The identifier for the specified assessment.
    /// </p>
    public let assessmentId: String?
    /// <p>
    ///
    ///    The identifier for the specified control.
    /// </p>
    public let controlId: String?
    /// <p>
    ///    The identifier for the specified control set.
    /// </p>
    public let controlSetId: String?
    /// <p>
    ///    Represents the maximum number of results per page, or per API request call.
    /// </p>
    public let maxResults: Int?
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?

    public init (
        assessmentId: String? = nil,
        controlId: String? = nil,
        controlSetId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlId = controlId
        self.controlSetId = controlSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetChangeLogsInputBody: Equatable {
}

extension GetChangeLogsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetChangeLogsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChangeLogsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetChangeLogsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChangeLogsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetChangeLogsOutputResponse(changeLogs: \(String(describing: changeLogs)), nextToken: \(String(describing: nextToken)))"}
}

extension GetChangeLogsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetChangeLogsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.changeLogs = output.changeLogs
            self.nextToken = output.nextToken
        } else {
            self.changeLogs = nil
            self.nextToken = nil
        }
    }
}

public struct GetChangeLogsOutputResponse: Equatable {
    /// <p>
    ///          The list of user activity for the control.
    ///       </p>
    public let changeLogs: [ChangeLog]?
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?

    public init (
        changeLogs: [ChangeLog]? = nil,
        nextToken: String? = nil
    )
    {
        self.changeLogs = changeLogs
        self.nextToken = nextToken
    }
}

struct GetChangeLogsOutputResponseBody: Equatable {
    public let changeLogs: [ChangeLog]?
    public let nextToken: String?
}

extension GetChangeLogsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case changeLogs
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changeLogsContainer = try containerValues.decodeIfPresent([ChangeLog?].self, forKey: .changeLogs)
        var changeLogsDecoded0:[ChangeLog]? = nil
        if let changeLogsContainer = changeLogsContainer {
            changeLogsDecoded0 = [ChangeLog]()
            for structure0 in changeLogsContainer {
                if let structure0 = structure0 {
                    changeLogsDecoded0?.append(structure0)
                }
            }
        }
        changeLogs = changeLogsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetControlInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetControlInput(controlId: \(String(describing: controlId)))"}
}

extension GetControlInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetControlInputHeadersMiddleware: Middleware {
    public let id: String = "GetControlInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetControlInput>,
                  next: H) -> Swift.Result<OperationOutput<GetControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetControlInput>
    public typealias MOutput = OperationOutput<GetControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetControlOutputError>
}

public struct GetControlInputQueryItemMiddleware: Middleware {
    public let id: String = "GetControlInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetControlInput>,
                  next: H) -> Swift.Result<OperationOutput<GetControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetControlInput>
    public typealias MOutput = OperationOutput<GetControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetControlOutputError>
}

public struct GetControlInput: Equatable {
    /// <p>
    ///
    ///    The identifier for the specified control.
    /// </p>
    public let controlId: String?

    public init (
        controlId: String? = nil
    )
    {
        self.controlId = controlId
    }
}

struct GetControlInputBody: Equatable {
}

extension GetControlInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetControlOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetControlOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetControlOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetControlOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetControlOutputResponse(control: \(String(describing: control)))"}
}

extension GetControlOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetControlOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.control = output.control
        } else {
            self.control = nil
        }
    }
}

public struct GetControlOutputResponse: Equatable {
    /// <p>
    ///    The name of the control returned by the <code>GetControl</code> API.
    /// </p>
    public let control: Control?

    public init (
        control: Control? = nil
    )
    {
        self.control = control
    }
}

struct GetControlOutputResponseBody: Equatable {
    public let control: Control?
}

extension GetControlOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case control
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlDecoded = try containerValues.decodeIfPresent(Control.self, forKey: .control)
        control = controlDecoded
    }
}

extension GetDelegationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDelegationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetDelegationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDelegationsInputHeadersMiddleware: Middleware {
    public let id: String = "GetDelegationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDelegationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDelegationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDelegationsInput>
    public typealias MOutput = OperationOutput<GetDelegationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDelegationsOutputError>
}

public struct GetDelegationsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDelegationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDelegationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDelegationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDelegationsInput>
    public typealias MOutput = OperationOutput<GetDelegationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDelegationsOutputError>
}

public struct GetDelegationsInput: Equatable {
    /// <p>
    ///    Represents the maximum number of results per page, or per API request call.
    /// </p>
    public let maxResults: Int?
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetDelegationsInputBody: Equatable {
}

extension GetDelegationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDelegationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDelegationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDelegationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDelegationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDelegationsOutputResponse(delegations: \(String(describing: delegations)), nextToken: \(String(describing: nextToken)))"}
}

extension GetDelegationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDelegationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.delegations = output.delegations
            self.nextToken = output.nextToken
        } else {
            self.delegations = nil
            self.nextToken = nil
        }
    }
}

public struct GetDelegationsOutputResponse: Equatable {
    /// <p>
    ///    The list of delegations returned by the <code>GetDelegations</code> API.
    /// </p>
    public let delegations: [DelegationMetadata]?
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?

    public init (
        delegations: [DelegationMetadata]? = nil,
        nextToken: String? = nil
    )
    {
        self.delegations = delegations
        self.nextToken = nextToken
    }
}

struct GetDelegationsOutputResponseBody: Equatable {
    public let delegations: [DelegationMetadata]?
    public let nextToken: String?
}

extension GetDelegationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case delegations
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delegationsContainer = try containerValues.decodeIfPresent([DelegationMetadata?].self, forKey: .delegations)
        var delegationsDecoded0:[DelegationMetadata]? = nil
        if let delegationsContainer = delegationsContainer {
            delegationsDecoded0 = [DelegationMetadata]()
            for structure0 in delegationsContainer {
                if let structure0 = structure0 {
                    delegationsDecoded0?.append(structure0)
                }
            }
        }
        delegations = delegationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetEvidenceByEvidenceFolderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEvidenceByEvidenceFolderInput(assessmentId: \(String(describing: assessmentId)), controlSetId: \(String(describing: controlSetId)), evidenceFolderId: \(String(describing: evidenceFolderId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetEvidenceByEvidenceFolderInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetEvidenceByEvidenceFolderInputHeadersMiddleware: Middleware {
    public let id: String = "GetEvidenceByEvidenceFolderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEvidenceByEvidenceFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEvidenceByEvidenceFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEvidenceByEvidenceFolderInput>
    public typealias MOutput = OperationOutput<GetEvidenceByEvidenceFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEvidenceByEvidenceFolderOutputError>
}

public struct GetEvidenceByEvidenceFolderInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEvidenceByEvidenceFolderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEvidenceByEvidenceFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEvidenceByEvidenceFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEvidenceByEvidenceFolderInput>
    public typealias MOutput = OperationOutput<GetEvidenceByEvidenceFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEvidenceByEvidenceFolderOutputError>
}

public struct GetEvidenceByEvidenceFolderInput: Equatable {
    /// <p>
    ///    The identifier for the specified assessment.
    /// </p>
    public let assessmentId: String?
    /// <p>
    ///    The identifier for the control set.
    /// </p>
    public let controlSetId: String?
    /// <p>
    ///    The unique identifier for the folder in which the evidence is stored.
    /// </p>
    public let evidenceFolderId: String?
    /// <p>
    ///    Represents the maximum number of results per page, or per API request call.
    /// </p>
    public let maxResults: Int?
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?

    public init (
        assessmentId: String? = nil,
        controlSetId: String? = nil,
        evidenceFolderId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlSetId = controlSetId
        self.evidenceFolderId = evidenceFolderId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetEvidenceByEvidenceFolderInputBody: Equatable {
}

extension GetEvidenceByEvidenceFolderInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetEvidenceByEvidenceFolderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEvidenceByEvidenceFolderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEvidenceByEvidenceFolderOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEvidenceByEvidenceFolderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEvidenceByEvidenceFolderOutputResponse(evidence: \(String(describing: evidence)), nextToken: \(String(describing: nextToken)))"}
}

extension GetEvidenceByEvidenceFolderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEvidenceByEvidenceFolderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.evidence = output.evidence
            self.nextToken = output.nextToken
        } else {
            self.evidence = nil
            self.nextToken = nil
        }
    }
}

public struct GetEvidenceByEvidenceFolderOutputResponse: Equatable {
    /// <p>
    ///    The list of evidence returned by the <code>GetEvidenceByEvidenceFolder</code> API.
    /// </p>
    public let evidence: [Evidence]?
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?

    public init (
        evidence: [Evidence]? = nil,
        nextToken: String? = nil
    )
    {
        self.evidence = evidence
        self.nextToken = nextToken
    }
}

struct GetEvidenceByEvidenceFolderOutputResponseBody: Equatable {
    public let evidence: [Evidence]?
    public let nextToken: String?
}

extension GetEvidenceByEvidenceFolderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case evidence
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceContainer = try containerValues.decodeIfPresent([Evidence?].self, forKey: .evidence)
        var evidenceDecoded0:[Evidence]? = nil
        if let evidenceContainer = evidenceContainer {
            evidenceDecoded0 = [Evidence]()
            for structure0 in evidenceContainer {
                if let structure0 = structure0 {
                    evidenceDecoded0?.append(structure0)
                }
            }
        }
        evidence = evidenceDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetEvidenceFolderInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEvidenceFolderInput(assessmentId: \(String(describing: assessmentId)), controlSetId: \(String(describing: controlSetId)), evidenceFolderId: \(String(describing: evidenceFolderId)))"}
}

extension GetEvidenceFolderInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetEvidenceFolderInputHeadersMiddleware: Middleware {
    public let id: String = "GetEvidenceFolderInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEvidenceFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEvidenceFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEvidenceFolderInput>
    public typealias MOutput = OperationOutput<GetEvidenceFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEvidenceFolderOutputError>
}

public struct GetEvidenceFolderInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEvidenceFolderInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEvidenceFolderInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEvidenceFolderOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEvidenceFolderInput>
    public typealias MOutput = OperationOutput<GetEvidenceFolderOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEvidenceFolderOutputError>
}

public struct GetEvidenceFolderInput: Equatable {
    /// <p>
    ///    The identifier for the specified assessment.
    /// </p>
    public let assessmentId: String?
    /// <p>
    ///    The identifier for the specified control set.
    /// </p>
    public let controlSetId: String?
    /// <p>
    ///    The identifier for the folder in which the evidence is stored.
    /// </p>
    public let evidenceFolderId: String?

    public init (
        assessmentId: String? = nil,
        controlSetId: String? = nil,
        evidenceFolderId: String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlSetId = controlSetId
        self.evidenceFolderId = evidenceFolderId
    }
}

struct GetEvidenceFolderInputBody: Equatable {
}

extension GetEvidenceFolderInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetEvidenceFolderOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEvidenceFolderOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEvidenceFolderOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEvidenceFolderOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEvidenceFolderOutputResponse(evidenceFolder: \(String(describing: evidenceFolder)))"}
}

extension GetEvidenceFolderOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEvidenceFolderOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.evidenceFolder = output.evidenceFolder
        } else {
            self.evidenceFolder = nil
        }
    }
}

public struct GetEvidenceFolderOutputResponse: Equatable {
    /// <p>
    /// The folder in which evidence is stored.
    /// </p>
    public let evidenceFolder: AssessmentEvidenceFolder?

    public init (
        evidenceFolder: AssessmentEvidenceFolder? = nil
    )
    {
        self.evidenceFolder = evidenceFolder
    }
}

struct GetEvidenceFolderOutputResponseBody: Equatable {
    public let evidenceFolder: AssessmentEvidenceFolder?
}

extension GetEvidenceFolderOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case evidenceFolder
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFolderDecoded = try containerValues.decodeIfPresent(AssessmentEvidenceFolder.self, forKey: .evidenceFolder)
        evidenceFolder = evidenceFolderDecoded
    }
}

extension GetEvidenceFoldersByAssessmentControlInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEvidenceFoldersByAssessmentControlInput(assessmentId: \(String(describing: assessmentId)), controlId: \(String(describing: controlId)), controlSetId: \(String(describing: controlSetId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetEvidenceFoldersByAssessmentControlInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetEvidenceFoldersByAssessmentControlInputHeadersMiddleware: Middleware {
    public let id: String = "GetEvidenceFoldersByAssessmentControlInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEvidenceFoldersByAssessmentControlInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEvidenceFoldersByAssessmentControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEvidenceFoldersByAssessmentControlInput>
    public typealias MOutput = OperationOutput<GetEvidenceFoldersByAssessmentControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEvidenceFoldersByAssessmentControlOutputError>
}

public struct GetEvidenceFoldersByAssessmentControlInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEvidenceFoldersByAssessmentControlInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEvidenceFoldersByAssessmentControlInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEvidenceFoldersByAssessmentControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEvidenceFoldersByAssessmentControlInput>
    public typealias MOutput = OperationOutput<GetEvidenceFoldersByAssessmentControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEvidenceFoldersByAssessmentControlOutputError>
}

public struct GetEvidenceFoldersByAssessmentControlInput: Equatable {
    /// <p>
    ///    The identifier for the specified assessment.
    /// </p>
    public let assessmentId: String?
    /// <p>
    ///    The identifier for the specified control.
    /// </p>
    public let controlId: String?
    /// <p>
    ///    The identifier for the specified control set.
    /// </p>
    public let controlSetId: String?
    /// <p>
    ///    Represents the maximum number of results per page, or per API request call.
    /// </p>
    public let maxResults: Int?
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?

    public init (
        assessmentId: String? = nil,
        controlId: String? = nil,
        controlSetId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlId = controlId
        self.controlSetId = controlSetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetEvidenceFoldersByAssessmentControlInputBody: Equatable {
}

extension GetEvidenceFoldersByAssessmentControlInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetEvidenceFoldersByAssessmentControlOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEvidenceFoldersByAssessmentControlOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEvidenceFoldersByAssessmentControlOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEvidenceFoldersByAssessmentControlOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEvidenceFoldersByAssessmentControlOutputResponse(evidenceFolders: \(String(describing: evidenceFolders)), nextToken: \(String(describing: nextToken)))"}
}

extension GetEvidenceFoldersByAssessmentControlOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEvidenceFoldersByAssessmentControlOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.evidenceFolders = output.evidenceFolders
            self.nextToken = output.nextToken
        } else {
            self.evidenceFolders = nil
            self.nextToken = nil
        }
    }
}

public struct GetEvidenceFoldersByAssessmentControlOutputResponse: Equatable {
    /// <p>
    ///    The list of evidence folders returned by the <code>GetEvidenceFoldersByAssessmentControl</code> API.
    /// </p>
    public let evidenceFolders: [AssessmentEvidenceFolder]?
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?

    public init (
        evidenceFolders: [AssessmentEvidenceFolder]? = nil,
        nextToken: String? = nil
    )
    {
        self.evidenceFolders = evidenceFolders
        self.nextToken = nextToken
    }
}

struct GetEvidenceFoldersByAssessmentControlOutputResponseBody: Equatable {
    public let evidenceFolders: [AssessmentEvidenceFolder]?
    public let nextToken: String?
}

extension GetEvidenceFoldersByAssessmentControlOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case evidenceFolders
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFoldersContainer = try containerValues.decodeIfPresent([AssessmentEvidenceFolder?].self, forKey: .evidenceFolders)
        var evidenceFoldersDecoded0:[AssessmentEvidenceFolder]? = nil
        if let evidenceFoldersContainer = evidenceFoldersContainer {
            evidenceFoldersDecoded0 = [AssessmentEvidenceFolder]()
            for structure0 in evidenceFoldersContainer {
                if let structure0 = structure0 {
                    evidenceFoldersDecoded0?.append(structure0)
                }
            }
        }
        evidenceFolders = evidenceFoldersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetEvidenceFoldersByAssessmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEvidenceFoldersByAssessmentInput(assessmentId: \(String(describing: assessmentId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetEvidenceFoldersByAssessmentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetEvidenceFoldersByAssessmentInputHeadersMiddleware: Middleware {
    public let id: String = "GetEvidenceFoldersByAssessmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEvidenceFoldersByAssessmentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEvidenceFoldersByAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEvidenceFoldersByAssessmentInput>
    public typealias MOutput = OperationOutput<GetEvidenceFoldersByAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEvidenceFoldersByAssessmentOutputError>
}

public struct GetEvidenceFoldersByAssessmentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEvidenceFoldersByAssessmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEvidenceFoldersByAssessmentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEvidenceFoldersByAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEvidenceFoldersByAssessmentInput>
    public typealias MOutput = OperationOutput<GetEvidenceFoldersByAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEvidenceFoldersByAssessmentOutputError>
}

public struct GetEvidenceFoldersByAssessmentInput: Equatable {
    /// <p>
    ///    The identifier for the specified assessment.
    /// </p>
    public let assessmentId: String?
    /// <p>
    ///    Represents the maximum number of results per page, or per API request call.
    /// </p>
    public let maxResults: Int?
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?

    public init (
        assessmentId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetEvidenceFoldersByAssessmentInputBody: Equatable {
}

extension GetEvidenceFoldersByAssessmentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetEvidenceFoldersByAssessmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEvidenceFoldersByAssessmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEvidenceFoldersByAssessmentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEvidenceFoldersByAssessmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEvidenceFoldersByAssessmentOutputResponse(evidenceFolders: \(String(describing: evidenceFolders)), nextToken: \(String(describing: nextToken)))"}
}

extension GetEvidenceFoldersByAssessmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEvidenceFoldersByAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.evidenceFolders = output.evidenceFolders
            self.nextToken = output.nextToken
        } else {
            self.evidenceFolders = nil
            self.nextToken = nil
        }
    }
}

public struct GetEvidenceFoldersByAssessmentOutputResponse: Equatable {
    /// <p>
    ///    The list of evidence folders returned by the <code>GetEvidenceFoldersByAssessment</code> API.
    /// </p>
    public let evidenceFolders: [AssessmentEvidenceFolder]?
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?

    public init (
        evidenceFolders: [AssessmentEvidenceFolder]? = nil,
        nextToken: String? = nil
    )
    {
        self.evidenceFolders = evidenceFolders
        self.nextToken = nextToken
    }
}

struct GetEvidenceFoldersByAssessmentOutputResponseBody: Equatable {
    public let evidenceFolders: [AssessmentEvidenceFolder]?
    public let nextToken: String?
}

extension GetEvidenceFoldersByAssessmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case evidenceFolders
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceFoldersContainer = try containerValues.decodeIfPresent([AssessmentEvidenceFolder?].self, forKey: .evidenceFolders)
        var evidenceFoldersDecoded0:[AssessmentEvidenceFolder]? = nil
        if let evidenceFoldersContainer = evidenceFoldersContainer {
            evidenceFoldersDecoded0 = [AssessmentEvidenceFolder]()
            for structure0 in evidenceFoldersContainer {
                if let structure0 = structure0 {
                    evidenceFoldersDecoded0?.append(structure0)
                }
            }
        }
        evidenceFolders = evidenceFoldersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetEvidenceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEvidenceInput(assessmentId: \(String(describing: assessmentId)), controlSetId: \(String(describing: controlSetId)), evidenceFolderId: \(String(describing: evidenceFolderId)), evidenceId: \(String(describing: evidenceId)))"}
}

extension GetEvidenceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetEvidenceInputHeadersMiddleware: Middleware {
    public let id: String = "GetEvidenceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEvidenceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEvidenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEvidenceInput>
    public typealias MOutput = OperationOutput<GetEvidenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEvidenceOutputError>
}

public struct GetEvidenceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEvidenceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEvidenceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEvidenceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEvidenceInput>
    public typealias MOutput = OperationOutput<GetEvidenceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEvidenceOutputError>
}

public struct GetEvidenceInput: Equatable {
    /// <p>
    ///    The identifier for the specified assessment.
    /// </p>
    public let assessmentId: String?
    /// <p>
    ///    The identifier for the specified control set.
    /// </p>
    public let controlSetId: String?
    /// <p>
    ///    The identifier for the folder in which the evidence is stored.
    /// </p>
    public let evidenceFolderId: String?
    /// <p>
    ///    The identifier for the evidence.
    /// </p>
    public let evidenceId: String?

    public init (
        assessmentId: String? = nil,
        controlSetId: String? = nil,
        evidenceFolderId: String? = nil,
        evidenceId: String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.controlSetId = controlSetId
        self.evidenceFolderId = evidenceFolderId
        self.evidenceId = evidenceId
    }
}

struct GetEvidenceInputBody: Equatable {
}

extension GetEvidenceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetEvidenceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEvidenceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEvidenceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEvidenceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEvidenceOutputResponse(evidence: \(String(describing: evidence)))"}
}

extension GetEvidenceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEvidenceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.evidence = output.evidence
        } else {
            self.evidence = nil
        }
    }
}

public struct GetEvidenceOutputResponse: Equatable {
    /// <p>
    ///    The evidence returned by the <code>GetEvidenceResponse</code> API.
    /// </p>
    public let evidence: Evidence?

    public init (
        evidence: Evidence? = nil
    )
    {
        self.evidence = evidence
    }
}

struct GetEvidenceOutputResponseBody: Equatable {
    public let evidence: Evidence?
}

extension GetEvidenceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case evidence
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let evidenceDecoded = try containerValues.decodeIfPresent(Evidence.self, forKey: .evidence)
        evidence = evidenceDecoded
    }
}

extension GetOrganizationAdminAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOrganizationAdminAccountInput()"}
}

extension GetOrganizationAdminAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetOrganizationAdminAccountInputHeadersMiddleware: Middleware {
    public let id: String = "GetOrganizationAdminAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<GetOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOrganizationAdminAccountOutputError>
}

public struct GetOrganizationAdminAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "GetOrganizationAdminAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<GetOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOrganizationAdminAccountOutputError>
}

public struct GetOrganizationAdminAccountInput: Equatable {

    public init() {}
}

struct GetOrganizationAdminAccountInputBody: Equatable {
}

extension GetOrganizationAdminAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetOrganizationAdminAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOrganizationAdminAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOrganizationAdminAccountOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOrganizationAdminAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOrganizationAdminAccountOutputResponse(adminAccountId: \(String(describing: adminAccountId)), organizationId: \(String(describing: organizationId)))"}
}

extension GetOrganizationAdminAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetOrganizationAdminAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.adminAccountId = output.adminAccountId
            self.organizationId = output.organizationId
        } else {
            self.adminAccountId = nil
            self.organizationId = nil
        }
    }
}

public struct GetOrganizationAdminAccountOutputResponse: Equatable {
    /// <p>
    ///    The identifier for the specified administrator account.
    /// </p>
    public let adminAccountId: String?
    /// <p>
    ///    The identifier for the specified organization.
    /// </p>
    public let organizationId: String?

    public init (
        adminAccountId: String? = nil,
        organizationId: String? = nil
    )
    {
        self.adminAccountId = adminAccountId
        self.organizationId = organizationId
    }
}

struct GetOrganizationAdminAccountOutputResponseBody: Equatable {
    public let adminAccountId: String?
    public let organizationId: String?
}

extension GetOrganizationAdminAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adminAccountId
        case organizationId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension GetServicesInScopeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServicesInScopeInput()"}
}

extension GetServicesInScopeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetServicesInScopeInputHeadersMiddleware: Middleware {
    public let id: String = "GetServicesInScopeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServicesInScopeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServicesInScopeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServicesInScopeInput>
    public typealias MOutput = OperationOutput<GetServicesInScopeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServicesInScopeOutputError>
}

public struct GetServicesInScopeInputQueryItemMiddleware: Middleware {
    public let id: String = "GetServicesInScopeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServicesInScopeInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServicesInScopeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServicesInScopeInput>
    public typealias MOutput = OperationOutput<GetServicesInScopeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServicesInScopeOutputError>
}

public struct GetServicesInScopeInput: Equatable {

    public init() {}
}

struct GetServicesInScopeInputBody: Equatable {
}

extension GetServicesInScopeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetServicesInScopeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServicesInScopeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServicesInScopeOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServicesInScopeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServicesInScopeOutputResponse(serviceMetadata: \(String(describing: serviceMetadata)))"}
}

extension GetServicesInScopeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetServicesInScopeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serviceMetadata = output.serviceMetadata
        } else {
            self.serviceMetadata = nil
        }
    }
}

public struct GetServicesInScopeOutputResponse: Equatable {
    /// <p>
    ///    The metadata associated with the aAWS service.
    /// </p>
    public let serviceMetadata: [ServiceMetadata]?

    public init (
        serviceMetadata: [ServiceMetadata]? = nil
    )
    {
        self.serviceMetadata = serviceMetadata
    }
}

struct GetServicesInScopeOutputResponseBody: Equatable {
    public let serviceMetadata: [ServiceMetadata]?
}

extension GetServicesInScopeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serviceMetadata
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceMetadataContainer = try containerValues.decodeIfPresent([ServiceMetadata?].self, forKey: .serviceMetadata)
        var serviceMetadataDecoded0:[ServiceMetadata]? = nil
        if let serviceMetadataContainer = serviceMetadataContainer {
            serviceMetadataDecoded0 = [ServiceMetadata]()
            for structure0 in serviceMetadataContainer {
                if let structure0 = structure0 {
                    serviceMetadataDecoded0?.append(structure0)
                }
            }
        }
        serviceMetadata = serviceMetadataDecoded0
    }
}

extension GetSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSettingsInput(attribute: \(String(describing: attribute)))"}
}

extension GetSettingsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "GetSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSettingsInput>
    public typealias MOutput = OperationOutput<GetSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSettingsOutputError>
}

public struct GetSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSettingsInput>
    public typealias MOutput = OperationOutput<GetSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSettingsOutputError>
}

public struct GetSettingsInput: Equatable {
    /// <p>
    ///    The list of <code>SettingAttribute</code> enum values.
    /// </p>
    public let attribute: SettingAttribute?

    public init (
        attribute: SettingAttribute? = nil
    )
    {
        self.attribute = attribute
    }
}

struct GetSettingsInputBody: Equatable {
}

extension GetSettingsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSettingsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSettingsOutputResponse(settings: \(String(describing: settings)))"}
}

extension GetSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSettingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.settings = output.settings
        } else {
            self.settings = nil
        }
    }
}

public struct GetSettingsOutputResponse: Equatable {
    /// <p>
    ///    The settings object that holds all supported AWS Audit Manager settings.
    /// </p>
    public let settings: Settings?

    public init (
        settings: Settings? = nil
    )
    {
        self.settings = settings
    }
}

struct GetSettingsOutputResponseBody: Equatable {
    public let settings: Settings?
}

extension GetSettingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case settings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let settingsDecoded = try containerValues.decodeIfPresent(Settings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///   An internal service error occurred during the processing of your request. Try again later.
/// </p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum KeywordInputType {
    case selectFromList
    case sdkUnknown(String)
}

extension KeywordInputType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [KeywordInputType] {
        return [
            .selectFromList,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .selectFromList: return "SELECT_FROM_LIST"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = KeywordInputType(rawValue: rawValue) ?? KeywordInputType.sdkUnknown(rawValue)
    }
}

extension ListAssessmentFrameworksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssessmentFrameworksInput(frameworkType: \(String(describing: frameworkType)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssessmentFrameworksInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAssessmentFrameworksInputHeadersMiddleware: Middleware {
    public let id: String = "ListAssessmentFrameworksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssessmentFrameworksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssessmentFrameworksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssessmentFrameworksInput>
    public typealias MOutput = OperationOutput<ListAssessmentFrameworksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssessmentFrameworksOutputError>
}

public struct ListAssessmentFrameworksInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAssessmentFrameworksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssessmentFrameworksInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssessmentFrameworksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let frameworkType = input.operationInput.frameworkType {
            let frameworkTypeQueryItem = URLQueryItem(name: "frameworkType".urlPercentEncoding(), value: String(frameworkType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(frameworkTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssessmentFrameworksInput>
    public typealias MOutput = OperationOutput<ListAssessmentFrameworksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssessmentFrameworksOutputError>
}

public struct ListAssessmentFrameworksInput: Equatable {
    /// <p>
    ///    The type of framework, such as standard or custom.
    /// </p>
    public let frameworkType: FrameworkType?
    /// <p>
    ///    Represents the maximum number of results per page, or per API request call.
    /// </p>
    public let maxResults: Int?
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?

    public init (
        frameworkType: FrameworkType? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.frameworkType = frameworkType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssessmentFrameworksInputBody: Equatable {
}

extension ListAssessmentFrameworksInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAssessmentFrameworksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssessmentFrameworksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssessmentFrameworksOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssessmentFrameworksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssessmentFrameworksOutputResponse(frameworkMetadataList: \(String(describing: frameworkMetadataList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssessmentFrameworksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAssessmentFrameworksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.frameworkMetadataList = output.frameworkMetadataList
            self.nextToken = output.nextToken
        } else {
            self.frameworkMetadataList = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentFrameworksOutputResponse: Equatable {
    /// <p>
    /// The list of metadata objects for the specified framework.
    /// </p>
    public let frameworkMetadataList: [AssessmentFrameworkMetadata]?
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?

    public init (
        frameworkMetadataList: [AssessmentFrameworkMetadata]? = nil,
        nextToken: String? = nil
    )
    {
        self.frameworkMetadataList = frameworkMetadataList
        self.nextToken = nextToken
    }
}

struct ListAssessmentFrameworksOutputResponseBody: Equatable {
    public let frameworkMetadataList: [AssessmentFrameworkMetadata]?
    public let nextToken: String?
}

extension ListAssessmentFrameworksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case frameworkMetadataList
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkMetadataListContainer = try containerValues.decodeIfPresent([AssessmentFrameworkMetadata?].self, forKey: .frameworkMetadataList)
        var frameworkMetadataListDecoded0:[AssessmentFrameworkMetadata]? = nil
        if let frameworkMetadataListContainer = frameworkMetadataListContainer {
            frameworkMetadataListDecoded0 = [AssessmentFrameworkMetadata]()
            for structure0 in frameworkMetadataListContainer {
                if let structure0 = structure0 {
                    frameworkMetadataListDecoded0?.append(structure0)
                }
            }
        }
        frameworkMetadataList = frameworkMetadataListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssessmentReportsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssessmentReportsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssessmentReportsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAssessmentReportsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAssessmentReportsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssessmentReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssessmentReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssessmentReportsInput>
    public typealias MOutput = OperationOutput<ListAssessmentReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssessmentReportsOutputError>
}

public struct ListAssessmentReportsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAssessmentReportsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssessmentReportsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssessmentReportsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssessmentReportsInput>
    public typealias MOutput = OperationOutput<ListAssessmentReportsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssessmentReportsOutputError>
}

public struct ListAssessmentReportsInput: Equatable {
    /// <p>
    ///    Represents the maximum number of results per page, or per API request call.
    /// </p>
    public let maxResults: Int?
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssessmentReportsInputBody: Equatable {
}

extension ListAssessmentReportsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAssessmentReportsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssessmentReportsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssessmentReportsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssessmentReportsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssessmentReportsOutputResponse(assessmentReports: \(String(describing: assessmentReports)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssessmentReportsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAssessmentReportsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assessmentReports = output.assessmentReports
            self.nextToken = output.nextToken
        } else {
            self.assessmentReports = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentReportsOutputResponse: Equatable {
    /// <p>
    ///    The list of assessment reports returned by the <code>ListAssessmentReports</code> API.
    /// </p>
    public let assessmentReports: [AssessmentReportMetadata]?
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?

    public init (
        assessmentReports: [AssessmentReportMetadata]? = nil,
        nextToken: String? = nil
    )
    {
        self.assessmentReports = assessmentReports
        self.nextToken = nextToken
    }
}

struct ListAssessmentReportsOutputResponseBody: Equatable {
    public let assessmentReports: [AssessmentReportMetadata]?
    public let nextToken: String?
}

extension ListAssessmentReportsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentReports
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentReportsContainer = try containerValues.decodeIfPresent([AssessmentReportMetadata?].self, forKey: .assessmentReports)
        var assessmentReportsDecoded0:[AssessmentReportMetadata]? = nil
        if let assessmentReportsContainer = assessmentReportsContainer {
            assessmentReportsDecoded0 = [AssessmentReportMetadata]()
            for structure0 in assessmentReportsContainer {
                if let structure0 = structure0 {
                    assessmentReportsDecoded0?.append(structure0)
                }
            }
        }
        assessmentReports = assessmentReportsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssessmentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssessmentsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssessmentsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAssessmentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAssessmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssessmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssessmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssessmentsInput>
    public typealias MOutput = OperationOutput<ListAssessmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssessmentsOutputError>
}

public struct ListAssessmentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAssessmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssessmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssessmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssessmentsInput>
    public typealias MOutput = OperationOutput<ListAssessmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssessmentsOutputError>
}

public struct ListAssessmentsInput: Equatable {
    /// <p>
    ///    Represents the maximum number of results per page, or per API request call.
    /// </p>
    public let maxResults: Int?
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssessmentsInputBody: Equatable {
}

extension ListAssessmentsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAssessmentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssessmentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssessmentsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssessmentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssessmentsOutputResponse(assessmentMetadata: \(String(describing: assessmentMetadata)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssessmentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAssessmentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assessmentMetadata = output.assessmentMetadata
            self.nextToken = output.nextToken
        } else {
            self.assessmentMetadata = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentsOutputResponse: Equatable {
    /// <p>
    ///    The metadata associated with the assessment.
    /// </p>
    public let assessmentMetadata: [AssessmentMetadataItem]?
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?

    public init (
        assessmentMetadata: [AssessmentMetadataItem]? = nil,
        nextToken: String? = nil
    )
    {
        self.assessmentMetadata = assessmentMetadata
        self.nextToken = nextToken
    }
}

struct ListAssessmentsOutputResponseBody: Equatable {
    public let assessmentMetadata: [AssessmentMetadataItem]?
    public let nextToken: String?
}

extension ListAssessmentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentMetadata
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentMetadataContainer = try containerValues.decodeIfPresent([AssessmentMetadataItem?].self, forKey: .assessmentMetadata)
        var assessmentMetadataDecoded0:[AssessmentMetadataItem]? = nil
        if let assessmentMetadataContainer = assessmentMetadataContainer {
            assessmentMetadataDecoded0 = [AssessmentMetadataItem]()
            for structure0 in assessmentMetadataContainer {
                if let structure0 = structure0 {
                    assessmentMetadataDecoded0?.append(structure0)
                }
            }
        }
        assessmentMetadata = assessmentMetadataDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListControlsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListControlsInput(controlType: \(String(describing: controlType)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListControlsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListControlsInputHeadersMiddleware: Middleware {
    public let id: String = "ListControlsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListControlsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListControlsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListControlsInput>
    public typealias MOutput = OperationOutput<ListControlsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListControlsOutputError>
}

public struct ListControlsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListControlsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListControlsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListControlsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let controlType = input.operationInput.controlType {
            let controlTypeQueryItem = URLQueryItem(name: "controlType".urlPercentEncoding(), value: String(controlType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(controlTypeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListControlsInput>
    public typealias MOutput = OperationOutput<ListControlsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListControlsOutputError>
}

public struct ListControlsInput: Equatable {
    /// <p>
    /// The type of control, such as standard or custom.
    /// </p>
    public let controlType: ControlType?
    /// <p>
    ///    Represents the maximum number of results per page, or per API request call.
    /// </p>
    public let maxResults: Int?
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?

    public init (
        controlType: ControlType? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.controlType = controlType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListControlsInputBody: Equatable {
}

extension ListControlsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListControlsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListControlsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListControlsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListControlsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListControlsOutputResponse(controlMetadataList: \(String(describing: controlMetadataList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListControlsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListControlsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.controlMetadataList = output.controlMetadataList
            self.nextToken = output.nextToken
        } else {
            self.controlMetadataList = nil
            self.nextToken = nil
        }
    }
}

public struct ListControlsOutputResponse: Equatable {
    /// <p>
    ///    The list of control metadata objects returned by the <code>ListControls</code> API.
    /// </p>
    public let controlMetadataList: [ControlMetadata]?
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?

    public init (
        controlMetadataList: [ControlMetadata]? = nil,
        nextToken: String? = nil
    )
    {
        self.controlMetadataList = controlMetadataList
        self.nextToken = nextToken
    }
}

struct ListControlsOutputResponseBody: Equatable {
    public let controlMetadataList: [ControlMetadata]?
    public let nextToken: String?
}

extension ListControlsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case controlMetadataList
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlMetadataListContainer = try containerValues.decodeIfPresent([ControlMetadata?].self, forKey: .controlMetadataList)
        var controlMetadataListDecoded0:[ControlMetadata]? = nil
        if let controlMetadataListContainer = controlMetadataListContainer {
            controlMetadataListDecoded0 = [ControlMetadata]()
            for structure0 in controlMetadataListContainer {
                if let structure0 = structure0 {
                    controlMetadataListDecoded0?.append(structure0)
                }
            }
        }
        controlMetadataList = controlMetadataListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListKeywordsForDataSourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListKeywordsForDataSourceInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), source: \(String(describing: source)))"}
}

extension ListKeywordsForDataSourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListKeywordsForDataSourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListKeywordsForDataSourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListKeywordsForDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListKeywordsForDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListKeywordsForDataSourceInput>
    public typealias MOutput = OperationOutput<ListKeywordsForDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListKeywordsForDataSourceOutputError>
}

public struct ListKeywordsForDataSourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListKeywordsForDataSourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListKeywordsForDataSourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListKeywordsForDataSourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let source = input.operationInput.source {
            let sourceQueryItem = URLQueryItem(name: "source".urlPercentEncoding(), value: String(source.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(sourceQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListKeywordsForDataSourceInput>
    public typealias MOutput = OperationOutput<ListKeywordsForDataSourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListKeywordsForDataSourceOutputError>
}

public struct ListKeywordsForDataSourceInput: Equatable {
    /// <p>
    ///    Represents the maximum number of results per page, or per API request call.
    /// </p>
    public let maxResults: Int?
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?
    /// <p>
    /// The control mapping data source to which the keywords apply.
    /// </p>
    public let source: SourceType?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        source: SourceType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.source = source
    }
}

struct ListKeywordsForDataSourceInputBody: Equatable {
}

extension ListKeywordsForDataSourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListKeywordsForDataSourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListKeywordsForDataSourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListKeywordsForDataSourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListKeywordsForDataSourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListKeywordsForDataSourceOutputResponse(keywords: \(String(describing: keywords)), nextToken: \(String(describing: nextToken)))"}
}

extension ListKeywordsForDataSourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListKeywordsForDataSourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.keywords = output.keywords
            self.nextToken = output.nextToken
        } else {
            self.keywords = nil
            self.nextToken = nil
        }
    }
}

public struct ListKeywordsForDataSourceOutputResponse: Equatable {
    /// <p>
    ///    The list of keywords for the specified event mapping source.
    /// </p>
    public let keywords: [String]?
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?

    public init (
        keywords: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.keywords = keywords
        self.nextToken = nextToken
    }
}

struct ListKeywordsForDataSourceOutputResponseBody: Equatable {
    public let keywords: [String]?
    public let nextToken: String?
}

extension ListKeywordsForDataSourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case keywords
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keywordsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .keywords)
        var keywordsDecoded0:[String]? = nil
        if let keywordsContainer = keywordsContainer {
            keywordsDecoded0 = [String]()
            for string0 in keywordsContainer {
                if let string0 = string0 {
                    keywordsDecoded0?.append(string0)
                }
            }
        }
        keywords = keywordsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListNotificationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListNotificationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListNotificationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListNotificationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListNotificationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNotificationsInput>
    public typealias MOutput = OperationOutput<ListNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNotificationsOutputError>
}

public struct ListNotificationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListNotificationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListNotificationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListNotificationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListNotificationsInput>
    public typealias MOutput = OperationOutput<ListNotificationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListNotificationsOutputError>
}

public struct ListNotificationsInput: Equatable {
    /// <p>
    ///   Represents the maximum number of results per page, or per API request call.
    /// </p>
    public let maxResults: Int?
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListNotificationsInputBody: Equatable {
}

extension ListNotificationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListNotificationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListNotificationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListNotificationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListNotificationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListNotificationsOutputResponse(nextToken: \(String(describing: nextToken)), notifications: \(String(describing: notifications)))"}
}

extension ListNotificationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListNotificationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.notifications = output.notifications
        } else {
            self.nextToken = nil
            self.notifications = nil
        }
    }
}

public struct ListNotificationsOutputResponse: Equatable {
    /// <p>
    ///    The pagination token used to fetch the next set of results.
    /// </p>
    public let nextToken: String?
    /// <p>
    ///  The returned list of notifications.
    /// </p>
    public let notifications: [Notification]?

    public init (
        nextToken: String? = nil,
        notifications: [Notification]? = nil
    )
    {
        self.nextToken = nextToken
        self.notifications = notifications
    }
}

struct ListNotificationsOutputResponseBody: Equatable {
    public let notifications: [Notification]?
    public let nextToken: String?
}

extension ListNotificationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case notifications
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationsContainer = try containerValues.decodeIfPresent([Notification?].self, forKey: .notifications)
        var notificationsDecoded0:[Notification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [Notification]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>
    ///    The Amazon Resource Name (ARN) of the specified resource.
    /// </p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>
    ///    The list of tags returned by the <code>ListTagsForResource</code> API.
    /// </p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ManualEvidence: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3ResourcePath
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3ResourcePath = s3ResourcePath {
            try encodeContainer.encode(s3ResourcePath, forKey: .s3ResourcePath)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ResourcePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3ResourcePath)
        s3ResourcePath = s3ResourcePathDecoded
    }
}

extension ManualEvidence: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ManualEvidence(s3ResourcePath: \(String(describing: s3ResourcePath)))"}
}

/// <p>
///    Evidence that is uploaded to AWS Audit Manager manually.
/// </p>
public struct ManualEvidence: Equatable {
    /// <p>
    ///    The Amazon S3 URL that points to a manual evidence object.
    /// </p>
    public let s3ResourcePath: String?

    public init (
        s3ResourcePath: String? = nil
    )
    {
        self.s3ResourcePath = s3ResourcePath
    }
}

extension Notification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentId
        case assessmentName
        case controlSetId
        case controlSetName
        case description
        case eventTime
        case id
        case source
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentId = assessmentId {
            try encodeContainer.encode(assessmentId, forKey: .assessmentId)
        }
        if let assessmentName = assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let controlSetId = controlSetId {
            try encodeContainer.encode(controlSetId, forKey: .controlSetId)
        }
        if let controlSetName = controlSetName {
            try encodeContainer.encode(controlSetName, forKey: .controlSetName)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventTime = eventTime {
            try encodeContainer.encode(eventTime.timeIntervalSince1970, forKey: .eventTime)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let assessmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
        let assessmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let controlSetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .controlSetId)
        controlSetId = controlSetIdDecoded
        let controlSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .controlSetName)
        controlSetName = controlSetNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let eventTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension Notification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Notification(assessmentId: \(String(describing: assessmentId)), assessmentName: \(String(describing: assessmentName)), controlSetId: \(String(describing: controlSetId)), controlSetName: \(String(describing: controlSetName)), description: \(String(describing: description)), eventTime: \(String(describing: eventTime)), id: \(String(describing: id)), source: \(String(describing: source)))"}
}

/// <p>
///    The notification used to inform a user of an update in AWS Audit Manager. For example, this includes the notification that is sent when a control set is delegated for review.
/// </p>
public struct Notification: Equatable {
    /// <p>
    ///    The identifier for the specified assessment.
    /// </p>
    public let assessmentId: String?
    /// <p>
    ///  The name of the related assessment.
    /// </p>
    public let assessmentName: String?
    /// <p>
    ///    The identifier for the specified control set.
    /// </p>
    public let controlSetId: String?
    /// <p>
    ///          Specifies the name of the control set that the notification is about.
    ///       </p>
    public let controlSetName: String?
    /// <p>
    ///  The description of the notification.
    /// </p>
    public let description: String?
    /// <p>
    ///          The time when the notification was sent.
    ///       </p>
    public let eventTime: Date?
    /// <p>
    ///  The unique identifier for the notification.
    /// </p>
    public let id: String?
    /// <p>
    ///  The sender of the notification.
    /// </p>
    public let source: String?

    public init (
        assessmentId: String? = nil,
        assessmentName: String? = nil,
        controlSetId: String? = nil,
        controlSetName: String? = nil,
        description: String? = nil,
        eventTime: Date? = nil,
        id: String? = nil,
        source: String? = nil
    )
    {
        self.assessmentId = assessmentId
        self.assessmentName = assessmentName
        self.controlSetId = controlSetId
        self.controlSetName = controlSetName
        self.description = description
        self.eventTime = eventTime
        self.id = id
        self.source = source
    }
}

public enum ObjectTypeEnum {
    case assessment
    case assessmentReport
    case control
    case controlSet
    case delegation
    case sdkUnknown(String)
}

extension ObjectTypeEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ObjectTypeEnum] {
        return [
            .assessment,
            .assessmentReport,
            .control,
            .controlSet,
            .delegation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .assessment: return "ASSESSMENT"
        case .assessmentReport: return "ASSESSMENT_REPORT"
        case .control: return "CONTROL"
        case .controlSet: return "CONTROL_SET"
        case .delegation: return "DELEGATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ObjectTypeEnum(rawValue: rawValue) ?? ObjectTypeEnum.sdkUnknown(rawValue)
    }
}

public struct RegisterAccountInputBodyMiddleware: Middleware {
    public let id: String = "RegisterAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterAccountInput>
    public typealias MOutput = OperationOutput<RegisterAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterAccountOutputError>
}

extension RegisterAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterAccountInput(delegatedAdminAccount: \(String(describing: delegatedAdminAccount)), kmsKey: \(String(describing: kmsKey)))"}
}

extension RegisterAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case delegatedAdminAccount
        case kmsKey
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delegatedAdminAccount = delegatedAdminAccount {
            try encodeContainer.encode(delegatedAdminAccount, forKey: .delegatedAdminAccount)
        }
        if let kmsKey = kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
    }
}

public struct RegisterAccountInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterAccountInput>
    public typealias MOutput = OperationOutput<RegisterAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterAccountOutputError>
}

public struct RegisterAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterAccountInput>
    public typealias MOutput = OperationOutput<RegisterAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterAccountOutputError>
}

public struct RegisterAccountInput: Equatable {
    /// <p>
    ///    The delegated administrator account for AWS Audit Manager.
    /// </p>
    public let delegatedAdminAccount: String?
    /// <p>
    ///    The AWS KMS key details.
    /// </p>
    public let kmsKey: String?

    public init (
        delegatedAdminAccount: String? = nil,
        kmsKey: String? = nil
    )
    {
        self.delegatedAdminAccount = delegatedAdminAccount
        self.kmsKey = kmsKey
    }
}

struct RegisterAccountInputBody: Equatable {
    public let kmsKey: String?
    public let delegatedAdminAccount: String?
}

extension RegisterAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case delegatedAdminAccount
        case kmsKey
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
        let delegatedAdminAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .delegatedAdminAccount)
        delegatedAdminAccount = delegatedAdminAccountDecoded
    }
}

extension RegisterAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterAccountOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterAccountOutputResponse(status: \(String(describing: status)))"}
}

extension RegisterAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct RegisterAccountOutputResponse: Equatable {
    /// <p>
    ///  The status of the account registration request.
    /// </p>
    public let status: AccountStatus?

    public init (
        status: AccountStatus? = nil
    )
    {
        self.status = status
    }
}

struct RegisterAccountOutputResponseBody: Equatable {
    public let status: AccountStatus?
}

extension RegisterAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AccountStatus.self, forKey: .status)
        status = statusDecoded
    }
}

public struct RegisterOrganizationAdminAccountInputBodyMiddleware: Middleware {
    public let id: String = "RegisterOrganizationAdminAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<RegisterOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterOrganizationAdminAccountOutputError>
}

extension RegisterOrganizationAdminAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterOrganizationAdminAccountInput(adminAccountId: \(String(describing: adminAccountId)))"}
}

extension RegisterOrganizationAdminAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adminAccountId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
    }
}

public struct RegisterOrganizationAdminAccountInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterOrganizationAdminAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<RegisterOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterOrganizationAdminAccountOutputError>
}

public struct RegisterOrganizationAdminAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterOrganizationAdminAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterOrganizationAdminAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterOrganizationAdminAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterOrganizationAdminAccountInput>
    public typealias MOutput = OperationOutput<RegisterOrganizationAdminAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterOrganizationAdminAccountOutputError>
}

public struct RegisterOrganizationAdminAccountInput: Equatable {
    /// <p>
    ///    The identifier for the specified delegated administrator account.
    /// </p>
    public let adminAccountId: String?

    public init (
        adminAccountId: String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

struct RegisterOrganizationAdminAccountInputBody: Equatable {
    public let adminAccountId: String?
}

extension RegisterOrganizationAdminAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adminAccountId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
    }
}

extension RegisterOrganizationAdminAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterOrganizationAdminAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterOrganizationAdminAccountOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterOrganizationAdminAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterOrganizationAdminAccountOutputResponse(adminAccountId: \(String(describing: adminAccountId)), organizationId: \(String(describing: organizationId)))"}
}

extension RegisterOrganizationAdminAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterOrganizationAdminAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.adminAccountId = output.adminAccountId
            self.organizationId = output.organizationId
        } else {
            self.adminAccountId = nil
            self.organizationId = nil
        }
    }
}

public struct RegisterOrganizationAdminAccountOutputResponse: Equatable {
    /// <p>
    ///    The identifier for the specified delegated administrator account.
    /// </p>
    public let adminAccountId: String?
    /// <p>
    ///    The identifier for the specified AWS organization.
    /// </p>
    public let organizationId: String?

    public init (
        adminAccountId: String? = nil,
        organizationId: String? = nil
    )
    {
        self.adminAccountId = adminAccountId
        self.organizationId = organizationId
    }
}

struct RegisterOrganizationAdminAccountOutputResponseBody: Equatable {
    public let adminAccountId: String?
    public let organizationId: String?
}

extension RegisterOrganizationAdminAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case adminAccountId
        case organizationId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension Resource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Resource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Resource(arn: \(String(describing: arn)), value: \(String(describing: value)))"}
}

/// <p>
///       A system asset that is evaluated in an AWS Audit Manager assessment.
///     </p>
public struct Resource: Equatable {
    /// <p>
    ///  The Amazon Resource Name (ARN) for the specified resource.
    ///     </p>
    public let arn: String?
    /// <p>
    ///   The value of the specified resource.
    ///     </p>
    public let value: String?

    public init (
        arn: String? = nil,
        value: String? = nil
    )
    {
        self.arn = arn
        self.value = value
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///   The resource specified in the request cannot be found.
/// </p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>
    ///       The unique identifier for the specified resource.
    ///       </p>
    public var resourceId: String?
    /// <p>
    ///          The type of resource affected by the error.
    ///       </p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension Role: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleArn
        case roleType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let roleType = roleType {
            try encodeContainer.encode(roleType.rawValue, forKey: .roleType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleTypeDecoded = try containerValues.decodeIfPresent(RoleType.self, forKey: .roleType)
        roleType = roleTypeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension Role: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Role(roleArn: \(String(describing: roleArn)), roleType: \(String(describing: roleType)))"}
}

/// <p>
///      The wrapper that contains the AWS Audit Manager role information of the current user, such as the role type and IAM Amazon Resource Name (ARN).
///   </p>
public struct Role: Equatable {
    /// <p>
    ///    The Amazon Resource Name (ARN) of the IAM role.
    /// </p>
    public let roleArn: String?
    /// <p>
    ///    The type of customer persona.
    /// </p>
    ///          <note>
    ///             <p>In <code>CreateAssessment</code>, <code>roleType</code> can only be <code>PROCESS_OWNER</code>. </p>
    ///             <p>In <code>UpdateSettings</code>, <code>roleType</code> can only be <code>PROCESS_OWNER</code>.</p>
    ///             <p>In <code>BatchCreateDelegationByAssessment</code>, <code>roleType</code> can only be <code>RESOURCE_OWNER</code>.</p>
    ///          </note>
    public let roleType: RoleType?

    public init (
        roleArn: String? = nil,
        roleType: RoleType? = nil
    )
    {
        self.roleArn = roleArn
        self.roleType = roleType
    }
}

public enum RoleType {
    case processOwner
    case resourceOwner
    case sdkUnknown(String)
}

extension RoleType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RoleType] {
        return [
            .processOwner,
            .resourceOwner,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .processOwner: return "PROCESS_OWNER"
        case .resourceOwner: return "RESOURCE_OWNER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RoleType(rawValue: rawValue) ?? RoleType.sdkUnknown(rawValue)
    }
}

extension Scope: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsAccounts
        case awsServices
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccounts = awsAccounts {
            var awsAccountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsAccounts)
            for awsaccounts0 in awsAccounts {
                try awsAccountsContainer.encode(awsaccounts0)
            }
        }
        if let awsServices = awsServices {
            var awsServicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsServices)
            for awsservices0 in awsServices {
                try awsServicesContainer.encode(awsservices0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountsContainer = try containerValues.decodeIfPresent([AWSAccount?].self, forKey: .awsAccounts)
        var awsAccountsDecoded0:[AWSAccount]? = nil
        if let awsAccountsContainer = awsAccountsContainer {
            awsAccountsDecoded0 = [AWSAccount]()
            for structure0 in awsAccountsContainer {
                if let structure0 = structure0 {
                    awsAccountsDecoded0?.append(structure0)
                }
            }
        }
        awsAccounts = awsAccountsDecoded0
        let awsServicesContainer = try containerValues.decodeIfPresent([AWSService?].self, forKey: .awsServices)
        var awsServicesDecoded0:[AWSService]? = nil
        if let awsServicesContainer = awsServicesContainer {
            awsServicesDecoded0 = [AWSService]()
            for structure0 in awsServicesContainer {
                if let structure0 = structure0 {
                    awsServicesDecoded0?.append(structure0)
                }
            }
        }
        awsServices = awsServicesDecoded0
    }
}

extension Scope: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Scope(awsAccounts: \(String(describing: awsAccounts)), awsServices: \(String(describing: awsServices)))"}
}

/// <p>
///    The wrapper that contains the AWS accounts and AWS services in scope for the assessment.
/// </p>
public struct Scope: Equatable {
    /// <p>
    ///  The AWS accounts included in the scope of the assessment.
    /// </p>
    public let awsAccounts: [AWSAccount]?
    /// <p>
    ///  The AWS services included in the scope of the assessment.
    /// </p>
    public let awsServices: [AWSService]?

    public init (
        awsAccounts: [AWSAccount]? = nil,
        awsServices: [AWSService]? = nil
    )
    {
        self.awsAccounts = awsAccounts
        self.awsServices = awsServices
    }
}

extension ServiceMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case category
        case description
        case displayName
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .category)
        category = categoryDecoded
    }
}

extension ServiceMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceMetadata(category: \(String(describing: category)), description: \(String(describing: description)), displayName: \(String(describing: displayName)), name: \(String(describing: name)))"}
}

/// <p>
///    The metadata associated with the specified AWS service.
/// </p>
public struct ServiceMetadata: Equatable {
    /// <p>
    ///    The category in which the AWS service belongs, such as compute, storage, database, and so on.
    /// </p>
    public let category: String?
    /// <p>
    ///    The description of the specified AWS service.
    /// </p>
    public let description: String?
    /// <p>
    /// The display name of the AWS service.
    /// </p>
    public let displayName: String?
    /// <p>
    /// The name of the AWS service.
    /// </p>
    public let name: String?

    public init (
        category: String? = nil,
        description: String? = nil,
        displayName: String? = nil,
        name: String? = nil
    )
    {
        self.category = category
        self.description = description
        self.displayName = displayName
        self.name = name
    }
}

public enum SettingAttribute {
    case all
    case defaultAssessmentReportsDestination
    case defaultProcessOwners
    case isAwsOrgEnabled
    case snsTopic
    case sdkUnknown(String)
}

extension SettingAttribute : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SettingAttribute] {
        return [
            .all,
            .defaultAssessmentReportsDestination,
            .defaultProcessOwners,
            .isAwsOrgEnabled,
            .snsTopic,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .defaultAssessmentReportsDestination: return "DEFAULT_ASSESSMENT_REPORTS_DESTINATION"
        case .defaultProcessOwners: return "DEFAULT_PROCESS_OWNERS"
        case .isAwsOrgEnabled: return "IS_AWS_ORG_ENABLED"
        case .snsTopic: return "SNS_TOPIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SettingAttribute(rawValue: rawValue) ?? SettingAttribute.sdkUnknown(rawValue)
    }
}

extension Settings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultAssessmentReportsDestination
        case defaultProcessOwners
        case isAwsOrgEnabled
        case kmsKey
        case snsTopic
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultAssessmentReportsDestination = defaultAssessmentReportsDestination {
            try encodeContainer.encode(defaultAssessmentReportsDestination, forKey: .defaultAssessmentReportsDestination)
        }
        if let defaultProcessOwners = defaultProcessOwners {
            var defaultProcessOwnersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultProcessOwners)
            for roles0 in defaultProcessOwners {
                try defaultProcessOwnersContainer.encode(roles0)
            }
        }
        if let isAwsOrgEnabled = isAwsOrgEnabled {
            try encodeContainer.encode(isAwsOrgEnabled, forKey: .isAwsOrgEnabled)
        }
        if let kmsKey = kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let snsTopic = snsTopic {
            try encodeContainer.encode(snsTopic, forKey: .snsTopic)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isAwsOrgEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .isAwsOrgEnabled)
        isAwsOrgEnabled = isAwsOrgEnabledDecoded
        let snsTopicDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopic)
        snsTopic = snsTopicDecoded
        let defaultAssessmentReportsDestinationDecoded = try containerValues.decodeIfPresent(AssessmentReportsDestination.self, forKey: .defaultAssessmentReportsDestination)
        defaultAssessmentReportsDestination = defaultAssessmentReportsDestinationDecoded
        let defaultProcessOwnersContainer = try containerValues.decodeIfPresent([Role?].self, forKey: .defaultProcessOwners)
        var defaultProcessOwnersDecoded0:[Role]? = nil
        if let defaultProcessOwnersContainer = defaultProcessOwnersContainer {
            defaultProcessOwnersDecoded0 = [Role]()
            for structure0 in defaultProcessOwnersContainer {
                if let structure0 = structure0 {
                    defaultProcessOwnersDecoded0?.append(structure0)
                }
            }
        }
        defaultProcessOwners = defaultProcessOwnersDecoded0
        let kmsKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
    }
}

extension Settings: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Settings(defaultAssessmentReportsDestination: \(String(describing: defaultAssessmentReportsDestination)), defaultProcessOwners: \(String(describing: defaultProcessOwners)), isAwsOrgEnabled: \(String(describing: isAwsOrgEnabled)), kmsKey: \(String(describing: kmsKey)), snsTopic: \(String(describing: snsTopic)))"}
}

/// <p>
///    The settings object that holds all supported AWS Audit Manager settings.
/// </p>
public struct Settings: Equatable {
    /// <p>
    ///    The default storage destination for assessment reports.
    /// </p>
    public let defaultAssessmentReportsDestination: AssessmentReportsDestination?
    /// <p>
    ///  The designated default audit owners.
    /// </p>
    public let defaultProcessOwners: [Role]?
    /// <p>
    ///  Specifies whether AWS Organizations is enabled.
    /// </p>
    public let isAwsOrgEnabled: Bool?
    /// <p>
    ///          The AWS KMS key details.
    ///       </p>
    public let kmsKey: String?
    /// <p>
    ///  The designated Amazon Simple Notification Service (Amazon SNS) topic.
    /// </p>
    public let snsTopic: String?

    public init (
        defaultAssessmentReportsDestination: AssessmentReportsDestination? = nil,
        defaultProcessOwners: [Role]? = nil,
        isAwsOrgEnabled: Bool? = nil,
        kmsKey: String? = nil,
        snsTopic: String? = nil
    )
    {
        self.defaultAssessmentReportsDestination = defaultAssessmentReportsDestination
        self.defaultProcessOwners = defaultProcessOwners
        self.isAwsOrgEnabled = isAwsOrgEnabled
        self.kmsKey = kmsKey
        self.snsTopic = snsTopic
    }
}

public enum SourceFrequency {
    case daily
    case monthly
    case weekly
    case sdkUnknown(String)
}

extension SourceFrequency : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SourceFrequency] {
        return [
            .daily,
            .monthly,
            .weekly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .daily: return "DAILY"
        case .monthly: return "MONTHLY"
        case .weekly: return "WEEKLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SourceFrequency(rawValue: rawValue) ?? SourceFrequency.sdkUnknown(rawValue)
    }
}

extension SourceKeyword: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case keywordInputType
        case keywordValue
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let keywordInputType = keywordInputType {
            try encodeContainer.encode(keywordInputType.rawValue, forKey: .keywordInputType)
        }
        if let keywordValue = keywordValue {
            try encodeContainer.encode(keywordValue, forKey: .keywordValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keywordInputTypeDecoded = try containerValues.decodeIfPresent(KeywordInputType.self, forKey: .keywordInputType)
        keywordInputType = keywordInputTypeDecoded
        let keywordValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keywordValue)
        keywordValue = keywordValueDecoded
    }
}

extension SourceKeyword: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceKeyword(keywordInputType: \(String(describing: keywordInputType)), keywordValue: \(String(describing: keywordValue)))"}
}

/// <p>
/// The keyword to search for in AWS CloudTrail logs, AWS Config rules, AWS Security Hub checks, and AWS API names.
/// </p>
public struct SourceKeyword: Equatable {
    /// <p>
    /// The method of input for the specified keyword.
    /// </p>
    public let keywordInputType: KeywordInputType?
    /// <p>
    /// The value of the keyword used to search AWS CloudTrail logs, AWS Config rules, AWS Security Hub checks, and AWS API names when mapping a control data source.
    /// </p>
    public let keywordValue: String?

    public init (
        keywordInputType: KeywordInputType? = nil,
        keywordValue: String? = nil
    )
    {
        self.keywordInputType = keywordInputType
        self.keywordValue = keywordValue
    }
}

public enum SourceSetUpOption {
    case proceduralControlsMapping
    case systemControlsMapping
    case sdkUnknown(String)
}

extension SourceSetUpOption : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SourceSetUpOption] {
        return [
            .proceduralControlsMapping,
            .systemControlsMapping,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .proceduralControlsMapping: return "Procedural_Controls_Mapping"
        case .systemControlsMapping: return "System_Controls_Mapping"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SourceSetUpOption(rawValue: rawValue) ?? SourceSetUpOption.sdkUnknown(rawValue)
    }
}

public enum SourceType {
    case awsApiCall
    case awsCloudtrail
    case awsConfig
    case awsSecurityHub
    case manual
    case sdkUnknown(String)
}

extension SourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SourceType] {
        return [
            .awsApiCall,
            .awsCloudtrail,
            .awsConfig,
            .awsSecurityHub,
            .manual,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .awsApiCall: return "AWS_API_Call"
        case .awsCloudtrail: return "AWS_Cloudtrail"
        case .awsConfig: return "AWS_Config"
        case .awsSecurityHub: return "AWS_Security_Hub"
        case .manual: return "MANUAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>
    ///    The Amazon Resource Name (ARN) of the specified resource.
    /// </p>
    public let resourceArn: String?
    /// <p>
    /// The tags to be associated with the resource.
    /// </p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension URL: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hyperlinkName
        case link
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hyperlinkName = hyperlinkName {
            try encodeContainer.encode(hyperlinkName, forKey: .hyperlinkName)
        }
        if let link = link {
            try encodeContainer.encode(link, forKey: .link)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hyperlinkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hyperlinkName)
        hyperlinkName = hyperlinkNameDecoded
        let linkDecoded = try containerValues.decodeIfPresent(String.self, forKey: .link)
        link = linkDecoded
    }
}

extension URL: CustomDebugStringConvertible {
    public var debugDescription: String {
        "URL(hyperlinkName: \(String(describing: hyperlinkName)), link: \(String(describing: link)))"}
}

/// <p>
///    A uniform resource locator, used as a unique identifier to locate a resource on the internet.
/// </p>
public struct URL: Equatable {
    /// <p>
    ///    The name or word used as a hyperlink to the URL.
    /// </p>
    public let hyperlinkName: String?
    /// <p>
    ///    The unique identifier for the internet resource.
    /// </p>
    public let link: String?

    public init (
        hyperlinkName: String? = nil,
        link: String? = nil
    )
    {
        self.hyperlinkName = hyperlinkName
        self.link = link
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>
    ///    The Amazon Resource Name (ARN) of the specified resource.
    /// </p>
    public let resourceArn: String?
    /// <p>
    ///    The name or key of the tag.
    /// </p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAssessmentControlInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAssessmentControlInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssessmentControlInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssessmentControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssessmentControlInput>
    public typealias MOutput = OperationOutput<UpdateAssessmentControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssessmentControlOutputError>
}

extension UpdateAssessmentControlInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssessmentControlInput(assessmentId: \(String(describing: assessmentId)), commentBody: \(String(describing: commentBody)), controlId: \(String(describing: controlId)), controlSetId: \(String(describing: controlSetId)), controlStatus: \(String(describing: controlStatus)))"}
}

extension UpdateAssessmentControlInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case commentBody
        case controlStatus
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commentBody = commentBody {
            try encodeContainer.encode(commentBody, forKey: .commentBody)
        }
        if let controlStatus = controlStatus {
            try encodeContainer.encode(controlStatus.rawValue, forKey: .controlStatus)
        }
    }
}

public struct UpdateAssessmentControlInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAssessmentControlInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssessmentControlInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssessmentControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssessmentControlInput>
    public typealias MOutput = OperationOutput<UpdateAssessmentControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssessmentControlOutputError>
}

public struct UpdateAssessmentControlInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAssessmentControlInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssessmentControlInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssessmentControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssessmentControlInput>
    public typealias MOutput = OperationOutput<UpdateAssessmentControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssessmentControlOutputError>
}

public struct UpdateAssessmentControlInput: Equatable {
    /// <p>
    ///    The identifier for the specified assessment.
    /// </p>
    public let assessmentId: String?
    /// <p>
    ///    The comment body text for the specified control.
    /// </p>
    public let commentBody: String?
    /// <p>
    ///
    ///    The identifier for the specified control.
    /// </p>
    public let controlId: String?
    /// <p>
    ///    The identifier for the specified control set.
    /// </p>
    public let controlSetId: String?
    /// <p>
    ///    The status of the specified control.
    /// </p>
    public let controlStatus: ControlStatus?

    public init (
        assessmentId: String? = nil,
        commentBody: String? = nil,
        controlId: String? = nil,
        controlSetId: String? = nil,
        controlStatus: ControlStatus? = nil
    )
    {
        self.assessmentId = assessmentId
        self.commentBody = commentBody
        self.controlId = controlId
        self.controlSetId = controlSetId
        self.controlStatus = controlStatus
    }
}

struct UpdateAssessmentControlInputBody: Equatable {
    public let controlStatus: ControlStatus?
    public let commentBody: String?
}

extension UpdateAssessmentControlInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case commentBody
        case controlStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlStatusDecoded = try containerValues.decodeIfPresent(ControlStatus.self, forKey: .controlStatus)
        controlStatus = controlStatusDecoded
        let commentBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .commentBody)
        commentBody = commentBodyDecoded
    }
}

extension UpdateAssessmentControlOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssessmentControlOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssessmentControlOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssessmentControlOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssessmentControlOutputResponse(control: \(String(describing: control)))"}
}

extension UpdateAssessmentControlOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAssessmentControlOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.control = output.control
        } else {
            self.control = nil
        }
    }
}

public struct UpdateAssessmentControlOutputResponse: Equatable {
    /// <p>
    ///    The name of the updated control set returned by the <code>UpdateAssessmentControl</code> API.
    /// </p>
    public let control: AssessmentControl?

    public init (
        control: AssessmentControl? = nil
    )
    {
        self.control = control
    }
}

struct UpdateAssessmentControlOutputResponseBody: Equatable {
    public let control: AssessmentControl?
}

extension UpdateAssessmentControlOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case control
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlDecoded = try containerValues.decodeIfPresent(AssessmentControl.self, forKey: .control)
        control = controlDecoded
    }
}

public struct UpdateAssessmentControlSetStatusInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAssessmentControlSetStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssessmentControlSetStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssessmentControlSetStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssessmentControlSetStatusInput>
    public typealias MOutput = OperationOutput<UpdateAssessmentControlSetStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssessmentControlSetStatusOutputError>
}

extension UpdateAssessmentControlSetStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssessmentControlSetStatusInput(assessmentId: \(String(describing: assessmentId)), comment: \(String(describing: comment)), controlSetId: \(String(describing: controlSetId)), status: \(String(describing: status)))"}
}

extension UpdateAssessmentControlSetStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comment
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comment = comment {
            try encodeContainer.encode(comment, forKey: .comment)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct UpdateAssessmentControlSetStatusInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAssessmentControlSetStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssessmentControlSetStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssessmentControlSetStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssessmentControlSetStatusInput>
    public typealias MOutput = OperationOutput<UpdateAssessmentControlSetStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssessmentControlSetStatusOutputError>
}

public struct UpdateAssessmentControlSetStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAssessmentControlSetStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssessmentControlSetStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssessmentControlSetStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssessmentControlSetStatusInput>
    public typealias MOutput = OperationOutput<UpdateAssessmentControlSetStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssessmentControlSetStatusOutputError>
}

public struct UpdateAssessmentControlSetStatusInput: Equatable {
    /// <p>
    ///    The identifier for the specified assessment.
    /// </p>
    public let assessmentId: String?
    /// <p>
    ///    The comment related to the status update.
    /// </p>
    public let comment: String?
    /// <p>
    ///    The identifier for the specified control set.
    /// </p>
    public let controlSetId: String?
    /// <p>
    /// The status of the control set that is being updated.
    /// </p>
    public let status: ControlSetStatus?

    public init (
        assessmentId: String? = nil,
        comment: String? = nil,
        controlSetId: String? = nil,
        status: ControlSetStatus? = nil
    )
    {
        self.assessmentId = assessmentId
        self.comment = comment
        self.controlSetId = controlSetId
        self.status = status
    }
}

struct UpdateAssessmentControlSetStatusInputBody: Equatable {
    public let status: ControlSetStatus?
    public let comment: String?
}

extension UpdateAssessmentControlSetStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case comment
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ControlSetStatus.self, forKey: .status)
        status = statusDecoded
        let commentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comment)
        comment = commentDecoded
    }
}

extension UpdateAssessmentControlSetStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssessmentControlSetStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssessmentControlSetStatusOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssessmentControlSetStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssessmentControlSetStatusOutputResponse(controlSet: \(String(describing: controlSet)))"}
}

extension UpdateAssessmentControlSetStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAssessmentControlSetStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.controlSet = output.controlSet
        } else {
            self.controlSet = nil
        }
    }
}

public struct UpdateAssessmentControlSetStatusOutputResponse: Equatable {
    /// <p>
    ///    The name of the updated control set returned by the <code>UpdateAssessmentControlSetStatus</code> API.
    /// </p>
    public let controlSet: AssessmentControlSet?

    public init (
        controlSet: AssessmentControlSet? = nil
    )
    {
        self.controlSet = controlSet
    }
}

struct UpdateAssessmentControlSetStatusOutputResponseBody: Equatable {
    public let controlSet: AssessmentControlSet?
}

extension UpdateAssessmentControlSetStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case controlSet
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlSetDecoded = try containerValues.decodeIfPresent(AssessmentControlSet.self, forKey: .controlSet)
        controlSet = controlSetDecoded
    }
}

extension UpdateAssessmentFrameworkControlSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case controls
        case id
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let controls = controls {
            var controlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controls)
            for createassessmentframeworkcontrols0 in controls {
                try controlsContainer.encode(createassessmentframeworkcontrols0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let controlsContainer = try containerValues.decodeIfPresent([CreateAssessmentFrameworkControl?].self, forKey: .controls)
        var controlsDecoded0:[CreateAssessmentFrameworkControl]? = nil
        if let controlsContainer = controlsContainer {
            controlsDecoded0 = [CreateAssessmentFrameworkControl]()
            for structure0 in controlsContainer {
                if let structure0 = structure0 {
                    controlsDecoded0?.append(structure0)
                }
            }
        }
        controls = controlsDecoded0
    }
}

extension UpdateAssessmentFrameworkControlSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssessmentFrameworkControlSet(controls: \(String(describing: controls)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>
///    A <code>controlSet</code> entity that represents a collection of controls in AWS Audit Manager. This does not contain the control set ID.
/// </p>
public struct UpdateAssessmentFrameworkControlSet: Equatable {
    /// <p>
    /// The list of controls contained within the control set.
    /// </p>
    public let controls: [CreateAssessmentFrameworkControl]?
    /// <p>
    /// The unique identifier for the control set.
    /// </p>
    public let id: String?
    /// <p>
    /// The name of the control set.
    /// </p>
    public let name: String?

    public init (
        controls: [CreateAssessmentFrameworkControl]? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.controls = controls
        self.id = id
        self.name = name
    }
}

public struct UpdateAssessmentFrameworkInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAssessmentFrameworkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssessmentFrameworkInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssessmentFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssessmentFrameworkInput>
    public typealias MOutput = OperationOutput<UpdateAssessmentFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssessmentFrameworkOutputError>
}

extension UpdateAssessmentFrameworkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssessmentFrameworkInput(complianceType: \(String(describing: complianceType)), controlSets: \(String(describing: controlSets)), description: \(String(describing: description)), frameworkId: \(String(describing: frameworkId)), name: \(String(describing: name)))"}
}

extension UpdateAssessmentFrameworkInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case complianceType
        case controlSets
        case description
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let complianceType = complianceType {
            try encodeContainer.encode(complianceType, forKey: .complianceType)
        }
        if let controlSets = controlSets {
            var controlSetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlSets)
            for updateassessmentframeworkcontrolsets0 in controlSets {
                try controlSetsContainer.encode(updateassessmentframeworkcontrolsets0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateAssessmentFrameworkInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAssessmentFrameworkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssessmentFrameworkInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssessmentFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssessmentFrameworkInput>
    public typealias MOutput = OperationOutput<UpdateAssessmentFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssessmentFrameworkOutputError>
}

public struct UpdateAssessmentFrameworkInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAssessmentFrameworkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssessmentFrameworkInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssessmentFrameworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssessmentFrameworkInput>
    public typealias MOutput = OperationOutput<UpdateAssessmentFrameworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssessmentFrameworkOutputError>
}

public struct UpdateAssessmentFrameworkInput: Equatable {
    /// <p>
    ///    The compliance type that the new custom framework supports, such as CIS or HIPAA.
    /// </p>
    public let complianceType: String?
    /// <p>
    ///    The control sets associated with the framework.
    /// </p>
    public let controlSets: [UpdateAssessmentFrameworkControlSet]?
    /// <p>
    /// The description of the framework that is to be updated.
    /// </p>
    public let description: String?
    /// <p>
    ///    The identifier for the specified framework.
    /// </p>
    public let frameworkId: String?
    /// <p>
    /// The name of the framework to be updated.
    /// </p>
    public let name: String?

    public init (
        complianceType: String? = nil,
        controlSets: [UpdateAssessmentFrameworkControlSet]? = nil,
        description: String? = nil,
        frameworkId: String? = nil,
        name: String? = nil
    )
    {
        self.complianceType = complianceType
        self.controlSets = controlSets
        self.description = description
        self.frameworkId = frameworkId
        self.name = name
    }
}

struct UpdateAssessmentFrameworkInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let complianceType: String?
    public let controlSets: [UpdateAssessmentFrameworkControlSet]?
}

extension UpdateAssessmentFrameworkInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case complianceType
        case controlSets
        case description
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let complianceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .complianceType)
        complianceType = complianceTypeDecoded
        let controlSetsContainer = try containerValues.decodeIfPresent([UpdateAssessmentFrameworkControlSet?].self, forKey: .controlSets)
        var controlSetsDecoded0:[UpdateAssessmentFrameworkControlSet]? = nil
        if let controlSetsContainer = controlSetsContainer {
            controlSetsDecoded0 = [UpdateAssessmentFrameworkControlSet]()
            for structure0 in controlSetsContainer {
                if let structure0 = structure0 {
                    controlSetsDecoded0?.append(structure0)
                }
            }
        }
        controlSets = controlSetsDecoded0
    }
}

extension UpdateAssessmentFrameworkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssessmentFrameworkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssessmentFrameworkOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssessmentFrameworkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssessmentFrameworkOutputResponse(framework: \(String(describing: framework)))"}
}

extension UpdateAssessmentFrameworkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAssessmentFrameworkOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.framework = output.framework
        } else {
            self.framework = nil
        }
    }
}

public struct UpdateAssessmentFrameworkOutputResponse: Equatable {
    /// <p>
    /// The name of the specified framework.
    /// </p>
    public let framework: Framework?

    public init (
        framework: Framework? = nil
    )
    {
        self.framework = framework
    }
}

struct UpdateAssessmentFrameworkOutputResponseBody: Equatable {
    public let framework: Framework?
}

extension UpdateAssessmentFrameworkOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case framework
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let frameworkDecoded = try containerValues.decodeIfPresent(Framework.self, forKey: .framework)
        framework = frameworkDecoded
    }
}

public struct UpdateAssessmentInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAssessmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssessmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssessmentInput>
    public typealias MOutput = OperationOutput<UpdateAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssessmentOutputError>
}

extension UpdateAssessmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssessmentInput(assessmentDescription: \(String(describing: assessmentDescription)), assessmentId: \(String(describing: assessmentId)), assessmentName: \(String(describing: assessmentName)), assessmentReportsDestination: \(String(describing: assessmentReportsDestination)), roles: \(String(describing: roles)), scope: \(String(describing: scope)))"}
}

extension UpdateAssessmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentDescription
        case assessmentName
        case assessmentReportsDestination
        case roles
        case scope
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentDescription = assessmentDescription {
            try encodeContainer.encode(assessmentDescription, forKey: .assessmentDescription)
        }
        if let assessmentName = assessmentName {
            try encodeContainer.encode(assessmentName, forKey: .assessmentName)
        }
        if let assessmentReportsDestination = assessmentReportsDestination {
            try encodeContainer.encode(assessmentReportsDestination, forKey: .assessmentReportsDestination)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for roles0 in roles {
                try rolesContainer.encode(roles0)
            }
        }
        if let scope = scope {
            try encodeContainer.encode(scope, forKey: .scope)
        }
    }
}

public struct UpdateAssessmentInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAssessmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssessmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssessmentInput>
    public typealias MOutput = OperationOutput<UpdateAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssessmentOutputError>
}

public struct UpdateAssessmentInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAssessmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssessmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssessmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssessmentInput>
    public typealias MOutput = OperationOutput<UpdateAssessmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssessmentOutputError>
}

public struct UpdateAssessmentInput: Equatable {
    /// <p>
    ///  The description of the specified assessment.
    /// </p>
    public let assessmentDescription: String?
    /// <p>
    ///    The identifier for the specified assessment.
    /// </p>
    public let assessmentId: String?
    /// <p>
    ///  The name of the specified assessment to be updated.
    /// </p>
    public let assessmentName: String?
    /// <p>
    ///    The assessment report storage destination for the specified assessment that is being updated.
    /// </p>
    public let assessmentReportsDestination: AssessmentReportsDestination?
    /// <p>
    ///  The list of roles for the specified assessment.
    /// </p>
    public let roles: [Role]?
    /// <p>
    ///  The scope of the specified assessment.
    /// </p>
    public let scope: Scope?

    public init (
        assessmentDescription: String? = nil,
        assessmentId: String? = nil,
        assessmentName: String? = nil,
        assessmentReportsDestination: AssessmentReportsDestination? = nil,
        roles: [Role]? = nil,
        scope: Scope? = nil
    )
    {
        self.assessmentDescription = assessmentDescription
        self.assessmentId = assessmentId
        self.assessmentName = assessmentName
        self.assessmentReportsDestination = assessmentReportsDestination
        self.roles = roles
        self.scope = scope
    }
}

struct UpdateAssessmentInputBody: Equatable {
    public let assessmentName: String?
    public let assessmentDescription: String?
    public let scope: Scope?
    public let assessmentReportsDestination: AssessmentReportsDestination?
    public let roles: [Role]?
}

extension UpdateAssessmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentDescription
        case assessmentName
        case assessmentReportsDestination
        case roles
        case scope
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentName)
        assessmentName = assessmentNameDecoded
        let assessmentDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentDescription)
        assessmentDescription = assessmentDescriptionDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Scope.self, forKey: .scope)
        scope = scopeDecoded
        let assessmentReportsDestinationDecoded = try containerValues.decodeIfPresent(AssessmentReportsDestination.self, forKey: .assessmentReportsDestination)
        assessmentReportsDestination = assessmentReportsDestinationDecoded
        let rolesContainer = try containerValues.decodeIfPresent([Role?].self, forKey: .roles)
        var rolesDecoded0:[Role]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [Role]()
            for structure0 in rolesContainer {
                if let structure0 = structure0 {
                    rolesDecoded0?.append(structure0)
                }
            }
        }
        roles = rolesDecoded0
    }
}

extension UpdateAssessmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssessmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssessmentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssessmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssessmentOutputResponse(assessment: \(String(describing: assessment)))"}
}

extension UpdateAssessmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAssessmentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assessment = output.assessment
        } else {
            self.assessment = nil
        }
    }
}

public struct UpdateAssessmentOutputResponse: Equatable {
    /// <p>
    ///    The response object (name of the updated assessment) for the <code>UpdateAssessmentRequest</code> API.
    /// </p>
    public let assessment: Assessment?

    public init (
        assessment: Assessment? = nil
    )
    {
        self.assessment = assessment
    }
}

struct UpdateAssessmentOutputResponseBody: Equatable {
    public let assessment: Assessment?
}

extension UpdateAssessmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessment
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentDecoded = try containerValues.decodeIfPresent(Assessment.self, forKey: .assessment)
        assessment = assessmentDecoded
    }
}

public struct UpdateAssessmentStatusInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAssessmentStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssessmentStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssessmentStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssessmentStatusInput>
    public typealias MOutput = OperationOutput<UpdateAssessmentStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssessmentStatusOutputError>
}

extension UpdateAssessmentStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssessmentStatusInput(assessmentId: \(String(describing: assessmentId)), status: \(String(describing: status)))"}
}

extension UpdateAssessmentStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

public struct UpdateAssessmentStatusInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAssessmentStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssessmentStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssessmentStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssessmentStatusInput>
    public typealias MOutput = OperationOutput<UpdateAssessmentStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssessmentStatusOutputError>
}

public struct UpdateAssessmentStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAssessmentStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssessmentStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssessmentStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssessmentStatusInput>
    public typealias MOutput = OperationOutput<UpdateAssessmentStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssessmentStatusOutputError>
}

public struct UpdateAssessmentStatusInput: Equatable {
    /// <p>
    ///    The identifier for the specified assessment.
    /// </p>
    public let assessmentId: String?
    /// <p>
    ///    The current status of the specified assessment.
    /// </p>
    public let status: AssessmentStatus?

    public init (
        assessmentId: String? = nil,
        status: AssessmentStatus? = nil
    )
    {
        self.assessmentId = assessmentId
        self.status = status
    }
}

struct UpdateAssessmentStatusInputBody: Equatable {
    public let status: AssessmentStatus?
}

extension UpdateAssessmentStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AssessmentStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension UpdateAssessmentStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssessmentStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssessmentStatusOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssessmentStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssessmentStatusOutputResponse(assessment: \(String(describing: assessment)))"}
}

extension UpdateAssessmentStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAssessmentStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assessment = output.assessment
        } else {
            self.assessment = nil
        }
    }
}

public struct UpdateAssessmentStatusOutputResponse: Equatable {
    /// <p>
    ///    The name of the updated assessment returned by the <code>UpdateAssessmentStatus</code> API.
    /// </p>
    public let assessment: Assessment?

    public init (
        assessment: Assessment? = nil
    )
    {
        self.assessment = assessment
    }
}

struct UpdateAssessmentStatusOutputResponseBody: Equatable {
    public let assessment: Assessment?
}

extension UpdateAssessmentStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessment
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentDecoded = try containerValues.decodeIfPresent(Assessment.self, forKey: .assessment)
        assessment = assessmentDecoded
    }
}

public struct UpdateControlInputBodyMiddleware: Middleware {
    public let id: String = "UpdateControlInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateControlInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateControlInput>
    public typealias MOutput = OperationOutput<UpdateControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateControlOutputError>
}

extension UpdateControlInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateControlInput(actionPlanInstructions: \(String(describing: actionPlanInstructions)), actionPlanTitle: \(String(describing: actionPlanTitle)), controlId: \(String(describing: controlId)), controlMappingSources: \(String(describing: controlMappingSources)), description: \(String(describing: description)), name: \(String(describing: name)), testingInformation: \(String(describing: testingInformation)))"}
}

extension UpdateControlInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actionPlanInstructions
        case actionPlanTitle
        case controlMappingSources
        case description
        case name
        case testingInformation
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionPlanInstructions = actionPlanInstructions {
            try encodeContainer.encode(actionPlanInstructions, forKey: .actionPlanInstructions)
        }
        if let actionPlanTitle = actionPlanTitle {
            try encodeContainer.encode(actionPlanTitle, forKey: .actionPlanTitle)
        }
        if let controlMappingSources = controlMappingSources {
            var controlMappingSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .controlMappingSources)
            for controlmappingsources0 in controlMappingSources {
                try controlMappingSourcesContainer.encode(controlmappingsources0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let testingInformation = testingInformation {
            try encodeContainer.encode(testingInformation, forKey: .testingInformation)
        }
    }
}

public struct UpdateControlInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateControlInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateControlInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateControlInput>
    public typealias MOutput = OperationOutput<UpdateControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateControlOutputError>
}

public struct UpdateControlInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateControlInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateControlInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateControlOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateControlInput>
    public typealias MOutput = OperationOutput<UpdateControlOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateControlOutputError>
}

public struct UpdateControlInput: Equatable {
    /// <p>
    ///
    ///          The recommended actions to carry out if the control is not fulfilled.
    ///       </p>
    public let actionPlanInstructions: String?
    /// <p>
    ///          The title of the action plan for remediating the control.
    ///       </p>
    public let actionPlanTitle: String?
    /// <p>
    ///    The identifier for the specified control.
    /// </p>
    public let controlId: String?
    /// <p>
    ///    The data mapping sources for the specified control.
    /// </p>
    public let controlMappingSources: [ControlMappingSource]?
    /// <p>
    /// The optional description of the control.
    /// </p>
    public let description: String?
    /// <p>
    /// The name of the control to be updated.
    /// </p>
    public let name: String?
    /// <p>
    ///          The steps that to follow to determine if the control has been satisfied.
    ///       </p>
    public let testingInformation: String?

    public init (
        actionPlanInstructions: String? = nil,
        actionPlanTitle: String? = nil,
        controlId: String? = nil,
        controlMappingSources: [ControlMappingSource]? = nil,
        description: String? = nil,
        name: String? = nil,
        testingInformation: String? = nil
    )
    {
        self.actionPlanInstructions = actionPlanInstructions
        self.actionPlanTitle = actionPlanTitle
        self.controlId = controlId
        self.controlMappingSources = controlMappingSources
        self.description = description
        self.name = name
        self.testingInformation = testingInformation
    }
}

struct UpdateControlInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let testingInformation: String?
    public let actionPlanTitle: String?
    public let actionPlanInstructions: String?
    public let controlMappingSources: [ControlMappingSource]?
}

extension UpdateControlInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actionPlanInstructions
        case actionPlanTitle
        case controlMappingSources
        case description
        case name
        case testingInformation
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let testingInformationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .testingInformation)
        testingInformation = testingInformationDecoded
        let actionPlanTitleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionPlanTitle)
        actionPlanTitle = actionPlanTitleDecoded
        let actionPlanInstructionsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .actionPlanInstructions)
        actionPlanInstructions = actionPlanInstructionsDecoded
        let controlMappingSourcesContainer = try containerValues.decodeIfPresent([ControlMappingSource?].self, forKey: .controlMappingSources)
        var controlMappingSourcesDecoded0:[ControlMappingSource]? = nil
        if let controlMappingSourcesContainer = controlMappingSourcesContainer {
            controlMappingSourcesDecoded0 = [ControlMappingSource]()
            for structure0 in controlMappingSourcesContainer {
                if let structure0 = structure0 {
                    controlMappingSourcesDecoded0?.append(structure0)
                }
            }
        }
        controlMappingSources = controlMappingSourcesDecoded0
    }
}

extension UpdateControlOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateControlOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateControlOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateControlOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateControlOutputResponse(control: \(String(describing: control)))"}
}

extension UpdateControlOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateControlOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.control = output.control
        } else {
            self.control = nil
        }
    }
}

public struct UpdateControlOutputResponse: Equatable {
    /// <p>
    ///    The name of the updated control set returned by the <code>UpdateControl</code> API.
    /// </p>
    public let control: Control?

    public init (
        control: Control? = nil
    )
    {
        self.control = control
    }
}

struct UpdateControlOutputResponseBody: Equatable {
    public let control: Control?
}

extension UpdateControlOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case control
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let controlDecoded = try containerValues.decodeIfPresent(Control.self, forKey: .control)
        control = controlDecoded
    }
}

public struct UpdateSettingsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSettingsInput>
    public typealias MOutput = OperationOutput<UpdateSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSettingsOutputError>
}

extension UpdateSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSettingsInput(defaultAssessmentReportsDestination: \(String(describing: defaultAssessmentReportsDestination)), defaultProcessOwners: \(String(describing: defaultProcessOwners)), kmsKey: \(String(describing: kmsKey)), snsTopic: \(String(describing: snsTopic)))"}
}

extension UpdateSettingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultAssessmentReportsDestination
        case defaultProcessOwners
        case kmsKey
        case snsTopic
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultAssessmentReportsDestination = defaultAssessmentReportsDestination {
            try encodeContainer.encode(defaultAssessmentReportsDestination, forKey: .defaultAssessmentReportsDestination)
        }
        if let defaultProcessOwners = defaultProcessOwners {
            var defaultProcessOwnersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultProcessOwners)
            for roles0 in defaultProcessOwners {
                try defaultProcessOwnersContainer.encode(roles0)
            }
        }
        if let kmsKey = kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let snsTopic = snsTopic {
            try encodeContainer.encode(snsTopic, forKey: .snsTopic)
        }
    }
}

public struct UpdateSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSettingsInput>
    public typealias MOutput = OperationOutput<UpdateSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSettingsOutputError>
}

public struct UpdateSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSettingsInput>
    public typealias MOutput = OperationOutput<UpdateSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSettingsOutputError>
}

public struct UpdateSettingsInput: Equatable {
    /// <p>
    ///    The default storage destination for assessment reports.
    /// </p>
    public let defaultAssessmentReportsDestination: AssessmentReportsDestination?
    /// <p>
    /// A list of the default audit owners.
    /// </p>
    public let defaultProcessOwners: [Role]?
    /// <p>
    ///          The AWS KMS key details.
    ///       </p>
    public let kmsKey: String?
    /// <p>
    /// The Amazon Simple Notification Service (Amazon SNS) topic to which AWS Audit Manager sends notifications.
    /// </p>
    public let snsTopic: String?

    public init (
        defaultAssessmentReportsDestination: AssessmentReportsDestination? = nil,
        defaultProcessOwners: [Role]? = nil,
        kmsKey: String? = nil,
        snsTopic: String? = nil
    )
    {
        self.defaultAssessmentReportsDestination = defaultAssessmentReportsDestination
        self.defaultProcessOwners = defaultProcessOwners
        self.kmsKey = kmsKey
        self.snsTopic = snsTopic
    }
}

struct UpdateSettingsInputBody: Equatable {
    public let snsTopic: String?
    public let defaultAssessmentReportsDestination: AssessmentReportsDestination?
    public let defaultProcessOwners: [Role]?
    public let kmsKey: String?
}

extension UpdateSettingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultAssessmentReportsDestination
        case defaultProcessOwners
        case kmsKey
        case snsTopic
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snsTopicDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopic)
        snsTopic = snsTopicDecoded
        let defaultAssessmentReportsDestinationDecoded = try containerValues.decodeIfPresent(AssessmentReportsDestination.self, forKey: .defaultAssessmentReportsDestination)
        defaultAssessmentReportsDestination = defaultAssessmentReportsDestinationDecoded
        let defaultProcessOwnersContainer = try containerValues.decodeIfPresent([Role?].self, forKey: .defaultProcessOwners)
        var defaultProcessOwnersDecoded0:[Role]? = nil
        if let defaultProcessOwnersContainer = defaultProcessOwnersContainer {
            defaultProcessOwnersDecoded0 = [Role]()
            for structure0 in defaultProcessOwnersContainer {
                if let structure0 = structure0 {
                    defaultProcessOwnersDecoded0?.append(structure0)
                }
            }
        }
        defaultProcessOwners = defaultProcessOwnersDecoded0
        let kmsKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
    }
}

extension UpdateSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSettingsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSettingsOutputResponse(settings: \(String(describing: settings)))"}
}

extension UpdateSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSettingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.settings = output.settings
        } else {
            self.settings = nil
        }
    }
}

public struct UpdateSettingsOutputResponse: Equatable {
    /// <p>
    /// The current list of settings.
    /// </p>
    public let settings: Settings?

    public init (
        settings: Settings? = nil
    )
    {
        self.settings = settings
    }
}

struct UpdateSettingsOutputResponseBody: Equatable {
    public let settings: Settings?
}

extension UpdateSettingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case settings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let settingsDecoded = try containerValues.decodeIfPresent(Settings.self, forKey: .settings)
        settings = settingsDecoded
    }
}

public struct ValidateAssessmentReportIntegrityInputBodyMiddleware: Middleware {
    public let id: String = "ValidateAssessmentReportIntegrityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidateAssessmentReportIntegrityInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidateAssessmentReportIntegrityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidateAssessmentReportIntegrityInput>
    public typealias MOutput = OperationOutput<ValidateAssessmentReportIntegrityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidateAssessmentReportIntegrityOutputError>
}

extension ValidateAssessmentReportIntegrityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidateAssessmentReportIntegrityInput(s3RelativePath: \(String(describing: s3RelativePath)))"}
}

extension ValidateAssessmentReportIntegrityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3RelativePath
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3RelativePath = s3RelativePath {
            try encodeContainer.encode(s3RelativePath, forKey: .s3RelativePath)
        }
    }
}

public struct ValidateAssessmentReportIntegrityInputHeadersMiddleware: Middleware {
    public let id: String = "ValidateAssessmentReportIntegrityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidateAssessmentReportIntegrityInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidateAssessmentReportIntegrityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidateAssessmentReportIntegrityInput>
    public typealias MOutput = OperationOutput<ValidateAssessmentReportIntegrityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidateAssessmentReportIntegrityOutputError>
}

public struct ValidateAssessmentReportIntegrityInputQueryItemMiddleware: Middleware {
    public let id: String = "ValidateAssessmentReportIntegrityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ValidateAssessmentReportIntegrityInput>,
                  next: H) -> Swift.Result<OperationOutput<ValidateAssessmentReportIntegrityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ValidateAssessmentReportIntegrityInput>
    public typealias MOutput = OperationOutput<ValidateAssessmentReportIntegrityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ValidateAssessmentReportIntegrityOutputError>
}

public struct ValidateAssessmentReportIntegrityInput: Equatable {
    /// <p>
    ///    The relative path of the specified Amazon S3 bucket in which the assessment report is stored.
    /// </p>
    public let s3RelativePath: String?

    public init (
        s3RelativePath: String? = nil
    )
    {
        self.s3RelativePath = s3RelativePath
    }
}

struct ValidateAssessmentReportIntegrityInputBody: Equatable {
    public let s3RelativePath: String?
}

extension ValidateAssessmentReportIntegrityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case s3RelativePath
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3RelativePathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3RelativePath)
        s3RelativePath = s3RelativePathDecoded
    }
}

extension ValidateAssessmentReportIntegrityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ValidateAssessmentReportIntegrityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ValidateAssessmentReportIntegrityOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ValidateAssessmentReportIntegrityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidateAssessmentReportIntegrityOutputResponse(signatureAlgorithm: \(String(describing: signatureAlgorithm)), signatureDateTime: \(String(describing: signatureDateTime)), signatureKeyId: \(String(describing: signatureKeyId)), signatureValid: \(String(describing: signatureValid)), validationErrors: \(String(describing: validationErrors)))"}
}

extension ValidateAssessmentReportIntegrityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidateAssessmentReportIntegrityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.signatureAlgorithm = output.signatureAlgorithm
            self.signatureDateTime = output.signatureDateTime
            self.signatureKeyId = output.signatureKeyId
            self.signatureValid = output.signatureValid
            self.validationErrors = output.validationErrors
        } else {
            self.signatureAlgorithm = nil
            self.signatureDateTime = nil
            self.signatureKeyId = nil
            self.signatureValid = nil
            self.validationErrors = nil
        }
    }
}

public struct ValidateAssessmentReportIntegrityOutputResponse: Equatable {
    /// <p>
    ///    The signature algorithm used to code sign the assessment report file.
    /// </p>
    public let signatureAlgorithm: String?
    /// <p>
    /// The date and time signature that specifies when the assessment report was created.
    /// </p>
    public let signatureDateTime: String?
    /// <p>
    /// The unique identifier for the validation signature key.
    /// </p>
    public let signatureKeyId: String?
    /// <p>
    /// Specifies whether the signature key is valid.
    /// </p>
    public let signatureValid: Bool?
    /// <p>
    /// Represents any errors that occurred when validating the assessment report.
    /// </p>
    public let validationErrors: [String]?

    public init (
        signatureAlgorithm: String? = nil,
        signatureDateTime: String? = nil,
        signatureKeyId: String? = nil,
        signatureValid: Bool? = nil,
        validationErrors: [String]? = nil
    )
    {
        self.signatureAlgorithm = signatureAlgorithm
        self.signatureDateTime = signatureDateTime
        self.signatureKeyId = signatureKeyId
        self.signatureValid = signatureValid
        self.validationErrors = validationErrors
    }
}

struct ValidateAssessmentReportIntegrityOutputResponseBody: Equatable {
    public let signatureValid: Bool?
    public let signatureAlgorithm: String?
    public let signatureDateTime: String?
    public let signatureKeyId: String?
    public let validationErrors: [String]?
}

extension ValidateAssessmentReportIntegrityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case signatureAlgorithm
        case signatureDateTime
        case signatureKeyId
        case signatureValid
        case validationErrors
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signatureValidDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .signatureValid)
        signatureValid = signatureValidDecoded
        let signatureAlgorithmDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signatureAlgorithm)
        signatureAlgorithm = signatureAlgorithmDecoded
        let signatureDateTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signatureDateTime)
        signatureDateTime = signatureDateTimeDecoded
        let signatureKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signatureKeyId)
        signatureKeyId = signatureKeyIdDecoded
        let validationErrorsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .validationErrors)
        var validationErrorsDecoded0:[String]? = nil
        if let validationErrorsContainer = validationErrorsContainer {
            validationErrorsDecoded0 = [String]()
            for string0 in validationErrorsContainer {
                if let string0 = string0 {
                    validationErrorsDecoded0?.append(string0)
                }
            }
        }
        validationErrors = validationErrorsDecoded0
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(fields: \(String(describing: fields)), message: \(String(describing: message)), reason: \(String(describing: reason)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///    The request has invalid or missing parameters.
/// </p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>
    ///          The fields that caused the error, if applicable.
    ///       </p>
    public var fields: [ValidationExceptionField]?
    public var message: String?
    /// <p>
    ///          The reason the request failed validation.
    ///       </p>
    public var reason: ValidationExceptionReason?

    public init (
        fields: [ValidationExceptionField]? = nil,
        message: String? = nil,
        reason: ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
    public let reason: ValidationExceptionReason?
    public let fields: [ValidationExceptionField]?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fields
        case message
        case reason
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension ValidationExceptionField: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationExceptionField: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationExceptionField(message: \(String(describing: message)), name: \(String(describing: name)))"}
}

/// <p>
///    Indicates that the request has invalid or missing parameters for the specified field.
/// </p>
public struct ValidationExceptionField: Equatable {
    /// <p>
    ///  The body of the error message.
    /// </p>
    public let message: String?
    /// <p>
    ///  The name of the validation error.
    /// </p>
    public let name: String?

    public init (
        message: String? = nil,
        name: String? = nil
    )
    {
        self.message = message
        self.name = name
    }
}

public enum ValidationExceptionReason {
    case cannotParse
    case fieldValidationFailed
    case other
    case unknownOperation
    case sdkUnknown(String)
}

extension ValidationExceptionReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ValidationExceptionReason] {
        return [
            .cannotParse,
            .fieldValidationFailed,
            .other,
            .unknownOperation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cannotParse: return "cannotParse"
        case .fieldValidationFailed: return "fieldValidationFailed"
        case .other: return "other"
        case .unknownOperation: return "unknownOperation"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
    }
}
