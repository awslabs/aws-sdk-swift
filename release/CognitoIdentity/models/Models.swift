// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public enum AmbiguousRoleResolutionType {
    case authenticatedRole
    case deny
    case sdkUnknown(String)
}

extension AmbiguousRoleResolutionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AmbiguousRoleResolutionType] {
        return [
            .authenticatedRole,
            .deny,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .authenticatedRole: return "AuthenticatedRole"
        case .deny: return "Deny"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AmbiguousRoleResolutionType(rawValue: rawValue) ?? AmbiguousRoleResolutionType.sdkUnknown(rawValue)
    }
}

extension CognitoIdentityProvider: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientId = "ClientId"
        case providerName = "ProviderName"
        case serverSideTokenCheck = "ServerSideTokenCheck"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let providerName = providerName {
            try encodeContainer.encode(providerName, forKey: .providerName)
        }
        if serverSideTokenCheck != false {
            try encodeContainer.encode(serverSideTokenCheck, forKey: .serverSideTokenCheck)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .providerName)
        providerName = providerNameDecoded
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let serverSideTokenCheckDecoded = try containerValues.decode(Bool.self, forKey: .serverSideTokenCheck)
        serverSideTokenCheck = serverSideTokenCheckDecoded
    }
}

extension CognitoIdentityProvider: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CognitoIdentityProvider(clientId: \(String(describing: clientId)), providerName: \(String(describing: providerName)), serverSideTokenCheck: \(String(describing: serverSideTokenCheck)))"}
}

/// <p>A provider representing an Amazon Cognito user pool and its client ID.</p>
public struct CognitoIdentityProvider: Equatable {
    /// <p>The client ID for the Amazon Cognito user pool.</p>
    public let clientId: String?
    /// <p>The provider name for an Amazon Cognito user pool. For example,
    ///             <code>cognito-idp.us-east-1.amazonaws.com/us-east-1_123456789</code>.</p>
    public let providerName: String?
    /// <p>TRUE if server-side token validation is enabled for the identity providerâ€™s
    ///          token.</p>
    ///          <p>Once you set <code>ServerSideTokenCheck</code> to TRUE for an identity pool, that
    ///          identity pool will check with the integrated user pools to make sure that the user has not
    ///          been globally signed out or deleted before the identity pool provides an OIDC token or AWS
    ///          credentials for the user.</p>
    ///          <p>If the user is signed out or deleted, the identity pool will return a 400 Not
    ///          Authorized error.</p>
    public let serverSideTokenCheck: Bool

    public init (
        clientId: String? = nil,
        providerName: String? = nil,
        serverSideTokenCheck: Bool = false
    )
    {
        self.clientId = clientId
        self.providerName = providerName
        self.serverSideTokenCheck = serverSideTokenCheck
    }
}

extension ConcurrentModificationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConcurrentModificationException(message: \(String(describing: message)))"}
}

extension ConcurrentModificationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Thrown if there are parallel requests to modify a resource.</p>
public struct ConcurrentModificationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned by a ConcurrentModificationException.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Equatable {
    public let message: String?
}

extension ConcurrentModificationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateIdentityPoolInputBodyMiddleware: Middleware {
    public let id: String = "CreateIdentityPoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIdentityPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIdentityPoolInput>
    public typealias MOutput = OperationOutput<CreateIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIdentityPoolOutputError>
}

extension CreateIdentityPoolInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIdentityPoolInput(allowClassicFlow: \(String(describing: allowClassicFlow)), allowUnauthenticatedIdentities: \(String(describing: allowUnauthenticatedIdentities)), cognitoIdentityProviders: \(String(describing: cognitoIdentityProviders)), developerProviderName: \(String(describing: developerProviderName)), identityPoolName: \(String(describing: identityPoolName)), identityPoolTags: \(String(describing: identityPoolTags)), openIdConnectProviderARNs: \(String(describing: openIdConnectProviderARNs)), samlProviderARNs: \(String(describing: samlProviderARNs)), supportedLoginProviders: \(String(describing: supportedLoginProviders)))"}
}

extension CreateIdentityPoolInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowClassicFlow = allowClassicFlow {
            try encodeContainer.encode(allowClassicFlow, forKey: .allowClassicFlow)
        }
        if allowUnauthenticatedIdentities != false {
            try encodeContainer.encode(allowUnauthenticatedIdentities, forKey: .allowUnauthenticatedIdentities)
        }
        if let cognitoIdentityProviders = cognitoIdentityProviders {
            var cognitoIdentityProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cognitoIdentityProviders)
            for cognitoidentityproviderlist0 in cognitoIdentityProviders {
                try cognitoIdentityProvidersContainer.encode(cognitoidentityproviderlist0)
            }
        }
        if let developerProviderName = developerProviderName {
            try encodeContainer.encode(developerProviderName, forKey: .developerProviderName)
        }
        if let identityPoolName = identityPoolName {
            try encodeContainer.encode(identityPoolName, forKey: .identityPoolName)
        }
        if let identityPoolTags = identityPoolTags {
            var identityPoolTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .identityPoolTags)
            for (dictKey0, identitypooltagstype0) in identityPoolTags {
                try identityPoolTagsContainer.encode(identitypooltagstype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let openIdConnectProviderARNs = openIdConnectProviderARNs {
            var openIdConnectProviderARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .openIdConnectProviderARNs)
            for oidcproviderlist0 in openIdConnectProviderARNs {
                try openIdConnectProviderARNsContainer.encode(oidcproviderlist0)
            }
        }
        if let samlProviderARNs = samlProviderARNs {
            var samlProviderARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .samlProviderARNs)
            for samlproviderlist0 in samlProviderARNs {
                try samlProviderARNsContainer.encode(samlproviderlist0)
            }
        }
        if let supportedLoginProviders = supportedLoginProviders {
            var supportedLoginProvidersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .supportedLoginProviders)
            for (dictKey0, identityproviders0) in supportedLoginProviders {
                try supportedLoginProvidersContainer.encode(identityproviders0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateIdentityPoolInputHeadersMiddleware: Middleware {
    public let id: String = "CreateIdentityPoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIdentityPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIdentityPoolInput>
    public typealias MOutput = OperationOutput<CreateIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIdentityPoolOutputError>
}

public struct CreateIdentityPoolInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateIdentityPoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateIdentityPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateIdentityPoolInput>
    public typealias MOutput = OperationOutput<CreateIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateIdentityPoolOutputError>
}

/// <p>Input to the CreateIdentityPool action.</p>
public struct CreateIdentityPoolInput: Equatable {
    /// <p>Enables or disables the Basic (Classic) authentication flow. For more information, see
    ///       <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/authentication-flow.html">Identity Pools (Federated Identities) Authentication Flow</a> in the <i>Amazon Cognito Developer Guide</i>.</p>
    public let allowClassicFlow: Bool?
    /// <p>TRUE if the identity pool supports unauthenticated logins.</p>
    public let allowUnauthenticatedIdentities: Bool
    /// <p>An array of Amazon Cognito user pools and their client IDs.</p>
    public let cognitoIdentityProviders: [CognitoIdentityProvider]?
    /// <p>The "domain" by which Cognito will refer to your users. This name acts as a
    ///          placeholder that allows your backend and the Cognito service to communicate about the
    ///          developer provider. For the <code>DeveloperProviderName</code>, you can use letters as well
    ///          as period (<code>.</code>), underscore (<code>_</code>), and dash
    ///          (<code>-</code>).</p>
    ///          <p>Once you have set a developer provider name, you cannot change it. Please take care
    ///          in setting this parameter.</p>
    public let developerProviderName: String?
    /// <p>A string that you provide.</p>
    public let identityPoolName: String?
    /// <p>Tags to assign to the identity pool. A tag is a label that you can apply to identity
    ///          pools to categorize and manage them in different ways, such as by purpose, owner,
    ///          environment, or other criteria.</p>
    public let identityPoolTags: [String:String]?
    /// <p>The Amazon Resource Names (ARN) of the OpenID Connect providers.</p>
    public let openIdConnectProviderARNs: [String]?
    /// <p>An array of Amazon Resource Names (ARNs) of the SAML provider for your identity
    ///          pool.</p>
    public let samlProviderARNs: [String]?
    /// <p>Optional key:value pairs mapping provider names to provider app IDs.</p>
    public let supportedLoginProviders: [String:String]?

    public init (
        allowClassicFlow: Bool? = nil,
        allowUnauthenticatedIdentities: Bool = false,
        cognitoIdentityProviders: [CognitoIdentityProvider]? = nil,
        developerProviderName: String? = nil,
        identityPoolName: String? = nil,
        identityPoolTags: [String:String]? = nil,
        openIdConnectProviderARNs: [String]? = nil,
        samlProviderARNs: [String]? = nil,
        supportedLoginProviders: [String:String]? = nil
    )
    {
        self.allowClassicFlow = allowClassicFlow
        self.allowUnauthenticatedIdentities = allowUnauthenticatedIdentities
        self.cognitoIdentityProviders = cognitoIdentityProviders
        self.developerProviderName = developerProviderName
        self.identityPoolName = identityPoolName
        self.identityPoolTags = identityPoolTags
        self.openIdConnectProviderARNs = openIdConnectProviderARNs
        self.samlProviderARNs = samlProviderARNs
        self.supportedLoginProviders = supportedLoginProviders
    }
}

struct CreateIdentityPoolInputBody: Equatable {
    public let identityPoolName: String?
    public let allowUnauthenticatedIdentities: Bool
    public let allowClassicFlow: Bool?
    public let supportedLoginProviders: [String:String]?
    public let developerProviderName: String?
    public let openIdConnectProviderARNs: [String]?
    public let cognitoIdentityProviders: [CognitoIdentityProvider]?
    public let samlProviderARNs: [String]?
    public let identityPoolTags: [String:String]?
}

extension CreateIdentityPoolInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let allowUnauthenticatedIdentitiesDecoded = try containerValues.decode(Bool.self, forKey: .allowUnauthenticatedIdentities)
        allowUnauthenticatedIdentities = allowUnauthenticatedIdentitiesDecoded
        let allowClassicFlowDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowClassicFlow)
        allowClassicFlow = allowClassicFlowDecoded
        let supportedLoginProvidersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .supportedLoginProviders)
        var supportedLoginProvidersDecoded0: [String:String]? = nil
        if let supportedLoginProvidersContainer = supportedLoginProvidersContainer {
            supportedLoginProvidersDecoded0 = [String:String]()
            for (key0, identityproviderid0) in supportedLoginProvidersContainer {
                if let identityproviderid0 = identityproviderid0 {
                    supportedLoginProvidersDecoded0?[key0] = identityproviderid0
                }
            }
        }
        supportedLoginProviders = supportedLoginProvidersDecoded0
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let openIdConnectProviderARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .openIdConnectProviderARNs)
        var openIdConnectProviderARNsDecoded0:[String]? = nil
        if let openIdConnectProviderARNsContainer = openIdConnectProviderARNsContainer {
            openIdConnectProviderARNsDecoded0 = [String]()
            for string0 in openIdConnectProviderARNsContainer {
                if let string0 = string0 {
                    openIdConnectProviderARNsDecoded0?.append(string0)
                }
            }
        }
        openIdConnectProviderARNs = openIdConnectProviderARNsDecoded0
        let cognitoIdentityProvidersContainer = try containerValues.decodeIfPresent([CognitoIdentityProvider?].self, forKey: .cognitoIdentityProviders)
        var cognitoIdentityProvidersDecoded0:[CognitoIdentityProvider]? = nil
        if let cognitoIdentityProvidersContainer = cognitoIdentityProvidersContainer {
            cognitoIdentityProvidersDecoded0 = [CognitoIdentityProvider]()
            for structure0 in cognitoIdentityProvidersContainer {
                if let structure0 = structure0 {
                    cognitoIdentityProvidersDecoded0?.append(structure0)
                }
            }
        }
        cognitoIdentityProviders = cognitoIdentityProvidersDecoded0
        let samlProviderARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .samlProviderARNs)
        var samlProviderARNsDecoded0:[String]? = nil
        if let samlProviderARNsContainer = samlProviderARNsContainer {
            samlProviderARNsDecoded0 = [String]()
            for string0 in samlProviderARNsContainer {
                if let string0 = string0 {
                    samlProviderARNsDecoded0?.append(string0)
                }
            }
        }
        samlProviderARNs = samlProviderARNsDecoded0
        let identityPoolTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .identityPoolTags)
        var identityPoolTagsDecoded0: [String:String]? = nil
        if let identityPoolTagsContainer = identityPoolTagsContainer {
            identityPoolTagsDecoded0 = [String:String]()
            for (key0, tagvaluetype0) in identityPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    identityPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        identityPoolTags = identityPoolTagsDecoded0
    }
}

extension CreateIdentityPoolOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIdentityPoolOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateIdentityPoolOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIdentityPoolOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateIdentityPoolOutputResponse(allowClassicFlow: \(String(describing: allowClassicFlow)), allowUnauthenticatedIdentities: \(String(describing: allowUnauthenticatedIdentities)), cognitoIdentityProviders: \(String(describing: cognitoIdentityProviders)), developerProviderName: \(String(describing: developerProviderName)), identityPoolId: \(String(describing: identityPoolId)), identityPoolName: \(String(describing: identityPoolName)), identityPoolTags: \(String(describing: identityPoolTags)), openIdConnectProviderARNs: \(String(describing: openIdConnectProviderARNs)), samlProviderARNs: \(String(describing: samlProviderARNs)), supportedLoginProviders: \(String(describing: supportedLoginProviders)))"}
}

extension CreateIdentityPoolOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateIdentityPoolOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.allowClassicFlow = output.allowClassicFlow
            self.allowUnauthenticatedIdentities = output.allowUnauthenticatedIdentities
            self.cognitoIdentityProviders = output.cognitoIdentityProviders
            self.developerProviderName = output.developerProviderName
            self.identityPoolId = output.identityPoolId
            self.identityPoolName = output.identityPoolName
            self.identityPoolTags = output.identityPoolTags
            self.openIdConnectProviderARNs = output.openIdConnectProviderARNs
            self.samlProviderARNs = output.samlProviderARNs
            self.supportedLoginProviders = output.supportedLoginProviders
        } else {
            self.allowClassicFlow = nil
            self.allowUnauthenticatedIdentities = false
            self.cognitoIdentityProviders = nil
            self.developerProviderName = nil
            self.identityPoolId = nil
            self.identityPoolName = nil
            self.identityPoolTags = nil
            self.openIdConnectProviderARNs = nil
            self.samlProviderARNs = nil
            self.supportedLoginProviders = nil
        }
    }
}

/// <p>An object representing an Amazon Cognito identity pool.</p>
public struct CreateIdentityPoolOutputResponse: Equatable {
    /// <p>Enables or disables the Basic (Classic) authentication flow. For more information, see
    ///       <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/authentication-flow.html">Identity Pools (Federated Identities) Authentication Flow</a> in the <i>Amazon Cognito Developer Guide</i>.</p>
    public let allowClassicFlow: Bool?
    /// <p>TRUE if the identity pool supports unauthenticated logins.</p>
    public let allowUnauthenticatedIdentities: Bool
    /// <p>A list representing an Amazon Cognito user pool and its client ID.</p>
    public let cognitoIdentityProviders: [CognitoIdentityProvider]?
    /// <p>The "domain" by which Cognito will refer to your users.</p>
    public let developerProviderName: String?
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: String?
    /// <p>A string that you provide.</p>
    public let identityPoolName: String?
    /// <p>The tags that are assigned to the identity pool. A tag is a label that you can apply to
    ///          identity pools to categorize and manage them in different ways, such as by purpose, owner,
    ///          environment, or other criteria.</p>
    public let identityPoolTags: [String:String]?
    /// <p>The ARNs of the OpenID Connect providers.</p>
    public let openIdConnectProviderARNs: [String]?
    /// <p>An array of Amazon Resource Names (ARNs) of the SAML provider for your identity
    ///          pool.</p>
    public let samlProviderARNs: [String]?
    /// <p>Optional key:value pairs mapping provider names to provider app IDs.</p>
    public let supportedLoginProviders: [String:String]?

    public init (
        allowClassicFlow: Bool? = nil,
        allowUnauthenticatedIdentities: Bool = false,
        cognitoIdentityProviders: [CognitoIdentityProvider]? = nil,
        developerProviderName: String? = nil,
        identityPoolId: String? = nil,
        identityPoolName: String? = nil,
        identityPoolTags: [String:String]? = nil,
        openIdConnectProviderARNs: [String]? = nil,
        samlProviderARNs: [String]? = nil,
        supportedLoginProviders: [String:String]? = nil
    )
    {
        self.allowClassicFlow = allowClassicFlow
        self.allowUnauthenticatedIdentities = allowUnauthenticatedIdentities
        self.cognitoIdentityProviders = cognitoIdentityProviders
        self.developerProviderName = developerProviderName
        self.identityPoolId = identityPoolId
        self.identityPoolName = identityPoolName
        self.identityPoolTags = identityPoolTags
        self.openIdConnectProviderARNs = openIdConnectProviderARNs
        self.samlProviderARNs = samlProviderARNs
        self.supportedLoginProviders = supportedLoginProviders
    }
}

struct CreateIdentityPoolOutputResponseBody: Equatable {
    public let identityPoolId: String?
    public let identityPoolName: String?
    public let allowUnauthenticatedIdentities: Bool
    public let allowClassicFlow: Bool?
    public let supportedLoginProviders: [String:String]?
    public let developerProviderName: String?
    public let openIdConnectProviderARNs: [String]?
    public let cognitoIdentityProviders: [CognitoIdentityProvider]?
    public let samlProviderARNs: [String]?
    public let identityPoolTags: [String:String]?
}

extension CreateIdentityPoolOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let allowUnauthenticatedIdentitiesDecoded = try containerValues.decode(Bool.self, forKey: .allowUnauthenticatedIdentities)
        allowUnauthenticatedIdentities = allowUnauthenticatedIdentitiesDecoded
        let allowClassicFlowDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowClassicFlow)
        allowClassicFlow = allowClassicFlowDecoded
        let supportedLoginProvidersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .supportedLoginProviders)
        var supportedLoginProvidersDecoded0: [String:String]? = nil
        if let supportedLoginProvidersContainer = supportedLoginProvidersContainer {
            supportedLoginProvidersDecoded0 = [String:String]()
            for (key0, identityproviderid0) in supportedLoginProvidersContainer {
                if let identityproviderid0 = identityproviderid0 {
                    supportedLoginProvidersDecoded0?[key0] = identityproviderid0
                }
            }
        }
        supportedLoginProviders = supportedLoginProvidersDecoded0
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let openIdConnectProviderARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .openIdConnectProviderARNs)
        var openIdConnectProviderARNsDecoded0:[String]? = nil
        if let openIdConnectProviderARNsContainer = openIdConnectProviderARNsContainer {
            openIdConnectProviderARNsDecoded0 = [String]()
            for string0 in openIdConnectProviderARNsContainer {
                if let string0 = string0 {
                    openIdConnectProviderARNsDecoded0?.append(string0)
                }
            }
        }
        openIdConnectProviderARNs = openIdConnectProviderARNsDecoded0
        let cognitoIdentityProvidersContainer = try containerValues.decodeIfPresent([CognitoIdentityProvider?].self, forKey: .cognitoIdentityProviders)
        var cognitoIdentityProvidersDecoded0:[CognitoIdentityProvider]? = nil
        if let cognitoIdentityProvidersContainer = cognitoIdentityProvidersContainer {
            cognitoIdentityProvidersDecoded0 = [CognitoIdentityProvider]()
            for structure0 in cognitoIdentityProvidersContainer {
                if let structure0 = structure0 {
                    cognitoIdentityProvidersDecoded0?.append(structure0)
                }
            }
        }
        cognitoIdentityProviders = cognitoIdentityProvidersDecoded0
        let samlProviderARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .samlProviderARNs)
        var samlProviderARNsDecoded0:[String]? = nil
        if let samlProviderARNsContainer = samlProviderARNsContainer {
            samlProviderARNsDecoded0 = [String]()
            for string0 in samlProviderARNsContainer {
                if let string0 = string0 {
                    samlProviderARNsDecoded0?.append(string0)
                }
            }
        }
        samlProviderARNs = samlProviderARNsDecoded0
        let identityPoolTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .identityPoolTags)
        var identityPoolTagsDecoded0: [String:String]? = nil
        if let identityPoolTagsContainer = identityPoolTagsContainer {
            identityPoolTagsDecoded0 = [String:String]()
            for (key0, tagvaluetype0) in identityPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    identityPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        identityPoolTags = identityPoolTagsDecoded0
    }
}

extension Credentials: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessKeyId = "AccessKeyId"
        case expiration = "Expiration"
        case secretKey = "SecretKey"
        case sessionToken = "SessionToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let expiration = expiration {
            try encodeContainer.encode(expiration.timeIntervalSince1970, forKey: .expiration)
        }
        if let secretKey = secretKey {
            try encodeContainer.encode(secretKey, forKey: .secretKey)
        }
        if let sessionToken = sessionToken {
            try encodeContainer.encode(sessionToken, forKey: .sessionToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretKey)
        secretKey = secretKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .expiration)
        expiration = expirationDecoded
    }
}

extension Credentials: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Credentials(accessKeyId: \(String(describing: accessKeyId)), expiration: \(String(describing: expiration)), secretKey: \(String(describing: secretKey)), sessionToken: \(String(describing: sessionToken)))"}
}

/// <p>Credentials for the provided identity ID.</p>
public struct Credentials: Equatable {
    /// <p>The Access Key portion of the credentials.</p>
    public let accessKeyId: String?
    /// <p>The date at which these credentials will expire.</p>
    public let expiration: Date?
    /// <p>The Secret Access Key portion of the credentials</p>
    public let secretKey: String?
    /// <p>The Session Token portion of the credentials</p>
    public let sessionToken: String?

    public init (
        accessKeyId: String? = nil,
        expiration: Date? = nil,
        secretKey: String? = nil,
        sessionToken: String? = nil
    )
    {
        self.accessKeyId = accessKeyId
        self.expiration = expiration
        self.secretKey = secretKey
        self.sessionToken = sessionToken
    }
}

public struct DeleteIdentitiesInputBodyMiddleware: Middleware {
    public let id: String = "DeleteIdentitiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIdentitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIdentitiesInput>
    public typealias MOutput = OperationOutput<DeleteIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIdentitiesOutputError>
}

extension DeleteIdentitiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIdentitiesInput(identityIdsToDelete: \(String(describing: identityIdsToDelete)))"}
}

extension DeleteIdentitiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityIdsToDelete = "IdentityIdsToDelete"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityIdsToDelete = identityIdsToDelete {
            var identityIdsToDeleteContainer = encodeContainer.nestedUnkeyedContainer(forKey: .identityIdsToDelete)
            for identityidlist0 in identityIdsToDelete {
                try identityIdsToDeleteContainer.encode(identityidlist0)
            }
        }
    }
}

public struct DeleteIdentitiesInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteIdentitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIdentitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIdentitiesInput>
    public typealias MOutput = OperationOutput<DeleteIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIdentitiesOutputError>
}

public struct DeleteIdentitiesInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteIdentitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIdentitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIdentitiesInput>
    public typealias MOutput = OperationOutput<DeleteIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIdentitiesOutputError>
}

/// <p>Input to the <code>DeleteIdentities</code> action.</p>
public struct DeleteIdentitiesInput: Equatable {
    /// <p>A list of 1-60 identities that you want to delete.</p>
    public let identityIdsToDelete: [String]?

    public init (
        identityIdsToDelete: [String]? = nil
    )
    {
        self.identityIdsToDelete = identityIdsToDelete
    }
}

struct DeleteIdentitiesInputBody: Equatable {
    public let identityIdsToDelete: [String]?
}

extension DeleteIdentitiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityIdsToDelete = "IdentityIdsToDelete"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdsToDeleteContainer = try containerValues.decodeIfPresent([String?].self, forKey: .identityIdsToDelete)
        var identityIdsToDeleteDecoded0:[String]? = nil
        if let identityIdsToDeleteContainer = identityIdsToDeleteContainer {
            identityIdsToDeleteDecoded0 = [String]()
            for string0 in identityIdsToDeleteContainer {
                if let string0 = string0 {
                    identityIdsToDeleteDecoded0?.append(string0)
                }
            }
        }
        identityIdsToDelete = identityIdsToDeleteDecoded0
    }
}

extension DeleteIdentitiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIdentitiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIdentitiesOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIdentitiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIdentitiesOutputResponse(unprocessedIdentityIds: \(String(describing: unprocessedIdentityIds)))"}
}

extension DeleteIdentitiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteIdentitiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.unprocessedIdentityIds = output.unprocessedIdentityIds
        } else {
            self.unprocessedIdentityIds = nil
        }
    }
}

/// <p>Returned in response to a successful <code>DeleteIdentities</code>
///          operation.</p>
public struct DeleteIdentitiesOutputResponse: Equatable {
    /// <p>An array of UnprocessedIdentityId objects, each of which contains an ErrorCode and
    ///          IdentityId.</p>
    public let unprocessedIdentityIds: [UnprocessedIdentityId]?

    public init (
        unprocessedIdentityIds: [UnprocessedIdentityId]? = nil
    )
    {
        self.unprocessedIdentityIds = unprocessedIdentityIds
    }
}

struct DeleteIdentitiesOutputResponseBody: Equatable {
    public let unprocessedIdentityIds: [UnprocessedIdentityId]?
}

extension DeleteIdentitiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case unprocessedIdentityIds = "UnprocessedIdentityIds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedIdentityIdsContainer = try containerValues.decodeIfPresent([UnprocessedIdentityId?].self, forKey: .unprocessedIdentityIds)
        var unprocessedIdentityIdsDecoded0:[UnprocessedIdentityId]? = nil
        if let unprocessedIdentityIdsContainer = unprocessedIdentityIdsContainer {
            unprocessedIdentityIdsDecoded0 = [UnprocessedIdentityId]()
            for structure0 in unprocessedIdentityIdsContainer {
                if let structure0 = structure0 {
                    unprocessedIdentityIdsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedIdentityIds = unprocessedIdentityIdsDecoded0
    }
}

public struct DeleteIdentityPoolInputBodyMiddleware: Middleware {
    public let id: String = "DeleteIdentityPoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIdentityPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIdentityPoolInput>
    public typealias MOutput = OperationOutput<DeleteIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIdentityPoolOutputError>
}

extension DeleteIdentityPoolInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIdentityPoolInput(identityPoolId: \(String(describing: identityPoolId)))"}
}

extension DeleteIdentityPoolInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
    }
}

public struct DeleteIdentityPoolInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteIdentityPoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIdentityPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIdentityPoolInput>
    public typealias MOutput = OperationOutput<DeleteIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIdentityPoolOutputError>
}

public struct DeleteIdentityPoolInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteIdentityPoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIdentityPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIdentityPoolInput>
    public typealias MOutput = OperationOutput<DeleteIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIdentityPoolOutputError>
}

/// <p>Input to the DeleteIdentityPool action.</p>
public struct DeleteIdentityPoolInput: Equatable {
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: String?

    public init (
        identityPoolId: String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct DeleteIdentityPoolInputBody: Equatable {
    public let identityPoolId: String?
}

extension DeleteIdentityPoolInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
    }
}

extension DeleteIdentityPoolOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIdentityPoolOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIdentityPoolOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIdentityPoolOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIdentityPoolOutputResponse()"}
}

extension DeleteIdentityPoolOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIdentityPoolOutputResponse: Equatable {

    public init() {}
}

struct DeleteIdentityPoolOutputResponseBody: Equatable {
}

extension DeleteIdentityPoolOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeIdentityInputBodyMiddleware: Middleware {
    public let id: String = "DescribeIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIdentityInput>
    public typealias MOutput = OperationOutput<DescribeIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIdentityOutputError>
}

extension DescribeIdentityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIdentityInput(identityId: \(String(describing: identityId)))"}
}

extension DescribeIdentityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityId = "IdentityId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
    }
}

public struct DescribeIdentityInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIdentityInput>
    public typealias MOutput = OperationOutput<DescribeIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIdentityOutputError>
}

public struct DescribeIdentityInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIdentityInput>
    public typealias MOutput = OperationOutput<DescribeIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIdentityOutputError>
}

/// <p>Input to the <code>DescribeIdentity</code> action.</p>
public struct DescribeIdentityInput: Equatable {
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: String?

    public init (
        identityId: String? = nil
    )
    {
        self.identityId = identityId
    }
}

struct DescribeIdentityInputBody: Equatable {
    public let identityId: String?
}

extension DescribeIdentityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityId = "IdentityId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityId)
        identityId = identityIdDecoded
    }
}

extension DescribeIdentityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIdentityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIdentityOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIdentityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIdentityOutputResponse(creationDate: \(String(describing: creationDate)), identityId: \(String(describing: identityId)), lastModifiedDate: \(String(describing: lastModifiedDate)), logins: \(String(describing: logins)))"}
}

extension DescribeIdentityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeIdentityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.creationDate = output.creationDate
            self.identityId = output.identityId
            self.lastModifiedDate = output.lastModifiedDate
            self.logins = output.logins
        } else {
            self.creationDate = nil
            self.identityId = nil
            self.lastModifiedDate = nil
            self.logins = nil
        }
    }
}

/// <p>A description of the identity.</p>
public struct DescribeIdentityOutputResponse: Equatable {
    /// <p>Date on which the identity was created.</p>
    public let creationDate: Date?
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: String?
    /// <p>Date on which the identity was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The provider names.</p>
    public let logins: [String]?

    public init (
        creationDate: Date? = nil,
        identityId: String? = nil,
        lastModifiedDate: Date? = nil,
        logins: [String]? = nil
    )
    {
        self.creationDate = creationDate
        self.identityId = identityId
        self.lastModifiedDate = lastModifiedDate
        self.logins = logins
    }
}

struct DescribeIdentityOutputResponseBody: Equatable {
    public let identityId: String?
    public let logins: [String]?
    public let creationDate: Date?
    public let lastModifiedDate: Date?
}

extension DescribeIdentityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case creationDate = "CreationDate"
        case identityId = "IdentityId"
        case lastModifiedDate = "LastModifiedDate"
        case logins = "Logins"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .logins)
        var loginsDecoded0:[String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [String]()
            for string0 in loginsContainer {
                if let string0 = string0 {
                    loginsDecoded0?.append(string0)
                }
            }
        }
        logins = loginsDecoded0
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

public struct DescribeIdentityPoolInputBodyMiddleware: Middleware {
    public let id: String = "DescribeIdentityPoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIdentityPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIdentityPoolInput>
    public typealias MOutput = OperationOutput<DescribeIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIdentityPoolOutputError>
}

extension DescribeIdentityPoolInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIdentityPoolInput(identityPoolId: \(String(describing: identityPoolId)))"}
}

extension DescribeIdentityPoolInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
    }
}

public struct DescribeIdentityPoolInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeIdentityPoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIdentityPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIdentityPoolInput>
    public typealias MOutput = OperationOutput<DescribeIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIdentityPoolOutputError>
}

public struct DescribeIdentityPoolInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeIdentityPoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeIdentityPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeIdentityPoolInput>
    public typealias MOutput = OperationOutput<DescribeIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeIdentityPoolOutputError>
}

/// <p>Input to the DescribeIdentityPool action.</p>
public struct DescribeIdentityPoolInput: Equatable {
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: String?

    public init (
        identityPoolId: String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct DescribeIdentityPoolInputBody: Equatable {
    public let identityPoolId: String?
}

extension DescribeIdentityPoolInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
    }
}

extension DescribeIdentityPoolOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeIdentityPoolOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeIdentityPoolOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeIdentityPoolOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeIdentityPoolOutputResponse(allowClassicFlow: \(String(describing: allowClassicFlow)), allowUnauthenticatedIdentities: \(String(describing: allowUnauthenticatedIdentities)), cognitoIdentityProviders: \(String(describing: cognitoIdentityProviders)), developerProviderName: \(String(describing: developerProviderName)), identityPoolId: \(String(describing: identityPoolId)), identityPoolName: \(String(describing: identityPoolName)), identityPoolTags: \(String(describing: identityPoolTags)), openIdConnectProviderARNs: \(String(describing: openIdConnectProviderARNs)), samlProviderARNs: \(String(describing: samlProviderARNs)), supportedLoginProviders: \(String(describing: supportedLoginProviders)))"}
}

extension DescribeIdentityPoolOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeIdentityPoolOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.allowClassicFlow = output.allowClassicFlow
            self.allowUnauthenticatedIdentities = output.allowUnauthenticatedIdentities
            self.cognitoIdentityProviders = output.cognitoIdentityProviders
            self.developerProviderName = output.developerProviderName
            self.identityPoolId = output.identityPoolId
            self.identityPoolName = output.identityPoolName
            self.identityPoolTags = output.identityPoolTags
            self.openIdConnectProviderARNs = output.openIdConnectProviderARNs
            self.samlProviderARNs = output.samlProviderARNs
            self.supportedLoginProviders = output.supportedLoginProviders
        } else {
            self.allowClassicFlow = nil
            self.allowUnauthenticatedIdentities = false
            self.cognitoIdentityProviders = nil
            self.developerProviderName = nil
            self.identityPoolId = nil
            self.identityPoolName = nil
            self.identityPoolTags = nil
            self.openIdConnectProviderARNs = nil
            self.samlProviderARNs = nil
            self.supportedLoginProviders = nil
        }
    }
}

/// <p>An object representing an Amazon Cognito identity pool.</p>
public struct DescribeIdentityPoolOutputResponse: Equatable {
    /// <p>Enables or disables the Basic (Classic) authentication flow. For more information, see
    ///       <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/authentication-flow.html">Identity Pools (Federated Identities) Authentication Flow</a> in the <i>Amazon Cognito Developer Guide</i>.</p>
    public let allowClassicFlow: Bool?
    /// <p>TRUE if the identity pool supports unauthenticated logins.</p>
    public let allowUnauthenticatedIdentities: Bool
    /// <p>A list representing an Amazon Cognito user pool and its client ID.</p>
    public let cognitoIdentityProviders: [CognitoIdentityProvider]?
    /// <p>The "domain" by which Cognito will refer to your users.</p>
    public let developerProviderName: String?
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: String?
    /// <p>A string that you provide.</p>
    public let identityPoolName: String?
    /// <p>The tags that are assigned to the identity pool. A tag is a label that you can apply to
    ///          identity pools to categorize and manage them in different ways, such as by purpose, owner,
    ///          environment, or other criteria.</p>
    public let identityPoolTags: [String:String]?
    /// <p>The ARNs of the OpenID Connect providers.</p>
    public let openIdConnectProviderARNs: [String]?
    /// <p>An array of Amazon Resource Names (ARNs) of the SAML provider for your identity
    ///          pool.</p>
    public let samlProviderARNs: [String]?
    /// <p>Optional key:value pairs mapping provider names to provider app IDs.</p>
    public let supportedLoginProviders: [String:String]?

    public init (
        allowClassicFlow: Bool? = nil,
        allowUnauthenticatedIdentities: Bool = false,
        cognitoIdentityProviders: [CognitoIdentityProvider]? = nil,
        developerProviderName: String? = nil,
        identityPoolId: String? = nil,
        identityPoolName: String? = nil,
        identityPoolTags: [String:String]? = nil,
        openIdConnectProviderARNs: [String]? = nil,
        samlProviderARNs: [String]? = nil,
        supportedLoginProviders: [String:String]? = nil
    )
    {
        self.allowClassicFlow = allowClassicFlow
        self.allowUnauthenticatedIdentities = allowUnauthenticatedIdentities
        self.cognitoIdentityProviders = cognitoIdentityProviders
        self.developerProviderName = developerProviderName
        self.identityPoolId = identityPoolId
        self.identityPoolName = identityPoolName
        self.identityPoolTags = identityPoolTags
        self.openIdConnectProviderARNs = openIdConnectProviderARNs
        self.samlProviderARNs = samlProviderARNs
        self.supportedLoginProviders = supportedLoginProviders
    }
}

struct DescribeIdentityPoolOutputResponseBody: Equatable {
    public let identityPoolId: String?
    public let identityPoolName: String?
    public let allowUnauthenticatedIdentities: Bool
    public let allowClassicFlow: Bool?
    public let supportedLoginProviders: [String:String]?
    public let developerProviderName: String?
    public let openIdConnectProviderARNs: [String]?
    public let cognitoIdentityProviders: [CognitoIdentityProvider]?
    public let samlProviderARNs: [String]?
    public let identityPoolTags: [String:String]?
}

extension DescribeIdentityPoolOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let allowUnauthenticatedIdentitiesDecoded = try containerValues.decode(Bool.self, forKey: .allowUnauthenticatedIdentities)
        allowUnauthenticatedIdentities = allowUnauthenticatedIdentitiesDecoded
        let allowClassicFlowDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowClassicFlow)
        allowClassicFlow = allowClassicFlowDecoded
        let supportedLoginProvidersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .supportedLoginProviders)
        var supportedLoginProvidersDecoded0: [String:String]? = nil
        if let supportedLoginProvidersContainer = supportedLoginProvidersContainer {
            supportedLoginProvidersDecoded0 = [String:String]()
            for (key0, identityproviderid0) in supportedLoginProvidersContainer {
                if let identityproviderid0 = identityproviderid0 {
                    supportedLoginProvidersDecoded0?[key0] = identityproviderid0
                }
            }
        }
        supportedLoginProviders = supportedLoginProvidersDecoded0
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let openIdConnectProviderARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .openIdConnectProviderARNs)
        var openIdConnectProviderARNsDecoded0:[String]? = nil
        if let openIdConnectProviderARNsContainer = openIdConnectProviderARNsContainer {
            openIdConnectProviderARNsDecoded0 = [String]()
            for string0 in openIdConnectProviderARNsContainer {
                if let string0 = string0 {
                    openIdConnectProviderARNsDecoded0?.append(string0)
                }
            }
        }
        openIdConnectProviderARNs = openIdConnectProviderARNsDecoded0
        let cognitoIdentityProvidersContainer = try containerValues.decodeIfPresent([CognitoIdentityProvider?].self, forKey: .cognitoIdentityProviders)
        var cognitoIdentityProvidersDecoded0:[CognitoIdentityProvider]? = nil
        if let cognitoIdentityProvidersContainer = cognitoIdentityProvidersContainer {
            cognitoIdentityProvidersDecoded0 = [CognitoIdentityProvider]()
            for structure0 in cognitoIdentityProvidersContainer {
                if let structure0 = structure0 {
                    cognitoIdentityProvidersDecoded0?.append(structure0)
                }
            }
        }
        cognitoIdentityProviders = cognitoIdentityProvidersDecoded0
        let samlProviderARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .samlProviderARNs)
        var samlProviderARNsDecoded0:[String]? = nil
        if let samlProviderARNsContainer = samlProviderARNsContainer {
            samlProviderARNsDecoded0 = [String]()
            for string0 in samlProviderARNsContainer {
                if let string0 = string0 {
                    samlProviderARNsDecoded0?.append(string0)
                }
            }
        }
        samlProviderARNs = samlProviderARNsDecoded0
        let identityPoolTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .identityPoolTags)
        var identityPoolTagsDecoded0: [String:String]? = nil
        if let identityPoolTagsContainer = identityPoolTagsContainer {
            identityPoolTagsDecoded0 = [String:String]()
            for (key0, tagvaluetype0) in identityPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    identityPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        identityPoolTags = identityPoolTagsDecoded0
    }
}

extension DeveloperUserAlreadyRegisteredException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeveloperUserAlreadyRegisteredException(message: \(String(describing: message)))"}
}

extension DeveloperUserAlreadyRegisteredException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeveloperUserAlreadyRegisteredExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The provided developer user identifier is already registered with Cognito under a
///          different identity ID.</p>
public struct DeveloperUserAlreadyRegisteredException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>This developer user identifier is already registered with Cognito.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct DeveloperUserAlreadyRegisteredExceptionBody: Equatable {
    public let message: String?
}

extension DeveloperUserAlreadyRegisteredExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ErrorCode {
    case accessDenied
    case internalServerError
    case sdkUnknown(String)
}

extension ErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ErrorCode] {
        return [
            .accessDenied,
            .internalServerError,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessDenied: return "AccessDenied"
        case .internalServerError: return "InternalServerError"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
    }
}

extension ExternalServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExternalServiceException(message: \(String(describing: message)))"}
}

extension ExternalServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExternalServiceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An exception thrown when a dependent service such as Facebook or Twitter is not
///          responding</p>
public struct ExternalServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned by an ExternalServiceException</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ExternalServiceExceptionBody: Equatable {
    public let message: String?
}

extension ExternalServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct GetCredentialsForIdentityInputBodyMiddleware: Middleware {
    public let id: String = "GetCredentialsForIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCredentialsForIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCredentialsForIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCredentialsForIdentityInput>
    public typealias MOutput = OperationOutput<GetCredentialsForIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCredentialsForIdentityOutputError>
}

extension GetCredentialsForIdentityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCredentialsForIdentityInput(customRoleArn: \(String(describing: customRoleArn)), identityId: \(String(describing: identityId)), logins: \(String(describing: logins)))"}
}

extension GetCredentialsForIdentityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customRoleArn = "CustomRoleArn"
        case identityId = "IdentityId"
        case logins = "Logins"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customRoleArn = customRoleArn {
            try encodeContainer.encode(customRoleArn, forKey: .customRoleArn)
        }
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .logins)
            for (dictKey0, loginsmap0) in logins {
                try loginsContainer.encode(loginsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct GetCredentialsForIdentityInputHeadersMiddleware: Middleware {
    public let id: String = "GetCredentialsForIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCredentialsForIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCredentialsForIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCredentialsForIdentityInput>
    public typealias MOutput = OperationOutput<GetCredentialsForIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCredentialsForIdentityOutputError>
}

public struct GetCredentialsForIdentityInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCredentialsForIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCredentialsForIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCredentialsForIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCredentialsForIdentityInput>
    public typealias MOutput = OperationOutput<GetCredentialsForIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCredentialsForIdentityOutputError>
}

/// <p>Input to the <code>GetCredentialsForIdentity</code> action.</p>
public struct GetCredentialsForIdentityInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the role to be assumed when multiple roles were
    ///          received in the token from the identity provider. For example, a SAML-based identity
    ///          provider. This parameter is optional for identity providers that do not support role
    ///          customization.</p>
    public let customRoleArn: String?
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: String?
    /// <p>A set of optional name-value pairs that map provider names to provider tokens. The
    ///          name-value pair will follow the syntax "provider_name":
    ///          "provider_user_identifier".</p>
    ///          <p>Logins should not be specified when trying to get credentials for an unauthenticated
    ///          identity.</p>
    ///          <p>The Logins parameter is required when using identities associated with external
    ///          identity providers such as Facebook. For examples of <code>Logins</code> maps, see the code
    ///          examples in the <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/external-identity-providers.html">External Identity Providers</a> section of the Amazon Cognito Developer
    ///          Guide.</p>
    public let logins: [String:String]?

    public init (
        customRoleArn: String? = nil,
        identityId: String? = nil,
        logins: [String:String]? = nil
    )
    {
        self.customRoleArn = customRoleArn
        self.identityId = identityId
        self.logins = logins
    }
}

struct GetCredentialsForIdentityInputBody: Equatable {
    public let identityId: String?
    public let logins: [String:String]?
    public let customRoleArn: String?
}

extension GetCredentialsForIdentityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customRoleArn = "CustomRoleArn"
        case identityId = "IdentityId"
        case logins = "Logins"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .logins)
        var loginsDecoded0: [String:String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [String:String]()
            for (key0, identityprovidertoken0) in loginsContainer {
                if let identityprovidertoken0 = identityprovidertoken0 {
                    loginsDecoded0?[key0] = identityprovidertoken0
                }
            }
        }
        logins = loginsDecoded0
        let customRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customRoleArn)
        customRoleArn = customRoleArnDecoded
    }
}

extension GetCredentialsForIdentityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCredentialsForIdentityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ExternalServiceException" : self = .externalServiceException(try ExternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidIdentityPoolConfigurationException" : self = .invalidIdentityPoolConfigurationException(try InvalidIdentityPoolConfigurationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCredentialsForIdentityOutputError: Equatable {
    case externalServiceException(ExternalServiceException)
    case internalErrorException(InternalErrorException)
    case invalidIdentityPoolConfigurationException(InvalidIdentityPoolConfigurationException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCredentialsForIdentityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCredentialsForIdentityOutputResponse(credentials: \(String(describing: credentials)), identityId: \(String(describing: identityId)))"}
}

extension GetCredentialsForIdentityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCredentialsForIdentityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.credentials = output.credentials
            self.identityId = output.identityId
        } else {
            self.credentials = nil
            self.identityId = nil
        }
    }
}

/// <p>Returned in response to a successful <code>GetCredentialsForIdentity</code>
///          operation.</p>
public struct GetCredentialsForIdentityOutputResponse: Equatable {
    /// <p>Credentials for the provided identity ID.</p>
    public let credentials: Credentials?
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: String?

    public init (
        credentials: Credentials? = nil,
        identityId: String? = nil
    )
    {
        self.credentials = credentials
        self.identityId = identityId
    }
}

struct GetCredentialsForIdentityOutputResponseBody: Equatable {
    public let identityId: String?
    public let credentials: Credentials?
}

extension GetCredentialsForIdentityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case credentials = "Credentials"
        case identityId = "IdentityId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let credentialsDecoded = try containerValues.decodeIfPresent(Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
    }
}

public struct GetIdInputBodyMiddleware: Middleware {
    public let id: String = "GetIdInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdInput>
    public typealias MOutput = OperationOutput<GetIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdOutputError>
}

extension GetIdInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIdInput(accountId: \(String(describing: accountId)), identityPoolId: \(String(describing: identityPoolId)), logins: \(String(describing: logins)))"}
}

extension GetIdInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case identityPoolId = "IdentityPoolId"
        case logins = "Logins"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .logins)
            for (dictKey0, loginsmap0) in logins {
                try loginsContainer.encode(loginsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct GetIdInputHeadersMiddleware: Middleware {
    public let id: String = "GetIdInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdInput>
    public typealias MOutput = OperationOutput<GetIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdOutputError>
}

public struct GetIdInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIdInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdInput>
    public typealias MOutput = OperationOutput<GetIdOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdOutputError>
}

/// <p>Input to the GetId action.</p>
public struct GetIdInput: Equatable {
    /// <p>A standard AWS account ID (9+ digits).</p>
    public let accountId: String?
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: String?
    /// <p>A set of optional name-value pairs that map provider names to provider tokens. The
    ///          available provider names for <code>Logins</code> are as follows:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Facebook: <code>graph.facebook.com</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon Cognito user pool:
    ///                   <code>cognito-idp.<region>.amazonaws.com/<YOUR_USER_POOL_ID></code>,
    ///                for example, <code>cognito-idp.us-east-1.amazonaws.com/us-east-1_123456789</code>.
    ///             </p>
    ///             </li>
    ///             <li>
    ///                <p>Google: <code>accounts.google.com</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Amazon: <code>www.amazon.com</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Twitter: <code>api.twitter.com</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Digits: <code>www.digits.com</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let logins: [String:String]?

    public init (
        accountId: String? = nil,
        identityPoolId: String? = nil,
        logins: [String:String]? = nil
    )
    {
        self.accountId = accountId
        self.identityPoolId = identityPoolId
        self.logins = logins
    }
}

struct GetIdInputBody: Equatable {
    public let accountId: String?
    public let identityPoolId: String?
    public let logins: [String:String]?
}

extension GetIdInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountId = "AccountId"
        case identityPoolId = "IdentityPoolId"
        case logins = "Logins"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .logins)
        var loginsDecoded0: [String:String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [String:String]()
            for (key0, identityprovidertoken0) in loginsContainer {
                if let identityprovidertoken0 = identityprovidertoken0 {
                    loginsDecoded0?[key0] = identityprovidertoken0
                }
            }
        }
        logins = loginsDecoded0
    }
}

extension GetIdOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIdOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ExternalServiceException" : self = .externalServiceException(try ExternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIdOutputError: Equatable {
    case externalServiceException(ExternalServiceException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIdOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIdOutputResponse(identityId: \(String(describing: identityId)))"}
}

extension GetIdOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetIdOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.identityId = output.identityId
        } else {
            self.identityId = nil
        }
    }
}

/// <p>Returned in response to a GetId request.</p>
public struct GetIdOutputResponse: Equatable {
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: String?

    public init (
        identityId: String? = nil
    )
    {
        self.identityId = identityId
    }
}

struct GetIdOutputResponseBody: Equatable {
    public let identityId: String?
}

extension GetIdOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityId = "IdentityId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityId)
        identityId = identityIdDecoded
    }
}

public struct GetIdentityPoolRolesInputBodyMiddleware: Middleware {
    public let id: String = "GetIdentityPoolRolesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityPoolRolesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityPoolRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityPoolRolesInput>
    public typealias MOutput = OperationOutput<GetIdentityPoolRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityPoolRolesOutputError>
}

extension GetIdentityPoolRolesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIdentityPoolRolesInput(identityPoolId: \(String(describing: identityPoolId)))"}
}

extension GetIdentityPoolRolesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
    }
}

public struct GetIdentityPoolRolesInputHeadersMiddleware: Middleware {
    public let id: String = "GetIdentityPoolRolesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityPoolRolesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityPoolRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityPoolRolesInput>
    public typealias MOutput = OperationOutput<GetIdentityPoolRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityPoolRolesOutputError>
}

public struct GetIdentityPoolRolesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIdentityPoolRolesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIdentityPoolRolesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIdentityPoolRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIdentityPoolRolesInput>
    public typealias MOutput = OperationOutput<GetIdentityPoolRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIdentityPoolRolesOutputError>
}

/// <p>Input to the <code>GetIdentityPoolRoles</code> action.</p>
public struct GetIdentityPoolRolesInput: Equatable {
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: String?

    public init (
        identityPoolId: String? = nil
    )
    {
        self.identityPoolId = identityPoolId
    }
}

struct GetIdentityPoolRolesInputBody: Equatable {
    public let identityPoolId: String?
}

extension GetIdentityPoolRolesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityPoolId = "IdentityPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
    }
}

extension GetIdentityPoolRolesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIdentityPoolRolesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIdentityPoolRolesOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIdentityPoolRolesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIdentityPoolRolesOutputResponse(identityPoolId: \(String(describing: identityPoolId)), roleMappings: \(String(describing: roleMappings)), roles: \(String(describing: roles)))"}
}

extension GetIdentityPoolRolesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetIdentityPoolRolesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.identityPoolId = output.identityPoolId
            self.roleMappings = output.roleMappings
            self.roles = output.roles
        } else {
            self.identityPoolId = nil
            self.roleMappings = nil
            self.roles = nil
        }
    }
}

/// <p>Returned in response to a successful <code>GetIdentityPoolRoles</code>
///          operation.</p>
public struct GetIdentityPoolRolesOutputResponse: Equatable {
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: String?
    /// <p>How users for a specific identity provider are to mapped to roles. This is a
    ///             String-to-<a>RoleMapping</a> object map. The string identifies the identity
    ///          provider, for example, "graph.facebook.com" or
    ///          "cognito-idp.us-east-1.amazonaws.com/us-east-1_abcdefghi:app_client_id".</p>
    public let roleMappings: [String:RoleMapping]?
    /// <p>The map of roles associated with this pool. Currently only authenticated and
    ///          unauthenticated roles are supported.</p>
    public let roles: [String:String]?

    public init (
        identityPoolId: String? = nil,
        roleMappings: [String:RoleMapping]? = nil,
        roles: [String:String]? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.roleMappings = roleMappings
        self.roles = roles
    }
}

struct GetIdentityPoolRolesOutputResponseBody: Equatable {
    public let identityPoolId: String?
    public let roles: [String:String]?
    public let roleMappings: [String:RoleMapping]?
}

extension GetIdentityPoolRolesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityPoolId = "IdentityPoolId"
        case roleMappings = "RoleMappings"
        case roles = "Roles"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let rolesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .roles)
        var rolesDecoded0: [String:String]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [String:String]()
            for (key0, arnstring0) in rolesContainer {
                if let arnstring0 = arnstring0 {
                    rolesDecoded0?[key0] = arnstring0
                }
            }
        }
        roles = rolesDecoded0
        let roleMappingsContainer = try containerValues.decodeIfPresent([String: RoleMapping?].self, forKey: .roleMappings)
        var roleMappingsDecoded0: [String:RoleMapping]? = nil
        if let roleMappingsContainer = roleMappingsContainer {
            roleMappingsDecoded0 = [String:RoleMapping]()
            for (key0, rolemapping0) in roleMappingsContainer {
                if let rolemapping0 = rolemapping0 {
                    roleMappingsDecoded0?[key0] = rolemapping0
                }
            }
        }
        roleMappings = roleMappingsDecoded0
    }
}

public struct GetOpenIdTokenForDeveloperIdentityInputBodyMiddleware: Middleware {
    public let id: String = "GetOpenIdTokenForDeveloperIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOpenIdTokenForDeveloperIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOpenIdTokenForDeveloperIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOpenIdTokenForDeveloperIdentityInput>
    public typealias MOutput = OperationOutput<GetOpenIdTokenForDeveloperIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOpenIdTokenForDeveloperIdentityOutputError>
}

extension GetOpenIdTokenForDeveloperIdentityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOpenIdTokenForDeveloperIdentityInput(identityId: \(String(describing: identityId)), identityPoolId: \(String(describing: identityPoolId)), logins: \(String(describing: logins)), principalTags: \(String(describing: principalTags)), tokenDuration: \(String(describing: tokenDuration)))"}
}

extension GetOpenIdTokenForDeveloperIdentityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
        case logins = "Logins"
        case principalTags = "PrincipalTags"
        case tokenDuration = "TokenDuration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .logins)
            for (dictKey0, loginsmap0) in logins {
                try loginsContainer.encode(loginsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let principalTags = principalTags {
            var principalTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .principalTags)
            for (dictKey0, principaltags0) in principalTags {
                try principalTagsContainer.encode(principaltags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let tokenDuration = tokenDuration {
            try encodeContainer.encode(tokenDuration, forKey: .tokenDuration)
        }
    }
}

public struct GetOpenIdTokenForDeveloperIdentityInputHeadersMiddleware: Middleware {
    public let id: String = "GetOpenIdTokenForDeveloperIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOpenIdTokenForDeveloperIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOpenIdTokenForDeveloperIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOpenIdTokenForDeveloperIdentityInput>
    public typealias MOutput = OperationOutput<GetOpenIdTokenForDeveloperIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOpenIdTokenForDeveloperIdentityOutputError>
}

public struct GetOpenIdTokenForDeveloperIdentityInputQueryItemMiddleware: Middleware {
    public let id: String = "GetOpenIdTokenForDeveloperIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOpenIdTokenForDeveloperIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOpenIdTokenForDeveloperIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOpenIdTokenForDeveloperIdentityInput>
    public typealias MOutput = OperationOutput<GetOpenIdTokenForDeveloperIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOpenIdTokenForDeveloperIdentityOutputError>
}

/// <p>Input to the <code>GetOpenIdTokenForDeveloperIdentity</code> action.</p>
public struct GetOpenIdTokenForDeveloperIdentityInput: Equatable {
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: String?
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: String?
    /// <p>A set of optional name-value pairs that map provider names to provider tokens. Each
    ///          name-value pair represents a user from a public provider or developer provider. If the user
    ///          is from a developer provider, the name-value pair will follow the syntax
    ///             <code>"developer_provider_name": "developer_user_identifier"</code>. The developer
    ///          provider is the "domain" by which Cognito will refer to your users; you provided this
    ///          domain while creating/updating the identity pool. The developer user identifier is an
    ///          identifier from your backend that uniquely identifies a user. When you create an identity
    ///          pool, you can specify the supported logins.</p>
    public let logins: [String:String]?
    /// <p>Use this operation to configure attribute mappings for custom providers. </p>
    public let principalTags: [String:String]?
    /// <p>The expiration time of the token, in seconds. You can specify a custom expiration
    ///          time for the token so that you can cache it. If you don't provide an expiration time, the
    ///          token is valid for 15 minutes. You can exchange the token with Amazon STS for temporary AWS
    ///          credentials, which are valid for a maximum of one hour. The maximum token duration you can
    ///          set is 24 hours. You should take care in setting the expiration time for a token, as there
    ///          are significant security implications: an attacker could use a leaked token to access your
    ///          AWS resources for the token's duration.</p>
    ///          <note>
    ///             <p>Please provide for a small grace period, usually no more than 5 minutes, to account for clock skew.</p>
    ///          </note>
    public let tokenDuration: Int?

    public init (
        identityId: String? = nil,
        identityPoolId: String? = nil,
        logins: [String:String]? = nil,
        principalTags: [String:String]? = nil,
        tokenDuration: Int? = nil
    )
    {
        self.identityId = identityId
        self.identityPoolId = identityPoolId
        self.logins = logins
        self.principalTags = principalTags
        self.tokenDuration = tokenDuration
    }
}

struct GetOpenIdTokenForDeveloperIdentityInputBody: Equatable {
    public let identityPoolId: String?
    public let identityId: String?
    public let logins: [String:String]?
    public let principalTags: [String:String]?
    public let tokenDuration: Int?
}

extension GetOpenIdTokenForDeveloperIdentityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
        case logins = "Logins"
        case principalTags = "PrincipalTags"
        case tokenDuration = "TokenDuration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .logins)
        var loginsDecoded0: [String:String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [String:String]()
            for (key0, identityprovidertoken0) in loginsContainer {
                if let identityprovidertoken0 = identityprovidertoken0 {
                    loginsDecoded0?[key0] = identityprovidertoken0
                }
            }
        }
        logins = loginsDecoded0
        let principalTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .principalTags)
        var principalTagsDecoded0: [String:String]? = nil
        if let principalTagsContainer = principalTagsContainer {
            principalTagsDecoded0 = [String:String]()
            for (key0, principaltagvalue0) in principalTagsContainer {
                if let principaltagvalue0 = principaltagvalue0 {
                    principalTagsDecoded0?[key0] = principaltagvalue0
                }
            }
        }
        principalTags = principalTagsDecoded0
        let tokenDurationDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .tokenDuration)
        tokenDuration = tokenDurationDecoded
    }
}

extension GetOpenIdTokenForDeveloperIdentityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOpenIdTokenForDeveloperIdentityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "DeveloperUserAlreadyRegisteredException" : self = .developerUserAlreadyRegisteredException(try DeveloperUserAlreadyRegisteredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOpenIdTokenForDeveloperIdentityOutputError: Equatable {
    case developerUserAlreadyRegisteredException(DeveloperUserAlreadyRegisteredException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOpenIdTokenForDeveloperIdentityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOpenIdTokenForDeveloperIdentityOutputResponse(identityId: \(String(describing: identityId)), token: \(String(describing: token)))"}
}

extension GetOpenIdTokenForDeveloperIdentityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetOpenIdTokenForDeveloperIdentityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.identityId = output.identityId
            self.token = output.token
        } else {
            self.identityId = nil
            self.token = nil
        }
    }
}

/// <p>Returned in response to a successful <code>GetOpenIdTokenForDeveloperIdentity</code>
///          request.</p>
public struct GetOpenIdTokenForDeveloperIdentityOutputResponse: Equatable {
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: String?
    /// <p>An OpenID token.</p>
    public let token: String?

    public init (
        identityId: String? = nil,
        token: String? = nil
    )
    {
        self.identityId = identityId
        self.token = token
    }
}

struct GetOpenIdTokenForDeveloperIdentityOutputResponseBody: Equatable {
    public let identityId: String?
    public let token: String?
}

extension GetOpenIdTokenForDeveloperIdentityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityId = "IdentityId"
        case token = "Token"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .token)
        token = tokenDecoded
    }
}

public struct GetOpenIdTokenInputBodyMiddleware: Middleware {
    public let id: String = "GetOpenIdTokenInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOpenIdTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOpenIdTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOpenIdTokenInput>
    public typealias MOutput = OperationOutput<GetOpenIdTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOpenIdTokenOutputError>
}

extension GetOpenIdTokenInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOpenIdTokenInput(identityId: \(String(describing: identityId)), logins: \(String(describing: logins)))"}
}

extension GetOpenIdTokenInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityId = "IdentityId"
        case logins = "Logins"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .logins)
            for (dictKey0, loginsmap0) in logins {
                try loginsContainer.encode(loginsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct GetOpenIdTokenInputHeadersMiddleware: Middleware {
    public let id: String = "GetOpenIdTokenInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOpenIdTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOpenIdTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOpenIdTokenInput>
    public typealias MOutput = OperationOutput<GetOpenIdTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOpenIdTokenOutputError>
}

public struct GetOpenIdTokenInputQueryItemMiddleware: Middleware {
    public let id: String = "GetOpenIdTokenInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetOpenIdTokenInput>,
                  next: H) -> Swift.Result<OperationOutput<GetOpenIdTokenOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetOpenIdTokenInput>
    public typealias MOutput = OperationOutput<GetOpenIdTokenOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetOpenIdTokenOutputError>
}

/// <p>Input to the GetOpenIdToken action.</p>
public struct GetOpenIdTokenInput: Equatable {
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: String?
    /// <p>A set of optional name-value pairs that map provider names to provider tokens. When
    ///          using graph.facebook.com and www.amazon.com, supply the access_token returned from the
    ///          provider's authflow. For accounts.google.com, an Amazon Cognito user pool provider, or any
    ///          other OpenID Connect provider, always include the <code>id_token</code>.</p>
    public let logins: [String:String]?

    public init (
        identityId: String? = nil,
        logins: [String:String]? = nil
    )
    {
        self.identityId = identityId
        self.logins = logins
    }
}

struct GetOpenIdTokenInputBody: Equatable {
    public let identityId: String?
    public let logins: [String:String]?
}

extension GetOpenIdTokenInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityId = "IdentityId"
        case logins = "Logins"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .logins)
        var loginsDecoded0: [String:String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [String:String]()
            for (key0, identityprovidertoken0) in loginsContainer {
                if let identityprovidertoken0 = identityprovidertoken0 {
                    loginsDecoded0?[key0] = identityprovidertoken0
                }
            }
        }
        logins = loginsDecoded0
    }
}

extension GetOpenIdTokenOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetOpenIdTokenOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ExternalServiceException" : self = .externalServiceException(try ExternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetOpenIdTokenOutputError: Equatable {
    case externalServiceException(ExternalServiceException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetOpenIdTokenOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetOpenIdTokenOutputResponse(identityId: \(String(describing: identityId)), token: \(String(describing: token)))"}
}

extension GetOpenIdTokenOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetOpenIdTokenOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.identityId = output.identityId
            self.token = output.token
        } else {
            self.identityId = nil
            self.token = nil
        }
    }
}

/// <p>Returned in response to a successful GetOpenIdToken request.</p>
public struct GetOpenIdTokenOutputResponse: Equatable {
    /// <p>A unique identifier in the format REGION:GUID. Note that the IdentityId returned may
    ///          not match the one passed on input.</p>
    public let identityId: String?
    /// <p>An OpenID token, valid for 10 minutes.</p>
    public let token: String?

    public init (
        identityId: String? = nil,
        token: String? = nil
    )
    {
        self.identityId = identityId
        self.token = token
    }
}

struct GetOpenIdTokenOutputResponseBody: Equatable {
    public let identityId: String?
    public let token: String?
}

extension GetOpenIdTokenOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityId = "IdentityId"
        case token = "Token"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let tokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .token)
        token = tokenDecoded
    }
}

public struct GetPrincipalTagAttributeMapInputBodyMiddleware: Middleware {
    public let id: String = "GetPrincipalTagAttributeMapInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPrincipalTagAttributeMapInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPrincipalTagAttributeMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPrincipalTagAttributeMapInput>
    public typealias MOutput = OperationOutput<GetPrincipalTagAttributeMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPrincipalTagAttributeMapOutputError>
}

extension GetPrincipalTagAttributeMapInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPrincipalTagAttributeMapInput(identityPoolId: \(String(describing: identityPoolId)), identityProviderName: \(String(describing: identityProviderName)))"}
}

extension GetPrincipalTagAttributeMapInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let identityProviderName = identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
    }
}

public struct GetPrincipalTagAttributeMapInputHeadersMiddleware: Middleware {
    public let id: String = "GetPrincipalTagAttributeMapInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPrincipalTagAttributeMapInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPrincipalTagAttributeMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPrincipalTagAttributeMapInput>
    public typealias MOutput = OperationOutput<GetPrincipalTagAttributeMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPrincipalTagAttributeMapOutputError>
}

public struct GetPrincipalTagAttributeMapInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPrincipalTagAttributeMapInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPrincipalTagAttributeMapInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPrincipalTagAttributeMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPrincipalTagAttributeMapInput>
    public typealias MOutput = OperationOutput<GetPrincipalTagAttributeMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPrincipalTagAttributeMapOutputError>
}

public struct GetPrincipalTagAttributeMapInput: Equatable {
    /// <p>You can use this operation to get the ID of the Identity Pool you setup attribute mappings for.</p>
    public let identityPoolId: String?
    /// <p>You can use this operation to get the provider name.</p>
    public let identityProviderName: String?

    public init (
        identityPoolId: String? = nil,
        identityProviderName: String? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.identityProviderName = identityProviderName
    }
}

struct GetPrincipalTagAttributeMapInputBody: Equatable {
    public let identityPoolId: String?
    public let identityProviderName: String?
}

extension GetPrincipalTagAttributeMapInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
    }
}

extension GetPrincipalTagAttributeMapOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPrincipalTagAttributeMapOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPrincipalTagAttributeMapOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPrincipalTagAttributeMapOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPrincipalTagAttributeMapOutputResponse(identityPoolId: \(String(describing: identityPoolId)), identityProviderName: \(String(describing: identityProviderName)), principalTags: \(String(describing: principalTags)), useDefaults: \(String(describing: useDefaults)))"}
}

extension GetPrincipalTagAttributeMapOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPrincipalTagAttributeMapOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.identityPoolId = output.identityPoolId
            self.identityProviderName = output.identityProviderName
            self.principalTags = output.principalTags
            self.useDefaults = output.useDefaults
        } else {
            self.identityPoolId = nil
            self.identityProviderName = nil
            self.principalTags = nil
            self.useDefaults = nil
        }
    }
}

public struct GetPrincipalTagAttributeMapOutputResponse: Equatable {
    /// <p>You can use this operation to get the ID of the Identity Pool you setup attribute mappings for.</p>
    public let identityPoolId: String?
    /// <p>You can use this operation to get the provider name.</p>
    public let identityProviderName: String?
    /// <p>You can use this operation to add principal tags. The <code>PrincipalTags</code>operation enables you to reference user attributes in your IAM permissions policy.</p>
    public let principalTags: [String:String]?
    /// <p>You can use this operation to list </p>
    public let useDefaults: Bool?

    public init (
        identityPoolId: String? = nil,
        identityProviderName: String? = nil,
        principalTags: [String:String]? = nil,
        useDefaults: Bool? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.identityProviderName = identityProviderName
        self.principalTags = principalTags
        self.useDefaults = useDefaults
    }
}

struct GetPrincipalTagAttributeMapOutputResponseBody: Equatable {
    public let identityPoolId: String?
    public let identityProviderName: String?
    public let useDefaults: Bool?
    public let principalTags: [String:String]?
}

extension GetPrincipalTagAttributeMapOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
        case principalTags = "PrincipalTags"
        case useDefaults = "UseDefaults"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let useDefaultsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useDefaults)
        useDefaults = useDefaultsDecoded
        let principalTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .principalTags)
        var principalTagsDecoded0: [String:String]? = nil
        if let principalTagsContainer = principalTagsContainer {
            principalTagsDecoded0 = [String:String]()
            for (key0, principaltagvalue0) in principalTagsContainer {
                if let principaltagvalue0 = principaltagvalue0 {
                    principalTagsDecoded0?[key0] = principaltagvalue0
                }
            }
        }
        principalTags = principalTagsDecoded0
    }
}

extension IdentityDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate = "CreationDate"
        case identityId = "IdentityId"
        case lastModifiedDate = "LastModifiedDate"
        case logins = "Logins"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate.timeIntervalSince1970, forKey: .lastModifiedDate)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .logins)
            for loginslist0 in logins {
                try loginsContainer.encode(loginslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .logins)
        var loginsDecoded0:[String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [String]()
            for string0 in loginsContainer {
                if let string0 = string0 {
                    loginsDecoded0?.append(string0)
                }
            }
        }
        logins = loginsDecoded0
        let creationDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
    }
}

extension IdentityDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdentityDescription(creationDate: \(String(describing: creationDate)), identityId: \(String(describing: identityId)), lastModifiedDate: \(String(describing: lastModifiedDate)), logins: \(String(describing: logins)))"}
}

/// <p>A description of the identity.</p>
public struct IdentityDescription: Equatable {
    /// <p>Date on which the identity was created.</p>
    public let creationDate: Date?
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: String?
    /// <p>Date on which the identity was last modified.</p>
    public let lastModifiedDate: Date?
    /// <p>The provider names.</p>
    public let logins: [String]?

    public init (
        creationDate: Date? = nil,
        identityId: String? = nil,
        lastModifiedDate: Date? = nil,
        logins: [String]? = nil
    )
    {
        self.creationDate = creationDate
        self.identityId = identityId
        self.lastModifiedDate = lastModifiedDate
        self.logins = logins
    }
}

extension IdentityPoolShortDescription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let identityPoolName = identityPoolName {
            try encodeContainer.encode(identityPoolName, forKey: .identityPoolName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
    }
}

extension IdentityPoolShortDescription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IdentityPoolShortDescription(identityPoolId: \(String(describing: identityPoolId)), identityPoolName: \(String(describing: identityPoolName)))"}
}

/// <p>A description of the identity pool.</p>
public struct IdentityPoolShortDescription: Equatable {
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: String?
    /// <p>A string that you provide.</p>
    public let identityPoolName: String?

    public init (
        identityPoolId: String? = nil,
        identityPoolName: String? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.identityPoolName = identityPoolName
    }
}

extension InternalErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalErrorException(message: \(String(describing: message)))"}
}

extension InternalErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Thrown when the service encounters an error during processing the request.</p>
public struct InternalErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The message returned by an InternalErrorException.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorExceptionBody: Equatable {
    public let message: String?
}

extension InternalErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidIdentityPoolConfigurationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidIdentityPoolConfigurationException(message: \(String(describing: message)))"}
}

extension InvalidIdentityPoolConfigurationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidIdentityPoolConfigurationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Thrown if the identity pool has no role associated for the given auth type
///          (auth/unauth) or if the AssumeRole fails.</p>
public struct InvalidIdentityPoolConfigurationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned for an <code>InvalidIdentityPoolConfigurationException</code>
    ///          </p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidIdentityPoolConfigurationExceptionBody: Equatable {
    public let message: String?
}

extension InvalidIdentityPoolConfigurationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterException(message: \(String(describing: message)))"}
}

extension InvalidParameterException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Thrown for missing or bad input parameter(s).</p>
public struct InvalidParameterException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned by an InvalidParameterException.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Equatable {
    public let message: String?
}

extension InvalidParameterExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Thrown when the total number of user pools has exceeded a preset limit.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned by a LimitExceededException.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListIdentitiesInputBodyMiddleware: Middleware {
    public let id: String = "ListIdentitiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIdentitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIdentitiesInput>
    public typealias MOutput = OperationOutput<ListIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIdentitiesOutputError>
}

extension ListIdentitiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIdentitiesInput(hideDisabled: \(String(describing: hideDisabled)), identityPoolId: \(String(describing: identityPoolId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIdentitiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hideDisabled = "HideDisabled"
        case identityPoolId = "IdentityPoolId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if hideDisabled != false {
            try encodeContainer.encode(hideDisabled, forKey: .hideDisabled)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListIdentitiesInputHeadersMiddleware: Middleware {
    public let id: String = "ListIdentitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIdentitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIdentitiesInput>
    public typealias MOutput = OperationOutput<ListIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIdentitiesOutputError>
}

public struct ListIdentitiesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListIdentitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIdentitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIdentitiesInput>
    public typealias MOutput = OperationOutput<ListIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIdentitiesOutputError>
}

/// <p>Input to the ListIdentities action.</p>
public struct ListIdentitiesInput: Equatable {
    /// <p>An optional boolean parameter that allows you to hide disabled identities. If
    ///          omitted, the ListIdentities API will include disabled identities in the response.</p>
    public let hideDisabled: Bool
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: String?
    /// <p>The maximum number of identities to return.</p>
    public let maxResults: Int
    /// <p>A pagination token.</p>
    public let nextToken: String?

    public init (
        hideDisabled: Bool = false,
        identityPoolId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.hideDisabled = hideDisabled
        self.identityPoolId = identityPoolId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIdentitiesInputBody: Equatable {
    public let identityPoolId: String?
    public let maxResults: Int
    public let nextToken: String?
    public let hideDisabled: Bool
}

extension ListIdentitiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case hideDisabled = "HideDisabled"
        case identityPoolId = "IdentityPoolId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let hideDisabledDecoded = try containerValues.decode(Bool.self, forKey: .hideDisabled)
        hideDisabled = hideDisabledDecoded
    }
}

extension ListIdentitiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIdentitiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIdentitiesOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIdentitiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIdentitiesOutputResponse(identities: \(String(describing: identities)), identityPoolId: \(String(describing: identityPoolId)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIdentitiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListIdentitiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.identities = output.identities
            self.identityPoolId = output.identityPoolId
            self.nextToken = output.nextToken
        } else {
            self.identities = nil
            self.identityPoolId = nil
            self.nextToken = nil
        }
    }
}

/// <p>The response to a ListIdentities request.</p>
public struct ListIdentitiesOutputResponse: Equatable {
    /// <p>An object containing a set of identities and associated mappings.</p>
    public let identities: [IdentityDescription]?
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: String?
    /// <p>A pagination token.</p>
    public let nextToken: String?

    public init (
        identities: [IdentityDescription]? = nil,
        identityPoolId: String? = nil,
        nextToken: String? = nil
    )
    {
        self.identities = identities
        self.identityPoolId = identityPoolId
        self.nextToken = nextToken
    }
}

struct ListIdentitiesOutputResponseBody: Equatable {
    public let identityPoolId: String?
    public let identities: [IdentityDescription]?
    public let nextToken: String?
}

extension ListIdentitiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identities = "Identities"
        case identityPoolId = "IdentityPoolId"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identitiesContainer = try containerValues.decodeIfPresent([IdentityDescription?].self, forKey: .identities)
        var identitiesDecoded0:[IdentityDescription]? = nil
        if let identitiesContainer = identitiesContainer {
            identitiesDecoded0 = [IdentityDescription]()
            for structure0 in identitiesContainer {
                if let structure0 = structure0 {
                    identitiesDecoded0?.append(structure0)
                }
            }
        }
        identities = identitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListIdentityPoolsInputBodyMiddleware: Middleware {
    public let id: String = "ListIdentityPoolsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIdentityPoolsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIdentityPoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIdentityPoolsInput>
    public typealias MOutput = OperationOutput<ListIdentityPoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIdentityPoolsOutputError>
}

extension ListIdentityPoolsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIdentityPoolsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIdentityPoolsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListIdentityPoolsInputHeadersMiddleware: Middleware {
    public let id: String = "ListIdentityPoolsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIdentityPoolsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIdentityPoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIdentityPoolsInput>
    public typealias MOutput = OperationOutput<ListIdentityPoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIdentityPoolsOutputError>
}

public struct ListIdentityPoolsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListIdentityPoolsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIdentityPoolsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIdentityPoolsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIdentityPoolsInput>
    public typealias MOutput = OperationOutput<ListIdentityPoolsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIdentityPoolsOutputError>
}

/// <p>Input to the ListIdentityPools action.</p>
public struct ListIdentityPoolsInput: Equatable {
    /// <p>The maximum number of identities to return.</p>
    public let maxResults: Int
    /// <p>A pagination token.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIdentityPoolsInputBody: Equatable {
    public let maxResults: Int
    public let nextToken: String?
}

extension ListIdentityPoolsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIdentityPoolsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIdentityPoolsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIdentityPoolsOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIdentityPoolsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIdentityPoolsOutputResponse(identityPools: \(String(describing: identityPools)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIdentityPoolsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListIdentityPoolsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.identityPools = output.identityPools
            self.nextToken = output.nextToken
        } else {
            self.identityPools = nil
            self.nextToken = nil
        }
    }
}

/// <p>The result of a successful ListIdentityPools action.</p>
public struct ListIdentityPoolsOutputResponse: Equatable {
    /// <p>The identity pools returned by the ListIdentityPools action.</p>
    public let identityPools: [IdentityPoolShortDescription]?
    /// <p>A pagination token.</p>
    public let nextToken: String?

    public init (
        identityPools: [IdentityPoolShortDescription]? = nil,
        nextToken: String? = nil
    )
    {
        self.identityPools = identityPools
        self.nextToken = nextToken
    }
}

struct ListIdentityPoolsOutputResponseBody: Equatable {
    public let identityPools: [IdentityPoolShortDescription]?
    public let nextToken: String?
}

extension ListIdentityPoolsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityPools = "IdentityPools"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolsContainer = try containerValues.decodeIfPresent([IdentityPoolShortDescription?].self, forKey: .identityPools)
        var identityPoolsDecoded0:[IdentityPoolShortDescription]? = nil
        if let identityPoolsContainer = identityPoolsContainer {
            identityPoolsDecoded0 = [IdentityPoolShortDescription]()
            for structure0 in identityPoolsContainer {
                if let structure0 = structure0 {
                    identityPoolsDecoded0?.append(structure0)
                }
            }
        }
        identityPools = identityPoolsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the identity pool that the tags are assigned
    ///          to.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags that are assigned to the identity pool.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvaluetype0) in tagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    tagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct LookupDeveloperIdentityInputBodyMiddleware: Middleware {
    public let id: String = "LookupDeveloperIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<LookupDeveloperIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<LookupDeveloperIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<LookupDeveloperIdentityInput>
    public typealias MOutput = OperationOutput<LookupDeveloperIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<LookupDeveloperIdentityOutputError>
}

extension LookupDeveloperIdentityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LookupDeveloperIdentityInput(developerUserIdentifier: \(String(describing: developerUserIdentifier)), identityId: \(String(describing: identityId)), identityPoolId: \(String(describing: identityPoolId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension LookupDeveloperIdentityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case developerUserIdentifier = "DeveloperUserIdentifier"
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let developerUserIdentifier = developerUserIdentifier {
            try encodeContainer.encode(developerUserIdentifier, forKey: .developerUserIdentifier)
        }
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct LookupDeveloperIdentityInputHeadersMiddleware: Middleware {
    public let id: String = "LookupDeveloperIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<LookupDeveloperIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<LookupDeveloperIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<LookupDeveloperIdentityInput>
    public typealias MOutput = OperationOutput<LookupDeveloperIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<LookupDeveloperIdentityOutputError>
}

public struct LookupDeveloperIdentityInputQueryItemMiddleware: Middleware {
    public let id: String = "LookupDeveloperIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<LookupDeveloperIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<LookupDeveloperIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<LookupDeveloperIdentityInput>
    public typealias MOutput = OperationOutput<LookupDeveloperIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<LookupDeveloperIdentityOutputError>
}

/// <p>Input to the <code>LookupDeveloperIdentityInput</code> action.</p>
public struct LookupDeveloperIdentityInput: Equatable {
    /// <p>A unique ID used by your backend authentication process to identify a user.
    ///          Typically, a developer identity provider would issue many developer user identifiers, in
    ///          keeping with the number of users.</p>
    public let developerUserIdentifier: String?
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: String?
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: String?
    /// <p>The maximum number of identities to return.</p>
    public let maxResults: Int
    /// <p>A pagination token. The first call you make will have <code>NextToken</code> set to
    ///          null. After that the service will return <code>NextToken</code> values as needed. For
    ///          example, let's say you make a request with <code>MaxResults</code> set to 10, and there are
    ///          20 matches in the database. The service will return a pagination token as a part of the
    ///          response. This token can be used to call the API again and get results starting from the
    ///          11th match.</p>
    public let nextToken: String?

    public init (
        developerUserIdentifier: String? = nil,
        identityId: String? = nil,
        identityPoolId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.developerUserIdentifier = developerUserIdentifier
        self.identityId = identityId
        self.identityPoolId = identityPoolId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct LookupDeveloperIdentityInputBody: Equatable {
    public let identityPoolId: String?
    public let identityId: String?
    public let developerUserIdentifier: String?
    public let maxResults: Int
    public let nextToken: String?
}

extension LookupDeveloperIdentityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case developerUserIdentifier = "DeveloperUserIdentifier"
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let developerUserIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .developerUserIdentifier)
        developerUserIdentifier = developerUserIdentifierDecoded
        let maxResultsDecoded = try containerValues.decode(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension LookupDeveloperIdentityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension LookupDeveloperIdentityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum LookupDeveloperIdentityOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension LookupDeveloperIdentityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LookupDeveloperIdentityOutputResponse(developerUserIdentifierList: \(String(describing: developerUserIdentifierList)), identityId: \(String(describing: identityId)), nextToken: \(String(describing: nextToken)))"}
}

extension LookupDeveloperIdentityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LookupDeveloperIdentityOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.developerUserIdentifierList = output.developerUserIdentifierList
            self.identityId = output.identityId
            self.nextToken = output.nextToken
        } else {
            self.developerUserIdentifierList = nil
            self.identityId = nil
            self.nextToken = nil
        }
    }
}

/// <p>Returned in response to a successful <code>LookupDeveloperIdentity</code>
///          action.</p>
public struct LookupDeveloperIdentityOutputResponse: Equatable {
    /// <p>This is the list of developer user identifiers associated with an identity ID.
    ///          Cognito supports the association of multiple developer user identifiers with an identity
    ///          ID.</p>
    public let developerUserIdentifierList: [String]?
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: String?
    /// <p>A pagination token. The first call you make will have <code>NextToken</code> set to
    ///          null. After that the service will return <code>NextToken</code> values as needed. For
    ///          example, let's say you make a request with <code>MaxResults</code> set to 10, and there are
    ///          20 matches in the database. The service will return a pagination token as a part of the
    ///          response. This token can be used to call the API again and get results starting from the
    ///          11th match.</p>
    public let nextToken: String?

    public init (
        developerUserIdentifierList: [String]? = nil,
        identityId: String? = nil,
        nextToken: String? = nil
    )
    {
        self.developerUserIdentifierList = developerUserIdentifierList
        self.identityId = identityId
        self.nextToken = nextToken
    }
}

struct LookupDeveloperIdentityOutputResponseBody: Equatable {
    public let identityId: String?
    public let developerUserIdentifierList: [String]?
    public let nextToken: String?
}

extension LookupDeveloperIdentityOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case developerUserIdentifierList = "DeveloperUserIdentifierList"
        case identityId = "IdentityId"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let developerUserIdentifierListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .developerUserIdentifierList)
        var developerUserIdentifierListDecoded0:[String]? = nil
        if let developerUserIdentifierListContainer = developerUserIdentifierListContainer {
            developerUserIdentifierListDecoded0 = [String]()
            for string0 in developerUserIdentifierListContainer {
                if let string0 = string0 {
                    developerUserIdentifierListDecoded0?.append(string0)
                }
            }
        }
        developerUserIdentifierList = developerUserIdentifierListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MappingRule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case claim = "Claim"
        case matchType = "MatchType"
        case roleARN = "RoleARN"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let claim = claim {
            try encodeContainer.encode(claim, forKey: .claim)
        }
        if let matchType = matchType {
            try encodeContainer.encode(matchType.rawValue, forKey: .matchType)
        }
        if let roleARN = roleARN {
            try encodeContainer.encode(roleARN, forKey: .roleARN)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let claimDecoded = try containerValues.decodeIfPresent(String.self, forKey: .claim)
        claim = claimDecoded
        let matchTypeDecoded = try containerValues.decodeIfPresent(MappingRuleMatchType.self, forKey: .matchType)
        matchType = matchTypeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
        let roleARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleARN)
        roleARN = roleARNDecoded
    }
}

extension MappingRule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MappingRule(claim: \(String(describing: claim)), matchType: \(String(describing: matchType)), roleARN: \(String(describing: roleARN)), value: \(String(describing: value)))"}
}

/// <p>A rule that maps a claim name, a claim value, and a match type to a role
///          ARN.</p>
public struct MappingRule: Equatable {
    /// <p>The claim name that must be present in the token, for example, "isAdmin" or
    ///          "paid".</p>
    public let claim: String?
    /// <p>The match condition that specifies how closely the claim value in the IdP token must
    ///          match <code>Value</code>.</p>
    public let matchType: MappingRuleMatchType?
    /// <p>The role ARN.</p>
    public let roleARN: String?
    /// <p>A brief string that the claim must match, for example, "paid" or "yes".</p>
    public let value: String?

    public init (
        claim: String? = nil,
        matchType: MappingRuleMatchType? = nil,
        roleARN: String? = nil,
        value: String? = nil
    )
    {
        self.claim = claim
        self.matchType = matchType
        self.roleARN = roleARN
        self.value = value
    }
}

public enum MappingRuleMatchType {
    case contains
    case equals
    case notEqual
    case startsWith
    case sdkUnknown(String)
}

extension MappingRuleMatchType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MappingRuleMatchType] {
        return [
            .contains,
            .equals,
            .notEqual,
            .startsWith,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .contains: return "Contains"
        case .equals: return "Equals"
        case .notEqual: return "NotEqual"
        case .startsWith: return "StartsWith"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MappingRuleMatchType(rawValue: rawValue) ?? MappingRuleMatchType.sdkUnknown(rawValue)
    }
}

public struct MergeDeveloperIdentitiesInputBodyMiddleware: Middleware {
    public let id: String = "MergeDeveloperIdentitiesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergeDeveloperIdentitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<MergeDeveloperIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergeDeveloperIdentitiesInput>
    public typealias MOutput = OperationOutput<MergeDeveloperIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergeDeveloperIdentitiesOutputError>
}

extension MergeDeveloperIdentitiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergeDeveloperIdentitiesInput(destinationUserIdentifier: \(String(describing: destinationUserIdentifier)), developerProviderName: \(String(describing: developerProviderName)), identityPoolId: \(String(describing: identityPoolId)), sourceUserIdentifier: \(String(describing: sourceUserIdentifier)))"}
}

extension MergeDeveloperIdentitiesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationUserIdentifier = "DestinationUserIdentifier"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case sourceUserIdentifier = "SourceUserIdentifier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationUserIdentifier = destinationUserIdentifier {
            try encodeContainer.encode(destinationUserIdentifier, forKey: .destinationUserIdentifier)
        }
        if let developerProviderName = developerProviderName {
            try encodeContainer.encode(developerProviderName, forKey: .developerProviderName)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let sourceUserIdentifier = sourceUserIdentifier {
            try encodeContainer.encode(sourceUserIdentifier, forKey: .sourceUserIdentifier)
        }
    }
}

public struct MergeDeveloperIdentitiesInputHeadersMiddleware: Middleware {
    public let id: String = "MergeDeveloperIdentitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergeDeveloperIdentitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<MergeDeveloperIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergeDeveloperIdentitiesInput>
    public typealias MOutput = OperationOutput<MergeDeveloperIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergeDeveloperIdentitiesOutputError>
}

public struct MergeDeveloperIdentitiesInputQueryItemMiddleware: Middleware {
    public let id: String = "MergeDeveloperIdentitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<MergeDeveloperIdentitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<MergeDeveloperIdentitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<MergeDeveloperIdentitiesInput>
    public typealias MOutput = OperationOutput<MergeDeveloperIdentitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<MergeDeveloperIdentitiesOutputError>
}

/// <p>Input to the <code>MergeDeveloperIdentities</code> action.</p>
public struct MergeDeveloperIdentitiesInput: Equatable {
    /// <p>User identifier for the destination user. The value should be a
    ///             <code>DeveloperUserIdentifier</code>.</p>
    public let destinationUserIdentifier: String?
    /// <p>The "domain" by which Cognito will refer to your users. This is a (pseudo) domain
    ///          name that you provide while creating an identity pool. This name acts as a placeholder that
    ///          allows your backend and the Cognito service to communicate about the developer provider.
    ///          For the <code>DeveloperProviderName</code>, you can use letters as well as period (.),
    ///          underscore (_), and dash (-).</p>
    public let developerProviderName: String?
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: String?
    /// <p>User identifier for the source user. The value should be a
    ///             <code>DeveloperUserIdentifier</code>.</p>
    public let sourceUserIdentifier: String?

    public init (
        destinationUserIdentifier: String? = nil,
        developerProviderName: String? = nil,
        identityPoolId: String? = nil,
        sourceUserIdentifier: String? = nil
    )
    {
        self.destinationUserIdentifier = destinationUserIdentifier
        self.developerProviderName = developerProviderName
        self.identityPoolId = identityPoolId
        self.sourceUserIdentifier = sourceUserIdentifier
    }
}

struct MergeDeveloperIdentitiesInputBody: Equatable {
    public let sourceUserIdentifier: String?
    public let destinationUserIdentifier: String?
    public let developerProviderName: String?
    public let identityPoolId: String?
}

extension MergeDeveloperIdentitiesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationUserIdentifier = "DestinationUserIdentifier"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case sourceUserIdentifier = "SourceUserIdentifier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceUserIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceUserIdentifier)
        sourceUserIdentifier = sourceUserIdentifierDecoded
        let destinationUserIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationUserIdentifier)
        destinationUserIdentifier = destinationUserIdentifierDecoded
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
    }
}

extension MergeDeveloperIdentitiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MergeDeveloperIdentitiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum MergeDeveloperIdentitiesOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MergeDeveloperIdentitiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MergeDeveloperIdentitiesOutputResponse(identityId: \(String(describing: identityId)))"}
}

extension MergeDeveloperIdentitiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MergeDeveloperIdentitiesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.identityId = output.identityId
        } else {
            self.identityId = nil
        }
    }
}

/// <p>Returned in response to a successful <code>MergeDeveloperIdentities</code>
///          action.</p>
public struct MergeDeveloperIdentitiesOutputResponse: Equatable {
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: String?

    public init (
        identityId: String? = nil
    )
    {
        self.identityId = identityId
    }
}

struct MergeDeveloperIdentitiesOutputResponseBody: Equatable {
    public let identityId: String?
}

extension MergeDeveloperIdentitiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityId = "IdentityId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityId)
        identityId = identityIdDecoded
    }
}

extension NotAuthorizedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotAuthorizedException(message: \(String(describing: message)))"}
}

extension NotAuthorizedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotAuthorizedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Thrown when a user is not authorized to access the requested resource.</p>
public struct NotAuthorizedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned by a NotAuthorizedException</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotAuthorizedExceptionBody: Equatable {
    public let message: String?
}

extension NotAuthorizedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceConflictException(message: \(String(describing: message)))"}
}

extension ResourceConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Thrown when a user tries to use a login which is already linked to another
///          account.</p>
public struct ResourceConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned by a ResourceConflictException.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceConflictExceptionBody: Equatable {
    public let message: String?
}

extension ResourceConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Thrown when the requested resource (for example, a dataset or record) does not
///          exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message returned by a ResourceNotFoundException.</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RoleMapping: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ambiguousRoleResolution = "AmbiguousRoleResolution"
        case rulesConfiguration = "RulesConfiguration"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ambiguousRoleResolution = ambiguousRoleResolution {
            try encodeContainer.encode(ambiguousRoleResolution.rawValue, forKey: .ambiguousRoleResolution)
        }
        if let rulesConfiguration = rulesConfiguration {
            try encodeContainer.encode(rulesConfiguration, forKey: .rulesConfiguration)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(RoleMappingType.self, forKey: .type)
        type = typeDecoded
        let ambiguousRoleResolutionDecoded = try containerValues.decodeIfPresent(AmbiguousRoleResolutionType.self, forKey: .ambiguousRoleResolution)
        ambiguousRoleResolution = ambiguousRoleResolutionDecoded
        let rulesConfigurationDecoded = try containerValues.decodeIfPresent(RulesConfigurationType.self, forKey: .rulesConfiguration)
        rulesConfiguration = rulesConfigurationDecoded
    }
}

extension RoleMapping: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RoleMapping(ambiguousRoleResolution: \(String(describing: ambiguousRoleResolution)), rulesConfiguration: \(String(describing: rulesConfiguration)), type: \(String(describing: type)))"}
}

/// <p>A role mapping.</p>
public struct RoleMapping: Equatable {
    /// <p>If you specify Token or Rules as the <code>Type</code>,
    ///             <code>AmbiguousRoleResolution</code> is required.</p>
    ///          <p>Specifies the action to be taken if either no rules match the claim value for the
    ///             <code>Rules</code> type, or there is no <code>cognito:preferred_role</code> claim and
    ///          there are multiple <code>cognito:roles</code> matches for the <code>Token</code>
    ///          type.</p>
    public let ambiguousRoleResolution: AmbiguousRoleResolutionType?
    /// <p>The rules to be used for mapping users to roles.</p>
    ///          <p>If you specify Rules as the role mapping type, <code>RulesConfiguration</code> is
    ///          required.</p>
    public let rulesConfiguration: RulesConfigurationType?
    /// <p>The role mapping type. Token will use <code>cognito:roles</code> and
    ///             <code>cognito:preferred_role</code> claims from the Cognito identity provider token to
    ///          map groups to roles. Rules will attempt to match claims from the token to map to a
    ///          role.</p>
    public let type: RoleMappingType?

    public init (
        ambiguousRoleResolution: AmbiguousRoleResolutionType? = nil,
        rulesConfiguration: RulesConfigurationType? = nil,
        type: RoleMappingType? = nil
    )
    {
        self.ambiguousRoleResolution = ambiguousRoleResolution
        self.rulesConfiguration = rulesConfiguration
        self.type = type
    }
}

public enum RoleMappingType {
    case rules
    case token
    case sdkUnknown(String)
}

extension RoleMappingType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RoleMappingType] {
        return [
            .rules,
            .token,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .rules: return "Rules"
        case .token: return "Token"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RoleMappingType(rawValue: rawValue) ?? RoleMappingType.sdkUnknown(rawValue)
    }
}

extension RulesConfigurationType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rules = "Rules"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for mappingruleslist0 in rules {
                try rulesContainer.encode(mappingruleslist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([MappingRule?].self, forKey: .rules)
        var rulesDecoded0:[MappingRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [MappingRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension RulesConfigurationType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RulesConfigurationType(rules: \(String(describing: rules)))"}
}

/// <p>A container for rules.</p>
public struct RulesConfigurationType: Equatable {
    /// <p>An array of rules. You can specify up to 25 rules per identity provider.</p>
    ///          <p>Rules are evaluated in order. The first one to match specifies the role.</p>
    public let rules: [MappingRule]?

    public init (
        rules: [MappingRule]? = nil
    )
    {
        self.rules = rules
    }
}

public struct SetIdentityPoolRolesInputBodyMiddleware: Middleware {
    public let id: String = "SetIdentityPoolRolesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIdentityPoolRolesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIdentityPoolRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIdentityPoolRolesInput>
    public typealias MOutput = OperationOutput<SetIdentityPoolRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIdentityPoolRolesOutputError>
}

extension SetIdentityPoolRolesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetIdentityPoolRolesInput(identityPoolId: \(String(describing: identityPoolId)), roleMappings: \(String(describing: roleMappings)), roles: \(String(describing: roles)))"}
}

extension SetIdentityPoolRolesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityPoolId = "IdentityPoolId"
        case roleMappings = "RoleMappings"
        case roles = "Roles"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let roleMappings = roleMappings {
            var roleMappingsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .roleMappings)
            for (dictKey0, rolemappingmap0) in roleMappings {
                try roleMappingsContainer.encode(rolemappingmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .roles)
            for (dictKey0, rolesmap0) in roles {
                try rolesContainer.encode(rolesmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct SetIdentityPoolRolesInputHeadersMiddleware: Middleware {
    public let id: String = "SetIdentityPoolRolesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIdentityPoolRolesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIdentityPoolRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIdentityPoolRolesInput>
    public typealias MOutput = OperationOutput<SetIdentityPoolRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIdentityPoolRolesOutputError>
}

public struct SetIdentityPoolRolesInputQueryItemMiddleware: Middleware {
    public let id: String = "SetIdentityPoolRolesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetIdentityPoolRolesInput>,
                  next: H) -> Swift.Result<OperationOutput<SetIdentityPoolRolesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetIdentityPoolRolesInput>
    public typealias MOutput = OperationOutput<SetIdentityPoolRolesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetIdentityPoolRolesOutputError>
}

/// <p>Input to the <code>SetIdentityPoolRoles</code> action.</p>
public struct SetIdentityPoolRolesInput: Equatable {
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: String?
    /// <p>How users for a specific identity provider are to mapped to roles. This is a string
    ///          to <a>RoleMapping</a> object map. The string identifies the identity provider,
    ///          for example, "graph.facebook.com" or
    ///          "cognito-idp.us-east-1.amazonaws.com/us-east-1_abcdefghi:app_client_id".</p>
    ///          <p>Up to 25 rules can be specified per identity provider.</p>
    public let roleMappings: [String:RoleMapping]?
    /// <p>The map of roles associated with this pool. For a given role, the key will be either
    ///          "authenticated" or "unauthenticated" and the value will be the Role ARN.</p>
    public let roles: [String:String]?

    public init (
        identityPoolId: String? = nil,
        roleMappings: [String:RoleMapping]? = nil,
        roles: [String:String]? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.roleMappings = roleMappings
        self.roles = roles
    }
}

struct SetIdentityPoolRolesInputBody: Equatable {
    public let identityPoolId: String?
    public let roles: [String:String]?
    public let roleMappings: [String:RoleMapping]?
}

extension SetIdentityPoolRolesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityPoolId = "IdentityPoolId"
        case roleMappings = "RoleMappings"
        case roles = "Roles"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let rolesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .roles)
        var rolesDecoded0: [String:String]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [String:String]()
            for (key0, arnstring0) in rolesContainer {
                if let arnstring0 = arnstring0 {
                    rolesDecoded0?[key0] = arnstring0
                }
            }
        }
        roles = rolesDecoded0
        let roleMappingsContainer = try containerValues.decodeIfPresent([String: RoleMapping?].self, forKey: .roleMappings)
        var roleMappingsDecoded0: [String:RoleMapping]? = nil
        if let roleMappingsContainer = roleMappingsContainer {
            roleMappingsDecoded0 = [String:RoleMapping]()
            for (key0, rolemapping0) in roleMappingsContainer {
                if let rolemapping0 = rolemapping0 {
                    roleMappingsDecoded0?[key0] = rolemapping0
                }
            }
        }
        roleMappings = roleMappingsDecoded0
    }
}

extension SetIdentityPoolRolesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetIdentityPoolRolesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetIdentityPoolRolesOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetIdentityPoolRolesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetIdentityPoolRolesOutputResponse()"}
}

extension SetIdentityPoolRolesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetIdentityPoolRolesOutputResponse: Equatable {

    public init() {}
}

struct SetIdentityPoolRolesOutputResponseBody: Equatable {
}

extension SetIdentityPoolRolesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SetPrincipalTagAttributeMapInputBodyMiddleware: Middleware {
    public let id: String = "SetPrincipalTagAttributeMapInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetPrincipalTagAttributeMapInput>,
                  next: H) -> Swift.Result<OperationOutput<SetPrincipalTagAttributeMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetPrincipalTagAttributeMapInput>
    public typealias MOutput = OperationOutput<SetPrincipalTagAttributeMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetPrincipalTagAttributeMapOutputError>
}

extension SetPrincipalTagAttributeMapInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetPrincipalTagAttributeMapInput(identityPoolId: \(String(describing: identityPoolId)), identityProviderName: \(String(describing: identityProviderName)), principalTags: \(String(describing: principalTags)), useDefaults: \(String(describing: useDefaults)))"}
}

extension SetPrincipalTagAttributeMapInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
        case principalTags = "PrincipalTags"
        case useDefaults = "UseDefaults"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let identityProviderName = identityProviderName {
            try encodeContainer.encode(identityProviderName, forKey: .identityProviderName)
        }
        if let principalTags = principalTags {
            var principalTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .principalTags)
            for (dictKey0, principaltags0) in principalTags {
                try principalTagsContainer.encode(principaltags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let useDefaults = useDefaults {
            try encodeContainer.encode(useDefaults, forKey: .useDefaults)
        }
    }
}

public struct SetPrincipalTagAttributeMapInputHeadersMiddleware: Middleware {
    public let id: String = "SetPrincipalTagAttributeMapInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetPrincipalTagAttributeMapInput>,
                  next: H) -> Swift.Result<OperationOutput<SetPrincipalTagAttributeMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetPrincipalTagAttributeMapInput>
    public typealias MOutput = OperationOutput<SetPrincipalTagAttributeMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetPrincipalTagAttributeMapOutputError>
}

public struct SetPrincipalTagAttributeMapInputQueryItemMiddleware: Middleware {
    public let id: String = "SetPrincipalTagAttributeMapInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetPrincipalTagAttributeMapInput>,
                  next: H) -> Swift.Result<OperationOutput<SetPrincipalTagAttributeMapOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetPrincipalTagAttributeMapInput>
    public typealias MOutput = OperationOutput<SetPrincipalTagAttributeMapOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetPrincipalTagAttributeMapOutputError>
}

public struct SetPrincipalTagAttributeMapInput: Equatable {
    /// <p>The ID of the Identity Pool you want to set attribute mappings for.</p>
    public let identityPoolId: String?
    /// <p>The provider name you want to use for attribute mappings.</p>
    public let identityProviderName: String?
    /// <p>You can use this operation to add principal tags.</p>
    public let principalTags: [String:String]?
    /// <p>You can use this operation to use default (username and clientID) attribute mappings.</p>
    public let useDefaults: Bool?

    public init (
        identityPoolId: String? = nil,
        identityProviderName: String? = nil,
        principalTags: [String:String]? = nil,
        useDefaults: Bool? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.identityProviderName = identityProviderName
        self.principalTags = principalTags
        self.useDefaults = useDefaults
    }
}

struct SetPrincipalTagAttributeMapInputBody: Equatable {
    public let identityPoolId: String?
    public let identityProviderName: String?
    public let useDefaults: Bool?
    public let principalTags: [String:String]?
}

extension SetPrincipalTagAttributeMapInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
        case principalTags = "PrincipalTags"
        case useDefaults = "UseDefaults"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let useDefaultsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useDefaults)
        useDefaults = useDefaultsDecoded
        let principalTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .principalTags)
        var principalTagsDecoded0: [String:String]? = nil
        if let principalTagsContainer = principalTagsContainer {
            principalTagsDecoded0 = [String:String]()
            for (key0, principaltagvalue0) in principalTagsContainer {
                if let principaltagvalue0 = principaltagvalue0 {
                    principalTagsDecoded0?[key0] = principaltagvalue0
                }
            }
        }
        principalTags = principalTagsDecoded0
    }
}

extension SetPrincipalTagAttributeMapOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetPrincipalTagAttributeMapOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetPrincipalTagAttributeMapOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetPrincipalTagAttributeMapOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetPrincipalTagAttributeMapOutputResponse(identityPoolId: \(String(describing: identityPoolId)), identityProviderName: \(String(describing: identityProviderName)), principalTags: \(String(describing: principalTags)), useDefaults: \(String(describing: useDefaults)))"}
}

extension SetPrincipalTagAttributeMapOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SetPrincipalTagAttributeMapOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.identityPoolId = output.identityPoolId
            self.identityProviderName = output.identityProviderName
            self.principalTags = output.principalTags
            self.useDefaults = output.useDefaults
        } else {
            self.identityPoolId = nil
            self.identityProviderName = nil
            self.principalTags = nil
            self.useDefaults = nil
        }
    }
}

public struct SetPrincipalTagAttributeMapOutputResponse: Equatable {
    /// <p>The ID of the Identity Pool you want to set attribute mappings for.</p>
    public let identityPoolId: String?
    /// <p>The provider name you want to use for attribute mappings.</p>
    public let identityProviderName: String?
    /// <p>You can use this operation to add principal tags. The <code>PrincipalTags</code>operation enables you to reference user attributes in your IAM permissions policy.</p>
    public let principalTags: [String:String]?
    /// <p>You can use this operation to select default (username and clientID) attribute mappings.</p>
    public let useDefaults: Bool?

    public init (
        identityPoolId: String? = nil,
        identityProviderName: String? = nil,
        principalTags: [String:String]? = nil,
        useDefaults: Bool? = nil
    )
    {
        self.identityPoolId = identityPoolId
        self.identityProviderName = identityProviderName
        self.principalTags = principalTags
        self.useDefaults = useDefaults
    }
}

struct SetPrincipalTagAttributeMapOutputResponseBody: Equatable {
    public let identityPoolId: String?
    public let identityProviderName: String?
    public let useDefaults: Bool?
    public let principalTags: [String:String]?
}

extension SetPrincipalTagAttributeMapOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityPoolId = "IdentityPoolId"
        case identityProviderName = "IdentityProviderName"
        case principalTags = "PrincipalTags"
        case useDefaults = "UseDefaults"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityProviderNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityProviderName)
        identityProviderName = identityProviderNameDecoded
        let useDefaultsDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .useDefaults)
        useDefaults = useDefaultsDecoded
        let principalTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .principalTags)
        var principalTagsDecoded0: [String:String]? = nil
        if let principalTagsContainer = principalTagsContainer {
            principalTagsDecoded0 = [String:String]()
            for (key0, principaltagvalue0) in principalTagsContainer {
                if let principaltagvalue0 = principaltagvalue0 {
                    principalTagsDecoded0?[key0] = principaltagvalue0
                }
            }
        }
        principalTags = principalTagsDecoded0
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, identitypooltagstype0) in tags {
                try tagsContainer.encode(identitypooltagstype0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the identity pool.</p>
    public let resourceArn: String?
    /// <p>The tags to assign to the identity pool.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvaluetype0) in tagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    tagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Thrown when a request is throttled.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Message returned by a TooManyRequestsException</p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UnlinkDeveloperIdentityInputBodyMiddleware: Middleware {
    public let id: String = "UnlinkDeveloperIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnlinkDeveloperIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<UnlinkDeveloperIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnlinkDeveloperIdentityInput>
    public typealias MOutput = OperationOutput<UnlinkDeveloperIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnlinkDeveloperIdentityOutputError>
}

extension UnlinkDeveloperIdentityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnlinkDeveloperIdentityInput(developerProviderName: \(String(describing: developerProviderName)), developerUserIdentifier: \(String(describing: developerUserIdentifier)), identityId: \(String(describing: identityId)), identityPoolId: \(String(describing: identityPoolId)))"}
}

extension UnlinkDeveloperIdentityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case developerProviderName = "DeveloperProviderName"
        case developerUserIdentifier = "DeveloperUserIdentifier"
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let developerProviderName = developerProviderName {
            try encodeContainer.encode(developerProviderName, forKey: .developerProviderName)
        }
        if let developerUserIdentifier = developerUserIdentifier {
            try encodeContainer.encode(developerUserIdentifier, forKey: .developerUserIdentifier)
        }
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
    }
}

public struct UnlinkDeveloperIdentityInputHeadersMiddleware: Middleware {
    public let id: String = "UnlinkDeveloperIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnlinkDeveloperIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<UnlinkDeveloperIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnlinkDeveloperIdentityInput>
    public typealias MOutput = OperationOutput<UnlinkDeveloperIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnlinkDeveloperIdentityOutputError>
}

public struct UnlinkDeveloperIdentityInputQueryItemMiddleware: Middleware {
    public let id: String = "UnlinkDeveloperIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnlinkDeveloperIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<UnlinkDeveloperIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnlinkDeveloperIdentityInput>
    public typealias MOutput = OperationOutput<UnlinkDeveloperIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnlinkDeveloperIdentityOutputError>
}

/// <p>Input to the <code>UnlinkDeveloperIdentity</code> action.</p>
public struct UnlinkDeveloperIdentityInput: Equatable {
    /// <p>The "domain" by which Cognito will refer to your users.</p>
    public let developerProviderName: String?
    /// <p>A unique ID used by your backend authentication process to identify a user.</p>
    public let developerUserIdentifier: String?
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: String?
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: String?

    public init (
        developerProviderName: String? = nil,
        developerUserIdentifier: String? = nil,
        identityId: String? = nil,
        identityPoolId: String? = nil
    )
    {
        self.developerProviderName = developerProviderName
        self.developerUserIdentifier = developerUserIdentifier
        self.identityId = identityId
        self.identityPoolId = identityPoolId
    }
}

struct UnlinkDeveloperIdentityInputBody: Equatable {
    public let identityId: String?
    public let identityPoolId: String?
    public let developerProviderName: String?
    public let developerUserIdentifier: String?
}

extension UnlinkDeveloperIdentityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case developerProviderName = "DeveloperProviderName"
        case developerUserIdentifier = "DeveloperUserIdentifier"
        case identityId = "IdentityId"
        case identityPoolId = "IdentityPoolId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let developerUserIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .developerUserIdentifier)
        developerUserIdentifier = developerUserIdentifierDecoded
    }
}

extension UnlinkDeveloperIdentityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnlinkDeveloperIdentityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnlinkDeveloperIdentityOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnlinkDeveloperIdentityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnlinkDeveloperIdentityOutputResponse()"}
}

extension UnlinkDeveloperIdentityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UnlinkDeveloperIdentityOutputResponse: Equatable {

    public init() {}
}

struct UnlinkDeveloperIdentityOutputResponseBody: Equatable {
}

extension UnlinkDeveloperIdentityOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UnlinkIdentityInputBodyMiddleware: Middleware {
    public let id: String = "UnlinkIdentityInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnlinkIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<UnlinkIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnlinkIdentityInput>
    public typealias MOutput = OperationOutput<UnlinkIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnlinkIdentityOutputError>
}

extension UnlinkIdentityInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnlinkIdentityInput(identityId: \(String(describing: identityId)), logins: \(String(describing: logins)), loginsToRemove: \(String(describing: loginsToRemove)))"}
}

extension UnlinkIdentityInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identityId = "IdentityId"
        case logins = "Logins"
        case loginsToRemove = "LoginsToRemove"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
        if let logins = logins {
            var loginsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .logins)
            for (dictKey0, loginsmap0) in logins {
                try loginsContainer.encode(loginsmap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let loginsToRemove = loginsToRemove {
            var loginsToRemoveContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loginsToRemove)
            for loginslist0 in loginsToRemove {
                try loginsToRemoveContainer.encode(loginslist0)
            }
        }
    }
}

public struct UnlinkIdentityInputHeadersMiddleware: Middleware {
    public let id: String = "UnlinkIdentityInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnlinkIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<UnlinkIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnlinkIdentityInput>
    public typealias MOutput = OperationOutput<UnlinkIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnlinkIdentityOutputError>
}

public struct UnlinkIdentityInputQueryItemMiddleware: Middleware {
    public let id: String = "UnlinkIdentityInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnlinkIdentityInput>,
                  next: H) -> Swift.Result<OperationOutput<UnlinkIdentityOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnlinkIdentityInput>
    public typealias MOutput = OperationOutput<UnlinkIdentityOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnlinkIdentityOutputError>
}

/// <p>Input to the UnlinkIdentity action.</p>
public struct UnlinkIdentityInput: Equatable {
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: String?
    /// <p>A set of optional name-value pairs that map provider names to provider
    ///          tokens.</p>
    public let logins: [String:String]?
    /// <p>Provider names to unlink from this identity.</p>
    public let loginsToRemove: [String]?

    public init (
        identityId: String? = nil,
        logins: [String:String]? = nil,
        loginsToRemove: [String]? = nil
    )
    {
        self.identityId = identityId
        self.logins = logins
        self.loginsToRemove = loginsToRemove
    }
}

struct UnlinkIdentityInputBody: Equatable {
    public let identityId: String?
    public let logins: [String:String]?
    public let loginsToRemove: [String]?
}

extension UnlinkIdentityInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case identityId = "IdentityId"
        case logins = "Logins"
        case loginsToRemove = "LoginsToRemove"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let loginsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .logins)
        var loginsDecoded0: [String:String]? = nil
        if let loginsContainer = loginsContainer {
            loginsDecoded0 = [String:String]()
            for (key0, identityprovidertoken0) in loginsContainer {
                if let identityprovidertoken0 = identityprovidertoken0 {
                    loginsDecoded0?[key0] = identityprovidertoken0
                }
            }
        }
        logins = loginsDecoded0
        let loginsToRemoveContainer = try containerValues.decodeIfPresent([String?].self, forKey: .loginsToRemove)
        var loginsToRemoveDecoded0:[String]? = nil
        if let loginsToRemoveContainer = loginsToRemoveContainer {
            loginsToRemoveDecoded0 = [String]()
            for string0 in loginsToRemoveContainer {
                if let string0 = string0 {
                    loginsToRemoveDecoded0?.append(string0)
                }
            }
        }
        loginsToRemove = loginsToRemoveDecoded0
    }
}

extension UnlinkIdentityOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnlinkIdentityOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ExternalServiceException" : self = .externalServiceException(try ExternalServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnlinkIdentityOutputError: Equatable {
    case externalServiceException(ExternalServiceException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnlinkIdentityOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnlinkIdentityOutputResponse()"}
}

extension UnlinkIdentityOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UnlinkIdentityOutputResponse: Equatable {

    public init() {}
}

struct UnlinkIdentityOutputResponseBody: Equatable {
}

extension UnlinkIdentityOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UnprocessedIdentityId: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case identityId = "IdentityId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let identityId = identityId {
            try encodeContainer.encode(identityId, forKey: .identityId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityId)
        identityId = identityIdDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

extension UnprocessedIdentityId: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnprocessedIdentityId(errorCode: \(String(describing: errorCode)), identityId: \(String(describing: identityId)))"}
}

/// <p>An array of UnprocessedIdentityId objects, each of which contains an ErrorCode and
///          IdentityId.</p>
public struct UnprocessedIdentityId: Equatable {
    /// <p>The error code indicating the type of error that occurred.</p>
    public let errorCode: ErrorCode?
    /// <p>A unique identifier in the format REGION:GUID.</p>
    public let identityId: String?

    public init (
        errorCode: ErrorCode? = nil,
        identityId: String? = nil
    )
    {
        self.errorCode = errorCode
        self.identityId = identityId
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for identitypooltagslisttype0 in tagKeys {
                try tagKeysContainer.encode(identitypooltagslisttype0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the identity pool.</p>
    public let resourceArn: String?
    /// <p>The keys of the tags to remove from the user pool.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateIdentityPoolInputBodyMiddleware: Middleware {
    public let id: String = "UpdateIdentityPoolInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIdentityPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIdentityPoolInput>
    public typealias MOutput = OperationOutput<UpdateIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIdentityPoolOutputError>
}

extension UpdateIdentityPoolInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIdentityPoolInput(allowClassicFlow: \(String(describing: allowClassicFlow)), allowUnauthenticatedIdentities: \(String(describing: allowUnauthenticatedIdentities)), cognitoIdentityProviders: \(String(describing: cognitoIdentityProviders)), developerProviderName: \(String(describing: developerProviderName)), identityPoolId: \(String(describing: identityPoolId)), identityPoolName: \(String(describing: identityPoolName)), identityPoolTags: \(String(describing: identityPoolTags)), openIdConnectProviderARNs: \(String(describing: openIdConnectProviderARNs)), samlProviderARNs: \(String(describing: samlProviderARNs)), supportedLoginProviders: \(String(describing: supportedLoginProviders)))"}
}

extension UpdateIdentityPoolInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowClassicFlow = allowClassicFlow {
            try encodeContainer.encode(allowClassicFlow, forKey: .allowClassicFlow)
        }
        if allowUnauthenticatedIdentities != false {
            try encodeContainer.encode(allowUnauthenticatedIdentities, forKey: .allowUnauthenticatedIdentities)
        }
        if let cognitoIdentityProviders = cognitoIdentityProviders {
            var cognitoIdentityProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cognitoIdentityProviders)
            for cognitoidentityproviderlist0 in cognitoIdentityProviders {
                try cognitoIdentityProvidersContainer.encode(cognitoidentityproviderlist0)
            }
        }
        if let developerProviderName = developerProviderName {
            try encodeContainer.encode(developerProviderName, forKey: .developerProviderName)
        }
        if let identityPoolId = identityPoolId {
            try encodeContainer.encode(identityPoolId, forKey: .identityPoolId)
        }
        if let identityPoolName = identityPoolName {
            try encodeContainer.encode(identityPoolName, forKey: .identityPoolName)
        }
        if let identityPoolTags = identityPoolTags {
            var identityPoolTagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .identityPoolTags)
            for (dictKey0, identitypooltagstype0) in identityPoolTags {
                try identityPoolTagsContainer.encode(identitypooltagstype0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let openIdConnectProviderARNs = openIdConnectProviderARNs {
            var openIdConnectProviderARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .openIdConnectProviderARNs)
            for oidcproviderlist0 in openIdConnectProviderARNs {
                try openIdConnectProviderARNsContainer.encode(oidcproviderlist0)
            }
        }
        if let samlProviderARNs = samlProviderARNs {
            var samlProviderARNsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .samlProviderARNs)
            for samlproviderlist0 in samlProviderARNs {
                try samlProviderARNsContainer.encode(samlproviderlist0)
            }
        }
        if let supportedLoginProviders = supportedLoginProviders {
            var supportedLoginProvidersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .supportedLoginProviders)
            for (dictKey0, identityproviders0) in supportedLoginProviders {
                try supportedLoginProvidersContainer.encode(identityproviders0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct UpdateIdentityPoolInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateIdentityPoolInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIdentityPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIdentityPoolInput>
    public typealias MOutput = OperationOutput<UpdateIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIdentityPoolOutputError>
}

public struct UpdateIdentityPoolInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateIdentityPoolInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIdentityPoolInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIdentityPoolOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIdentityPoolInput>
    public typealias MOutput = OperationOutput<UpdateIdentityPoolOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIdentityPoolOutputError>
}

/// <p>An object representing an Amazon Cognito identity pool.</p>
public struct UpdateIdentityPoolInput: Equatable {
    /// <p>Enables or disables the Basic (Classic) authentication flow. For more information, see
    ///       <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/authentication-flow.html">Identity Pools (Federated Identities) Authentication Flow</a> in the <i>Amazon Cognito Developer Guide</i>.</p>
    public let allowClassicFlow: Bool?
    /// <p>TRUE if the identity pool supports unauthenticated logins.</p>
    public let allowUnauthenticatedIdentities: Bool
    /// <p>A list representing an Amazon Cognito user pool and its client ID.</p>
    public let cognitoIdentityProviders: [CognitoIdentityProvider]?
    /// <p>The "domain" by which Cognito will refer to your users.</p>
    public let developerProviderName: String?
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: String?
    /// <p>A string that you provide.</p>
    public let identityPoolName: String?
    /// <p>The tags that are assigned to the identity pool. A tag is a label that you can apply to
    ///          identity pools to categorize and manage them in different ways, such as by purpose, owner,
    ///          environment, or other criteria.</p>
    public let identityPoolTags: [String:String]?
    /// <p>The ARNs of the OpenID Connect providers.</p>
    public let openIdConnectProviderARNs: [String]?
    /// <p>An array of Amazon Resource Names (ARNs) of the SAML provider for your identity
    ///          pool.</p>
    public let samlProviderARNs: [String]?
    /// <p>Optional key:value pairs mapping provider names to provider app IDs.</p>
    public let supportedLoginProviders: [String:String]?

    public init (
        allowClassicFlow: Bool? = nil,
        allowUnauthenticatedIdentities: Bool = false,
        cognitoIdentityProviders: [CognitoIdentityProvider]? = nil,
        developerProviderName: String? = nil,
        identityPoolId: String? = nil,
        identityPoolName: String? = nil,
        identityPoolTags: [String:String]? = nil,
        openIdConnectProviderARNs: [String]? = nil,
        samlProviderARNs: [String]? = nil,
        supportedLoginProviders: [String:String]? = nil
    )
    {
        self.allowClassicFlow = allowClassicFlow
        self.allowUnauthenticatedIdentities = allowUnauthenticatedIdentities
        self.cognitoIdentityProviders = cognitoIdentityProviders
        self.developerProviderName = developerProviderName
        self.identityPoolId = identityPoolId
        self.identityPoolName = identityPoolName
        self.identityPoolTags = identityPoolTags
        self.openIdConnectProviderARNs = openIdConnectProviderARNs
        self.samlProviderARNs = samlProviderARNs
        self.supportedLoginProviders = supportedLoginProviders
    }
}

struct UpdateIdentityPoolInputBody: Equatable {
    public let identityPoolId: String?
    public let identityPoolName: String?
    public let allowUnauthenticatedIdentities: Bool
    public let allowClassicFlow: Bool?
    public let supportedLoginProviders: [String:String]?
    public let developerProviderName: String?
    public let openIdConnectProviderARNs: [String]?
    public let cognitoIdentityProviders: [CognitoIdentityProvider]?
    public let samlProviderARNs: [String]?
    public let identityPoolTags: [String:String]?
}

extension UpdateIdentityPoolInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let allowUnauthenticatedIdentitiesDecoded = try containerValues.decode(Bool.self, forKey: .allowUnauthenticatedIdentities)
        allowUnauthenticatedIdentities = allowUnauthenticatedIdentitiesDecoded
        let allowClassicFlowDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowClassicFlow)
        allowClassicFlow = allowClassicFlowDecoded
        let supportedLoginProvidersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .supportedLoginProviders)
        var supportedLoginProvidersDecoded0: [String:String]? = nil
        if let supportedLoginProvidersContainer = supportedLoginProvidersContainer {
            supportedLoginProvidersDecoded0 = [String:String]()
            for (key0, identityproviderid0) in supportedLoginProvidersContainer {
                if let identityproviderid0 = identityproviderid0 {
                    supportedLoginProvidersDecoded0?[key0] = identityproviderid0
                }
            }
        }
        supportedLoginProviders = supportedLoginProvidersDecoded0
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let openIdConnectProviderARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .openIdConnectProviderARNs)
        var openIdConnectProviderARNsDecoded0:[String]? = nil
        if let openIdConnectProviderARNsContainer = openIdConnectProviderARNsContainer {
            openIdConnectProviderARNsDecoded0 = [String]()
            for string0 in openIdConnectProviderARNsContainer {
                if let string0 = string0 {
                    openIdConnectProviderARNsDecoded0?.append(string0)
                }
            }
        }
        openIdConnectProviderARNs = openIdConnectProviderARNsDecoded0
        let cognitoIdentityProvidersContainer = try containerValues.decodeIfPresent([CognitoIdentityProvider?].self, forKey: .cognitoIdentityProviders)
        var cognitoIdentityProvidersDecoded0:[CognitoIdentityProvider]? = nil
        if let cognitoIdentityProvidersContainer = cognitoIdentityProvidersContainer {
            cognitoIdentityProvidersDecoded0 = [CognitoIdentityProvider]()
            for structure0 in cognitoIdentityProvidersContainer {
                if let structure0 = structure0 {
                    cognitoIdentityProvidersDecoded0?.append(structure0)
                }
            }
        }
        cognitoIdentityProviders = cognitoIdentityProvidersDecoded0
        let samlProviderARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .samlProviderARNs)
        var samlProviderARNsDecoded0:[String]? = nil
        if let samlProviderARNsContainer = samlProviderARNsContainer {
            samlProviderARNsDecoded0 = [String]()
            for string0 in samlProviderARNsContainer {
                if let string0 = string0 {
                    samlProviderARNsDecoded0?.append(string0)
                }
            }
        }
        samlProviderARNs = samlProviderARNsDecoded0
        let identityPoolTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .identityPoolTags)
        var identityPoolTagsDecoded0: [String:String]? = nil
        if let identityPoolTagsContainer = identityPoolTagsContainer {
            identityPoolTagsDecoded0 = [String:String]()
            for (key0, tagvaluetype0) in identityPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    identityPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        identityPoolTags = identityPoolTagsDecoded0
    }
}

extension UpdateIdentityPoolOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIdentityPoolOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIdentityPoolOutputError: Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case limitExceededException(LimitExceededException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIdentityPoolOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIdentityPoolOutputResponse(allowClassicFlow: \(String(describing: allowClassicFlow)), allowUnauthenticatedIdentities: \(String(describing: allowUnauthenticatedIdentities)), cognitoIdentityProviders: \(String(describing: cognitoIdentityProviders)), developerProviderName: \(String(describing: developerProviderName)), identityPoolId: \(String(describing: identityPoolId)), identityPoolName: \(String(describing: identityPoolName)), identityPoolTags: \(String(describing: identityPoolTags)), openIdConnectProviderARNs: \(String(describing: openIdConnectProviderARNs)), samlProviderARNs: \(String(describing: samlProviderARNs)), supportedLoginProviders: \(String(describing: supportedLoginProviders)))"}
}

extension UpdateIdentityPoolOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateIdentityPoolOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.allowClassicFlow = output.allowClassicFlow
            self.allowUnauthenticatedIdentities = output.allowUnauthenticatedIdentities
            self.cognitoIdentityProviders = output.cognitoIdentityProviders
            self.developerProviderName = output.developerProviderName
            self.identityPoolId = output.identityPoolId
            self.identityPoolName = output.identityPoolName
            self.identityPoolTags = output.identityPoolTags
            self.openIdConnectProviderARNs = output.openIdConnectProviderARNs
            self.samlProviderARNs = output.samlProviderARNs
            self.supportedLoginProviders = output.supportedLoginProviders
        } else {
            self.allowClassicFlow = nil
            self.allowUnauthenticatedIdentities = false
            self.cognitoIdentityProviders = nil
            self.developerProviderName = nil
            self.identityPoolId = nil
            self.identityPoolName = nil
            self.identityPoolTags = nil
            self.openIdConnectProviderARNs = nil
            self.samlProviderARNs = nil
            self.supportedLoginProviders = nil
        }
    }
}

/// <p>An object representing an Amazon Cognito identity pool.</p>
public struct UpdateIdentityPoolOutputResponse: Equatable {
    /// <p>Enables or disables the Basic (Classic) authentication flow. For more information, see
    ///       <a href="https://docs.aws.amazon.com/cognito/latest/developerguide/authentication-flow.html">Identity Pools (Federated Identities) Authentication Flow</a> in the <i>Amazon Cognito Developer Guide</i>.</p>
    public let allowClassicFlow: Bool?
    /// <p>TRUE if the identity pool supports unauthenticated logins.</p>
    public let allowUnauthenticatedIdentities: Bool
    /// <p>A list representing an Amazon Cognito user pool and its client ID.</p>
    public let cognitoIdentityProviders: [CognitoIdentityProvider]?
    /// <p>The "domain" by which Cognito will refer to your users.</p>
    public let developerProviderName: String?
    /// <p>An identity pool ID in the format REGION:GUID.</p>
    public let identityPoolId: String?
    /// <p>A string that you provide.</p>
    public let identityPoolName: String?
    /// <p>The tags that are assigned to the identity pool. A tag is a label that you can apply to
    ///          identity pools to categorize and manage them in different ways, such as by purpose, owner,
    ///          environment, or other criteria.</p>
    public let identityPoolTags: [String:String]?
    /// <p>The ARNs of the OpenID Connect providers.</p>
    public let openIdConnectProviderARNs: [String]?
    /// <p>An array of Amazon Resource Names (ARNs) of the SAML provider for your identity
    ///          pool.</p>
    public let samlProviderARNs: [String]?
    /// <p>Optional key:value pairs mapping provider names to provider app IDs.</p>
    public let supportedLoginProviders: [String:String]?

    public init (
        allowClassicFlow: Bool? = nil,
        allowUnauthenticatedIdentities: Bool = false,
        cognitoIdentityProviders: [CognitoIdentityProvider]? = nil,
        developerProviderName: String? = nil,
        identityPoolId: String? = nil,
        identityPoolName: String? = nil,
        identityPoolTags: [String:String]? = nil,
        openIdConnectProviderARNs: [String]? = nil,
        samlProviderARNs: [String]? = nil,
        supportedLoginProviders: [String:String]? = nil
    )
    {
        self.allowClassicFlow = allowClassicFlow
        self.allowUnauthenticatedIdentities = allowUnauthenticatedIdentities
        self.cognitoIdentityProviders = cognitoIdentityProviders
        self.developerProviderName = developerProviderName
        self.identityPoolId = identityPoolId
        self.identityPoolName = identityPoolName
        self.identityPoolTags = identityPoolTags
        self.openIdConnectProviderARNs = openIdConnectProviderARNs
        self.samlProviderARNs = samlProviderARNs
        self.supportedLoginProviders = supportedLoginProviders
    }
}

struct UpdateIdentityPoolOutputResponseBody: Equatable {
    public let identityPoolId: String?
    public let identityPoolName: String?
    public let allowUnauthenticatedIdentities: Bool
    public let allowClassicFlow: Bool?
    public let supportedLoginProviders: [String:String]?
    public let developerProviderName: String?
    public let openIdConnectProviderARNs: [String]?
    public let cognitoIdentityProviders: [CognitoIdentityProvider]?
    public let samlProviderARNs: [String]?
    public let identityPoolTags: [String:String]?
}

extension UpdateIdentityPoolOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowClassicFlow = "AllowClassicFlow"
        case allowUnauthenticatedIdentities = "AllowUnauthenticatedIdentities"
        case cognitoIdentityProviders = "CognitoIdentityProviders"
        case developerProviderName = "DeveloperProviderName"
        case identityPoolId = "IdentityPoolId"
        case identityPoolName = "IdentityPoolName"
        case identityPoolTags = "IdentityPoolTags"
        case openIdConnectProviderARNs = "OpenIdConnectProviderARNs"
        case samlProviderARNs = "SamlProviderARNs"
        case supportedLoginProviders = "SupportedLoginProviders"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identityPoolIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolId)
        identityPoolId = identityPoolIdDecoded
        let identityPoolNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identityPoolName)
        identityPoolName = identityPoolNameDecoded
        let allowUnauthenticatedIdentitiesDecoded = try containerValues.decode(Bool.self, forKey: .allowUnauthenticatedIdentities)
        allowUnauthenticatedIdentities = allowUnauthenticatedIdentitiesDecoded
        let allowClassicFlowDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .allowClassicFlow)
        allowClassicFlow = allowClassicFlowDecoded
        let supportedLoginProvidersContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .supportedLoginProviders)
        var supportedLoginProvidersDecoded0: [String:String]? = nil
        if let supportedLoginProvidersContainer = supportedLoginProvidersContainer {
            supportedLoginProvidersDecoded0 = [String:String]()
            for (key0, identityproviderid0) in supportedLoginProvidersContainer {
                if let identityproviderid0 = identityproviderid0 {
                    supportedLoginProvidersDecoded0?[key0] = identityproviderid0
                }
            }
        }
        supportedLoginProviders = supportedLoginProvidersDecoded0
        let developerProviderNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .developerProviderName)
        developerProviderName = developerProviderNameDecoded
        let openIdConnectProviderARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .openIdConnectProviderARNs)
        var openIdConnectProviderARNsDecoded0:[String]? = nil
        if let openIdConnectProviderARNsContainer = openIdConnectProviderARNsContainer {
            openIdConnectProviderARNsDecoded0 = [String]()
            for string0 in openIdConnectProviderARNsContainer {
                if let string0 = string0 {
                    openIdConnectProviderARNsDecoded0?.append(string0)
                }
            }
        }
        openIdConnectProviderARNs = openIdConnectProviderARNsDecoded0
        let cognitoIdentityProvidersContainer = try containerValues.decodeIfPresent([CognitoIdentityProvider?].self, forKey: .cognitoIdentityProviders)
        var cognitoIdentityProvidersDecoded0:[CognitoIdentityProvider]? = nil
        if let cognitoIdentityProvidersContainer = cognitoIdentityProvidersContainer {
            cognitoIdentityProvidersDecoded0 = [CognitoIdentityProvider]()
            for structure0 in cognitoIdentityProvidersContainer {
                if let structure0 = structure0 {
                    cognitoIdentityProvidersDecoded0?.append(structure0)
                }
            }
        }
        cognitoIdentityProviders = cognitoIdentityProvidersDecoded0
        let samlProviderARNsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .samlProviderARNs)
        var samlProviderARNsDecoded0:[String]? = nil
        if let samlProviderARNsContainer = samlProviderARNsContainer {
            samlProviderARNsDecoded0 = [String]()
            for string0 in samlProviderARNsContainer {
                if let string0 = string0 {
                    samlProviderARNsDecoded0?.append(string0)
                }
            }
        }
        samlProviderARNs = samlProviderARNsDecoded0
        let identityPoolTagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .identityPoolTags)
        var identityPoolTagsDecoded0: [String:String]? = nil
        if let identityPoolTagsContainer = identityPoolTagsContainer {
            identityPoolTagsDecoded0 = [String:String]()
            for (key0, tagvaluetype0) in identityPoolTagsContainer {
                if let tagvaluetype0 = tagvaluetype0 {
                    identityPoolTagsDecoded0?[key0] = tagvaluetype0
                }
            }
        }
        identityPoolTags = identityPoolTagsDecoded0
    }
}
