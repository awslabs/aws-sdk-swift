// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Operating denied due to a file permission or access check error.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension MgnClientTypes.Application: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationAggregatedStatus
        case applicationID
        case arn
        case creationDateTime
        case description
        case isArchived
        case lastModifiedDateTime
        case name
        case tags
        case waveID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationAggregatedStatus = self.applicationAggregatedStatus {
            try encodeContainer.encode(applicationAggregatedStatus, forKey: .applicationAggregatedStatus)
        }
        if let applicationID = self.applicationID {
            try encodeContainer.encode(applicationID, forKey: .applicationID)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encode(creationDateTime, forKey: .creationDateTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let isArchived = self.isArchived {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let lastModifiedDateTime = self.lastModifiedDateTime {
            try encodeContainer.encode(lastModifiedDateTime, forKey: .lastModifiedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let waveID = self.waveID {
            try encodeContainer.encode(waveID, forKey: .waveID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let applicationAggregatedStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ApplicationAggregatedStatus.self, forKey: .applicationAggregatedStatus)
        applicationAggregatedStatus = applicationAggregatedStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
    }
}

extension MgnClientTypes.Application: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Application(applicationAggregatedStatus: \(Swift.String(describing: applicationAggregatedStatus)), applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension MgnClientTypes {
    public struct Application: Swift.Equatable {
        /// Application aggregated status.
        public var applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
        /// Application ID.
        public var applicationID: Swift.String?
        /// Application ARN.
        public var arn: Swift.String?
        /// Application creation dateTime.
        public var creationDateTime: Swift.String?
        /// Application description.
        public var description: Swift.String?
        /// Application archival status.
        public var isArchived: Swift.Bool?
        /// Application last modified dateTime.
        public var lastModifiedDateTime: Swift.String?
        /// Application name.
        public var name: Swift.String?
        /// Application tags.
        public var tags: [Swift.String:Swift.String]?
        /// Application wave ID.
        public var waveID: Swift.String?

        public init (
            applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus? = nil,
            applicationID: Swift.String? = nil,
            arn: Swift.String? = nil,
            creationDateTime: Swift.String? = nil,
            description: Swift.String? = nil,
            isArchived: Swift.Bool? = nil,
            lastModifiedDateTime: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            waveID: Swift.String? = nil
        )
        {
            self.applicationAggregatedStatus = applicationAggregatedStatus
            self.applicationID = applicationID
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.isArchived = isArchived
            self.lastModifiedDateTime = lastModifiedDateTime
            self.name = name
            self.tags = tags
            self.waveID = waveID
        }
    }

}

extension MgnClientTypes.ApplicationAggregatedStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthStatus
        case lastUpdateDateTime
        case progressStatus
        case totalSourceServers
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthStatus = self.healthStatus {
            try encodeContainer.encode(healthStatus.rawValue, forKey: .healthStatus)
        }
        if let lastUpdateDateTime = self.lastUpdateDateTime {
            try encodeContainer.encode(lastUpdateDateTime, forKey: .lastUpdateDateTime)
        }
        if let progressStatus = self.progressStatus {
            try encodeContainer.encode(progressStatus.rawValue, forKey: .progressStatus)
        }
        if totalSourceServers != 0 {
            try encodeContainer.encode(totalSourceServers, forKey: .totalSourceServers)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastUpdateDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateDateTime)
        lastUpdateDateTime = lastUpdateDateTimeDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ApplicationHealthStatus.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
        let progressStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ApplicationProgressStatus.self, forKey: .progressStatus)
        progressStatus = progressStatusDecoded
        let totalSourceServersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalSourceServers) ?? 0
        totalSourceServers = totalSourceServersDecoded
    }
}

extension MgnClientTypes {
    /// Application aggregated status.
    public struct ApplicationAggregatedStatus: Swift.Equatable {
        /// Application aggregated status health status.
        public var healthStatus: MgnClientTypes.ApplicationHealthStatus?
        /// Application aggregated status last update dateTime.
        public var lastUpdateDateTime: Swift.String?
        /// Application aggregated status progress status.
        public var progressStatus: MgnClientTypes.ApplicationProgressStatus?
        /// Application aggregated status total source servers amount.
        public var totalSourceServers: Swift.Int

        public init (
            healthStatus: MgnClientTypes.ApplicationHealthStatus? = nil,
            lastUpdateDateTime: Swift.String? = nil,
            progressStatus: MgnClientTypes.ApplicationProgressStatus? = nil,
            totalSourceServers: Swift.Int = 0
        )
        {
            self.healthStatus = healthStatus
            self.lastUpdateDateTime = lastUpdateDateTime
            self.progressStatus = progressStatus
            self.totalSourceServers = totalSourceServers
        }
    }

}

extension MgnClientTypes {
    public enum ApplicationHealthStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case healthy
        case lagging
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationHealthStatus] {
            return [
                .error,
                .healthy,
                .lagging,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .healthy: return "HEALTHY"
            case .lagging: return "LAGGING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationHealthStatus(rawValue: rawValue) ?? ApplicationHealthStatus.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum ApplicationProgressStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationProgressStatus] {
            return [
                .completed,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationProgressStatus(rawValue: rawValue) ?? ApplicationProgressStatus.sdkUnknown(rawValue)
        }
    }
}

extension ArchiveApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationID = self.applicationID {
            try encodeContainer.encode(applicationID, forKey: .applicationID)
        }
    }
}

extension ArchiveApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ArchiveApplication"
    }
}

public struct ArchiveApplicationInput: Swift.Equatable {
    /// Application ID.
    /// This member is required.
    public var applicationID: Swift.String?

    public init (
        applicationID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
    }
}

struct ArchiveApplicationInputBody: Swift.Equatable {
    let applicationID: Swift.String?
}

extension ArchiveApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
    }
}

extension ArchiveApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ArchiveApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ArchiveApplicationOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ArchiveApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ArchiveApplicationOutputResponse(applicationAggregatedStatus: \(Swift.String(describing: applicationAggregatedStatus)), applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension ArchiveApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ArchiveApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationAggregatedStatus = output.applicationAggregatedStatus
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.isArchived = output.isArchived
            self.lastModifiedDateTime = output.lastModifiedDateTime
            self.name = output.name
            self.tags = output.tags
            self.waveID = output.waveID
        } else {
            self.applicationAggregatedStatus = nil
            self.applicationID = nil
            self.arn = nil
            self.creationDateTime = nil
            self.description = nil
            self.isArchived = nil
            self.lastModifiedDateTime = nil
            self.name = nil
            self.tags = nil
            self.waveID = nil
        }
    }
}

public struct ArchiveApplicationOutputResponse: Swift.Equatable {
    /// Application aggregated status.
    public var applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
    /// Application ID.
    public var applicationID: Swift.String?
    /// Application ARN.
    public var arn: Swift.String?
    /// Application creation dateTime.
    public var creationDateTime: Swift.String?
    /// Application description.
    public var description: Swift.String?
    /// Application archival status.
    public var isArchived: Swift.Bool?
    /// Application last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Application name.
    public var name: Swift.String?
    /// Application tags.
    public var tags: [Swift.String:Swift.String]?
    /// Application wave ID.
    public var waveID: Swift.String?

    public init (
        applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus? = nil,
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.applicationAggregatedStatus = applicationAggregatedStatus
        self.applicationID = applicationID
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveID = waveID
    }
}

struct ArchiveApplicationOutputResponseBody: Swift.Equatable {
    let applicationID: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let isArchived: Swift.Bool?
    let applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
    let creationDateTime: Swift.String?
    let lastModifiedDateTime: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let waveID: Swift.String?
}

extension ArchiveApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationAggregatedStatus
        case applicationID
        case arn
        case creationDateTime
        case description
        case isArchived
        case lastModifiedDateTime
        case name
        case tags
        case waveID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let applicationAggregatedStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ApplicationAggregatedStatus.self, forKey: .applicationAggregatedStatus)
        applicationAggregatedStatus = applicationAggregatedStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
    }
}

extension ArchiveWaveInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case waveID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let waveID = self.waveID {
            try encodeContainer.encode(waveID, forKey: .waveID)
        }
    }
}

extension ArchiveWaveInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ArchiveWave"
    }
}

public struct ArchiveWaveInput: Swift.Equatable {
    /// Wave ID.
    /// This member is required.
    public var waveID: Swift.String?

    public init (
        waveID: Swift.String? = nil
    )
    {
        self.waveID = waveID
    }
}

struct ArchiveWaveInputBody: Swift.Equatable {
    let waveID: Swift.String?
}

extension ArchiveWaveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case waveID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
    }
}

extension ArchiveWaveOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ArchiveWaveOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ArchiveWaveOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ArchiveWaveOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ArchiveWaveOutputResponse(arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveAggregatedStatus: \(Swift.String(describing: waveAggregatedStatus)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension ArchiveWaveOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ArchiveWaveOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.isArchived = output.isArchived
            self.lastModifiedDateTime = output.lastModifiedDateTime
            self.name = output.name
            self.tags = output.tags
            self.waveAggregatedStatus = output.waveAggregatedStatus
            self.waveID = output.waveID
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.description = nil
            self.isArchived = nil
            self.lastModifiedDateTime = nil
            self.name = nil
            self.tags = nil
            self.waveAggregatedStatus = nil
            self.waveID = nil
        }
    }
}

public struct ArchiveWaveOutputResponse: Swift.Equatable {
    /// Wave ARN.
    public var arn: Swift.String?
    /// Wave creation dateTime.
    public var creationDateTime: Swift.String?
    /// Wave description.
    public var description: Swift.String?
    /// Wave archival status.
    public var isArchived: Swift.Bool?
    /// Wave last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Wave name.
    public var name: Swift.String?
    /// Wave tags.
    public var tags: [Swift.String:Swift.String]?
    /// Wave aggregated status.
    public var waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
    /// Wave ID.
    public var waveID: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveAggregatedStatus = waveAggregatedStatus
        self.waveID = waveID
    }
}

struct ArchiveWaveOutputResponseBody: Swift.Equatable {
    let waveID: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let isArchived: Swift.Bool?
    let waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
    let creationDateTime: Swift.String?
    let lastModifiedDateTime: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension ArchiveWaveOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case description
        case isArchived
        case lastModifiedDateTime
        case name
        case tags
        case waveAggregatedStatus
        case waveID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let waveAggregatedStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.WaveAggregatedStatus.self, forKey: .waveAggregatedStatus)
        waveAggregatedStatus = waveAggregatedStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AssociateApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIDs
        case waveID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationIDs = applicationIDs {
            var applicationIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationIDs)
            for applicationid0 in applicationIDs {
                try applicationIDsContainer.encode(applicationid0)
            }
        }
        if let waveID = self.waveID {
            try encodeContainer.encode(waveID, forKey: .waveID)
        }
    }
}

extension AssociateApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/AssociateApplications"
    }
}

public struct AssociateApplicationsInput: Swift.Equatable {
    /// Application IDs list.
    /// This member is required.
    public var applicationIDs: [Swift.String]?
    /// Wave ID.
    /// This member is required.
    public var waveID: Swift.String?

    public init (
        applicationIDs: [Swift.String]? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.applicationIDs = applicationIDs
        self.waveID = waveID
    }
}

struct AssociateApplicationsInputBody: Swift.Equatable {
    let waveID: Swift.String?
    let applicationIDs: [Swift.String]?
}

extension AssociateApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIDs
        case waveID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
        let applicationIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applicationIDs)
        var applicationIDsDecoded0:[Swift.String]? = nil
        if let applicationIDsContainer = applicationIDsContainer {
            applicationIDsDecoded0 = [Swift.String]()
            for string0 in applicationIDsContainer {
                if let string0 = string0 {
                    applicationIDsDecoded0?.append(string0)
                }
            }
        }
        applicationIDs = applicationIDsDecoded0
    }
}

extension AssociateApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateApplicationsOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateApplicationsOutputResponse: Swift.Equatable {

    public init () { }
}

extension AssociateSourceServersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case sourceServerIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationID = self.applicationID {
            try encodeContainer.encode(applicationID, forKey: .applicationID)
        }
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for sourceserverid0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(sourceserverid0)
            }
        }
    }
}

extension AssociateSourceServersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/AssociateSourceServers"
    }
}

public struct AssociateSourceServersInput: Swift.Equatable {
    /// Application ID.
    /// This member is required.
    public var applicationID: Swift.String?
    /// Source server IDs list.
    /// This member is required.
    public var sourceServerIDs: [Swift.String]?

    public init (
        applicationID: Swift.String? = nil,
        sourceServerIDs: [Swift.String]? = nil
    )
    {
        self.applicationID = applicationID
        self.sourceServerIDs = sourceServerIDs
    }
}

struct AssociateSourceServersInputBody: Swift.Equatable {
    let applicationID: Swift.String?
    let sourceServerIDs: [Swift.String]?
}

extension AssociateSourceServersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case sourceServerIDs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[Swift.String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [Swift.String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
    }
}

extension AssociateSourceServersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateSourceServersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateSourceServersOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateSourceServersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateSourceServersOutputResponse: Swift.Equatable {

    public init () { }
}

extension MgnClientTypes {
    public enum BootMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case legacyBios
        case uefi
        case sdkUnknown(Swift.String)

        public static var allCases: [BootMode] {
            return [
                .legacyBios,
                .uefi,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .legacyBios: return "LEGACY_BIOS"
            case .uefi: return "UEFI"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BootMode(rawValue: rawValue) ?? BootMode.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.CPU: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cores
        case modelName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cores != 0 {
            try encodeContainer.encode(cores, forKey: .cores)
        }
        if let modelName = self.modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coresDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cores) ?? 0
        cores = coresDecoded
        let modelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelName)
        modelName = modelNameDecoded
    }
}

extension MgnClientTypes {
    /// Source server CPU information.
    public struct CPU: Swift.Equatable {
        /// The number of CPU cores on the source server.
        public var cores: Swift.Int
        /// The source server's CPU model name.
        public var modelName: Swift.String?

        public init (
            cores: Swift.Int = 0,
            modelName: Swift.String? = nil
        )
        {
            self.cores = cores
            self.modelName = modelName
        }
    }

}

extension ChangeServerLifeCycleStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifeCycle
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifeCycle = self.lifeCycle {
            try encodeContainer.encode(lifeCycle, forKey: .lifeCycle)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension ChangeServerLifeCycleStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ChangeServerLifeCycleState"
    }
}

public struct ChangeServerLifeCycleStateInput: Swift.Equatable {
    /// The request to change the source server migration lifecycle state.
    /// This member is required.
    public var lifeCycle: MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycle?
    /// The request to change the source server migration lifecycle state by source server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        lifeCycle: MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycle? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.lifeCycle = lifeCycle
        self.sourceServerID = sourceServerID
    }
}

struct ChangeServerLifeCycleStateInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let lifeCycle: MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycle?
}

extension ChangeServerLifeCycleStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifeCycle
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
    }
}

extension ChangeServerLifeCycleStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ChangeServerLifeCycleStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ChangeServerLifeCycleStateOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ChangeServerLifeCycleStateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ChangeServerLifeCycleStateOutputResponse(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

extension ChangeServerLifeCycleStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ChangeServerLifeCycleStateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.applicationID = nil
            self.arn = nil
            self.dataReplicationInfo = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.vcenterClientID = nil
        }
    }
}

public struct ChangeServerLifeCycleStateOutputResponse: Swift.Equatable {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init (
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.vcenterClientID = vcenterClientID
    }
}

struct ChangeServerLifeCycleStateOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
    let applicationID: Swift.String?
}

extension ChangeServerLifeCycleStateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case vcenterClientID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
    }
}

extension MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycleState.self, forKey: .state)
        state = stateDecoded
    }
}

extension MgnClientTypes {
    /// The request to change the source server migration lifecycle state.
    public struct ChangeServerLifeCycleStateSourceServerLifecycle: Swift.Equatable {
        /// The request to change the source server migration lifecycle state.
        /// This member is required.
        public var state: MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycleState?

        public init (
            state: MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycleState? = nil
        )
        {
            self.state = state
        }
    }

}

extension MgnClientTypes {
    public enum ChangeServerLifeCycleStateSourceServerLifecycleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cutover
        case readyForCutover
        case readyForTest
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeServerLifeCycleStateSourceServerLifecycleState] {
            return [
                .cutover,
                .readyForCutover,
                .readyForTest,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cutover: return "CUTOVER"
            case .readyForCutover: return "READY_FOR_CUTOVER"
            case .readyForTest: return "READY_FOR_TEST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeServerLifeCycleStateSourceServerLifecycleState(rawValue: rawValue) ?? ChangeServerLifeCycleStateSourceServerLifecycleState.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.errors = output.errors
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.code = nil
            self.errors = nil
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be completed due to a conflict with the current state of the target resource.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    /// Conflict Exception specific errors.
    public var errors: [MgnClientTypes.ErrorDetails]?
    public var message: Swift.String?
    /// A conflict occurred when prompting for the Resource ID.
    public var resourceId: Swift.String?
    /// A conflict occurred when prompting for resource type.
    public var resourceType: Swift.String?

    public init (
        code: Swift.String? = nil,
        errors: [MgnClientTypes.ErrorDetails]? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.code = code
        self.errors = errors
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let errors: [MgnClientTypes.ErrorDetails]?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case errors
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let errorsContainer = try containerValues.decodeIfPresent([MgnClientTypes.ErrorDetails?].self, forKey: .errors)
        var errorsDecoded0:[MgnClientTypes.ErrorDetails]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [MgnClientTypes.ErrorDetails]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension CreateApplicationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApplicationInput(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateApplication"
    }
}

public struct CreateApplicationInput: Swift.Equatable {
    /// Application description.
    public var description: Swift.String?
    /// Application name.
    /// This member is required.
    public var name: Swift.String?
    /// Application tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateApplicationOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateApplicationOutputResponse(applicationAggregatedStatus: \(Swift.String(describing: applicationAggregatedStatus)), applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationAggregatedStatus = output.applicationAggregatedStatus
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.isArchived = output.isArchived
            self.lastModifiedDateTime = output.lastModifiedDateTime
            self.name = output.name
            self.tags = output.tags
            self.waveID = output.waveID
        } else {
            self.applicationAggregatedStatus = nil
            self.applicationID = nil
            self.arn = nil
            self.creationDateTime = nil
            self.description = nil
            self.isArchived = nil
            self.lastModifiedDateTime = nil
            self.name = nil
            self.tags = nil
            self.waveID = nil
        }
    }
}

public struct CreateApplicationOutputResponse: Swift.Equatable {
    /// Application aggregated status.
    public var applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
    /// Application ID.
    public var applicationID: Swift.String?
    /// Application ARN.
    public var arn: Swift.String?
    /// Application creation dateTime.
    public var creationDateTime: Swift.String?
    /// Application description.
    public var description: Swift.String?
    /// Application archival status.
    public var isArchived: Swift.Bool?
    /// Application last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Application name.
    public var name: Swift.String?
    /// Application tags.
    public var tags: [Swift.String:Swift.String]?
    /// Application wave ID.
    public var waveID: Swift.String?

    public init (
        applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus? = nil,
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.applicationAggregatedStatus = applicationAggregatedStatus
        self.applicationID = applicationID
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveID = waveID
    }
}

struct CreateApplicationOutputResponseBody: Swift.Equatable {
    let applicationID: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let isArchived: Swift.Bool?
    let applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
    let creationDateTime: Swift.String?
    let lastModifiedDateTime: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let waveID: Swift.String?
}

extension CreateApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationAggregatedStatus
        case applicationID
        case arn
        case creationDateTime
        case description
        case isArchived
        case lastModifiedDateTime
        case name
        case tags
        case waveID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let applicationAggregatedStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ApplicationAggregatedStatus.self, forKey: .applicationAggregatedStatus)
        applicationAggregatedStatus = applicationAggregatedStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
    }
}

extension CreateLaunchConfigurationTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLaunchConfigurationTemplateInput(associatePublicIpAddress: \(Swift.String(describing: associatePublicIpAddress)), bootMode: \(Swift.String(describing: bootMode)), copyPrivateIp: \(Swift.String(describing: copyPrivateIp)), copyTags: \(Swift.String(describing: copyTags)), enableMapAutoTagging: \(Swift.String(describing: enableMapAutoTagging)), largeVolumeConf: \(Swift.String(describing: largeVolumeConf)), launchDisposition: \(Swift.String(describing: launchDisposition)), licensing: \(Swift.String(describing: licensing)), mapAutoTaggingMpeID: \(Swift.String(describing: mapAutoTaggingMpeID)), postLaunchActions: \(Swift.String(describing: postLaunchActions)), smallVolumeConf: \(Swift.String(describing: smallVolumeConf)), smallVolumeMaxSize: \(Swift.String(describing: smallVolumeMaxSize)), targetInstanceTypeRightSizingMethod: \(Swift.String(describing: targetInstanceTypeRightSizingMethod)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateLaunchConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatePublicIpAddress
        case bootMode
        case copyPrivateIp
        case copyTags
        case enableMapAutoTagging
        case largeVolumeConf
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case postLaunchActions
        case smallVolumeConf
        case smallVolumeMaxSize
        case tags
        case targetInstanceTypeRightSizingMethod
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatePublicIpAddress = self.associatePublicIpAddress {
            try encodeContainer.encode(associatePublicIpAddress, forKey: .associatePublicIpAddress)
        }
        if let bootMode = self.bootMode {
            try encodeContainer.encode(bootMode.rawValue, forKey: .bootMode)
        }
        if let copyPrivateIp = self.copyPrivateIp {
            try encodeContainer.encode(copyPrivateIp, forKey: .copyPrivateIp)
        }
        if let copyTags = self.copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let enableMapAutoTagging = self.enableMapAutoTagging {
            try encodeContainer.encode(enableMapAutoTagging, forKey: .enableMapAutoTagging)
        }
        if let largeVolumeConf = self.largeVolumeConf {
            try encodeContainer.encode(largeVolumeConf, forKey: .largeVolumeConf)
        }
        if let launchDisposition = self.launchDisposition {
            try encodeContainer.encode(launchDisposition.rawValue, forKey: .launchDisposition)
        }
        if let licensing = self.licensing {
            try encodeContainer.encode(licensing, forKey: .licensing)
        }
        if let mapAutoTaggingMpeID = self.mapAutoTaggingMpeID {
            try encodeContainer.encode(mapAutoTaggingMpeID, forKey: .mapAutoTaggingMpeID)
        }
        if let postLaunchActions = self.postLaunchActions {
            try encodeContainer.encode(postLaunchActions, forKey: .postLaunchActions)
        }
        if let smallVolumeConf = self.smallVolumeConf {
            try encodeContainer.encode(smallVolumeConf, forKey: .smallVolumeConf)
        }
        if smallVolumeMaxSize != 0 {
            try encodeContainer.encode(smallVolumeMaxSize, forKey: .smallVolumeMaxSize)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetInstanceTypeRightSizingMethod = self.targetInstanceTypeRightSizingMethod {
            try encodeContainer.encode(targetInstanceTypeRightSizingMethod.rawValue, forKey: .targetInstanceTypeRightSizingMethod)
        }
    }
}

extension CreateLaunchConfigurationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateLaunchConfigurationTemplate"
    }
}

public struct CreateLaunchConfigurationTemplateInput: Swift.Equatable {
    /// Associate public Ip address.
    public var associatePublicIpAddress: Swift.Bool?
    /// Launch configuration template boot mode.
    public var bootMode: MgnClientTypes.BootMode?
    /// Copy private Ip.
    public var copyPrivateIp: Swift.Bool?
    /// Copy tags.
    public var copyTags: Swift.Bool?
    /// Enable map auto tagging.
    public var enableMapAutoTagging: Swift.Bool?
    /// Large volume config.
    public var largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// Launch disposition.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Configure Licensing.
    public var licensing: MgnClientTypes.Licensing?
    /// Launch configuration template map auto tagging MPE ID.
    public var mapAutoTaggingMpeID: Swift.String?
    /// Launch configuration template post launch actions.
    public var postLaunchActions: MgnClientTypes.PostLaunchActions?
    /// Small volume config.
    public var smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// Small volume maximum size.
    public var smallVolumeMaxSize: Swift.Int
    /// Request to associate tags during creation of a Launch Configuration Template.
    public var tags: [Swift.String:Swift.String]?
    /// Target instance type right-sizing method.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init (
        associatePublicIpAddress: Swift.Bool? = nil,
        bootMode: MgnClientTypes.BootMode? = nil,
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        enableMapAutoTagging: Swift.Bool? = nil,
        largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        mapAutoTaggingMpeID: Swift.String? = nil,
        postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
        smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        smallVolumeMaxSize: Swift.Int = 0,
        tags: [Swift.String:Swift.String]? = nil,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.associatePublicIpAddress = associatePublicIpAddress
        self.bootMode = bootMode
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.enableMapAutoTagging = enableMapAutoTagging
        self.largeVolumeConf = largeVolumeConf
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
        self.postLaunchActions = postLaunchActions
        self.smallVolumeConf = smallVolumeConf
        self.smallVolumeMaxSize = smallVolumeMaxSize
        self.tags = tags
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct CreateLaunchConfigurationTemplateInputBody: Swift.Equatable {
    let postLaunchActions: MgnClientTypes.PostLaunchActions?
    let enableMapAutoTagging: Swift.Bool?
    let mapAutoTaggingMpeID: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let launchDisposition: MgnClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let associatePublicIpAddress: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: MgnClientTypes.Licensing?
    let bootMode: MgnClientTypes.BootMode?
    let smallVolumeMaxSize: Swift.Int
    let smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    let largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
}

extension CreateLaunchConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatePublicIpAddress
        case bootMode
        case copyPrivateIp
        case copyTags
        case enableMapAutoTagging
        case largeVolumeConf
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case postLaunchActions
        case smallVolumeConf
        case smallVolumeMaxSize
        case tags
        case targetInstanceTypeRightSizingMethod
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let postLaunchActionsDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActions.self, forKey: .postLaunchActions)
        postLaunchActions = postLaunchActionsDecoded
        let enableMapAutoTaggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMapAutoTagging)
        enableMapAutoTagging = enableMapAutoTaggingDecoded
        let mapAutoTaggingMpeIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapAutoTaggingMpeID)
        mapAutoTaggingMpeID = mapAutoTaggingMpeIDDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchDispositionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(MgnClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let associatePublicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associatePublicIpAddress)
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let bootModeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.BootMode.self, forKey: .bootMode)
        bootMode = bootModeDecoded
        let smallVolumeMaxSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .smallVolumeMaxSize) ?? 0
        smallVolumeMaxSize = smallVolumeMaxSizeDecoded
        let smallVolumeConfDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchTemplateDiskConf.self, forKey: .smallVolumeConf)
        smallVolumeConf = smallVolumeConfDecoded
        let largeVolumeConfDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchTemplateDiskConf.self, forKey: .largeVolumeConf)
        largeVolumeConf = largeVolumeConfDecoded
    }
}

extension CreateLaunchConfigurationTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLaunchConfigurationTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateLaunchConfigurationTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLaunchConfigurationTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLaunchConfigurationTemplateOutputResponse(arn: \(Swift.String(describing: arn)), associatePublicIpAddress: \(Swift.String(describing: associatePublicIpAddress)), bootMode: \(Swift.String(describing: bootMode)), copyPrivateIp: \(Swift.String(describing: copyPrivateIp)), copyTags: \(Swift.String(describing: copyTags)), ec2LaunchTemplateID: \(Swift.String(describing: ec2LaunchTemplateID)), enableMapAutoTagging: \(Swift.String(describing: enableMapAutoTagging)), largeVolumeConf: \(Swift.String(describing: largeVolumeConf)), launchConfigurationTemplateID: \(Swift.String(describing: launchConfigurationTemplateID)), launchDisposition: \(Swift.String(describing: launchDisposition)), licensing: \(Swift.String(describing: licensing)), mapAutoTaggingMpeID: \(Swift.String(describing: mapAutoTaggingMpeID)), postLaunchActions: \(Swift.String(describing: postLaunchActions)), smallVolumeConf: \(Swift.String(describing: smallVolumeConf)), smallVolumeMaxSize: \(Swift.String(describing: smallVolumeMaxSize)), targetInstanceTypeRightSizingMethod: \(Swift.String(describing: targetInstanceTypeRightSizingMethod)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateLaunchConfigurationTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateLaunchConfigurationTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associatePublicIpAddress = output.associatePublicIpAddress
            self.bootMode = output.bootMode
            self.copyPrivateIp = output.copyPrivateIp
            self.copyTags = output.copyTags
            self.ec2LaunchTemplateID = output.ec2LaunchTemplateID
            self.enableMapAutoTagging = output.enableMapAutoTagging
            self.largeVolumeConf = output.largeVolumeConf
            self.launchConfigurationTemplateID = output.launchConfigurationTemplateID
            self.launchDisposition = output.launchDisposition
            self.licensing = output.licensing
            self.mapAutoTaggingMpeID = output.mapAutoTaggingMpeID
            self.postLaunchActions = output.postLaunchActions
            self.smallVolumeConf = output.smallVolumeConf
            self.smallVolumeMaxSize = output.smallVolumeMaxSize
            self.tags = output.tags
            self.targetInstanceTypeRightSizingMethod = output.targetInstanceTypeRightSizingMethod
        } else {
            self.arn = nil
            self.associatePublicIpAddress = nil
            self.bootMode = nil
            self.copyPrivateIp = nil
            self.copyTags = nil
            self.ec2LaunchTemplateID = nil
            self.enableMapAutoTagging = nil
            self.largeVolumeConf = nil
            self.launchConfigurationTemplateID = nil
            self.launchDisposition = nil
            self.licensing = nil
            self.mapAutoTaggingMpeID = nil
            self.postLaunchActions = nil
            self.smallVolumeConf = nil
            self.smallVolumeMaxSize = 0
            self.tags = nil
            self.targetInstanceTypeRightSizingMethod = nil
        }
    }
}

public struct CreateLaunchConfigurationTemplateOutputResponse: Swift.Equatable {
    /// ARN of the Launch Configuration Template.
    public var arn: Swift.String?
    /// Associate public Ip address.
    public var associatePublicIpAddress: Swift.Bool?
    /// Launch configuration template boot mode.
    public var bootMode: MgnClientTypes.BootMode?
    /// Copy private Ip.
    public var copyPrivateIp: Swift.Bool?
    /// Copy tags.
    public var copyTags: Swift.Bool?
    /// EC2 launch template ID.
    public var ec2LaunchTemplateID: Swift.String?
    /// Enable map auto tagging.
    public var enableMapAutoTagging: Swift.Bool?
    /// Large volume config.
    public var largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// ID of the Launch Configuration Template.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?
    /// Launch disposition.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Configure Licensing.
    public var licensing: MgnClientTypes.Licensing?
    /// Launch configuration template map auto tagging MPE ID.
    public var mapAutoTaggingMpeID: Swift.String?
    /// Post Launch Actions of the Launch Configuration Template.
    public var postLaunchActions: MgnClientTypes.PostLaunchActions?
    /// Small volume config.
    public var smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// Small volume maximum size.
    public var smallVolumeMaxSize: Swift.Int
    /// Tags of the Launch Configuration Template.
    public var tags: [Swift.String:Swift.String]?
    /// Target instance type right-sizing method.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init (
        arn: Swift.String? = nil,
        associatePublicIpAddress: Swift.Bool? = nil,
        bootMode: MgnClientTypes.BootMode? = nil,
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        ec2LaunchTemplateID: Swift.String? = nil,
        enableMapAutoTagging: Swift.Bool? = nil,
        largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        launchConfigurationTemplateID: Swift.String? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        mapAutoTaggingMpeID: Swift.String? = nil,
        postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
        smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        smallVolumeMaxSize: Swift.Int = 0,
        tags: [Swift.String:Swift.String]? = nil,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.arn = arn
        self.associatePublicIpAddress = associatePublicIpAddress
        self.bootMode = bootMode
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.ec2LaunchTemplateID = ec2LaunchTemplateID
        self.enableMapAutoTagging = enableMapAutoTagging
        self.largeVolumeConf = largeVolumeConf
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
        self.postLaunchActions = postLaunchActions
        self.smallVolumeConf = smallVolumeConf
        self.smallVolumeMaxSize = smallVolumeMaxSize
        self.tags = tags
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct CreateLaunchConfigurationTemplateOutputResponseBody: Swift.Equatable {
    let launchConfigurationTemplateID: Swift.String?
    let arn: Swift.String?
    let postLaunchActions: MgnClientTypes.PostLaunchActions?
    let enableMapAutoTagging: Swift.Bool?
    let mapAutoTaggingMpeID: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let ec2LaunchTemplateID: Swift.String?
    let launchDisposition: MgnClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let associatePublicIpAddress: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: MgnClientTypes.Licensing?
    let bootMode: MgnClientTypes.BootMode?
    let smallVolumeMaxSize: Swift.Int
    let smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    let largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
}

extension CreateLaunchConfigurationTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associatePublicIpAddress
        case bootMode
        case copyPrivateIp
        case copyTags
        case ec2LaunchTemplateID
        case enableMapAutoTagging
        case largeVolumeConf
        case launchConfigurationTemplateID
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case postLaunchActions
        case smallVolumeConf
        case smallVolumeMaxSize
        case tags
        case targetInstanceTypeRightSizingMethod
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationTemplateID)
        launchConfigurationTemplateID = launchConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let postLaunchActionsDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActions.self, forKey: .postLaunchActions)
        postLaunchActions = postLaunchActionsDecoded
        let enableMapAutoTaggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMapAutoTagging)
        enableMapAutoTagging = enableMapAutoTaggingDecoded
        let mapAutoTaggingMpeIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapAutoTaggingMpeID)
        mapAutoTaggingMpeID = mapAutoTaggingMpeIDDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let ec2LaunchTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2LaunchTemplateID)
        ec2LaunchTemplateID = ec2LaunchTemplateIDDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(MgnClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let associatePublicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associatePublicIpAddress)
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let bootModeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.BootMode.self, forKey: .bootMode)
        bootMode = bootModeDecoded
        let smallVolumeMaxSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .smallVolumeMaxSize) ?? 0
        smallVolumeMaxSize = smallVolumeMaxSizeDecoded
        let smallVolumeConfDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchTemplateDiskConf.self, forKey: .smallVolumeConf)
        smallVolumeConf = smallVolumeConfDecoded
        let largeVolumeConfDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchTemplateDiskConf.self, forKey: .largeVolumeConf)
        largeVolumeConf = largeVolumeConfDecoded
    }
}

extension CreateReplicationConfigurationTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateReplicationConfigurationTemplateInput(associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), stagingAreaTags: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension CreateReplicationConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associateDefaultSecurityGroup = self.associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = self.createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = self.dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = self.defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = self.ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = self.ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let replicationServerInstanceType = self.replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for securitygroupid0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(securitygroupid0)
            }
        }
        if let stagingAreaSubnetId = self.stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsMap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = self.useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
    }
}

extension CreateReplicationConfigurationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateReplicationConfigurationTemplate"
    }
}

public struct CreateReplicationConfigurationTemplateInput: Swift.Equatable {
    /// Request to associate the default Application Migration Service Security group with the Replication Settings template.
    /// This member is required.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Request to configure bandwidth throttling during Replication Settings template creation.
    /// This member is required.
    public var bandwidthThrottling: Swift.Int
    /// Request to create Public IP during Replication Settings template creation.
    /// This member is required.
    public var createPublicIP: Swift.Bool?
    /// Request to configure data plane routing during Replication Settings template creation.
    /// This member is required.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Request to configure the default large staging disk EBS volume type during Replication Settings template creation.
    /// This member is required.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Request to configure EBS encryption during Replication Settings template creation.
    /// This member is required.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Request to configure an EBS encryption key during Replication Settings template creation.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Request to configure the Replication Server instance type during Replication Settings template creation.
    /// This member is required.
    public var replicationServerInstanceType: Swift.String?
    /// Request to configure the Replication Server Security group ID during Replication Settings template creation.
    /// This member is required.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Request to configure the Staging Area subnet ID during Replication Settings template creation.
    /// This member is required.
    public var stagingAreaSubnetId: Swift.String?
    /// Request to configure Staging Area tags during Replication Settings template creation.
    /// This member is required.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Request to configure tags during Replication Settings template creation.
    public var tags: [Swift.String:Swift.String]?
    /// Request to use Dedicated Replication Servers during Replication Settings template creation.
    /// This member is required.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init (
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct CreateReplicationConfigurationTemplateInputBody: Swift.Equatable {
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateReplicationConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateReplicationConfigurationTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReplicationConfigurationTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateReplicationConfigurationTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReplicationConfigurationTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateReplicationConfigurationTemplateOutputResponse(arn: \(Swift.String(describing: arn)), associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), replicationConfigurationTemplateID: \(Swift.String(describing: replicationConfigurationTemplateID)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), stagingAreaTags: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension CreateReplicationConfigurationTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateReplicationConfigurationTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.replicationConfigurationTemplateID = output.replicationConfigurationTemplateID
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.tags = output.tags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
        } else {
            self.arn = nil
            self.associateDefaultSecurityGroup = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.replicationConfigurationTemplateID = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.tags = nil
            self.useDedicatedReplicationServer = nil
        }
    }
}

public struct CreateReplicationConfigurationTemplateOutputResponse: Swift.Equatable {
    /// Replication Configuration template ARN.
    public var arn: Swift.String?
    /// Replication Configuration template associate default Application Migration Service Security group.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Replication Configuration template bandwidth throttling.
    public var bandwidthThrottling: Swift.Int
    /// Replication Configuration template create Public IP.
    public var createPublicIP: Swift.Bool?
    /// Replication Configuration template data plane routing.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Replication Configuration template use default large Staging Disk type.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Replication Configuration template EBS encryption.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Replication Configuration template EBS encryption key ARN.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Replication Configuration template ID.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?
    /// Replication Configuration template server instance type.
    public var replicationServerInstanceType: Swift.String?
    /// Replication Configuration template server Security Groups IDs.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Replication Configuration template Staging Area subnet ID.
    public var stagingAreaSubnetId: Swift.String?
    /// Replication Configuration template Staging Area Tags.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Replication Configuration template Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Replication Configuration template use Dedicated Replication Server.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init (
        arn: Swift.String? = nil,
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        replicationConfigurationTemplateID: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct CreateReplicationConfigurationTemplateOutputResponseBody: Swift.Equatable {
    let replicationConfigurationTemplateID: Swift.String?
    let arn: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateReplicationConfigurationTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWaveInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWaveInput(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateWaveInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateWaveInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateWave"
    }
}

public struct CreateWaveInput: Swift.Equatable {
    /// Wave description.
    public var description: Swift.String?
    /// Wave name.
    /// This member is required.
    public var name: Swift.String?
    /// Wave tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateWaveInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateWaveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWaveOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWaveOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateWaveOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWaveOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWaveOutputResponse(arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveAggregatedStatus: \(Swift.String(describing: waveAggregatedStatus)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateWaveOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateWaveOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.isArchived = output.isArchived
            self.lastModifiedDateTime = output.lastModifiedDateTime
            self.name = output.name
            self.tags = output.tags
            self.waveAggregatedStatus = output.waveAggregatedStatus
            self.waveID = output.waveID
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.description = nil
            self.isArchived = nil
            self.lastModifiedDateTime = nil
            self.name = nil
            self.tags = nil
            self.waveAggregatedStatus = nil
            self.waveID = nil
        }
    }
}

public struct CreateWaveOutputResponse: Swift.Equatable {
    /// Wave ARN.
    public var arn: Swift.String?
    /// Wave creation dateTime.
    public var creationDateTime: Swift.String?
    /// Wave description.
    public var description: Swift.String?
    /// Wave archival status.
    public var isArchived: Swift.Bool?
    /// Wave last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Wave name.
    public var name: Swift.String?
    /// Wave tags.
    public var tags: [Swift.String:Swift.String]?
    /// Wave aggregated status.
    public var waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
    /// Wave ID.
    public var waveID: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveAggregatedStatus = waveAggregatedStatus
        self.waveID = waveID
    }
}

struct CreateWaveOutputResponseBody: Swift.Equatable {
    let waveID: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let isArchived: Swift.Bool?
    let waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
    let creationDateTime: Swift.String?
    let lastModifiedDateTime: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateWaveOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case description
        case isArchived
        case lastModifiedDateTime
        case name
        case tags
        case waveAggregatedStatus
        case waveID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let waveAggregatedStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.WaveAggregatedStatus.self, forKey: .waveAggregatedStatus)
        waveAggregatedStatus = waveAggregatedStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MgnClientTypes.DataReplicationError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case rawError
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error.rawValue, forKey: .error)
        }
        if let rawError = self.rawError {
            try encodeContainer.encode(rawError, forKey: .rawError)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationErrorString.self, forKey: .error)
        error = errorDecoded
        let rawErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rawError)
        rawError = rawErrorDecoded
    }
}

extension MgnClientTypes {
    /// Error in data replication.
    public struct DataReplicationError: Swift.Equatable {
        /// Error in data replication.
        public var error: MgnClientTypes.DataReplicationErrorString?
        /// Error in data replication.
        public var rawError: Swift.String?

        public init (
            error: MgnClientTypes.DataReplicationErrorString? = nil,
            rawError: Swift.String? = nil
        )
        {
            self.error = error
            self.rawError = rawError
        }
    }

}

extension MgnClientTypes {
    public enum DataReplicationErrorString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agentNotSeen
        case failedToAttachStagingDisks
        case failedToAuthenticateWithService
        case failedToBootReplicationServer
        case failedToConnectAgentToReplicationServer
        case failedToCreateSecurityGroup
        case failedToCreateStagingDisks
        case failedToDownloadReplicationSoftware
        case failedToLaunchReplicationServer
        case failedToPairReplicationServerWithAgent
        case failedToStartDataTransfer
        case lastSnapshotJobFailed
        case notConverging
        case snapshotsFailure
        case unstableNetwork
        case unsupportedVmConfiguration
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationErrorString] {
            return [
                .agentNotSeen,
                .failedToAttachStagingDisks,
                .failedToAuthenticateWithService,
                .failedToBootReplicationServer,
                .failedToConnectAgentToReplicationServer,
                .failedToCreateSecurityGroup,
                .failedToCreateStagingDisks,
                .failedToDownloadReplicationSoftware,
                .failedToLaunchReplicationServer,
                .failedToPairReplicationServerWithAgent,
                .failedToStartDataTransfer,
                .lastSnapshotJobFailed,
                .notConverging,
                .snapshotsFailure,
                .unstableNetwork,
                .unsupportedVmConfiguration,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agentNotSeen: return "AGENT_NOT_SEEN"
            case .failedToAttachStagingDisks: return "FAILED_TO_ATTACH_STAGING_DISKS"
            case .failedToAuthenticateWithService: return "FAILED_TO_AUTHENTICATE_WITH_SERVICE"
            case .failedToBootReplicationServer: return "FAILED_TO_BOOT_REPLICATION_SERVER"
            case .failedToConnectAgentToReplicationServer: return "FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"
            case .failedToCreateSecurityGroup: return "FAILED_TO_CREATE_SECURITY_GROUP"
            case .failedToCreateStagingDisks: return "FAILED_TO_CREATE_STAGING_DISKS"
            case .failedToDownloadReplicationSoftware: return "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"
            case .failedToLaunchReplicationServer: return "FAILED_TO_LAUNCH_REPLICATION_SERVER"
            case .failedToPairReplicationServerWithAgent: return "FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"
            case .failedToStartDataTransfer: return "FAILED_TO_START_DATA_TRANSFER"
            case .lastSnapshotJobFailed: return "LAST_SNAPSHOT_JOB_FAILED"
            case .notConverging: return "NOT_CONVERGING"
            case .snapshotsFailure: return "SNAPSHOTS_FAILURE"
            case .unstableNetwork: return "UNSTABLE_NETWORK"
            case .unsupportedVmConfiguration: return "UNSUPPORTED_VM_CONFIGURATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplicationErrorString(rawValue: rawValue) ?? DataReplicationErrorString.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.DataReplicationInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataReplicationError
        case dataReplicationInitiation
        case dataReplicationState
        case etaDateTime
        case lagDuration
        case lastSnapshotDateTime
        case replicatedDisks
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataReplicationError = self.dataReplicationError {
            try encodeContainer.encode(dataReplicationError, forKey: .dataReplicationError)
        }
        if let dataReplicationInitiation = self.dataReplicationInitiation {
            try encodeContainer.encode(dataReplicationInitiation, forKey: .dataReplicationInitiation)
        }
        if let dataReplicationState = self.dataReplicationState {
            try encodeContainer.encode(dataReplicationState.rawValue, forKey: .dataReplicationState)
        }
        if let etaDateTime = self.etaDateTime {
            try encodeContainer.encode(etaDateTime, forKey: .etaDateTime)
        }
        if let lagDuration = self.lagDuration {
            try encodeContainer.encode(lagDuration, forKey: .lagDuration)
        }
        if let lastSnapshotDateTime = self.lastSnapshotDateTime {
            try encodeContainer.encode(lastSnapshotDateTime, forKey: .lastSnapshotDateTime)
        }
        if let replicatedDisks = replicatedDisks {
            var replicatedDisksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicatedDisks)
            for datareplicationinforeplicateddisk0 in replicatedDisks {
                try replicatedDisksContainer.encode(datareplicationinforeplicateddisk0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lagDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagDuration)
        lagDuration = lagDurationDecoded
        let etaDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .etaDateTime)
        etaDateTime = etaDateTimeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([MgnClientTypes.DataReplicationInfoReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[MgnClientTypes.DataReplicationInfoReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [MgnClientTypes.DataReplicationInfoReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let dataReplicationStateDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationState.self, forKey: .dataReplicationState)
        dataReplicationState = dataReplicationStateDecoded
        let dataReplicationInitiationDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInitiation.self, forKey: .dataReplicationInitiation)
        dataReplicationInitiation = dataReplicationInitiationDecoded
        let dataReplicationErrorDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationError.self, forKey: .dataReplicationError)
        dataReplicationError = dataReplicationErrorDecoded
        let lastSnapshotDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSnapshotDateTime)
        lastSnapshotDateTime = lastSnapshotDateTimeDecoded
    }
}

extension MgnClientTypes {
    /// Request data replication info.
    public struct DataReplicationInfo: Swift.Equatable {
        /// Error in obtaining data replication info.
        public var dataReplicationError: MgnClientTypes.DataReplicationError?
        /// Request to query whether data replication has been initiated.
        public var dataReplicationInitiation: MgnClientTypes.DataReplicationInitiation?
        /// Request to query the data replication state.
        public var dataReplicationState: MgnClientTypes.DataReplicationState?
        /// Request to query the time when data replication will be complete.
        public var etaDateTime: Swift.String?
        /// Request to query data replication lag duration.
        public var lagDuration: Swift.String?
        /// Request to query data replication last snapshot time.
        public var lastSnapshotDateTime: Swift.String?
        /// Request to query disks replicated.
        public var replicatedDisks: [MgnClientTypes.DataReplicationInfoReplicatedDisk]?

        public init (
            dataReplicationError: MgnClientTypes.DataReplicationError? = nil,
            dataReplicationInitiation: MgnClientTypes.DataReplicationInitiation? = nil,
            dataReplicationState: MgnClientTypes.DataReplicationState? = nil,
            etaDateTime: Swift.String? = nil,
            lagDuration: Swift.String? = nil,
            lastSnapshotDateTime: Swift.String? = nil,
            replicatedDisks: [MgnClientTypes.DataReplicationInfoReplicatedDisk]? = nil
        )
        {
            self.dataReplicationError = dataReplicationError
            self.dataReplicationInitiation = dataReplicationInitiation
            self.dataReplicationState = dataReplicationState
            self.etaDateTime = etaDateTime
            self.lagDuration = lagDuration
            self.lastSnapshotDateTime = lastSnapshotDateTime
            self.replicatedDisks = replicatedDisks
        }
    }

}

extension MgnClientTypes.DataReplicationInfoReplicatedDisk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backloggedStorageBytes
        case deviceName
        case replicatedStorageBytes
        case rescannedStorageBytes
        case totalStorageBytes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if backloggedStorageBytes != 0 {
            try encodeContainer.encode(backloggedStorageBytes, forKey: .backloggedStorageBytes)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if replicatedStorageBytes != 0 {
            try encodeContainer.encode(replicatedStorageBytes, forKey: .replicatedStorageBytes)
        }
        if rescannedStorageBytes != 0 {
            try encodeContainer.encode(rescannedStorageBytes, forKey: .rescannedStorageBytes)
        }
        if totalStorageBytes != 0 {
            try encodeContainer.encode(totalStorageBytes, forKey: .totalStorageBytes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let totalStorageBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalStorageBytes) ?? 0
        totalStorageBytes = totalStorageBytesDecoded
        let replicatedStorageBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicatedStorageBytes) ?? 0
        replicatedStorageBytes = replicatedStorageBytesDecoded
        let rescannedStorageBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rescannedStorageBytes) ?? 0
        rescannedStorageBytes = rescannedStorageBytesDecoded
        let backloggedStorageBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backloggedStorageBytes) ?? 0
        backloggedStorageBytes = backloggedStorageBytesDecoded
    }
}

extension MgnClientTypes {
    /// Request to query disks replicated.
    public struct DataReplicationInfoReplicatedDisk: Swift.Equatable {
        /// Request to query data replication backlog size in bytes.
        public var backloggedStorageBytes: Swift.Int
        /// Request to query device name.
        public var deviceName: Swift.String?
        /// Request to query amount of data replicated in bytes.
        public var replicatedStorageBytes: Swift.Int
        /// Request to query amount of data rescanned in bytes.
        public var rescannedStorageBytes: Swift.Int
        /// Request to query total amount of data replicated in bytes.
        public var totalStorageBytes: Swift.Int

        public init (
            backloggedStorageBytes: Swift.Int = 0,
            deviceName: Swift.String? = nil,
            replicatedStorageBytes: Swift.Int = 0,
            rescannedStorageBytes: Swift.Int = 0,
            totalStorageBytes: Swift.Int = 0
        )
        {
            self.backloggedStorageBytes = backloggedStorageBytes
            self.deviceName = deviceName
            self.replicatedStorageBytes = replicatedStorageBytes
            self.rescannedStorageBytes = rescannedStorageBytes
            self.totalStorageBytes = totalStorageBytes
        }
    }

}

extension MgnClientTypes.DataReplicationInitiation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextAttemptDateTime
        case startDateTime
        case steps
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextAttemptDateTime = self.nextAttemptDateTime {
            try encodeContainer.encode(nextAttemptDateTime, forKey: .nextAttemptDateTime)
        }
        if let startDateTime = self.startDateTime {
            try encodeContainer.encode(startDateTime, forKey: .startDateTime)
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for datareplicationinitiationstep0 in steps {
                try stepsContainer.encode(datareplicationinitiationstep0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let nextAttemptDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextAttemptDateTime)
        nextAttemptDateTime = nextAttemptDateTimeDecoded
        let stepsContainer = try containerValues.decodeIfPresent([MgnClientTypes.DataReplicationInitiationStep?].self, forKey: .steps)
        var stepsDecoded0:[MgnClientTypes.DataReplicationInitiationStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [MgnClientTypes.DataReplicationInitiationStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
    }
}

extension MgnClientTypes {
    /// Data replication initiation.
    public struct DataReplicationInitiation: Swift.Equatable {
        /// Request to query next data initiation date and time.
        public var nextAttemptDateTime: Swift.String?
        /// Request to query data initiation start date and time.
        public var startDateTime: Swift.String?
        /// Request to query data initiation steps.
        public var steps: [MgnClientTypes.DataReplicationInitiationStep]?

        public init (
            nextAttemptDateTime: Swift.String? = nil,
            startDateTime: Swift.String? = nil,
            steps: [MgnClientTypes.DataReplicationInitiationStep]? = nil
        )
        {
            self.nextAttemptDateTime = nextAttemptDateTime
            self.startDateTime = startDateTime
            self.steps = steps
        }
    }

}

extension MgnClientTypes.DataReplicationInitiationStep: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInitiationStepName.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInitiationStepStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension MgnClientTypes {
    /// Data replication initiation step.
    public struct DataReplicationInitiationStep: Swift.Equatable {
        /// Request to query data initiation step name.
        public var name: MgnClientTypes.DataReplicationInitiationStepName?
        /// Request to query data initiation status.
        public var status: MgnClientTypes.DataReplicationInitiationStepStatus?

        public init (
            name: MgnClientTypes.DataReplicationInitiationStepName? = nil,
            status: MgnClientTypes.DataReplicationInitiationStepStatus? = nil
        )
        {
            self.name = name
            self.status = status
        }
    }

}

extension MgnClientTypes {
    public enum DataReplicationInitiationStepName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attachStagingDisks
        case authenticateWithService
        case bootReplicationServer
        case connectAgentToReplicationServer
        case createSecurityGroup
        case createStagingDisks
        case downloadReplicationSoftware
        case launchReplicationServer
        case pairReplicationServerWithAgent
        case startDataTransfer
        case wait
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationInitiationStepName] {
            return [
                .attachStagingDisks,
                .authenticateWithService,
                .bootReplicationServer,
                .connectAgentToReplicationServer,
                .createSecurityGroup,
                .createStagingDisks,
                .downloadReplicationSoftware,
                .launchReplicationServer,
                .pairReplicationServerWithAgent,
                .startDataTransfer,
                .wait,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attachStagingDisks: return "ATTACH_STAGING_DISKS"
            case .authenticateWithService: return "AUTHENTICATE_WITH_SERVICE"
            case .bootReplicationServer: return "BOOT_REPLICATION_SERVER"
            case .connectAgentToReplicationServer: return "CONNECT_AGENT_TO_REPLICATION_SERVER"
            case .createSecurityGroup: return "CREATE_SECURITY_GROUP"
            case .createStagingDisks: return "CREATE_STAGING_DISKS"
            case .downloadReplicationSoftware: return "DOWNLOAD_REPLICATION_SOFTWARE"
            case .launchReplicationServer: return "LAUNCH_REPLICATION_SERVER"
            case .pairReplicationServerWithAgent: return "PAIR_REPLICATION_SERVER_WITH_AGENT"
            case .startDataTransfer: return "START_DATA_TRANSFER"
            case .wait: return "WAIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplicationInitiationStepName(rawValue: rawValue) ?? DataReplicationInitiationStepName.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum DataReplicationInitiationStepStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case notStarted
        case skipped
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationInitiationStepStatus] {
            return [
                .failed,
                .inProgress,
                .notStarted,
                .skipped,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case .skipped: return "SKIPPED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplicationInitiationStepStatus(rawValue: rawValue) ?? DataReplicationInitiationStepStatus.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum DataReplicationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backlog
        case continuous
        case creatingSnapshot
        case disconnected
        case initialSync
        case initiating
        case paused
        case pendingSnapshotShipping
        case rescan
        case shippingSnapshot
        case stalled
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationState] {
            return [
                .backlog,
                .continuous,
                .creatingSnapshot,
                .disconnected,
                .initialSync,
                .initiating,
                .paused,
                .pendingSnapshotShipping,
                .rescan,
                .shippingSnapshot,
                .stalled,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backlog: return "BACKLOG"
            case .continuous: return "CONTINUOUS"
            case .creatingSnapshot: return "CREATING_SNAPSHOT"
            case .disconnected: return "DISCONNECTED"
            case .initialSync: return "INITIAL_SYNC"
            case .initiating: return "INITIATING"
            case .paused: return "PAUSED"
            case .pendingSnapshotShipping: return "PENDING_SNAPSHOT_SHIPPING"
            case .rescan: return "RESCAN"
            case .shippingSnapshot: return "SHIPPING_SNAPSHOT"
            case .stalled: return "STALLED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplicationState(rawValue: rawValue) ?? DataReplicationState.sdkUnknown(rawValue)
        }
    }
}

extension DeleteApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationID = self.applicationID {
            try encodeContainer.encode(applicationID, forKey: .applicationID)
        }
    }
}

extension DeleteApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteApplication"
    }
}

public struct DeleteApplicationInput: Swift.Equatable {
    /// Application ID.
    /// This member is required.
    public var applicationID: Swift.String?

    public init (
        applicationID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
    }
}

struct DeleteApplicationInputBody: Swift.Equatable {
    let applicationID: Swift.String?
}

extension DeleteApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
    }
}

extension DeleteApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteApplicationOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobID = self.jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
    }
}

extension DeleteJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteJob"
    }
}

public struct DeleteJobInput: Swift.Equatable {
    /// Request to delete Job from service by Job ID.
    /// This member is required.
    public var jobID: Swift.String?

    public init (
        jobID: Swift.String? = nil
    )
    {
        self.jobID = jobID
    }
}

struct DeleteJobInputBody: Swift.Equatable {
    let jobID: Swift.String?
}

extension DeleteJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
    }
}

extension DeleteJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteJobOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteJobOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteLaunchConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchConfigurationTemplateID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchConfigurationTemplateID = self.launchConfigurationTemplateID {
            try encodeContainer.encode(launchConfigurationTemplateID, forKey: .launchConfigurationTemplateID)
        }
    }
}

extension DeleteLaunchConfigurationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteLaunchConfigurationTemplate"
    }
}

public struct DeleteLaunchConfigurationTemplateInput: Swift.Equatable {
    /// ID of resource to be deleted.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?

    public init (
        launchConfigurationTemplateID: Swift.String? = nil
    )
    {
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
    }
}

struct DeleteLaunchConfigurationTemplateInputBody: Swift.Equatable {
    let launchConfigurationTemplateID: Swift.String?
}

extension DeleteLaunchConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchConfigurationTemplateID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationTemplateID)
        launchConfigurationTemplateID = launchConfigurationTemplateIDDecoded
    }
}

extension DeleteLaunchConfigurationTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLaunchConfigurationTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteLaunchConfigurationTemplateOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLaunchConfigurationTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLaunchConfigurationTemplateOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteReplicationConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfigurationTemplateID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationConfigurationTemplateID = self.replicationConfigurationTemplateID {
            try encodeContainer.encode(replicationConfigurationTemplateID, forKey: .replicationConfigurationTemplateID)
        }
    }
}

extension DeleteReplicationConfigurationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteReplicationConfigurationTemplate"
    }
}

public struct DeleteReplicationConfigurationTemplateInput: Swift.Equatable {
    /// Request to delete Replication Configuration Template from service by Replication Configuration Template ID.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?

    public init (
        replicationConfigurationTemplateID: Swift.String? = nil
    )
    {
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
    }
}

struct DeleteReplicationConfigurationTemplateInputBody: Swift.Equatable {
    let replicationConfigurationTemplateID: Swift.String?
}

extension DeleteReplicationConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfigurationTemplateID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
    }
}

extension DeleteReplicationConfigurationTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReplicationConfigurationTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteReplicationConfigurationTemplateOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReplicationConfigurationTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteReplicationConfigurationTemplateOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSourceServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension DeleteSourceServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteSourceServer"
    }
}

public struct DeleteSourceServerInput: Swift.Equatable {
    /// Request to delete Source Server from service by Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct DeleteSourceServerInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension DeleteSourceServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension DeleteSourceServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSourceServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSourceServerOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSourceServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSourceServerOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteVcenterClientInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vcenterClientID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vcenterClientID = self.vcenterClientID {
            try encodeContainer.encode(vcenterClientID, forKey: .vcenterClientID)
        }
    }
}

extension DeleteVcenterClientInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteVcenterClient"
    }
}

public struct DeleteVcenterClientInput: Swift.Equatable {
    /// ID of resource to be deleted.
    /// This member is required.
    public var vcenterClientID: Swift.String?

    public init (
        vcenterClientID: Swift.String? = nil
    )
    {
        self.vcenterClientID = vcenterClientID
    }
}

struct DeleteVcenterClientInputBody: Swift.Equatable {
    let vcenterClientID: Swift.String?
}

extension DeleteVcenterClientInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vcenterClientID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
    }
}

extension DeleteVcenterClientOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVcenterClientOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteVcenterClientOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVcenterClientOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVcenterClientOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteWaveInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case waveID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let waveID = self.waveID {
            try encodeContainer.encode(waveID, forKey: .waveID)
        }
    }
}

extension DeleteWaveInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteWave"
    }
}

public struct DeleteWaveInput: Swift.Equatable {
    /// Wave ID.
    /// This member is required.
    public var waveID: Swift.String?

    public init (
        waveID: Swift.String? = nil
    )
    {
        self.waveID = waveID
    }
}

struct DeleteWaveInputBody: Swift.Equatable {
    let waveID: Swift.String?
}

extension DeleteWaveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case waveID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
    }
}

extension DeleteWaveOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWaveOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteWaveOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWaveOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWaveOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeJobLogItemsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobID
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobID = self.jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeJobLogItemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeJobLogItems"
    }
}

public struct DescribeJobLogItemsInput: Swift.Equatable {
    /// Request to describe Job log job ID.
    /// This member is required.
    public var jobID: Swift.String?
    /// Request to describe Job log item maximum results.
    public var maxResults: Swift.Int
    /// Request to describe Job log next token.
    public var nextToken: Swift.String?

    public init (
        jobID: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.jobID = jobID
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeJobLogItemsInputBody: Swift.Equatable {
    let jobID: Swift.String?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeJobLogItemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobID
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeJobLogItemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobLogItemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeJobLogItemsOutputError: Swift.Error, Swift.Equatable {
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobLogItemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeJobLogItemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeJobLogItemsOutputResponse: Swift.Equatable {
    /// Request to describe Job log response items.
    public var items: [MgnClientTypes.JobLog]?
    /// Request to describe Job log response next token.
    public var nextToken: Swift.String?

    public init (
        items: [MgnClientTypes.JobLog]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeJobLogItemsOutputResponseBody: Swift.Equatable {
    let items: [MgnClientTypes.JobLog]?
    let nextToken: Swift.String?
}

extension DescribeJobLogItemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.JobLog?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.JobLog]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.JobLog]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeJobs"
    }
}

public struct DescribeJobsInput: Swift.Equatable {
    /// Request to describe Job log filters.
    public var filters: MgnClientTypes.DescribeJobsRequestFilters?
    /// Request to describe job log items by max results.
    public var maxResults: Swift.Int
    /// Request to describe job log items by next token.
    public var nextToken: Swift.String?

    public init (
        filters: MgnClientTypes.DescribeJobsRequestFilters? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeJobsInputBody: Swift.Equatable {
    let filters: MgnClientTypes.DescribeJobsRequestFilters?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DescribeJobsRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeJobsOutputError: Swift.Error, Swift.Equatable {
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeJobsOutputResponse: Swift.Equatable {
    /// Request to describe Job log items.
    public var items: [MgnClientTypes.Job]?
    /// Request to describe Job response by next token.
    public var nextToken: Swift.String?

    public init (
        items: [MgnClientTypes.Job]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeJobsOutputResponseBody: Swift.Equatable {
    let items: [MgnClientTypes.Job]?
    let nextToken: Swift.String?
}

extension DescribeJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.Job?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.Job]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.Job]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MgnClientTypes.DescribeJobsRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromDate
        case jobIDs
        case toDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromDate = self.fromDate {
            try encodeContainer.encode(fromDate, forKey: .fromDate)
        }
        if let jobIDs = jobIDs {
            var jobIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobIDs)
            for jobid0 in jobIDs {
                try jobIDsContainer.encode(jobid0)
            }
        }
        if let toDate = self.toDate {
            try encodeContainer.encode(toDate, forKey: .toDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .jobIDs)
        var jobIDsDecoded0:[Swift.String]? = nil
        if let jobIDsContainer = jobIDsContainer {
            jobIDsDecoded0 = [Swift.String]()
            for string0 in jobIDsContainer {
                if let string0 = string0 {
                    jobIDsDecoded0?.append(string0)
                }
            }
        }
        jobIDs = jobIDsDecoded0
        let fromDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromDate)
        fromDate = fromDateDecoded
        let toDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .toDate)
        toDate = toDateDecoded
    }
}

extension MgnClientTypes {
    /// Request to describe Job log filters.
    public struct DescribeJobsRequestFilters: Swift.Equatable {
        /// Request to describe Job log filters by date.
        public var fromDate: Swift.String?
        /// Request to describe Job log filters by job ID.
        public var jobIDs: [Swift.String]?
        /// Request to describe job log items by last date.
        public var toDate: Swift.String?

        public init (
            fromDate: Swift.String? = nil,
            jobIDs: [Swift.String]? = nil,
            toDate: Swift.String? = nil
        )
        {
            self.fromDate = fromDate
            self.jobIDs = jobIDs
            self.toDate = toDate
        }
    }

}

extension DescribeLaunchConfigurationTemplatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchConfigurationTemplateIDs
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchConfigurationTemplateIDs = launchConfigurationTemplateIDs {
            var launchConfigurationTemplateIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .launchConfigurationTemplateIDs)
            for launchconfigurationtemplateid0 in launchConfigurationTemplateIDs {
                try launchConfigurationTemplateIDsContainer.encode(launchconfigurationtemplateid0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeLaunchConfigurationTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeLaunchConfigurationTemplates"
    }
}

public struct DescribeLaunchConfigurationTemplatesInput: Swift.Equatable {
    /// Request to filter Launch Configuration Templates list by Launch Configuration Template ID.
    public var launchConfigurationTemplateIDs: [Swift.String]?
    /// Maximum results to be returned in DescribeLaunchConfigurationTemplates.
    public var maxResults: Swift.Int
    /// Next pagination token returned from DescribeLaunchConfigurationTemplates.
    public var nextToken: Swift.String?

    public init (
        launchConfigurationTemplateIDs: [Swift.String]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.launchConfigurationTemplateIDs = launchConfigurationTemplateIDs
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeLaunchConfigurationTemplatesInputBody: Swift.Equatable {
    let launchConfigurationTemplateIDs: [Swift.String]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeLaunchConfigurationTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchConfigurationTemplateIDs
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .launchConfigurationTemplateIDs)
        var launchConfigurationTemplateIDsDecoded0:[Swift.String]? = nil
        if let launchConfigurationTemplateIDsContainer = launchConfigurationTemplateIDsContainer {
            launchConfigurationTemplateIDsDecoded0 = [Swift.String]()
            for string0 in launchConfigurationTemplateIDsContainer {
                if let string0 = string0 {
                    launchConfigurationTemplateIDsDecoded0?.append(string0)
                }
            }
        }
        launchConfigurationTemplateIDs = launchConfigurationTemplateIDsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeLaunchConfigurationTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLaunchConfigurationTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeLaunchConfigurationTemplatesOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLaunchConfigurationTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeLaunchConfigurationTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeLaunchConfigurationTemplatesOutputResponse: Swift.Equatable {
    /// List of items returned by DescribeLaunchConfigurationTemplates.
    public var items: [MgnClientTypes.LaunchConfigurationTemplate]?
    /// Next pagination token returned from DescribeLaunchConfigurationTemplates.
    public var nextToken: Swift.String?

    public init (
        items: [MgnClientTypes.LaunchConfigurationTemplate]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeLaunchConfigurationTemplatesOutputResponseBody: Swift.Equatable {
    let items: [MgnClientTypes.LaunchConfigurationTemplate]?
    let nextToken: Swift.String?
}

extension DescribeLaunchConfigurationTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.LaunchConfigurationTemplate?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.LaunchConfigurationTemplate]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.LaunchConfigurationTemplate]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeReplicationConfigurationTemplatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case replicationConfigurationTemplateIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDs {
            var replicationConfigurationTemplateIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationConfigurationTemplateIDs)
            for replicationconfigurationtemplateid0 in replicationConfigurationTemplateIDs {
                try replicationConfigurationTemplateIDsContainer.encode(replicationconfigurationtemplateid0)
            }
        }
    }
}

extension DescribeReplicationConfigurationTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeReplicationConfigurationTemplates"
    }
}

public struct DescribeReplicationConfigurationTemplatesInput: Swift.Equatable {
    /// Request to describe Replication Configuration template by max results.
    public var maxResults: Swift.Int
    /// Request to describe Replication Configuration template by next token.
    public var nextToken: Swift.String?
    /// Request to describe Replication Configuration template by template IDs.
    public var replicationConfigurationTemplateIDs: [Swift.String]?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        replicationConfigurationTemplateIDs: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDs
    }
}

struct DescribeReplicationConfigurationTemplatesInputBody: Swift.Equatable {
    let replicationConfigurationTemplateIDs: [Swift.String]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeReplicationConfigurationTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case replicationConfigurationTemplateIDs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationConfigurationTemplateIDs)
        var replicationConfigurationTemplateIDsDecoded0:[Swift.String]? = nil
        if let replicationConfigurationTemplateIDsContainer = replicationConfigurationTemplateIDsContainer {
            replicationConfigurationTemplateIDsDecoded0 = [Swift.String]()
            for string0 in replicationConfigurationTemplateIDsContainer {
                if let string0 = string0 {
                    replicationConfigurationTemplateIDsDecoded0?.append(string0)
                }
            }
        }
        replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeReplicationConfigurationTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationConfigurationTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeReplicationConfigurationTemplatesOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationConfigurationTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeReplicationConfigurationTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeReplicationConfigurationTemplatesOutputResponse: Swift.Equatable {
    /// Request to describe Replication Configuration template by items.
    public var items: [MgnClientTypes.ReplicationConfigurationTemplate]?
    /// Request to describe Replication Configuration template by next token.
    public var nextToken: Swift.String?

    public init (
        items: [MgnClientTypes.ReplicationConfigurationTemplate]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeReplicationConfigurationTemplatesOutputResponseBody: Swift.Equatable {
    let items: [MgnClientTypes.ReplicationConfigurationTemplate]?
    let nextToken: Swift.String?
}

extension DescribeReplicationConfigurationTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.ReplicationConfigurationTemplate?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.ReplicationConfigurationTemplate]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.ReplicationConfigurationTemplate]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSourceServersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeSourceServersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeSourceServers"
    }
}

public struct DescribeSourceServersInput: Swift.Equatable {
    /// Request to filter Source Servers list.
    public var filters: MgnClientTypes.DescribeSourceServersRequestFilters?
    /// Request to filter Source Servers list by maximum results.
    public var maxResults: Swift.Int
    /// Request to filter Source Servers list by next token.
    public var nextToken: Swift.String?

    public init (
        filters: MgnClientTypes.DescribeSourceServersRequestFilters? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeSourceServersInputBody: Swift.Equatable {
    let filters: MgnClientTypes.DescribeSourceServersRequestFilters?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeSourceServersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DescribeSourceServersRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSourceServersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSourceServersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSourceServersOutputError: Swift.Error, Swift.Equatable {
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSourceServersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSourceServersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeSourceServersOutputResponse: Swift.Equatable {
    /// Request to filter Source Servers list by item.
    public var items: [MgnClientTypes.SourceServer]?
    /// Request to filter Source Servers next token.
    public var nextToken: Swift.String?

    public init (
        items: [MgnClientTypes.SourceServer]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeSourceServersOutputResponseBody: Swift.Equatable {
    let items: [MgnClientTypes.SourceServer]?
    let nextToken: Swift.String?
}

extension DescribeSourceServersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.SourceServer?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.SourceServer]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.SourceServer]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MgnClientTypes.DescribeSourceServersRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIDs
        case isArchived
        case lifeCycleStates
        case replicationTypes
        case sourceServerIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationIDs = applicationIDs {
            var applicationIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationIDs)
            for applicationid0 in applicationIDs {
                try applicationIDsContainer.encode(applicationid0)
            }
        }
        if let isArchived = self.isArchived {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let lifeCycleStates = lifeCycleStates {
            var lifeCycleStatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lifeCycleStates)
            for lifecyclestate0 in lifeCycleStates {
                try lifeCycleStatesContainer.encode(lifecyclestate0.rawValue)
            }
        }
        if let replicationTypes = replicationTypes {
            var replicationTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationTypes)
            for replicationtype0 in replicationTypes {
                try replicationTypesContainer.encode(replicationtype0.rawValue)
            }
        }
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for sourceserverid0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(sourceserverid0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[Swift.String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [Swift.String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let replicationTypesContainer = try containerValues.decodeIfPresent([MgnClientTypes.ReplicationType?].self, forKey: .replicationTypes)
        var replicationTypesDecoded0:[MgnClientTypes.ReplicationType]? = nil
        if let replicationTypesContainer = replicationTypesContainer {
            replicationTypesDecoded0 = [MgnClientTypes.ReplicationType]()
            for string0 in replicationTypesContainer {
                if let string0 = string0 {
                    replicationTypesDecoded0?.append(string0)
                }
            }
        }
        replicationTypes = replicationTypesDecoded0
        let lifeCycleStatesContainer = try containerValues.decodeIfPresent([MgnClientTypes.LifeCycleState?].self, forKey: .lifeCycleStates)
        var lifeCycleStatesDecoded0:[MgnClientTypes.LifeCycleState]? = nil
        if let lifeCycleStatesContainer = lifeCycleStatesContainer {
            lifeCycleStatesDecoded0 = [MgnClientTypes.LifeCycleState]()
            for string0 in lifeCycleStatesContainer {
                if let string0 = string0 {
                    lifeCycleStatesDecoded0?.append(string0)
                }
            }
        }
        lifeCycleStates = lifeCycleStatesDecoded0
        let applicationIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applicationIDs)
        var applicationIDsDecoded0:[Swift.String]? = nil
        if let applicationIDsContainer = applicationIDsContainer {
            applicationIDsDecoded0 = [Swift.String]()
            for string0 in applicationIDsContainer {
                if let string0 = string0 {
                    applicationIDsDecoded0?.append(string0)
                }
            }
        }
        applicationIDs = applicationIDsDecoded0
    }
}

extension MgnClientTypes {
    /// Request to filter Source Servers list.
    public struct DescribeSourceServersRequestFilters: Swift.Equatable {
        /// Request to filter Source Servers list by application IDs.
        public var applicationIDs: [Swift.String]?
        /// Request to filter Source Servers list by archived.
        public var isArchived: Swift.Bool?
        /// Request to filter Source Servers list by life cycle states.
        public var lifeCycleStates: [MgnClientTypes.LifeCycleState]?
        /// Request to filter Source Servers list by replication type.
        public var replicationTypes: [MgnClientTypes.ReplicationType]?
        /// Request to filter Source Servers list by Source Server ID.
        public var sourceServerIDs: [Swift.String]?

        public init (
            applicationIDs: [Swift.String]? = nil,
            isArchived: Swift.Bool? = nil,
            lifeCycleStates: [MgnClientTypes.LifeCycleState]? = nil,
            replicationTypes: [MgnClientTypes.ReplicationType]? = nil,
            sourceServerIDs: [Swift.String]? = nil
        )
        {
            self.applicationIDs = applicationIDs
            self.isArchived = isArchived
            self.lifeCycleStates = lifeCycleStates
            self.replicationTypes = replicationTypes
            self.sourceServerIDs = sourceServerIDs
        }
    }

}

extension DescribeVcenterClientsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension DescribeVcenterClientsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeVcenterClients"
    }
}

public struct DescribeVcenterClientsInput: Swift.Equatable {
    /// Maximum results to be returned in DescribeVcenterClients.
    public var maxResults: Swift.Int
    /// Next pagination token to be provided for DescribeVcenterClients.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeVcenterClientsInputBody: Swift.Equatable {
}

extension DescribeVcenterClientsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeVcenterClientsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVcenterClientsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeVcenterClientsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVcenterClientsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeVcenterClientsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeVcenterClientsOutputResponse: Swift.Equatable {
    /// List of items returned by DescribeVcenterClients.
    public var items: [MgnClientTypes.VcenterClient]?
    /// Next pagination token returned from DescribeVcenterClients.
    public var nextToken: Swift.String?

    public init (
        items: [MgnClientTypes.VcenterClient]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeVcenterClientsOutputResponseBody: Swift.Equatable {
    let items: [MgnClientTypes.VcenterClient]?
    let nextToken: Swift.String?
}

extension DescribeVcenterClientsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.VcenterClient?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.VcenterClient]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.VcenterClient]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DisassociateApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIDs
        case waveID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationIDs = applicationIDs {
            var applicationIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationIDs)
            for applicationid0 in applicationIDs {
                try applicationIDsContainer.encode(applicationid0)
            }
        }
        if let waveID = self.waveID {
            try encodeContainer.encode(waveID, forKey: .waveID)
        }
    }
}

extension DisassociateApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DisassociateApplications"
    }
}

public struct DisassociateApplicationsInput: Swift.Equatable {
    /// Application IDs list.
    /// This member is required.
    public var applicationIDs: [Swift.String]?
    /// Wave ID.
    /// This member is required.
    public var waveID: Swift.String?

    public init (
        applicationIDs: [Swift.String]? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.applicationIDs = applicationIDs
        self.waveID = waveID
    }
}

struct DisassociateApplicationsInputBody: Swift.Equatable {
    let waveID: Swift.String?
    let applicationIDs: [Swift.String]?
}

extension DisassociateApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIDs
        case waveID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
        let applicationIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applicationIDs)
        var applicationIDsDecoded0:[Swift.String]? = nil
        if let applicationIDsContainer = applicationIDsContainer {
            applicationIDsDecoded0 = [Swift.String]()
            for string0 in applicationIDsContainer {
                if let string0 = string0 {
                    applicationIDsDecoded0?.append(string0)
                }
            }
        }
        applicationIDs = applicationIDsDecoded0
    }
}

extension DisassociateApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateApplicationsOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateApplicationsOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateSourceServersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case sourceServerIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationID = self.applicationID {
            try encodeContainer.encode(applicationID, forKey: .applicationID)
        }
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for sourceserverid0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(sourceserverid0)
            }
        }
    }
}

extension DisassociateSourceServersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DisassociateSourceServers"
    }
}

public struct DisassociateSourceServersInput: Swift.Equatable {
    /// Application ID.
    /// This member is required.
    public var applicationID: Swift.String?
    /// Source server IDs list.
    /// This member is required.
    public var sourceServerIDs: [Swift.String]?

    public init (
        applicationID: Swift.String? = nil,
        sourceServerIDs: [Swift.String]? = nil
    )
    {
        self.applicationID = applicationID
        self.sourceServerIDs = sourceServerIDs
    }
}

struct DisassociateSourceServersInputBody: Swift.Equatable {
    let applicationID: Swift.String?
    let sourceServerIDs: [Swift.String]?
}

extension DisassociateSourceServersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case sourceServerIDs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[Swift.String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [Swift.String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
    }
}

extension DisassociateSourceServersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateSourceServersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateSourceServersOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateSourceServersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateSourceServersOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisconnectFromServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension DisconnectFromServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DisconnectFromService"
    }
}

public struct DisconnectFromServiceInput: Swift.Equatable {
    /// Request to disconnect Source Server from service by Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct DisconnectFromServiceInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension DisconnectFromServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension DisconnectFromServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisconnectFromServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisconnectFromServiceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisconnectFromServiceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisconnectFromServiceOutputResponse(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

extension DisconnectFromServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisconnectFromServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.applicationID = nil
            self.arn = nil
            self.dataReplicationInfo = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.vcenterClientID = nil
        }
    }
}

public struct DisconnectFromServiceOutputResponse: Swift.Equatable {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init (
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.vcenterClientID = vcenterClientID
    }
}

struct DisconnectFromServiceOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
    let applicationID: Swift.String?
}

extension DisconnectFromServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case vcenterClientID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
    }
}

extension MgnClientTypes.Disk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytes
        case deviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bytes != 0 {
            try encodeContainer.encode(bytes, forKey: .bytes)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let bytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytes) ?? 0
        bytes = bytesDecoded
    }
}

extension MgnClientTypes {
    /// The disk identifier.
    public struct Disk: Swift.Equatable {
        /// The amount of storage on the disk in bytes.
        public var bytes: Swift.Int
        /// The disk or device name.
        public var deviceName: Swift.String?

        public init (
            bytes: Swift.Int = 0,
            deviceName: Swift.String? = nil
        )
        {
            self.bytes = bytes
            self.deviceName = deviceName
        }
    }

}

extension MgnClientTypes.ErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case resourceId
        case resourceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension MgnClientTypes {
    /// Error details.
    public struct ErrorDetails: Swift.Equatable {
        /// Error details code.
        public var code: Swift.String?
        /// Error details message.
        public var message: Swift.String?
        /// Error details resourceId.
        public var resourceId: Swift.String?
        /// Error details resourceType.
        public var resourceType: Swift.String?

        public init (
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }

}

extension FinalizeCutoverInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension FinalizeCutoverInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/FinalizeCutover"
    }
}

public struct FinalizeCutoverInput: Swift.Equatable {
    /// Request to finalize Cutover by Source Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct FinalizeCutoverInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension FinalizeCutoverInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension FinalizeCutoverOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension FinalizeCutoverOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum FinalizeCutoverOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension FinalizeCutoverOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "FinalizeCutoverOutputResponse(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

extension FinalizeCutoverOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: FinalizeCutoverOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.applicationID = nil
            self.arn = nil
            self.dataReplicationInfo = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.vcenterClientID = nil
        }
    }
}

public struct FinalizeCutoverOutputResponse: Swift.Equatable {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init (
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.vcenterClientID = vcenterClientID
    }
}

struct FinalizeCutoverOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
    let applicationID: Swift.String?
}

extension FinalizeCutoverOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case vcenterClientID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
    }
}

extension MgnClientTypes {
    public enum FirstBoot: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case stopped
        case succeeded
        case unknown
        case waiting
        case sdkUnknown(Swift.String)

        public static var allCases: [FirstBoot] {
            return [
                .stopped,
                .succeeded,
                .unknown,
                .waiting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .stopped: return "STOPPED"
            case .succeeded: return "SUCCEEDED"
            case .unknown: return "UNKNOWN"
            case .waiting: return "WAITING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FirstBoot(rawValue: rawValue) ?? FirstBoot.sdkUnknown(rawValue)
        }
    }
}

extension GetLaunchConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension GetLaunchConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetLaunchConfiguration"
    }
}

public struct GetLaunchConfigurationInput: Swift.Equatable {
    /// Request to get Launch Configuration information by Source Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct GetLaunchConfigurationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension GetLaunchConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension GetLaunchConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLaunchConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetLaunchConfigurationOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLaunchConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetLaunchConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bootMode = output.bootMode
            self.copyPrivateIp = output.copyPrivateIp
            self.copyTags = output.copyTags
            self.ec2LaunchTemplateID = output.ec2LaunchTemplateID
            self.enableMapAutoTagging = output.enableMapAutoTagging
            self.launchDisposition = output.launchDisposition
            self.licensing = output.licensing
            self.mapAutoTaggingMpeID = output.mapAutoTaggingMpeID
            self.name = output.name
            self.postLaunchActions = output.postLaunchActions
            self.sourceServerID = output.sourceServerID
            self.targetInstanceTypeRightSizingMethod = output.targetInstanceTypeRightSizingMethod
        } else {
            self.bootMode = nil
            self.copyPrivateIp = nil
            self.copyTags = nil
            self.ec2LaunchTemplateID = nil
            self.enableMapAutoTagging = nil
            self.launchDisposition = nil
            self.licensing = nil
            self.mapAutoTaggingMpeID = nil
            self.name = nil
            self.postLaunchActions = nil
            self.sourceServerID = nil
            self.targetInstanceTypeRightSizingMethod = nil
        }
    }
}

public struct GetLaunchConfigurationOutputResponse: Swift.Equatable {
    /// Launch configuration boot mode.
    public var bootMode: MgnClientTypes.BootMode?
    /// Copy Private IP during Launch Configuration.
    public var copyPrivateIp: Swift.Bool?
    /// Copy Tags during Launch Configuration.
    public var copyTags: Swift.Bool?
    /// Launch configuration EC2 Launch template ID.
    public var ec2LaunchTemplateID: Swift.String?
    /// Enable map auto tagging.
    public var enableMapAutoTagging: Swift.Bool?
    /// Launch disposition for launch configuration.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Launch configuration OS licensing.
    public var licensing: MgnClientTypes.Licensing?
    /// Map auto tagging MPE ID.
    public var mapAutoTaggingMpeID: Swift.String?
    /// Launch configuration name.
    public var name: Swift.String?
    /// Post Launch Actions to executed on the Test or Cutover instance.
    public var postLaunchActions: MgnClientTypes.PostLaunchActions?
    /// Launch configuration Source Server ID.
    public var sourceServerID: Swift.String?
    /// Launch configuration Target instance type right sizing method.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init (
        bootMode: MgnClientTypes.BootMode? = nil,
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        ec2LaunchTemplateID: Swift.String? = nil,
        enableMapAutoTagging: Swift.Bool? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        mapAutoTaggingMpeID: Swift.String? = nil,
        name: Swift.String? = nil,
        postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
        sourceServerID: Swift.String? = nil,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.bootMode = bootMode
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.ec2LaunchTemplateID = ec2LaunchTemplateID
        self.enableMapAutoTagging = enableMapAutoTagging
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
        self.name = name
        self.postLaunchActions = postLaunchActions
        self.sourceServerID = sourceServerID
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct GetLaunchConfigurationOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let ec2LaunchTemplateID: Swift.String?
    let launchDisposition: MgnClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: MgnClientTypes.Licensing?
    let bootMode: MgnClientTypes.BootMode?
    let postLaunchActions: MgnClientTypes.PostLaunchActions?
    let enableMapAutoTagging: Swift.Bool?
    let mapAutoTaggingMpeID: Swift.String?
}

extension GetLaunchConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bootMode
        case copyPrivateIp
        case copyTags
        case ec2LaunchTemplateID
        case enableMapAutoTagging
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case name
        case postLaunchActions
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ec2LaunchTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2LaunchTemplateID)
        ec2LaunchTemplateID = ec2LaunchTemplateIDDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(MgnClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let bootModeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.BootMode.self, forKey: .bootMode)
        bootMode = bootModeDecoded
        let postLaunchActionsDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActions.self, forKey: .postLaunchActions)
        postLaunchActions = postLaunchActionsDecoded
        let enableMapAutoTaggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMapAutoTagging)
        enableMapAutoTagging = enableMapAutoTaggingDecoded
        let mapAutoTaggingMpeIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapAutoTaggingMpeID)
        mapAutoTaggingMpeID = mapAutoTaggingMpeIDDecoded
    }
}

extension GetReplicationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension GetReplicationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetReplicationConfiguration"
    }
}

public struct GetReplicationConfigurationInput: Swift.Equatable {
    /// Request to get Replication Configuration by Source Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct GetReplicationConfigurationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension GetReplicationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension GetReplicationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReplicationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetReplicationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReplicationConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetReplicationConfigurationOutputResponse(associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), name: \(Swift.String(describing: name)), replicatedDisks: \(Swift.String(describing: replicatedDisks)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), sourceServerID: \(Swift.String(describing: sourceServerID)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), stagingAreaTags: \"CONTENT_REDACTED\")"}
}

extension GetReplicationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetReplicationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.name = output.name
            self.replicatedDisks = output.replicatedDisks
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.sourceServerID = output.sourceServerID
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
        } else {
            self.associateDefaultSecurityGroup = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.name = nil
            self.replicatedDisks = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.sourceServerID = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.useDedicatedReplicationServer = nil
        }
    }
}

public struct GetReplicationConfigurationOutputResponse: Swift.Equatable {
    /// Replication Configuration associate default Application Migration Service Security Group.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Replication Configuration set bandwidth throttling.
    public var bandwidthThrottling: Swift.Int
    /// Replication Configuration create Public IP.
    public var createPublicIP: Swift.Bool?
    /// Replication Configuration data plane routing.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Replication Configuration use default large Staging Disks.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Replication Configuration EBS encryption.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Replication Configuration EBS encryption key ARN.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Replication Configuration name.
    public var name: Swift.String?
    /// Replication Configuration replicated disks.
    public var replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]?
    /// Replication Configuration Replication Server instance type.
    public var replicationServerInstanceType: Swift.String?
    /// Replication Configuration Replication Server Security Group IDs.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Replication Configuration Source Server ID.
    public var sourceServerID: Swift.String?
    /// Replication Configuration Staging Area subnet ID.
    public var stagingAreaSubnetId: Swift.String?
    /// Replication Configuration Staging Area tags.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Replication Configuration use Dedicated Replication Server.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init (
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        sourceServerID: Swift.String? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.name = name
        self.replicatedDisks = replicatedDisks
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.sourceServerID = sourceServerID
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct GetReplicationConfigurationOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]?
    let ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
}

extension GetReplicationConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([MgnClientTypes.ReplicationConfigurationReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[MgnClientTypes.ReplicationConfigurationReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [MgnClientTypes.ReplicationConfigurationReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
    }
}

extension MgnClientTypes.IdentificationHints: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsInstanceID
        case fqdn
        case hostname
        case vmPath
        case vmWareUuid
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsInstanceID = self.awsInstanceID {
            try encodeContainer.encode(awsInstanceID, forKey: .awsInstanceID)
        }
        if let fqdn = self.fqdn {
            try encodeContainer.encode(fqdn, forKey: .fqdn)
        }
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let vmPath = self.vmPath {
            try encodeContainer.encode(vmPath, forKey: .vmPath)
        }
        if let vmWareUuid = self.vmWareUuid {
            try encodeContainer.encode(vmWareUuid, forKey: .vmWareUuid)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fqdnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fqdn)
        fqdn = fqdnDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let vmWareUuidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmWareUuid)
        vmWareUuid = vmWareUuidDecoded
        let awsInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsInstanceID)
        awsInstanceID = awsInstanceIDDecoded
        let vmPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmPath)
        vmPath = vmPathDecoded
    }
}

extension MgnClientTypes {
    /// Identification hints.
    public struct IdentificationHints: Swift.Equatable {
        /// AWS Instance ID identification hint.
        public var awsInstanceID: Swift.String?
        /// FQDN address identification hint.
        public var fqdn: Swift.String?
        /// Hostname identification hint.
        public var hostname: Swift.String?
        /// vCenter VM path identification hint.
        public var vmPath: Swift.String?
        /// vmWare UUID identification hint.
        public var vmWareUuid: Swift.String?

        public init (
            awsInstanceID: Swift.String? = nil,
            fqdn: Swift.String? = nil,
            hostname: Swift.String? = nil,
            vmPath: Swift.String? = nil,
            vmWareUuid: Swift.String? = nil
        )
        {
            self.awsInstanceID = awsInstanceID
            self.fqdn = fqdn
            self.hostname = hostname
            self.vmPath = vmPath
            self.vmWareUuid = vmWareUuid
        }
    }

}

extension InitializeServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/InitializeService"
    }
}

public struct InitializeServiceInput: Swift.Equatable {

    public init () { }
}

struct InitializeServiceInputBody: Swift.Equatable {
}

extension InitializeServiceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension InitializeServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitializeServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum InitializeServiceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitializeServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct InitializeServiceOutputResponse: Swift.Equatable {

    public init () { }
}

extension MgnClientTypes {
    public enum InitiatedBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case diagnostic
        case startCutover
        case startTest
        case terminate
        case sdkUnknown(Swift.String)

        public static var allCases: [InitiatedBy] {
            return [
                .diagnostic,
                .startCutover,
                .startTest,
                .terminate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .diagnostic: return "DIAGNOSTIC"
            case .startCutover: return "START_CUTOVER"
            case .startTest: return "START_TEST"
            case .terminate: return "TERMINATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InitiatedBy(rawValue: rawValue) ?? InitiatedBy.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The server encountered an unexpected condition that prevented it from fulfilling the request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// The server encountered an unexpected condition that prevented it from fulfilling the request. The request will be retried again after x seconds.
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MgnClientTypes.Job: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case endDateTime
        case initiatedBy
        case jobID
        case participatingServers
        case status
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encode(creationDateTime, forKey: .creationDateTime)
        }
        if let endDateTime = self.endDateTime {
            try encodeContainer.encode(endDateTime, forKey: .endDateTime)
        }
        if let initiatedBy = self.initiatedBy {
            try encodeContainer.encode(initiatedBy.rawValue, forKey: .initiatedBy)
        }
        if let jobID = self.jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
        if let participatingServers = participatingServers {
            var participatingServersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .participatingServers)
            for participatingserver0 in participatingServers {
                try participatingServersContainer.encode(participatingserver0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.JobType.self, forKey: .type)
        type = typeDecoded
        let initiatedByDecoded = try containerValues.decodeIfPresent(MgnClientTypes.InitiatedBy.self, forKey: .initiatedBy)
        initiatedBy = initiatedByDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let participatingServersContainer = try containerValues.decodeIfPresent([MgnClientTypes.ParticipatingServer?].self, forKey: .participatingServers)
        var participatingServersDecoded0:[MgnClientTypes.ParticipatingServer]? = nil
        if let participatingServersContainer = participatingServersContainer {
            participatingServersDecoded0 = [MgnClientTypes.ParticipatingServer]()
            for structure0 in participatingServersContainer {
                if let structure0 = structure0 {
                    participatingServersDecoded0?.append(structure0)
                }
            }
        }
        participatingServers = participatingServersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MgnClientTypes.Job: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Job(arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), endDateTime: \(Swift.String(describing: endDateTime)), initiatedBy: \(Swift.String(describing: initiatedBy)), jobID: \(Swift.String(describing: jobID)), participatingServers: \(Swift.String(describing: participatingServers)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), tags: \"CONTENT_REDACTED\")"}
}

extension MgnClientTypes {
    /// Job.
    public struct Job: Swift.Equatable {
        /// the ARN of the specific Job.
        public var arn: Swift.String?
        /// Job creation time.
        public var creationDateTime: Swift.String?
        /// Job end time.
        public var endDateTime: Swift.String?
        /// Job initiated by field.
        public var initiatedBy: MgnClientTypes.InitiatedBy?
        /// Job ID.
        /// This member is required.
        public var jobID: Swift.String?
        /// Servers participating in a specific Job.
        public var participatingServers: [MgnClientTypes.ParticipatingServer]?
        /// Job status.
        public var status: MgnClientTypes.JobStatus?
        /// Tags associated with specific Job.
        public var tags: [Swift.String:Swift.String]?
        /// Job type.
        public var type: MgnClientTypes.JobType?

        public init (
            arn: Swift.String? = nil,
            creationDateTime: Swift.String? = nil,
            endDateTime: Swift.String? = nil,
            initiatedBy: MgnClientTypes.InitiatedBy? = nil,
            jobID: Swift.String? = nil,
            participatingServers: [MgnClientTypes.ParticipatingServer]? = nil,
            status: MgnClientTypes.JobStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: MgnClientTypes.JobType? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.endDateTime = endDateTime
            self.initiatedBy = initiatedBy
            self.jobID = jobID
            self.participatingServers = participatingServers
            self.status = status
            self.tags = tags
            self.type = type
        }
    }

}

extension MgnClientTypes.JobLog: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case eventData
        case logDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = self.event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let eventData = self.eventData {
            try encodeContainer.encode(eventData, forKey: .eventData)
        }
        if let logDateTime = self.logDateTime {
            try encodeContainer.encode(logDateTime, forKey: .logDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logDateTime)
        logDateTime = logDateTimeDecoded
        let eventDecoded = try containerValues.decodeIfPresent(MgnClientTypes.JobLogEvent.self, forKey: .event)
        event = eventDecoded
        let eventDataDecoded = try containerValues.decodeIfPresent(MgnClientTypes.JobLogEventData.self, forKey: .eventData)
        eventData = eventDataDecoded
    }
}

extension MgnClientTypes {
    /// Job log.
    public struct JobLog: Swift.Equatable {
        /// Job log event.
        public var event: MgnClientTypes.JobLogEvent?
        /// Job event data
        public var eventData: MgnClientTypes.JobLogEventData?
        /// Job log event date and time.
        public var logDateTime: Swift.String?

        public init (
            event: MgnClientTypes.JobLogEvent? = nil,
            eventData: MgnClientTypes.JobLogEventData? = nil,
            logDateTime: Swift.String? = nil
        )
        {
            self.event = event
            self.eventData = eventData
            self.logDateTime = logDateTime
        }
    }

}

extension MgnClientTypes {
    public enum JobLogEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cleanupEnd
        case cleanupFail
        case cleanupStart
        case conversionEnd
        case conversionFail
        case conversionStart
        case jobCancel
        case jobEnd
        case jobStart
        case launchFailed
        case launchStart
        case serverSkipped
        case snapshotEnd
        case snapshotFail
        case snapshotStart
        case usingPreviousSnapshot
        case sdkUnknown(Swift.String)

        public static var allCases: [JobLogEvent] {
            return [
                .cleanupEnd,
                .cleanupFail,
                .cleanupStart,
                .conversionEnd,
                .conversionFail,
                .conversionStart,
                .jobCancel,
                .jobEnd,
                .jobStart,
                .launchFailed,
                .launchStart,
                .serverSkipped,
                .snapshotEnd,
                .snapshotFail,
                .snapshotStart,
                .usingPreviousSnapshot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cleanupEnd: return "CLEANUP_END"
            case .cleanupFail: return "CLEANUP_FAIL"
            case .cleanupStart: return "CLEANUP_START"
            case .conversionEnd: return "CONVERSION_END"
            case .conversionFail: return "CONVERSION_FAIL"
            case .conversionStart: return "CONVERSION_START"
            case .jobCancel: return "JOB_CANCEL"
            case .jobEnd: return "JOB_END"
            case .jobStart: return "JOB_START"
            case .launchFailed: return "LAUNCH_FAILED"
            case .launchStart: return "LAUNCH_START"
            case .serverSkipped: return "SERVER_SKIPPED"
            case .snapshotEnd: return "SNAPSHOT_END"
            case .snapshotFail: return "SNAPSHOT_FAIL"
            case .snapshotStart: return "SNAPSHOT_START"
            case .usingPreviousSnapshot: return "USING_PREVIOUS_SNAPSHOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobLogEvent(rawValue: rawValue) ?? JobLogEvent.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.JobLogEventData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conversionServerID
        case rawError
        case sourceServerID
        case targetInstanceID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conversionServerID = self.conversionServerID {
            try encodeContainer.encode(conversionServerID, forKey: .conversionServerID)
        }
        if let rawError = self.rawError {
            try encodeContainer.encode(rawError, forKey: .rawError)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let targetInstanceID = self.targetInstanceID {
            try encodeContainer.encode(targetInstanceID, forKey: .targetInstanceID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let conversionServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conversionServerID)
        conversionServerID = conversionServerIDDecoded
        let targetInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetInstanceID)
        targetInstanceID = targetInstanceIDDecoded
        let rawErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rawError)
        rawError = rawErrorDecoded
    }
}

extension MgnClientTypes {
    /// Job log data
    public struct JobLogEventData: Swift.Equatable {
        /// Job Event conversion Server ID.
        public var conversionServerID: Swift.String?
        /// Job error.
        public var rawError: Swift.String?
        /// Job Event Source Server ID.
        public var sourceServerID: Swift.String?
        /// Job Event Target instance ID.
        public var targetInstanceID: Swift.String?

        public init (
            conversionServerID: Swift.String? = nil,
            rawError: Swift.String? = nil,
            sourceServerID: Swift.String? = nil,
            targetInstanceID: Swift.String? = nil
        )
        {
            self.conversionServerID = conversionServerID
            self.rawError = rawError
            self.sourceServerID = sourceServerID
            self.targetInstanceID = targetInstanceID
        }
    }

}

extension MgnClientTypes.JobPostLaunchActionsLaunchStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionID
        case executionStatus
        case failureReason
        case ssmDocument
        case ssmDocumentType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionID = self.executionID {
            try encodeContainer.encode(executionID, forKey: .executionID)
        }
        if let executionStatus = self.executionStatus {
            try encodeContainer.encode(executionStatus.rawValue, forKey: .executionStatus)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let ssmDocument = self.ssmDocument {
            try encodeContainer.encode(ssmDocument, forKey: .ssmDocument)
        }
        if let ssmDocumentType = self.ssmDocumentType {
            try encodeContainer.encode(ssmDocumentType.rawValue, forKey: .ssmDocumentType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ssmDocumentDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SsmDocument.self, forKey: .ssmDocument)
        ssmDocument = ssmDocumentDecoded
        let ssmDocumentTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SsmDocumentType.self, forKey: .ssmDocumentType)
        ssmDocumentType = ssmDocumentTypeDecoded
        let executionIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionID)
        executionID = executionIDDecoded
        let executionStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActionExecutionStatus.self, forKey: .executionStatus)
        executionStatus = executionStatusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension MgnClientTypes {
    /// Launch Status of the Job Post Launch Actions.
    public struct JobPostLaunchActionsLaunchStatus: Swift.Equatable {
        /// AWS Systems Manager Document's execution ID of the of the Job Post Launch Actions.
        public var executionID: Swift.String?
        /// AWS Systems Manager Document's execution status.
        public var executionStatus: MgnClientTypes.PostLaunchActionExecutionStatus?
        /// AWS Systems Manager Document's failure reason.
        public var failureReason: Swift.String?
        /// AWS Systems Manager's Document of the of the Job Post Launch Actions.
        public var ssmDocument: MgnClientTypes.SsmDocument?
        /// AWS Systems Manager Document type.
        public var ssmDocumentType: MgnClientTypes.SsmDocumentType?

        public init (
            executionID: Swift.String? = nil,
            executionStatus: MgnClientTypes.PostLaunchActionExecutionStatus? = nil,
            failureReason: Swift.String? = nil,
            ssmDocument: MgnClientTypes.SsmDocument? = nil,
            ssmDocumentType: MgnClientTypes.SsmDocumentType? = nil
        )
        {
            self.executionID = executionID
            self.executionStatus = executionStatus
            self.failureReason = failureReason
            self.ssmDocument = ssmDocument
            self.ssmDocumentType = ssmDocumentType
        }
    }

}

extension MgnClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case pending
        case started
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .completed,
                .pending,
                .started,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .pending: return "PENDING"
            case .started: return "STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum JobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case launch
        case terminate
        case sdkUnknown(Swift.String)

        public static var allCases: [JobType] {
            return [
                .launch,
                .terminate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .launch: return "LAUNCH"
            case .terminate: return "TERMINATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobType(rawValue: rawValue) ?? JobType.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.LaunchConfigurationTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associatePublicIpAddress
        case bootMode
        case copyPrivateIp
        case copyTags
        case ec2LaunchTemplateID
        case enableMapAutoTagging
        case largeVolumeConf
        case launchConfigurationTemplateID
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case postLaunchActions
        case smallVolumeConf
        case smallVolumeMaxSize
        case tags
        case targetInstanceTypeRightSizingMethod
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let associatePublicIpAddress = self.associatePublicIpAddress {
            try encodeContainer.encode(associatePublicIpAddress, forKey: .associatePublicIpAddress)
        }
        if let bootMode = self.bootMode {
            try encodeContainer.encode(bootMode.rawValue, forKey: .bootMode)
        }
        if let copyPrivateIp = self.copyPrivateIp {
            try encodeContainer.encode(copyPrivateIp, forKey: .copyPrivateIp)
        }
        if let copyTags = self.copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let ec2LaunchTemplateID = self.ec2LaunchTemplateID {
            try encodeContainer.encode(ec2LaunchTemplateID, forKey: .ec2LaunchTemplateID)
        }
        if let enableMapAutoTagging = self.enableMapAutoTagging {
            try encodeContainer.encode(enableMapAutoTagging, forKey: .enableMapAutoTagging)
        }
        if let largeVolumeConf = self.largeVolumeConf {
            try encodeContainer.encode(largeVolumeConf, forKey: .largeVolumeConf)
        }
        if let launchConfigurationTemplateID = self.launchConfigurationTemplateID {
            try encodeContainer.encode(launchConfigurationTemplateID, forKey: .launchConfigurationTemplateID)
        }
        if let launchDisposition = self.launchDisposition {
            try encodeContainer.encode(launchDisposition.rawValue, forKey: .launchDisposition)
        }
        if let licensing = self.licensing {
            try encodeContainer.encode(licensing, forKey: .licensing)
        }
        if let mapAutoTaggingMpeID = self.mapAutoTaggingMpeID {
            try encodeContainer.encode(mapAutoTaggingMpeID, forKey: .mapAutoTaggingMpeID)
        }
        if let postLaunchActions = self.postLaunchActions {
            try encodeContainer.encode(postLaunchActions, forKey: .postLaunchActions)
        }
        if let smallVolumeConf = self.smallVolumeConf {
            try encodeContainer.encode(smallVolumeConf, forKey: .smallVolumeConf)
        }
        if smallVolumeMaxSize != 0 {
            try encodeContainer.encode(smallVolumeMaxSize, forKey: .smallVolumeMaxSize)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetInstanceTypeRightSizingMethod = self.targetInstanceTypeRightSizingMethod {
            try encodeContainer.encode(targetInstanceTypeRightSizingMethod.rawValue, forKey: .targetInstanceTypeRightSizingMethod)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationTemplateID)
        launchConfigurationTemplateID = launchConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let postLaunchActionsDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActions.self, forKey: .postLaunchActions)
        postLaunchActions = postLaunchActionsDecoded
        let enableMapAutoTaggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMapAutoTagging)
        enableMapAutoTagging = enableMapAutoTaggingDecoded
        let mapAutoTaggingMpeIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapAutoTaggingMpeID)
        mapAutoTaggingMpeID = mapAutoTaggingMpeIDDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let ec2LaunchTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2LaunchTemplateID)
        ec2LaunchTemplateID = ec2LaunchTemplateIDDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(MgnClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let associatePublicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associatePublicIpAddress)
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let bootModeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.BootMode.self, forKey: .bootMode)
        bootMode = bootModeDecoded
        let smallVolumeMaxSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .smallVolumeMaxSize) ?? 0
        smallVolumeMaxSize = smallVolumeMaxSizeDecoded
        let smallVolumeConfDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchTemplateDiskConf.self, forKey: .smallVolumeConf)
        smallVolumeConf = smallVolumeConfDecoded
        let largeVolumeConfDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchTemplateDiskConf.self, forKey: .largeVolumeConf)
        largeVolumeConf = largeVolumeConfDecoded
    }
}

extension MgnClientTypes.LaunchConfigurationTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchConfigurationTemplate(arn: \(Swift.String(describing: arn)), associatePublicIpAddress: \(Swift.String(describing: associatePublicIpAddress)), bootMode: \(Swift.String(describing: bootMode)), copyPrivateIp: \(Swift.String(describing: copyPrivateIp)), copyTags: \(Swift.String(describing: copyTags)), ec2LaunchTemplateID: \(Swift.String(describing: ec2LaunchTemplateID)), enableMapAutoTagging: \(Swift.String(describing: enableMapAutoTagging)), largeVolumeConf: \(Swift.String(describing: largeVolumeConf)), launchConfigurationTemplateID: \(Swift.String(describing: launchConfigurationTemplateID)), launchDisposition: \(Swift.String(describing: launchDisposition)), licensing: \(Swift.String(describing: licensing)), mapAutoTaggingMpeID: \(Swift.String(describing: mapAutoTaggingMpeID)), postLaunchActions: \(Swift.String(describing: postLaunchActions)), smallVolumeConf: \(Swift.String(describing: smallVolumeConf)), smallVolumeMaxSize: \(Swift.String(describing: smallVolumeMaxSize)), targetInstanceTypeRightSizingMethod: \(Swift.String(describing: targetInstanceTypeRightSizingMethod)), tags: \"CONTENT_REDACTED\")"}
}

extension MgnClientTypes {
    public struct LaunchConfigurationTemplate: Swift.Equatable {
        /// ARN of the Launch Configuration Template.
        public var arn: Swift.String?
        /// Associate public Ip address.
        public var associatePublicIpAddress: Swift.Bool?
        /// Launch configuration template boot mode.
        public var bootMode: MgnClientTypes.BootMode?
        /// Copy private Ip.
        public var copyPrivateIp: Swift.Bool?
        /// Copy tags.
        public var copyTags: Swift.Bool?
        /// EC2 launch template ID.
        public var ec2LaunchTemplateID: Swift.String?
        /// Enable map auto tagging.
        public var enableMapAutoTagging: Swift.Bool?
        /// Large volume config.
        public var largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
        /// ID of the Launch Configuration Template.
        /// This member is required.
        public var launchConfigurationTemplateID: Swift.String?
        /// Launch disposition.
        public var launchDisposition: MgnClientTypes.LaunchDisposition?
        /// Configure Licensing.
        public var licensing: MgnClientTypes.Licensing?
        /// Launch configuration template map auto tagging MPE ID.
        public var mapAutoTaggingMpeID: Swift.String?
        /// Post Launch Actions of the Launch Configuration Template.
        public var postLaunchActions: MgnClientTypes.PostLaunchActions?
        /// Small volume config.
        public var smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
        /// Small volume maximum size.
        public var smallVolumeMaxSize: Swift.Int
        /// Tags of the Launch Configuration Template.
        public var tags: [Swift.String:Swift.String]?
        /// Target instance type right-sizing method.
        public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

        public init (
            arn: Swift.String? = nil,
            associatePublicIpAddress: Swift.Bool? = nil,
            bootMode: MgnClientTypes.BootMode? = nil,
            copyPrivateIp: Swift.Bool? = nil,
            copyTags: Swift.Bool? = nil,
            ec2LaunchTemplateID: Swift.String? = nil,
            enableMapAutoTagging: Swift.Bool? = nil,
            largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
            launchConfigurationTemplateID: Swift.String? = nil,
            launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
            licensing: MgnClientTypes.Licensing? = nil,
            mapAutoTaggingMpeID: Swift.String? = nil,
            postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
            smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
            smallVolumeMaxSize: Swift.Int = 0,
            tags: [Swift.String:Swift.String]? = nil,
            targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
        )
        {
            self.arn = arn
            self.associatePublicIpAddress = associatePublicIpAddress
            self.bootMode = bootMode
            self.copyPrivateIp = copyPrivateIp
            self.copyTags = copyTags
            self.ec2LaunchTemplateID = ec2LaunchTemplateID
            self.enableMapAutoTagging = enableMapAutoTagging
            self.largeVolumeConf = largeVolumeConf
            self.launchConfigurationTemplateID = launchConfigurationTemplateID
            self.launchDisposition = launchDisposition
            self.licensing = licensing
            self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
            self.postLaunchActions = postLaunchActions
            self.smallVolumeConf = smallVolumeConf
            self.smallVolumeMaxSize = smallVolumeMaxSize
            self.tags = tags
            self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
        }
    }

}

extension MgnClientTypes {
    public enum LaunchDisposition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case started
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchDisposition] {
            return [
                .started,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchDisposition(rawValue: rawValue) ?? LaunchDisposition.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum LaunchStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case launched
        case pending
        case terminated
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchStatus] {
            return [
                .failed,
                .inProgress,
                .launched,
                .pending,
                .terminated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .launched: return "LAUNCHED"
            case .pending: return "PENDING"
            case .terminated: return "TERMINATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchStatus(rawValue: rawValue) ?? LaunchStatus.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.LaunchTemplateDiskConf: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iops
        case throughput
        case volumeType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if iops != 0 {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if throughput != 0 {
            try encodeContainer.encode(throughput, forKey: .throughput)
        }
        if let volumeType = self.volumeType {
            try encodeContainer.encode(volumeType.rawValue, forKey: .volumeType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.VolumeType.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops) ?? 0
        iops = iopsDecoded
        let throughputDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .throughput) ?? 0
        throughput = throughputDecoded
    }
}

extension MgnClientTypes {
    /// Launch template disk configuration.
    public struct LaunchTemplateDiskConf: Swift.Equatable {
        /// Launch template disk iops configuration.
        public var iops: Swift.Int
        /// Launch template disk throughput configuration.
        public var throughput: Swift.Int
        /// Launch template disk volume type configuration.
        public var volumeType: MgnClientTypes.VolumeType?

        public init (
            iops: Swift.Int = 0,
            throughput: Swift.Int = 0,
            volumeType: MgnClientTypes.VolumeType? = nil
        )
        {
            self.iops = iops
            self.throughput = throughput
            self.volumeType = volumeType
        }
    }

}

extension MgnClientTypes.LaunchedInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2InstanceID
        case firstBoot
        case jobID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2InstanceID = self.ec2InstanceID {
            try encodeContainer.encode(ec2InstanceID, forKey: .ec2InstanceID)
        }
        if let firstBoot = self.firstBoot {
            try encodeContainer.encode(firstBoot.rawValue, forKey: .firstBoot)
        }
        if let jobID = self.jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2InstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceID)
        ec2InstanceID = ec2InstanceIDDecoded
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let firstBootDecoded = try containerValues.decodeIfPresent(MgnClientTypes.FirstBoot.self, forKey: .firstBoot)
        firstBoot = firstBootDecoded
    }
}

extension MgnClientTypes {
    /// Launched instance.
    public struct LaunchedInstance: Swift.Equatable {
        /// Launched instance EC2 ID.
        public var ec2InstanceID: Swift.String?
        /// Launched instance first boot.
        public var firstBoot: MgnClientTypes.FirstBoot?
        /// Launched instance Job ID.
        public var jobID: Swift.String?

        public init (
            ec2InstanceID: Swift.String? = nil,
            firstBoot: MgnClientTypes.FirstBoot? = nil,
            jobID: Swift.String? = nil
        )
        {
            self.ec2InstanceID = ec2InstanceID
            self.firstBoot = firstBoot
            self.jobID = jobID
        }
    }

}

extension MgnClientTypes.Licensing: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case osByol
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let osByol = self.osByol {
            try encodeContainer.encode(osByol, forKey: .osByol)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let osByolDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .osByol)
        osByol = osByolDecoded
    }
}

extension MgnClientTypes {
    /// Configure Licensing.
    public struct Licensing: Swift.Equatable {
        /// Configure BYOL OS licensing.
        public var osByol: Swift.Bool?

        public init (
            osByol: Swift.Bool? = nil
        )
        {
            self.osByol = osByol
        }
    }

}

extension MgnClientTypes.LifeCycle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addedToServiceDateTime
        case elapsedReplicationDuration
        case firstByteDateTime
        case lastCutover
        case lastSeenByServiceDateTime
        case lastTest
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addedToServiceDateTime = self.addedToServiceDateTime {
            try encodeContainer.encode(addedToServiceDateTime, forKey: .addedToServiceDateTime)
        }
        if let elapsedReplicationDuration = self.elapsedReplicationDuration {
            try encodeContainer.encode(elapsedReplicationDuration, forKey: .elapsedReplicationDuration)
        }
        if let firstByteDateTime = self.firstByteDateTime {
            try encodeContainer.encode(firstByteDateTime, forKey: .firstByteDateTime)
        }
        if let lastCutover = self.lastCutover {
            try encodeContainer.encode(lastCutover, forKey: .lastCutover)
        }
        if let lastSeenByServiceDateTime = self.lastSeenByServiceDateTime {
            try encodeContainer.encode(lastSeenByServiceDateTime, forKey: .lastSeenByServiceDateTime)
        }
        if let lastTest = self.lastTest {
            try encodeContainer.encode(lastTest, forKey: .lastTest)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addedToServiceDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addedToServiceDateTime)
        addedToServiceDateTime = addedToServiceDateTimeDecoded
        let firstByteDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstByteDateTime)
        firstByteDateTime = firstByteDateTimeDecoded
        let elapsedReplicationDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elapsedReplicationDuration)
        elapsedReplicationDuration = elapsedReplicationDurationDecoded
        let lastSeenByServiceDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSeenByServiceDateTime)
        lastSeenByServiceDateTime = lastSeenByServiceDateTimeDecoded
        let lastTestDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastTest.self, forKey: .lastTest)
        lastTest = lastTestDecoded
        let lastCutoverDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastCutover.self, forKey: .lastCutover)
        lastCutover = lastCutoverDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleState.self, forKey: .state)
        state = stateDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle.
    public struct LifeCycle: Swift.Equatable {
        /// Lifecycle added to service data and time.
        public var addedToServiceDateTime: Swift.String?
        /// Lifecycle elapsed time and duration.
        public var elapsedReplicationDuration: Swift.String?
        /// Lifecycle replication initiation date and time.
        public var firstByteDateTime: Swift.String?
        /// Lifecycle last Cutover.
        public var lastCutover: MgnClientTypes.LifeCycleLastCutover?
        /// Lifecycle last seen date and time.
        public var lastSeenByServiceDateTime: Swift.String?
        /// Lifecycle last Test.
        public var lastTest: MgnClientTypes.LifeCycleLastTest?
        /// Lifecycle state.
        public var state: MgnClientTypes.LifeCycleState?

        public init (
            addedToServiceDateTime: Swift.String? = nil,
            elapsedReplicationDuration: Swift.String? = nil,
            firstByteDateTime: Swift.String? = nil,
            lastCutover: MgnClientTypes.LifeCycleLastCutover? = nil,
            lastSeenByServiceDateTime: Swift.String? = nil,
            lastTest: MgnClientTypes.LifeCycleLastTest? = nil,
            state: MgnClientTypes.LifeCycleState? = nil
        )
        {
            self.addedToServiceDateTime = addedToServiceDateTime
            self.elapsedReplicationDuration = elapsedReplicationDuration
            self.firstByteDateTime = firstByteDateTime
            self.lastCutover = lastCutover
            self.lastSeenByServiceDateTime = lastSeenByServiceDateTime
            self.lastTest = lastTest
            self.state = state
        }
    }

}

extension MgnClientTypes.LifeCycleLastCutover: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case finalized
        case initiated
        case reverted
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let finalized = self.finalized {
            try encodeContainer.encode(finalized, forKey: .finalized)
        }
        if let initiated = self.initiated {
            try encodeContainer.encode(initiated, forKey: .initiated)
        }
        if let reverted = self.reverted {
            try encodeContainer.encode(reverted, forKey: .reverted)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initiatedDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastCutoverInitiated.self, forKey: .initiated)
        initiated = initiatedDecoded
        let revertedDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastCutoverReverted.self, forKey: .reverted)
        reverted = revertedDecoded
        let finalizedDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastCutoverFinalized.self, forKey: .finalized)
        finalized = finalizedDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle last Cutover .
    public struct LifeCycleLastCutover: Swift.Equatable {
        /// Lifecycle Cutover finalized date and time.
        public var finalized: MgnClientTypes.LifeCycleLastCutoverFinalized?
        /// Lifecycle last Cutover initiated.
        public var initiated: MgnClientTypes.LifeCycleLastCutoverInitiated?
        /// Lifecycle last Cutover reverted.
        public var reverted: MgnClientTypes.LifeCycleLastCutoverReverted?

        public init (
            finalized: MgnClientTypes.LifeCycleLastCutoverFinalized? = nil,
            initiated: MgnClientTypes.LifeCycleLastCutoverInitiated? = nil,
            reverted: MgnClientTypes.LifeCycleLastCutoverReverted? = nil
        )
        {
            self.finalized = finalized
            self.initiated = initiated
            self.reverted = reverted
        }
    }

}

extension MgnClientTypes.LifeCycleLastCutoverFinalized: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCallDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = self.apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle Cutover finalized
    public struct LifeCycleLastCutoverFinalized: Swift.Equatable {
        /// Lifecycle Cutover finalized date and time.
        public var apiCallDateTime: Swift.String?

        public init (
            apiCallDateTime: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
        }
    }

}

extension MgnClientTypes.LifeCycleLastCutoverInitiated: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCallDateTime
        case jobID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = self.apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
        if let jobID = self.jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle last Cutover initiated.
    public struct LifeCycleLastCutoverInitiated: Swift.Equatable {
        ///
        public var apiCallDateTime: Swift.String?
        /// Lifecycle last Cutover initiated by Job ID.
        public var jobID: Swift.String?

        public init (
            apiCallDateTime: Swift.String? = nil,
            jobID: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
            self.jobID = jobID
        }
    }

}

extension MgnClientTypes.LifeCycleLastCutoverReverted: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCallDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = self.apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle last Cutover reverted.
    public struct LifeCycleLastCutoverReverted: Swift.Equatable {
        /// Lifecycle last Cutover reverted API call date time.
        public var apiCallDateTime: Swift.String?

        public init (
            apiCallDateTime: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
        }
    }

}

extension MgnClientTypes.LifeCycleLastTest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case finalized
        case initiated
        case reverted
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let finalized = self.finalized {
            try encodeContainer.encode(finalized, forKey: .finalized)
        }
        if let initiated = self.initiated {
            try encodeContainer.encode(initiated, forKey: .initiated)
        }
        if let reverted = self.reverted {
            try encodeContainer.encode(reverted, forKey: .reverted)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initiatedDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastTestInitiated.self, forKey: .initiated)
        initiated = initiatedDecoded
        let revertedDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastTestReverted.self, forKey: .reverted)
        reverted = revertedDecoded
        let finalizedDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastTestFinalized.self, forKey: .finalized)
        finalized = finalizedDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle last Test.
    public struct LifeCycleLastTest: Swift.Equatable {
        /// Lifecycle last Test finalized.
        public var finalized: MgnClientTypes.LifeCycleLastTestFinalized?
        /// Lifecycle last Test initiated.
        public var initiated: MgnClientTypes.LifeCycleLastTestInitiated?
        /// Lifecycle last Test reverted.
        public var reverted: MgnClientTypes.LifeCycleLastTestReverted?

        public init (
            finalized: MgnClientTypes.LifeCycleLastTestFinalized? = nil,
            initiated: MgnClientTypes.LifeCycleLastTestInitiated? = nil,
            reverted: MgnClientTypes.LifeCycleLastTestReverted? = nil
        )
        {
            self.finalized = finalized
            self.initiated = initiated
            self.reverted = reverted
        }
    }

}

extension MgnClientTypes.LifeCycleLastTestFinalized: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCallDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = self.apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle last Test finalized.
    public struct LifeCycleLastTestFinalized: Swift.Equatable {
        /// Lifecycle Test failed API call date and time.
        public var apiCallDateTime: Swift.String?

        public init (
            apiCallDateTime: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
        }
    }

}

extension MgnClientTypes.LifeCycleLastTestInitiated: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCallDateTime
        case jobID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = self.apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
        if let jobID = self.jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle last Test initiated.
    public struct LifeCycleLastTestInitiated: Swift.Equatable {
        /// Lifecycle last Test initiated API call date and time.
        public var apiCallDateTime: Swift.String?
        /// Lifecycle last Test initiated Job ID.
        public var jobID: Swift.String?

        public init (
            apiCallDateTime: Swift.String? = nil,
            jobID: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
            self.jobID = jobID
        }
    }

}

extension MgnClientTypes.LifeCycleLastTestReverted: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCallDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = self.apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle last Test reverted.
    public struct LifeCycleLastTestReverted: Swift.Equatable {
        /// Lifecycle last Test reverted API call date and time.
        public var apiCallDateTime: Swift.String?

        public init (
            apiCallDateTime: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
        }
    }

}

extension MgnClientTypes {
    public enum LifeCycleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cutover
        case cuttingOver
        case disconnected
        case discovered
        case notReady
        case readyForCutover
        case readyForTest
        case stopped
        case testing
        case sdkUnknown(Swift.String)

        public static var allCases: [LifeCycleState] {
            return [
                .cutover,
                .cuttingOver,
                .disconnected,
                .discovered,
                .notReady,
                .readyForCutover,
                .readyForTest,
                .stopped,
                .testing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cutover: return "CUTOVER"
            case .cuttingOver: return "CUTTING_OVER"
            case .disconnected: return "DISCONNECTED"
            case .discovered: return "DISCOVERED"
            case .notReady: return "NOT_READY"
            case .readyForCutover: return "READY_FOR_CUTOVER"
            case .readyForTest: return "READY_FOR_TEST"
            case .stopped: return "STOPPED"
            case .testing: return "TESTING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LifeCycleState(rawValue: rawValue) ?? LifeCycleState.sdkUnknown(rawValue)
        }
    }
}

extension ListApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApplicationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListApplications"
    }
}

public struct ListApplicationsInput: Swift.Equatable {
    /// Applications list filters.
    public var filters: MgnClientTypes.ListApplicationsRequestFilters?
    /// Maximum results to return when listing applications.
    public var maxResults: Swift.Int
    /// Request next token.
    public var nextToken: Swift.String?

    public init (
        filters: MgnClientTypes.ListApplicationsRequestFilters? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
    let filters: MgnClientTypes.ListApplicationsRequestFilters?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension ListApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ListApplicationsRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListApplicationsOutputError: Swift.Error, Swift.Equatable {
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutputResponse: Swift.Equatable {
    /// Applications list.
    public var items: [MgnClientTypes.Application]?
    /// Response next token.
    public var nextToken: Swift.String?

    public init (
        items: [MgnClientTypes.Application]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputResponseBody: Swift.Equatable {
    let items: [MgnClientTypes.Application]?
    let nextToken: Swift.String?
}

extension ListApplicationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.Application?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.Application]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.Application]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MgnClientTypes.ListApplicationsRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationIDs
        case isArchived
        case waveIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationIDs = applicationIDs {
            var applicationIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationIDs)
            for applicationid0 in applicationIDs {
                try applicationIDsContainer.encode(applicationid0)
            }
        }
        if let isArchived = self.isArchived {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let waveIDs = waveIDs {
            var waveIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .waveIDs)
            for waveid0 in waveIDs {
                try waveIDsContainer.encode(waveid0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .applicationIDs)
        var applicationIDsDecoded0:[Swift.String]? = nil
        if let applicationIDsContainer = applicationIDsContainer {
            applicationIDsDecoded0 = [Swift.String]()
            for string0 in applicationIDsContainer {
                if let string0 = string0 {
                    applicationIDsDecoded0?.append(string0)
                }
            }
        }
        applicationIDs = applicationIDsDecoded0
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let waveIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .waveIDs)
        var waveIDsDecoded0:[Swift.String]? = nil
        if let waveIDsContainer = waveIDsContainer {
            waveIDsDecoded0 = [Swift.String]()
            for string0 in waveIDsContainer {
                if let string0 = string0 {
                    waveIDsDecoded0?.append(string0)
                }
            }
        }
        waveIDs = waveIDsDecoded0
    }
}

extension MgnClientTypes {
    /// Applications list filters.
    public struct ListApplicationsRequestFilters: Swift.Equatable {
        /// Filter applications list by application ID.
        public var applicationIDs: [Swift.String]?
        /// Filter applications list by archival status.
        public var isArchived: Swift.Bool?
        /// Filter applications list by wave ID.
        public var waveIDs: [Swift.String]?

        public init (
            applicationIDs: [Swift.String]? = nil,
            isArchived: Swift.Bool? = nil,
            waveIDs: [Swift.String]? = nil
        )
        {
            self.applicationIDs = applicationIDs
            self.isArchived = isArchived
            self.waveIDs = waveIDs
        }
    }

}

extension ListSourceServerActionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension ListSourceServerActionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListSourceServerActions"
    }
}

public struct ListSourceServerActionsInput: Swift.Equatable {
    /// Filters to apply when listing source server post migration custom actions.
    public var filters: MgnClientTypes.SourceServerActionsRequestFilters?
    /// Maximum amount of items to return when listing source server post migration custom actions.
    public var maxResults: Swift.Int
    /// Next token to use when listing source server post migration custom actions.
    public var nextToken: Swift.String?
    /// Source server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        filters: MgnClientTypes.SourceServerActionsRequestFilters? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sourceServerID = sourceServerID
    }
}

struct ListSourceServerActionsInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let filters: MgnClientTypes.SourceServerActionsRequestFilters?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension ListSourceServerActionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceServerActionsRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSourceServerActionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSourceServerActionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSourceServerActionsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSourceServerActionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSourceServerActionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListSourceServerActionsOutputResponse: Swift.Equatable {
    /// List of source server post migration custom actions.
    public var items: [MgnClientTypes.SourceServerActionDocument]?
    /// Next token returned when listing source server post migration custom actions.
    public var nextToken: Swift.String?

    public init (
        items: [MgnClientTypes.SourceServerActionDocument]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListSourceServerActionsOutputResponseBody: Swift.Equatable {
    let items: [MgnClientTypes.SourceServerActionDocument]?
    let nextToken: Swift.String?
}

extension ListSourceServerActionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.SourceServerActionDocument?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.SourceServerActionDocument]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.SourceServerActionDocument]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// List tags for resource request by ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \"CONTENT_REDACTED\")"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// List tags for resource response.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTemplateActionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case launchConfigurationTemplateID
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let launchConfigurationTemplateID = self.launchConfigurationTemplateID {
            try encodeContainer.encode(launchConfigurationTemplateID, forKey: .launchConfigurationTemplateID)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTemplateActionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListTemplateActions"
    }
}

public struct ListTemplateActionsInput: Swift.Equatable {
    /// Filters to apply when listing template post migration custom actions.
    public var filters: MgnClientTypes.TemplateActionsRequestFilters?
    /// Launch configuration template ID.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?
    /// Maximum amount of items to return when listing template post migration custom actions.
    public var maxResults: Swift.Int
    /// Next token to use when listing template post migration custom actions.
    public var nextToken: Swift.String?

    public init (
        filters: MgnClientTypes.TemplateActionsRequestFilters? = nil,
        launchConfigurationTemplateID: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTemplateActionsInputBody: Swift.Equatable {
    let launchConfigurationTemplateID: Swift.String?
    let filters: MgnClientTypes.TemplateActionsRequestFilters?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension ListTemplateActionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case launchConfigurationTemplateID
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationTemplateID)
        launchConfigurationTemplateID = launchConfigurationTemplateIDDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(MgnClientTypes.TemplateActionsRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTemplateActionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTemplateActionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTemplateActionsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTemplateActionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTemplateActionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListTemplateActionsOutputResponse: Swift.Equatable {
    /// List of template post migration custom actions.
    public var items: [MgnClientTypes.TemplateActionDocument]?
    /// Next token returned when listing template post migration custom actions.
    public var nextToken: Swift.String?

    public init (
        items: [MgnClientTypes.TemplateActionDocument]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListTemplateActionsOutputResponseBody: Swift.Equatable {
    let items: [MgnClientTypes.TemplateActionDocument]?
    let nextToken: Swift.String?
}

extension ListTemplateActionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.TemplateActionDocument?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.TemplateActionDocument]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.TemplateActionDocument]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWavesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListWavesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListWaves"
    }
}

public struct ListWavesInput: Swift.Equatable {
    /// Waves list filters.
    public var filters: MgnClientTypes.ListWavesRequestFilters?
    /// Maximum results to return when listing waves.
    public var maxResults: Swift.Int
    /// Request next token.
    public var nextToken: Swift.String?

    public init (
        filters: MgnClientTypes.ListWavesRequestFilters? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWavesInputBody: Swift.Equatable {
    let filters: MgnClientTypes.ListWavesRequestFilters?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension ListWavesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ListWavesRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListWavesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWavesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListWavesOutputError: Swift.Error, Swift.Equatable {
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWavesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListWavesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListWavesOutputResponse: Swift.Equatable {
    /// Waves list.
    public var items: [MgnClientTypes.Wave]?
    /// Response next token.
    public var nextToken: Swift.String?

    public init (
        items: [MgnClientTypes.Wave]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListWavesOutputResponseBody: Swift.Equatable {
    let items: [MgnClientTypes.Wave]?
    let nextToken: Swift.String?
}

extension ListWavesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.Wave?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.Wave]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.Wave]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MgnClientTypes.ListWavesRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isArchived
        case waveIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isArchived = self.isArchived {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let waveIDs = waveIDs {
            var waveIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .waveIDs)
            for waveid0 in waveIDs {
                try waveIDsContainer.encode(waveid0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .waveIDs)
        var waveIDsDecoded0:[Swift.String]? = nil
        if let waveIDsContainer = waveIDsContainer {
            waveIDsDecoded0 = [Swift.String]()
            for string0 in waveIDsContainer {
                if let string0 = string0 {
                    waveIDsDecoded0?.append(string0)
                }
            }
        }
        waveIDs = waveIDsDecoded0
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
    }
}

extension MgnClientTypes {
    /// Waves list filters.
    public struct ListWavesRequestFilters: Swift.Equatable {
        /// Filter waves list by archival status.
        public var isArchived: Swift.Bool?
        /// Filter waves list by wave ID.
        public var waveIDs: [Swift.String]?

        public init (
            isArchived: Swift.Bool? = nil,
            waveIDs: [Swift.String]? = nil
        )
        {
            self.isArchived = isArchived
            self.waveIDs = waveIDs
        }
    }

}

extension MarkAsArchivedInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension MarkAsArchivedInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/MarkAsArchived"
    }
}

public struct MarkAsArchivedInput: Swift.Equatable {
    /// Mark as archived by Source Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct MarkAsArchivedInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension MarkAsArchivedInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension MarkAsArchivedOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MarkAsArchivedOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum MarkAsArchivedOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MarkAsArchivedOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MarkAsArchivedOutputResponse(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

extension MarkAsArchivedOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: MarkAsArchivedOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.applicationID = nil
            self.arn = nil
            self.dataReplicationInfo = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.vcenterClientID = nil
        }
    }
}

public struct MarkAsArchivedOutputResponse: Swift.Equatable {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init (
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.vcenterClientID = vcenterClientID
    }
}

struct MarkAsArchivedOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
    let applicationID: Swift.String?
}

extension MarkAsArchivedOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case vcenterClientID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
    }
}

extension MgnClientTypes.NetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ips
        case isPrimary
        case macAddress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ips = ips {
            var ipsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ips)
            for boundedstring0 in ips {
                try ipsContainer.encode(boundedstring0)
            }
        }
        if let isPrimary = self.isPrimary {
            try encodeContainer.encode(isPrimary, forKey: .isPrimary)
        }
        if let macAddress = self.macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let macAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let ipsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ips)
        var ipsDecoded0:[Swift.String]? = nil
        if let ipsContainer = ipsContainer {
            ipsDecoded0 = [Swift.String]()
            for string0 in ipsContainer {
                if let string0 = string0 {
                    ipsDecoded0?.append(string0)
                }
            }
        }
        ips = ipsDecoded0
        let isPrimaryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPrimary)
        isPrimary = isPrimaryDecoded
    }
}

extension MgnClientTypes {
    /// Network interface.
    public struct NetworkInterface: Swift.Equatable {
        /// Network interface IPs.
        public var ips: [Swift.String]?
        /// Network interface primary IP.
        public var isPrimary: Swift.Bool?
        /// Network interface Mac address.
        public var macAddress: Swift.String?

        public init (
            ips: [Swift.String]? = nil,
            isPrimary: Swift.Bool? = nil,
            macAddress: Swift.String? = nil
        )
        {
            self.ips = ips
            self.isPrimary = isPrimary
            self.macAddress = macAddress
        }
    }

}

extension MgnClientTypes.OS: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fullString
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fullString = self.fullString {
            try encodeContainer.encode(fullString, forKey: .fullString)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fullString)
        fullString = fullStringDecoded
    }
}

extension MgnClientTypes {
    /// Operating System.
    public struct OS: Swift.Equatable {
        /// OS full string.
        public var fullString: Swift.String?

        public init (
            fullString: Swift.String? = nil
        )
        {
            self.fullString = fullString
        }
    }

}

extension MgnClientTypes.ParticipatingServer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchStatus
        case launchedEc2InstanceID
        case postLaunchActionsStatus
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchStatus = self.launchStatus {
            try encodeContainer.encode(launchStatus.rawValue, forKey: .launchStatus)
        }
        if let launchedEc2InstanceID = self.launchedEc2InstanceID {
            try encodeContainer.encode(launchedEc2InstanceID, forKey: .launchedEc2InstanceID)
        }
        if let postLaunchActionsStatus = self.postLaunchActionsStatus {
            try encodeContainer.encode(postLaunchActionsStatus, forKey: .postLaunchActionsStatus)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let launchStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchStatus.self, forKey: .launchStatus)
        launchStatus = launchStatusDecoded
        let launchedEc2InstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchedEc2InstanceID)
        launchedEc2InstanceID = launchedEc2InstanceIDDecoded
        let postLaunchActionsStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActionsStatus.self, forKey: .postLaunchActionsStatus)
        postLaunchActionsStatus = postLaunchActionsStatusDecoded
    }
}

extension MgnClientTypes {
    /// Server participating in Job.
    public struct ParticipatingServer: Swift.Equatable {
        /// Participating server launch status.
        public var launchStatus: MgnClientTypes.LaunchStatus?
        /// Participating server's launched ec2 instance ID.
        public var launchedEc2InstanceID: Swift.String?
        /// Participating server's Post Launch Actions Status.
        public var postLaunchActionsStatus: MgnClientTypes.PostLaunchActionsStatus?
        /// Participating server Source Server ID.
        /// This member is required.
        public var sourceServerID: Swift.String?

        public init (
            launchStatus: MgnClientTypes.LaunchStatus? = nil,
            launchedEc2InstanceID: Swift.String? = nil,
            postLaunchActionsStatus: MgnClientTypes.PostLaunchActionsStatus? = nil,
            sourceServerID: Swift.String? = nil
        )
        {
            self.launchStatus = launchStatus
            self.launchedEc2InstanceID = launchedEc2InstanceID
            self.postLaunchActionsStatus = postLaunchActionsStatus
            self.sourceServerID = sourceServerID
        }
    }

}

extension MgnClientTypes {
    public enum PostLaunchActionExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [PostLaunchActionExecutionStatus] {
            return [
                .failed,
                .inProgress,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PostLaunchActionExecutionStatus(rawValue: rawValue) ?? PostLaunchActionExecutionStatus.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.PostLaunchActions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudWatchLogGroupName
        case deployment
        case s3LogBucket
        case s3OutputKeyPrefix
        case ssmDocuments
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogGroupName = self.cloudWatchLogGroupName {
            try encodeContainer.encode(cloudWatchLogGroupName, forKey: .cloudWatchLogGroupName)
        }
        if let deployment = self.deployment {
            try encodeContainer.encode(deployment.rawValue, forKey: .deployment)
        }
        if let s3LogBucket = self.s3LogBucket {
            try encodeContainer.encode(s3LogBucket, forKey: .s3LogBucket)
        }
        if let s3OutputKeyPrefix = self.s3OutputKeyPrefix {
            try encodeContainer.encode(s3OutputKeyPrefix, forKey: .s3OutputKeyPrefix)
        }
        if let ssmDocuments = ssmDocuments {
            var ssmDocumentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ssmDocuments)
            for ssmdocument0 in ssmDocuments {
                try ssmDocumentsContainer.encode(ssmdocument0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActionsDeploymentType.self, forKey: .deployment)
        deployment = deploymentDecoded
        let s3LogBucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3LogBucket)
        s3LogBucket = s3LogBucketDecoded
        let s3OutputKeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3OutputKeyPrefix)
        s3OutputKeyPrefix = s3OutputKeyPrefixDecoded
        let cloudWatchLogGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudWatchLogGroupName)
        cloudWatchLogGroupName = cloudWatchLogGroupNameDecoded
        let ssmDocumentsContainer = try containerValues.decodeIfPresent([MgnClientTypes.SsmDocument?].self, forKey: .ssmDocuments)
        var ssmDocumentsDecoded0:[MgnClientTypes.SsmDocument]? = nil
        if let ssmDocumentsContainer = ssmDocumentsContainer {
            ssmDocumentsDecoded0 = [MgnClientTypes.SsmDocument]()
            for structure0 in ssmDocumentsContainer {
                if let structure0 = structure0 {
                    ssmDocumentsDecoded0?.append(structure0)
                }
            }
        }
        ssmDocuments = ssmDocumentsDecoded0
    }
}

extension MgnClientTypes {
    /// Post Launch Actions to executed on the Test or Cutover instance.
    public struct PostLaunchActions: Swift.Equatable {
        /// AWS Systems Manager Command's CloudWatch log group name.
        public var cloudWatchLogGroupName: Swift.String?
        /// Deployment type in which AWS Systems Manager Documents will be executed.
        public var deployment: MgnClientTypes.PostLaunchActionsDeploymentType?
        /// AWS Systems Manager Command's logs S3 log bucket.
        public var s3LogBucket: Swift.String?
        /// AWS Systems Manager Command's logs S3 output key prefix.
        public var s3OutputKeyPrefix: Swift.String?
        /// AWS Systems Manager Documents.
        public var ssmDocuments: [MgnClientTypes.SsmDocument]?

        public init (
            cloudWatchLogGroupName: Swift.String? = nil,
            deployment: MgnClientTypes.PostLaunchActionsDeploymentType? = nil,
            s3LogBucket: Swift.String? = nil,
            s3OutputKeyPrefix: Swift.String? = nil,
            ssmDocuments: [MgnClientTypes.SsmDocument]? = nil
        )
        {
            self.cloudWatchLogGroupName = cloudWatchLogGroupName
            self.deployment = deployment
            self.s3LogBucket = s3LogBucket
            self.s3OutputKeyPrefix = s3OutputKeyPrefix
            self.ssmDocuments = ssmDocuments
        }
    }

}

extension MgnClientTypes {
    public enum PostLaunchActionsDeploymentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cutoverOnly
        case testAndCutover
        case testOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [PostLaunchActionsDeploymentType] {
            return [
                .cutoverOnly,
                .testAndCutover,
                .testOnly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cutoverOnly: return "CUTOVER_ONLY"
            case .testAndCutover: return "TEST_AND_CUTOVER"
            case .testOnly: return "TEST_ONLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PostLaunchActionsDeploymentType(rawValue: rawValue) ?? PostLaunchActionsDeploymentType.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.PostLaunchActionsStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case postLaunchActionsLaunchStatusList
        case ssmAgentDiscoveryDatetime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let postLaunchActionsLaunchStatusList = postLaunchActionsLaunchStatusList {
            var postLaunchActionsLaunchStatusListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .postLaunchActionsLaunchStatusList)
            for jobpostlaunchactionslaunchstatus0 in postLaunchActionsLaunchStatusList {
                try postLaunchActionsLaunchStatusListContainer.encode(jobpostlaunchactionslaunchstatus0)
            }
        }
        if let ssmAgentDiscoveryDatetime = self.ssmAgentDiscoveryDatetime {
            try encodeContainer.encode(ssmAgentDiscoveryDatetime, forKey: .ssmAgentDiscoveryDatetime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ssmAgentDiscoveryDatetimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssmAgentDiscoveryDatetime)
        ssmAgentDiscoveryDatetime = ssmAgentDiscoveryDatetimeDecoded
        let postLaunchActionsLaunchStatusListContainer = try containerValues.decodeIfPresent([MgnClientTypes.JobPostLaunchActionsLaunchStatus?].self, forKey: .postLaunchActionsLaunchStatusList)
        var postLaunchActionsLaunchStatusListDecoded0:[MgnClientTypes.JobPostLaunchActionsLaunchStatus]? = nil
        if let postLaunchActionsLaunchStatusListContainer = postLaunchActionsLaunchStatusListContainer {
            postLaunchActionsLaunchStatusListDecoded0 = [MgnClientTypes.JobPostLaunchActionsLaunchStatus]()
            for structure0 in postLaunchActionsLaunchStatusListContainer {
                if let structure0 = structure0 {
                    postLaunchActionsLaunchStatusListDecoded0?.append(structure0)
                }
            }
        }
        postLaunchActionsLaunchStatusList = postLaunchActionsLaunchStatusListDecoded0
    }
}

extension MgnClientTypes {
    /// Status of the Post Launch Actions running on the Test or Cutover instance.
    public struct PostLaunchActionsStatus: Swift.Equatable {
        /// List of Post Launch Action status.
        public var postLaunchActionsLaunchStatusList: [MgnClientTypes.JobPostLaunchActionsLaunchStatus]?
        /// Time where the AWS Systems Manager was detected as running on the Test or Cutover instance.
        public var ssmAgentDiscoveryDatetime: Swift.String?

        public init (
            postLaunchActionsLaunchStatusList: [MgnClientTypes.JobPostLaunchActionsLaunchStatus]? = nil,
            ssmAgentDiscoveryDatetime: Swift.String? = nil
        )
        {
            self.postLaunchActionsLaunchStatusList = postLaunchActionsLaunchStatusList
            self.ssmAgentDiscoveryDatetime = ssmAgentDiscoveryDatetime
        }
    }

}

extension PutSourceServerActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionID
        case actionName
        case active
        case documentIdentifier
        case documentVersion
        case mustSucceedForCutover
        case order
        case parameters
        case sourceServerID
        case timeoutSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionID = self.actionID {
            try encodeContainer.encode(actionID, forKey: .actionID)
        }
        if let actionName = self.actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let documentIdentifier = self.documentIdentifier {
            try encodeContainer.encode(documentIdentifier, forKey: .documentIdentifier)
        }
        if let documentVersion = self.documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let mustSucceedForCutover = self.mustSucceedForCutover {
            try encodeContainer.encode(mustSucceedForCutover, forKey: .mustSucceedForCutover)
        }
        if order != 0 {
            try encodeContainer.encode(order, forKey: .order)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, ssmDocumentParameters0) in parameters {
                var ssmDocumentParameters0Container = parametersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for ssmparameterstoreparameter1 in ssmDocumentParameters0 {
                    try ssmDocumentParameters0Container.encode(ssmparameterstoreparameter1)
                }
            }
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if timeoutSeconds != 0 {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }
}

extension PutSourceServerActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/PutSourceServerAction"
    }
}

public struct PutSourceServerActionInput: Swift.Equatable {
    /// Source server post migration custom action ID.
    /// This member is required.
    public var actionID: Swift.String?
    /// Source server post migration custom action name.
    /// This member is required.
    public var actionName: Swift.String?
    /// Source server post migration custom action active status.
    public var active: Swift.Bool?
    /// Source server post migration custom action document identifier.
    /// This member is required.
    public var documentIdentifier: Swift.String?
    /// Source server post migration custom action document version.
    public var documentVersion: Swift.String?
    /// Source server post migration custom action must succeed for cutover.
    public var mustSucceedForCutover: Swift.Bool?
    /// Source server post migration custom action order.
    /// This member is required.
    public var order: Swift.Int
    /// Source server post migration custom action parameters.
    public var parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
    /// Source server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?
    /// Source server post migration custom action timeout in seconds.
    public var timeoutSeconds: Swift.Int

    public init (
        actionID: Swift.String? = nil,
        actionName: Swift.String? = nil,
        active: Swift.Bool? = nil,
        documentIdentifier: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        mustSucceedForCutover: Swift.Bool? = nil,
        order: Swift.Int = 0,
        parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil,
        sourceServerID: Swift.String? = nil,
        timeoutSeconds: Swift.Int = 0
    )
    {
        self.actionID = actionID
        self.actionName = actionName
        self.active = active
        self.documentIdentifier = documentIdentifier
        self.documentVersion = documentVersion
        self.mustSucceedForCutover = mustSucceedForCutover
        self.order = order
        self.parameters = parameters
        self.sourceServerID = sourceServerID
        self.timeoutSeconds = timeoutSeconds
    }
}

struct PutSourceServerActionInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let actionName: Swift.String?
    let documentIdentifier: Swift.String?
    let order: Swift.Int
    let actionID: Swift.String?
    let documentVersion: Swift.String?
    let active: Swift.Bool?
    let timeoutSeconds: Swift.Int
    let mustSucceedForCutover: Swift.Bool?
    let parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
}

extension PutSourceServerActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionID
        case actionName
        case active
        case documentIdentifier
        case documentVersion
        case mustSucceedForCutover
        case order
        case parameters
        case sourceServerID
        case timeoutSeconds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let documentIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentIdentifier)
        documentIdentifier = documentIdentifierDecoded
        let orderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .order) ?? 0
        order = orderDecoded
        let actionIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionID)
        actionID = actionIDDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let timeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutSeconds) ?? 0
        timeoutSeconds = timeoutSecondsDecoded
        let mustSucceedForCutoverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mustSucceedForCutover)
        mustSucceedForCutover = mustSucceedForCutoverDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [MgnClientTypes.SsmParameterStoreParameter?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]()
            for (key0, ssmparameterstoreparameters0) in parametersContainer {
                var ssmparameterstoreparameters0Decoded0: [MgnClientTypes.SsmParameterStoreParameter]? = nil
                if let ssmparameterstoreparameters0 = ssmparameterstoreparameters0 {
                    ssmparameterstoreparameters0Decoded0 = [MgnClientTypes.SsmParameterStoreParameter]()
                    for structure1 in ssmparameterstoreparameters0 {
                        if let structure1 = structure1 {
                            ssmparameterstoreparameters0Decoded0?.append(structure1)
                        }
                    }
                }
                parametersDecoded0?[key0] = ssmparameterstoreparameters0Decoded0
            }
        }
        parameters = parametersDecoded0
    }
}

extension PutSourceServerActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSourceServerActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutSourceServerActionOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSourceServerActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutSourceServerActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actionID = output.actionID
            self.actionName = output.actionName
            self.active = output.active
            self.documentIdentifier = output.documentIdentifier
            self.documentVersion = output.documentVersion
            self.mustSucceedForCutover = output.mustSucceedForCutover
            self.order = output.order
            self.parameters = output.parameters
            self.timeoutSeconds = output.timeoutSeconds
        } else {
            self.actionID = nil
            self.actionName = nil
            self.active = nil
            self.documentIdentifier = nil
            self.documentVersion = nil
            self.mustSucceedForCutover = nil
            self.order = 0
            self.parameters = nil
            self.timeoutSeconds = 0
        }
    }
}

public struct PutSourceServerActionOutputResponse: Swift.Equatable {
    /// Source server post migration custom action ID.
    public var actionID: Swift.String?
    /// Source server post migration custom action name.
    public var actionName: Swift.String?
    /// Source server post migration custom action active status.
    public var active: Swift.Bool?
    /// Source server post migration custom action document identifier.
    public var documentIdentifier: Swift.String?
    /// Source server post migration custom action document version.
    public var documentVersion: Swift.String?
    /// Source server post migration custom action must succeed for cutover.
    public var mustSucceedForCutover: Swift.Bool?
    /// Source server post migration custom action order.
    public var order: Swift.Int
    /// Source server post migration custom action parameters.
    public var parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
    /// Source server post migration custom action timeout in seconds.
    public var timeoutSeconds: Swift.Int

    public init (
        actionID: Swift.String? = nil,
        actionName: Swift.String? = nil,
        active: Swift.Bool? = nil,
        documentIdentifier: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        mustSucceedForCutover: Swift.Bool? = nil,
        order: Swift.Int = 0,
        parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil,
        timeoutSeconds: Swift.Int = 0
    )
    {
        self.actionID = actionID
        self.actionName = actionName
        self.active = active
        self.documentIdentifier = documentIdentifier
        self.documentVersion = documentVersion
        self.mustSucceedForCutover = mustSucceedForCutover
        self.order = order
        self.parameters = parameters
        self.timeoutSeconds = timeoutSeconds
    }
}

struct PutSourceServerActionOutputResponseBody: Swift.Equatable {
    let actionID: Swift.String?
    let actionName: Swift.String?
    let documentIdentifier: Swift.String?
    let order: Swift.Int
    let documentVersion: Swift.String?
    let active: Swift.Bool?
    let timeoutSeconds: Swift.Int
    let mustSucceedForCutover: Swift.Bool?
    let parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
}

extension PutSourceServerActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionID
        case actionName
        case active
        case documentIdentifier
        case documentVersion
        case mustSucceedForCutover
        case order
        case parameters
        case timeoutSeconds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionID)
        actionID = actionIDDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let documentIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentIdentifier)
        documentIdentifier = documentIdentifierDecoded
        let orderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .order) ?? 0
        order = orderDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let timeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutSeconds) ?? 0
        timeoutSeconds = timeoutSecondsDecoded
        let mustSucceedForCutoverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mustSucceedForCutover)
        mustSucceedForCutover = mustSucceedForCutoverDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [MgnClientTypes.SsmParameterStoreParameter?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]()
            for (key0, ssmparameterstoreparameters0) in parametersContainer {
                var ssmparameterstoreparameters0Decoded0: [MgnClientTypes.SsmParameterStoreParameter]? = nil
                if let ssmparameterstoreparameters0 = ssmparameterstoreparameters0 {
                    ssmparameterstoreparameters0Decoded0 = [MgnClientTypes.SsmParameterStoreParameter]()
                    for structure1 in ssmparameterstoreparameters0 {
                        if let structure1 = structure1 {
                            ssmparameterstoreparameters0Decoded0?.append(structure1)
                        }
                    }
                }
                parametersDecoded0?[key0] = ssmparameterstoreparameters0Decoded0
            }
        }
        parameters = parametersDecoded0
    }
}

extension PutTemplateActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionID
        case actionName
        case active
        case documentIdentifier
        case documentVersion
        case launchConfigurationTemplateID
        case mustSucceedForCutover
        case operatingSystem
        case order
        case parameters
        case timeoutSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionID = self.actionID {
            try encodeContainer.encode(actionID, forKey: .actionID)
        }
        if let actionName = self.actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let documentIdentifier = self.documentIdentifier {
            try encodeContainer.encode(documentIdentifier, forKey: .documentIdentifier)
        }
        if let documentVersion = self.documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let launchConfigurationTemplateID = self.launchConfigurationTemplateID {
            try encodeContainer.encode(launchConfigurationTemplateID, forKey: .launchConfigurationTemplateID)
        }
        if let mustSucceedForCutover = self.mustSucceedForCutover {
            try encodeContainer.encode(mustSucceedForCutover, forKey: .mustSucceedForCutover)
        }
        if let operatingSystem = self.operatingSystem {
            try encodeContainer.encode(operatingSystem, forKey: .operatingSystem)
        }
        if order != 0 {
            try encodeContainer.encode(order, forKey: .order)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, ssmDocumentParameters0) in parameters {
                var ssmDocumentParameters0Container = parametersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for ssmparameterstoreparameter1 in ssmDocumentParameters0 {
                    try ssmDocumentParameters0Container.encode(ssmparameterstoreparameter1)
                }
            }
        }
        if timeoutSeconds != 0 {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }
}

extension PutTemplateActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/PutTemplateAction"
    }
}

public struct PutTemplateActionInput: Swift.Equatable {
    /// Template post migration custom action ID.
    /// This member is required.
    public var actionID: Swift.String?
    /// Template post migration custom action name.
    /// This member is required.
    public var actionName: Swift.String?
    /// Template post migration custom action active status.
    public var active: Swift.Bool?
    /// Template post migration custom action document identifier.
    /// This member is required.
    public var documentIdentifier: Swift.String?
    /// Template post migration custom action document version.
    public var documentVersion: Swift.String?
    /// Launch configuration template ID.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?
    /// Template post migration custom action must succeed for cutover.
    public var mustSucceedForCutover: Swift.Bool?
    /// Operating system eligible for this template post migration custom action.
    public var operatingSystem: Swift.String?
    /// Template post migration custom action order.
    /// This member is required.
    public var order: Swift.Int
    /// Template post migration custom action parameters.
    public var parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
    /// Template post migration custom action timeout in seconds.
    public var timeoutSeconds: Swift.Int

    public init (
        actionID: Swift.String? = nil,
        actionName: Swift.String? = nil,
        active: Swift.Bool? = nil,
        documentIdentifier: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        launchConfigurationTemplateID: Swift.String? = nil,
        mustSucceedForCutover: Swift.Bool? = nil,
        operatingSystem: Swift.String? = nil,
        order: Swift.Int = 0,
        parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil,
        timeoutSeconds: Swift.Int = 0
    )
    {
        self.actionID = actionID
        self.actionName = actionName
        self.active = active
        self.documentIdentifier = documentIdentifier
        self.documentVersion = documentVersion
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
        self.mustSucceedForCutover = mustSucceedForCutover
        self.operatingSystem = operatingSystem
        self.order = order
        self.parameters = parameters
        self.timeoutSeconds = timeoutSeconds
    }
}

struct PutTemplateActionInputBody: Swift.Equatable {
    let launchConfigurationTemplateID: Swift.String?
    let actionName: Swift.String?
    let documentIdentifier: Swift.String?
    let order: Swift.Int
    let actionID: Swift.String?
    let documentVersion: Swift.String?
    let active: Swift.Bool?
    let timeoutSeconds: Swift.Int
    let mustSucceedForCutover: Swift.Bool?
    let parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
    let operatingSystem: Swift.String?
}

extension PutTemplateActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionID
        case actionName
        case active
        case documentIdentifier
        case documentVersion
        case launchConfigurationTemplateID
        case mustSucceedForCutover
        case operatingSystem
        case order
        case parameters
        case timeoutSeconds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationTemplateID)
        launchConfigurationTemplateID = launchConfigurationTemplateIDDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let documentIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentIdentifier)
        documentIdentifier = documentIdentifierDecoded
        let orderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .order) ?? 0
        order = orderDecoded
        let actionIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionID)
        actionID = actionIDDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let timeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutSeconds) ?? 0
        timeoutSeconds = timeoutSecondsDecoded
        let mustSucceedForCutoverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mustSucceedForCutover)
        mustSucceedForCutover = mustSucceedForCutoverDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [MgnClientTypes.SsmParameterStoreParameter?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]()
            for (key0, ssmparameterstoreparameters0) in parametersContainer {
                var ssmparameterstoreparameters0Decoded0: [MgnClientTypes.SsmParameterStoreParameter]? = nil
                if let ssmparameterstoreparameters0 = ssmparameterstoreparameters0 {
                    ssmparameterstoreparameters0Decoded0 = [MgnClientTypes.SsmParameterStoreParameter]()
                    for structure1 in ssmparameterstoreparameters0 {
                        if let structure1 = structure1 {
                            ssmparameterstoreparameters0Decoded0?.append(structure1)
                        }
                    }
                }
                parametersDecoded0?[key0] = ssmparameterstoreparameters0Decoded0
            }
        }
        parameters = parametersDecoded0
        let operatingSystemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
    }
}

extension PutTemplateActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutTemplateActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutTemplateActionOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutTemplateActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutTemplateActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actionID = output.actionID
            self.actionName = output.actionName
            self.active = output.active
            self.documentIdentifier = output.documentIdentifier
            self.documentVersion = output.documentVersion
            self.mustSucceedForCutover = output.mustSucceedForCutover
            self.operatingSystem = output.operatingSystem
            self.order = output.order
            self.parameters = output.parameters
            self.timeoutSeconds = output.timeoutSeconds
        } else {
            self.actionID = nil
            self.actionName = nil
            self.active = nil
            self.documentIdentifier = nil
            self.documentVersion = nil
            self.mustSucceedForCutover = nil
            self.operatingSystem = nil
            self.order = 0
            self.parameters = nil
            self.timeoutSeconds = 0
        }
    }
}

public struct PutTemplateActionOutputResponse: Swift.Equatable {
    /// Template post migration custom action ID.
    public var actionID: Swift.String?
    /// Template post migration custom action name.
    public var actionName: Swift.String?
    /// Template post migration custom action active status.
    public var active: Swift.Bool?
    /// Template post migration custom action document identifier.
    public var documentIdentifier: Swift.String?
    /// Template post migration custom action document version.
    public var documentVersion: Swift.String?
    /// Template post migration custom action must succeed for cutover.
    public var mustSucceedForCutover: Swift.Bool?
    /// Operating system eligible for this template post migration custom action.
    public var operatingSystem: Swift.String?
    /// Template post migration custom action order.
    public var order: Swift.Int
    /// Template post migration custom action parameters.
    public var parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
    /// Template post migration custom action timeout in seconds.
    public var timeoutSeconds: Swift.Int

    public init (
        actionID: Swift.String? = nil,
        actionName: Swift.String? = nil,
        active: Swift.Bool? = nil,
        documentIdentifier: Swift.String? = nil,
        documentVersion: Swift.String? = nil,
        mustSucceedForCutover: Swift.Bool? = nil,
        operatingSystem: Swift.String? = nil,
        order: Swift.Int = 0,
        parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil,
        timeoutSeconds: Swift.Int = 0
    )
    {
        self.actionID = actionID
        self.actionName = actionName
        self.active = active
        self.documentIdentifier = documentIdentifier
        self.documentVersion = documentVersion
        self.mustSucceedForCutover = mustSucceedForCutover
        self.operatingSystem = operatingSystem
        self.order = order
        self.parameters = parameters
        self.timeoutSeconds = timeoutSeconds
    }
}

struct PutTemplateActionOutputResponseBody: Swift.Equatable {
    let actionID: Swift.String?
    let actionName: Swift.String?
    let documentIdentifier: Swift.String?
    let order: Swift.Int
    let documentVersion: Swift.String?
    let active: Swift.Bool?
    let timeoutSeconds: Swift.Int
    let mustSucceedForCutover: Swift.Bool?
    let parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
    let operatingSystem: Swift.String?
}

extension PutTemplateActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionID
        case actionName
        case active
        case documentIdentifier
        case documentVersion
        case mustSucceedForCutover
        case operatingSystem
        case order
        case parameters
        case timeoutSeconds
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionID)
        actionID = actionIDDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let documentIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentIdentifier)
        documentIdentifier = documentIdentifierDecoded
        let orderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .order) ?? 0
        order = orderDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let timeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutSeconds) ?? 0
        timeoutSeconds = timeoutSecondsDecoded
        let mustSucceedForCutoverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mustSucceedForCutover)
        mustSucceedForCutover = mustSucceedForCutoverDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [MgnClientTypes.SsmParameterStoreParameter?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]()
            for (key0, ssmparameterstoreparameters0) in parametersContainer {
                var ssmparameterstoreparameters0Decoded0: [MgnClientTypes.SsmParameterStoreParameter]? = nil
                if let ssmparameterstoreparameters0 = ssmparameterstoreparameters0 {
                    ssmparameterstoreparameters0Decoded0 = [MgnClientTypes.SsmParameterStoreParameter]()
                    for structure1 in ssmparameterstoreparameters0 {
                        if let structure1 = structure1 {
                            ssmparameterstoreparameters0Decoded0?.append(structure1)
                        }
                    }
                }
                parametersDecoded0?[key0] = ssmparameterstoreparameters0Decoded0
            }
        }
        parameters = parametersDecoded0
        let operatingSystemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
    }
}

extension RemoveSourceServerActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionID
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionID = self.actionID {
            try encodeContainer.encode(actionID, forKey: .actionID)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension RemoveSourceServerActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/RemoveSourceServerAction"
    }
}

public struct RemoveSourceServerActionInput: Swift.Equatable {
    /// Source server post migration custom action ID to remove.
    /// This member is required.
    public var actionID: Swift.String?
    /// Source server ID of the post migration custom action to remove.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        actionID: Swift.String? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.actionID = actionID
        self.sourceServerID = sourceServerID
    }
}

struct RemoveSourceServerActionInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let actionID: Swift.String?
}

extension RemoveSourceServerActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionID
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let actionIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionID)
        actionID = actionIDDecoded
    }
}

extension RemoveSourceServerActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveSourceServerActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RemoveSourceServerActionOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveSourceServerActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveSourceServerActionOutputResponse: Swift.Equatable {

    public init () { }
}

extension RemoveTemplateActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionID
        case launchConfigurationTemplateID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionID = self.actionID {
            try encodeContainer.encode(actionID, forKey: .actionID)
        }
        if let launchConfigurationTemplateID = self.launchConfigurationTemplateID {
            try encodeContainer.encode(launchConfigurationTemplateID, forKey: .launchConfigurationTemplateID)
        }
    }
}

extension RemoveTemplateActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/RemoveTemplateAction"
    }
}

public struct RemoveTemplateActionInput: Swift.Equatable {
    /// Template post migration custom action ID to remove.
    /// This member is required.
    public var actionID: Swift.String?
    /// Launch configuration template ID of the post migration custom action to remove.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?

    public init (
        actionID: Swift.String? = nil,
        launchConfigurationTemplateID: Swift.String? = nil
    )
    {
        self.actionID = actionID
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
    }
}

struct RemoveTemplateActionInputBody: Swift.Equatable {
    let launchConfigurationTemplateID: Swift.String?
    let actionID: Swift.String?
}

extension RemoveTemplateActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionID
        case launchConfigurationTemplateID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationTemplateID)
        launchConfigurationTemplateID = launchConfigurationTemplateIDDecoded
        let actionIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionID)
        actionID = actionIDDecoded
    }
}

extension RemoveTemplateActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveTemplateActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RemoveTemplateActionOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveTemplateActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RemoveTemplateActionOutputResponse: Swift.Equatable {

    public init () { }
}

extension MgnClientTypes {
    public enum ReplicationConfigurationDataPlaneRouting: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case privateIp
        case publicIp
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationDataPlaneRouting] {
            return [
                .privateIp,
                .publicIp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .privateIp: return "PRIVATE_IP"
            case .publicIp: return "PUBLIC_IP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationConfigurationDataPlaneRouting(rawValue: rawValue) ?? ReplicationConfigurationDataPlaneRouting.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum ReplicationConfigurationDefaultLargeStagingDiskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gp2
        case gp3
        case st1
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationDefaultLargeStagingDiskType] {
            return [
                .gp2,
                .gp3,
                .st1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gp2: return "GP2"
            case .gp3: return "GP3"
            case .st1: return "ST1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationConfigurationDefaultLargeStagingDiskType(rawValue: rawValue) ?? ReplicationConfigurationDefaultLargeStagingDiskType.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum ReplicationConfigurationEbsEncryption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationEbsEncryption] {
            return [
                .custom,
                .default,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .default: return "DEFAULT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationConfigurationEbsEncryption(rawValue: rawValue) ?? ReplicationConfigurationEbsEncryption.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.ReplicationConfigurationReplicatedDisk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceName
        case iops
        case isBootDisk
        case stagingDiskType
        case throughput
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if iops != 0 {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let isBootDisk = self.isBootDisk {
            try encodeContainer.encode(isBootDisk, forKey: .isBootDisk)
        }
        if let stagingDiskType = self.stagingDiskType {
            try encodeContainer.encode(stagingDiskType.rawValue, forKey: .stagingDiskType)
        }
        if throughput != 0 {
            try encodeContainer.encode(throughput, forKey: .throughput)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let isBootDiskDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isBootDisk)
        isBootDisk = isBootDiskDecoded
        let stagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationReplicatedDiskStagingDiskType.self, forKey: .stagingDiskType)
        stagingDiskType = stagingDiskTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops) ?? 0
        iops = iopsDecoded
        let throughputDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .throughput) ?? 0
        throughput = throughputDecoded
    }
}

extension MgnClientTypes {
    /// Replication Configuration replicated disk.
    public struct ReplicationConfigurationReplicatedDisk: Swift.Equatable {
        /// Replication Configuration replicated disk device name.
        public var deviceName: Swift.String?
        /// Replication Configuration replicated disk IOPs.
        public var iops: Swift.Int
        /// Replication Configuration replicated disk boot disk.
        public var isBootDisk: Swift.Bool?
        /// Replication Configuration replicated disk staging disk type.
        public var stagingDiskType: MgnClientTypes.ReplicationConfigurationReplicatedDiskStagingDiskType?
        /// Replication Configuration replicated disk throughput.
        public var throughput: Swift.Int

        public init (
            deviceName: Swift.String? = nil,
            iops: Swift.Int = 0,
            isBootDisk: Swift.Bool? = nil,
            stagingDiskType: MgnClientTypes.ReplicationConfigurationReplicatedDiskStagingDiskType? = nil,
            throughput: Swift.Int = 0
        )
        {
            self.deviceName = deviceName
            self.iops = iops
            self.isBootDisk = isBootDisk
            self.stagingDiskType = stagingDiskType
            self.throughput = throughput
        }
    }

}

extension MgnClientTypes {
    public enum ReplicationConfigurationReplicatedDiskStagingDiskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case gp2
        case gp3
        case io1
        case io2
        case sc1
        case st1
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationReplicatedDiskStagingDiskType] {
            return [
                .auto,
                .gp2,
                .gp3,
                .io1,
                .io2,
                .sc1,
                .st1,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .gp2: return "GP2"
            case .gp3: return "GP3"
            case .io1: return "IO1"
            case .io2: return "IO2"
            case .sc1: return "SC1"
            case .st1: return "ST1"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationConfigurationReplicatedDiskStagingDiskType(rawValue: rawValue) ?? ReplicationConfigurationReplicatedDiskStagingDiskType.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.ReplicationConfigurationTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let associateDefaultSecurityGroup = self.associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = self.createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = self.dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = self.defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = self.ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = self.ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let replicationConfigurationTemplateID = self.replicationConfigurationTemplateID {
            try encodeContainer.encode(replicationConfigurationTemplateID, forKey: .replicationConfigurationTemplateID)
        }
        if let replicationServerInstanceType = self.replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for securitygroupid0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(securitygroupid0)
            }
        }
        if let stagingAreaSubnetId = self.stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsMap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = self.useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MgnClientTypes.ReplicationConfigurationTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicationConfigurationTemplate(arn: \(Swift.String(describing: arn)), associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), replicationConfigurationTemplateID: \(Swift.String(describing: replicationConfigurationTemplateID)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), stagingAreaTags: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension MgnClientTypes {
    public struct ReplicationConfigurationTemplate: Swift.Equatable {
        /// Replication Configuration template ARN.
        public var arn: Swift.String?
        /// Replication Configuration template associate default Application Migration Service Security group.
        public var associateDefaultSecurityGroup: Swift.Bool?
        /// Replication Configuration template bandwidth throttling.
        public var bandwidthThrottling: Swift.Int
        /// Replication Configuration template create Public IP.
        public var createPublicIP: Swift.Bool?
        /// Replication Configuration template data plane routing.
        public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
        /// Replication Configuration template use default large Staging Disk type.
        public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
        /// Replication Configuration template EBS encryption.
        public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
        /// Replication Configuration template EBS encryption key ARN.
        public var ebsEncryptionKeyArn: Swift.String?
        /// Replication Configuration template ID.
        /// This member is required.
        public var replicationConfigurationTemplateID: Swift.String?
        /// Replication Configuration template server instance type.
        public var replicationServerInstanceType: Swift.String?
        /// Replication Configuration template server Security Groups IDs.
        public var replicationServersSecurityGroupsIDs: [Swift.String]?
        /// Replication Configuration template Staging Area subnet ID.
        public var stagingAreaSubnetId: Swift.String?
        /// Replication Configuration template Staging Area Tags.
        public var stagingAreaTags: [Swift.String:Swift.String]?
        /// Replication Configuration template Tags.
        public var tags: [Swift.String:Swift.String]?
        /// Replication Configuration template use Dedicated Replication Server.
        public var useDedicatedReplicationServer: Swift.Bool?

        public init (
            arn: Swift.String? = nil,
            associateDefaultSecurityGroup: Swift.Bool? = nil,
            bandwidthThrottling: Swift.Int = 0,
            createPublicIP: Swift.Bool? = nil,
            dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
            defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
            ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
            ebsEncryptionKeyArn: Swift.String? = nil,
            replicationConfigurationTemplateID: Swift.String? = nil,
            replicationServerInstanceType: Swift.String? = nil,
            replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
            stagingAreaSubnetId: Swift.String? = nil,
            stagingAreaTags: [Swift.String:Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            useDedicatedReplicationServer: Swift.Bool? = nil
        )
        {
            self.arn = arn
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.tags = tags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
        }
    }

}

extension MgnClientTypes {
    public enum ReplicationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agentBased
        case snapshotShipping
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationType] {
            return [
                .agentBased,
                .snapshotShipping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agentBased: return "AGENT_BASED"
            case .snapshotShipping: return "SNAPSHOT_SHIPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationType(rawValue: rawValue) ?? ReplicationType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.code = nil
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Resource not found exception.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?
    /// Resource ID not found error.
    public var resourceId: Swift.String?
    /// Resource type not found error.
    public var resourceType: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension RetryDataReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension RetryDataReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/RetryDataReplication"
    }
}

public struct RetryDataReplicationInput: Swift.Equatable {
    /// Retry data replication for Source Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct RetryDataReplicationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension RetryDataReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension RetryDataReplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RetryDataReplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RetryDataReplicationOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RetryDataReplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetryDataReplicationOutputResponse(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

extension RetryDataReplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RetryDataReplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.applicationID = nil
            self.arn = nil
            self.dataReplicationInfo = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.vcenterClientID = nil
        }
    }
}

public struct RetryDataReplicationOutputResponse: Swift.Equatable {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init (
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.vcenterClientID = vcenterClientID
    }
}

struct RetryDataReplicationOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
    let applicationID: Swift.String?
}

extension RetryDataReplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case vcenterClientID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.quotaValue = output.quotaValue
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.code = nil
            self.message = nil
            self.quotaCode = nil
            self.quotaValue = 0
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be completed because its exceeded the service quota.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?
    /// Exceeded the service quota code.
    public var quotaCode: Swift.String?
    /// Exceeded the service quota value.
    public var quotaValue: Swift.Int
    /// Exceeded the service quota resource ID.
    public var resourceId: Swift.String?
    /// Exceeded the service quota resource type.
    public var resourceType: Swift.String?
    /// Exceeded the service quota service code.
    public var serviceCode: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        quotaValue: Swift.Int = 0,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.quotaCode = quotaCode
        self.quotaValue = quotaValue
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
    let quotaValue: Swift.Int
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case quotaCode
        case quotaValue
        case resourceId
        case resourceType
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let quotaValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .quotaValue) ?? 0
        quotaValue = quotaValueDecoded
    }
}

extension MgnClientTypes.SourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpus
        case disks
        case identificationHints
        case lastUpdatedDateTime
        case networkInterfaces
        case os
        case ramBytes
        case recommendedInstanceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpus = cpus {
            var cpusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cpus)
            for cpu0 in cpus {
                try cpusContainer.encode(cpu0)
            }
        }
        if let disks = disks {
            var disksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .disks)
            for disk0 in disks {
                try disksContainer.encode(disk0)
            }
        }
        if let identificationHints = self.identificationHints {
            try encodeContainer.encode(identificationHints, forKey: .identificationHints)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime, forKey: .lastUpdatedDateTime)
        }
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterface0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterface0)
            }
        }
        if let os = self.os {
            try encodeContainer.encode(os, forKey: .os)
        }
        if ramBytes != 0 {
            try encodeContainer.encode(ramBytes, forKey: .ramBytes)
        }
        if let recommendedInstanceType = self.recommendedInstanceType {
            try encodeContainer.encode(recommendedInstanceType, forKey: .recommendedInstanceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let recommendedInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedInstanceType)
        recommendedInstanceType = recommendedInstanceTypeDecoded
        let identificationHintsDecoded = try containerValues.decodeIfPresent(MgnClientTypes.IdentificationHints.self, forKey: .identificationHints)
        identificationHints = identificationHintsDecoded
        let networkInterfacesContainer = try containerValues.decodeIfPresent([MgnClientTypes.NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[MgnClientTypes.NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [MgnClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
        let disksContainer = try containerValues.decodeIfPresent([MgnClientTypes.Disk?].self, forKey: .disks)
        var disksDecoded0:[MgnClientTypes.Disk]? = nil
        if let disksContainer = disksContainer {
            disksDecoded0 = [MgnClientTypes.Disk]()
            for structure0 in disksContainer {
                if let structure0 = structure0 {
                    disksDecoded0?.append(structure0)
                }
            }
        }
        disks = disksDecoded0
        let cpusContainer = try containerValues.decodeIfPresent([MgnClientTypes.CPU?].self, forKey: .cpus)
        var cpusDecoded0:[MgnClientTypes.CPU]? = nil
        if let cpusContainer = cpusContainer {
            cpusDecoded0 = [MgnClientTypes.CPU]()
            for structure0 in cpusContainer {
                if let structure0 = structure0 {
                    cpusDecoded0?.append(structure0)
                }
            }
        }
        cpus = cpusDecoded0
        let ramBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ramBytes) ?? 0
        ramBytes = ramBytesDecoded
        let osDecoded = try containerValues.decodeIfPresent(MgnClientTypes.OS.self, forKey: .os)
        os = osDecoded
    }
}

extension MgnClientTypes {
    /// Source server properties.
    public struct SourceProperties: Swift.Equatable {
        /// Source Server CPUs.
        public var cpus: [MgnClientTypes.CPU]?
        /// Source Server disks.
        public var disks: [MgnClientTypes.Disk]?
        /// Source server identification hints.
        public var identificationHints: MgnClientTypes.IdentificationHints?
        /// Source server last update date and time.
        public var lastUpdatedDateTime: Swift.String?
        /// Source server network interfaces.
        public var networkInterfaces: [MgnClientTypes.NetworkInterface]?
        /// Source server OS.
        public var os: MgnClientTypes.OS?
        /// Source server RAM in bytes.
        public var ramBytes: Swift.Int
        /// Source server recommended instance type.
        public var recommendedInstanceType: Swift.String?

        public init (
            cpus: [MgnClientTypes.CPU]? = nil,
            disks: [MgnClientTypes.Disk]? = nil,
            identificationHints: MgnClientTypes.IdentificationHints? = nil,
            lastUpdatedDateTime: Swift.String? = nil,
            networkInterfaces: [MgnClientTypes.NetworkInterface]? = nil,
            os: MgnClientTypes.OS? = nil,
            ramBytes: Swift.Int = 0,
            recommendedInstanceType: Swift.String? = nil
        )
        {
            self.cpus = cpus
            self.disks = disks
            self.identificationHints = identificationHints
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.networkInterfaces = networkInterfaces
            self.os = os
            self.ramBytes = ramBytes
            self.recommendedInstanceType = recommendedInstanceType
        }
    }

}

extension MgnClientTypes.SourceServer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case vcenterClientID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationID = self.applicationID {
            try encodeContainer.encode(applicationID, forKey: .applicationID)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dataReplicationInfo = self.dataReplicationInfo {
            try encodeContainer.encode(dataReplicationInfo, forKey: .dataReplicationInfo)
        }
        if let isArchived = self.isArchived {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let launchedInstance = self.launchedInstance {
            try encodeContainer.encode(launchedInstance, forKey: .launchedInstance)
        }
        if let lifeCycle = self.lifeCycle {
            try encodeContainer.encode(lifeCycle, forKey: .lifeCycle)
        }
        if let replicationType = self.replicationType {
            try encodeContainer.encode(replicationType.rawValue, forKey: .replicationType)
        }
        if let sourceProperties = self.sourceProperties {
            try encodeContainer.encode(sourceProperties, forKey: .sourceProperties)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vcenterClientID = self.vcenterClientID {
            try encodeContainer.encode(vcenterClientID, forKey: .vcenterClientID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
    }
}

extension MgnClientTypes.SourceServer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceServer(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

extension MgnClientTypes {
    public struct SourceServer: Swift.Equatable {
        /// Source server application ID.
        public var applicationID: Swift.String?
        /// Source server ARN.
        public var arn: Swift.String?
        /// Source server data replication info.
        public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
        /// Source server archived status.
        public var isArchived: Swift.Bool?
        /// Source server launched instance.
        public var launchedInstance: MgnClientTypes.LaunchedInstance?
        /// Source server lifecycle state.
        public var lifeCycle: MgnClientTypes.LifeCycle?
        /// Source server replication type.
        public var replicationType: MgnClientTypes.ReplicationType?
        /// Source server properties.
        public var sourceProperties: MgnClientTypes.SourceProperties?
        /// Source server ID.
        public var sourceServerID: Swift.String?
        /// Source server Tags.
        public var tags: [Swift.String:Swift.String]?
        /// Source server vCenter client id.
        public var vcenterClientID: Swift.String?

        public init (
            applicationID: Swift.String? = nil,
            arn: Swift.String? = nil,
            dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
            isArchived: Swift.Bool? = nil,
            launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
            lifeCycle: MgnClientTypes.LifeCycle? = nil,
            replicationType: MgnClientTypes.ReplicationType? = nil,
            sourceProperties: MgnClientTypes.SourceProperties? = nil,
            sourceServerID: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            vcenterClientID: Swift.String? = nil
        )
        {
            self.applicationID = applicationID
            self.arn = arn
            self.dataReplicationInfo = dataReplicationInfo
            self.isArchived = isArchived
            self.launchedInstance = launchedInstance
            self.lifeCycle = lifeCycle
            self.replicationType = replicationType
            self.sourceProperties = sourceProperties
            self.sourceServerID = sourceServerID
            self.tags = tags
            self.vcenterClientID = vcenterClientID
        }
    }

}

extension MgnClientTypes.SourceServerActionDocument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionID
        case actionName
        case active
        case documentIdentifier
        case documentVersion
        case mustSucceedForCutover
        case order
        case parameters
        case timeoutSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionID = self.actionID {
            try encodeContainer.encode(actionID, forKey: .actionID)
        }
        if let actionName = self.actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let documentIdentifier = self.documentIdentifier {
            try encodeContainer.encode(documentIdentifier, forKey: .documentIdentifier)
        }
        if let documentVersion = self.documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let mustSucceedForCutover = self.mustSucceedForCutover {
            try encodeContainer.encode(mustSucceedForCutover, forKey: .mustSucceedForCutover)
        }
        if order != 0 {
            try encodeContainer.encode(order, forKey: .order)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, ssmDocumentParameters0) in parameters {
                var ssmDocumentParameters0Container = parametersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for ssmparameterstoreparameter1 in ssmDocumentParameters0 {
                    try ssmDocumentParameters0Container.encode(ssmparameterstoreparameter1)
                }
            }
        }
        if timeoutSeconds != 0 {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionID)
        actionID = actionIDDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let documentIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentIdentifier)
        documentIdentifier = documentIdentifierDecoded
        let orderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .order) ?? 0
        order = orderDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let timeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutSeconds) ?? 0
        timeoutSeconds = timeoutSecondsDecoded
        let mustSucceedForCutoverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mustSucceedForCutover)
        mustSucceedForCutover = mustSucceedForCutoverDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [MgnClientTypes.SsmParameterStoreParameter?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]()
            for (key0, ssmparameterstoreparameters0) in parametersContainer {
                var ssmparameterstoreparameters0Decoded0: [MgnClientTypes.SsmParameterStoreParameter]? = nil
                if let ssmparameterstoreparameters0 = ssmparameterstoreparameters0 {
                    ssmparameterstoreparameters0Decoded0 = [MgnClientTypes.SsmParameterStoreParameter]()
                    for structure1 in ssmparameterstoreparameters0 {
                        if let structure1 = structure1 {
                            ssmparameterstoreparameters0Decoded0?.append(structure1)
                        }
                    }
                }
                parametersDecoded0?[key0] = ssmparameterstoreparameters0Decoded0
            }
        }
        parameters = parametersDecoded0
    }
}

extension MgnClientTypes {
    public struct SourceServerActionDocument: Swift.Equatable {
        /// Source server post migration custom action ID.
        public var actionID: Swift.String?
        /// Source server post migration custom action name.
        public var actionName: Swift.String?
        /// Source server post migration custom action active status.
        public var active: Swift.Bool?
        /// Source server post migration custom action document identifier.
        public var documentIdentifier: Swift.String?
        /// Source server post migration custom action document version.
        public var documentVersion: Swift.String?
        /// Source server post migration custom action must succeed for cutover.
        public var mustSucceedForCutover: Swift.Bool?
        /// Source server post migration custom action order.
        public var order: Swift.Int
        /// Source server post migration custom action parameters.
        public var parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
        /// Source server post migration custom action timeout in seconds.
        public var timeoutSeconds: Swift.Int

        public init (
            actionID: Swift.String? = nil,
            actionName: Swift.String? = nil,
            active: Swift.Bool? = nil,
            documentIdentifier: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            mustSucceedForCutover: Swift.Bool? = nil,
            order: Swift.Int = 0,
            parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil,
            timeoutSeconds: Swift.Int = 0
        )
        {
            self.actionID = actionID
            self.actionName = actionName
            self.active = active
            self.documentIdentifier = documentIdentifier
            self.documentVersion = documentVersion
            self.mustSucceedForCutover = mustSucceedForCutover
            self.order = order
            self.parameters = parameters
            self.timeoutSeconds = timeoutSeconds
        }
    }

}

extension MgnClientTypes.SourceServerActionsRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionIDs = actionIDs {
            var actionIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actionIDs)
            for actionid0 in actionIDs {
                try actionIDsContainer.encode(actionid0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actionIDs)
        var actionIDsDecoded0:[Swift.String]? = nil
        if let actionIDsContainer = actionIDsContainer {
            actionIDsDecoded0 = [Swift.String]()
            for string0 in actionIDsContainer {
                if let string0 = string0 {
                    actionIDsDecoded0?.append(string0)
                }
            }
        }
        actionIDs = actionIDsDecoded0
    }
}

extension MgnClientTypes {
    /// Source server post migration custom action filters.
    public struct SourceServerActionsRequestFilters: Swift.Equatable {
        /// Action IDs to filter source server post migration custom actions by.
        public var actionIDs: [Swift.String]?

        public init (
            actionIDs: [Swift.String]? = nil
        )
        {
            self.actionIDs = actionIDs
        }
    }

}

extension MgnClientTypes.SsmDocument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionName
        case mustSucceedForCutover
        case parameters
        case ssmDocumentName
        case timeoutSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionName = self.actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let mustSucceedForCutover = self.mustSucceedForCutover {
            try encodeContainer.encode(mustSucceedForCutover, forKey: .mustSucceedForCutover)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, ssmDocumentParameters0) in parameters {
                var ssmDocumentParameters0Container = parametersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for ssmparameterstoreparameter1 in ssmDocumentParameters0 {
                    try ssmDocumentParameters0Container.encode(ssmparameterstoreparameter1)
                }
            }
        }
        if let ssmDocumentName = self.ssmDocumentName {
            try encodeContainer.encode(ssmDocumentName, forKey: .ssmDocumentName)
        }
        if timeoutSeconds != 0 {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let ssmDocumentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssmDocumentName)
        ssmDocumentName = ssmDocumentNameDecoded
        let timeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutSeconds) ?? 0
        timeoutSeconds = timeoutSecondsDecoded
        let mustSucceedForCutoverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mustSucceedForCutover)
        mustSucceedForCutover = mustSucceedForCutoverDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [MgnClientTypes.SsmParameterStoreParameter?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]()
            for (key0, ssmparameterstoreparameters0) in parametersContainer {
                var ssmparameterstoreparameters0Decoded0: [MgnClientTypes.SsmParameterStoreParameter]? = nil
                if let ssmparameterstoreparameters0 = ssmparameterstoreparameters0 {
                    ssmparameterstoreparameters0Decoded0 = [MgnClientTypes.SsmParameterStoreParameter]()
                    for structure1 in ssmparameterstoreparameters0 {
                        if let structure1 = structure1 {
                            ssmparameterstoreparameters0Decoded0?.append(structure1)
                        }
                    }
                }
                parametersDecoded0?[key0] = ssmparameterstoreparameters0Decoded0
            }
        }
        parameters = parametersDecoded0
    }
}

extension MgnClientTypes {
    /// AWS Systems Manager Document.
    public struct SsmDocument: Swift.Equatable {
        /// User-friendly name for the AWS Systems Manager Document.
        /// This member is required.
        public var actionName: Swift.String?
        /// If true, Cutover will not be enabled if the document has failed.
        public var mustSucceedForCutover: Swift.Bool?
        /// AWS Systems Manager Document parameters.
        public var parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
        /// AWS Systems Manager Document name or full ARN.
        /// This member is required.
        public var ssmDocumentName: Swift.String?
        /// AWS Systems Manager Document timeout seconds.
        public var timeoutSeconds: Swift.Int

        public init (
            actionName: Swift.String? = nil,
            mustSucceedForCutover: Swift.Bool? = nil,
            parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil,
            ssmDocumentName: Swift.String? = nil,
            timeoutSeconds: Swift.Int = 0
        )
        {
            self.actionName = actionName
            self.mustSucceedForCutover = mustSucceedForCutover
            self.parameters = parameters
            self.ssmDocumentName = ssmDocumentName
            self.timeoutSeconds = timeoutSeconds
        }
    }

}

extension MgnClientTypes {
    public enum SsmDocumentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automation
        case command
        case sdkUnknown(Swift.String)

        public static var allCases: [SsmDocumentType] {
            return [
                .automation,
                .command,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automation: return "AUTOMATION"
            case .command: return "COMMAND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SsmDocumentType(rawValue: rawValue) ?? SsmDocumentType.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.SsmParameterStoreParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterName
        case parameterType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterName = self.parameterName {
            try encodeContainer.encode(parameterName, forKey: .parameterName)
        }
        if let parameterType = self.parameterType {
            try encodeContainer.encode(parameterType.rawValue, forKey: .parameterType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SsmParameterStoreParameterType.self, forKey: .parameterType)
        parameterType = parameterTypeDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
    }
}

extension MgnClientTypes {
    /// AWS Systems Manager Parameter Store parameter.
    public struct SsmParameterStoreParameter: Swift.Equatable {
        /// AWS Systems Manager Parameter Store parameter name.
        /// This member is required.
        public var parameterName: Swift.String?
        /// AWS Systems Manager Parameter Store parameter type.
        /// This member is required.
        public var parameterType: MgnClientTypes.SsmParameterStoreParameterType?

        public init (
            parameterName: Swift.String? = nil,
            parameterType: MgnClientTypes.SsmParameterStoreParameterType? = nil
        )
        {
            self.parameterName = parameterName
            self.parameterType = parameterType
        }
    }

}

extension MgnClientTypes {
    public enum SsmParameterStoreParameterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case string
        case sdkUnknown(Swift.String)

        public static var allCases: [SsmParameterStoreParameterType] {
            return [
                .string,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .string: return "STRING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SsmParameterStoreParameterType(rawValue: rawValue) ?? SsmParameterStoreParameterType.sdkUnknown(rawValue)
        }
    }
}

extension StartCutoverInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartCutoverInput(sourceServerIDs: \(Swift.String(describing: sourceServerIDs)), tags: \"CONTENT_REDACTED\")"}
}

extension StartCutoverInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerIDs
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for sourceserverid0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(sourceserverid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartCutoverInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StartCutover"
    }
}

public struct StartCutoverInput: Swift.Equatable {
    /// Start Cutover by Source Server IDs.
    /// This member is required.
    public var sourceServerIDs: [Swift.String]?
    /// Start Cutover by Tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        sourceServerIDs: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.sourceServerIDs = sourceServerIDs
        self.tags = tags
    }
}

struct StartCutoverInputBody: Swift.Equatable {
    let sourceServerIDs: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension StartCutoverInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerIDs
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[Swift.String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [Swift.String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartCutoverOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartCutoverOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartCutoverOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartCutoverOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartCutoverOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StartCutoverOutputResponse: Swift.Equatable {
    /// Start Cutover Job response.
    public var job: MgnClientTypes.Job?

    public init (
        job: MgnClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct StartCutoverOutputResponseBody: Swift.Equatable {
    let job: MgnClientTypes.Job?
}

extension StartCutoverOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

extension StartReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension StartReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StartReplication"
    }
}

public struct StartReplicationInput: Swift.Equatable {
    /// ID of source server on which to start replication.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct StartReplicationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension StartReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension StartReplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartReplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartReplicationOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartReplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartReplicationOutputResponse(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

extension StartReplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartReplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.applicationID = nil
            self.arn = nil
            self.dataReplicationInfo = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.vcenterClientID = nil
        }
    }
}

public struct StartReplicationOutputResponse: Swift.Equatable {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init (
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.vcenterClientID = vcenterClientID
    }
}

struct StartReplicationOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
    let applicationID: Swift.String?
}

extension StartReplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case vcenterClientID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
    }
}

extension StartTestInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartTestInput(sourceServerIDs: \(Swift.String(describing: sourceServerIDs)), tags: \"CONTENT_REDACTED\")"}
}

extension StartTestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerIDs
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for sourceserverid0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(sourceserverid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartTestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StartTest"
    }
}

public struct StartTestInput: Swift.Equatable {
    /// Start Test for Source Server IDs.
    /// This member is required.
    public var sourceServerIDs: [Swift.String]?
    /// Start Test by Tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        sourceServerIDs: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.sourceServerIDs = sourceServerIDs
        self.tags = tags
    }
}

struct StartTestInputBody: Swift.Equatable {
    let sourceServerIDs: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension StartTestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerIDs
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[Swift.String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [Swift.String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartTestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartTestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartTestOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartTestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartTestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StartTestOutputResponse: Swift.Equatable {
    /// Start Test Job response.
    public var job: MgnClientTypes.Job?

    public init (
        job: MgnClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct StartTestOutputResponseBody: Swift.Equatable {
    let job: MgnClientTypes.Job?
}

extension StartTestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// Tag resource by ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tag resource by Tags.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension MgnClientTypes {
    public enum TargetInstanceTypeRightSizingMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basic
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetInstanceTypeRightSizingMethod] {
            return [
                .basic,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basic: return "BASIC"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetInstanceTypeRightSizingMethod(rawValue: rawValue) ?? TargetInstanceTypeRightSizingMethod.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.TemplateActionDocument: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionID
        case actionName
        case active
        case documentIdentifier
        case documentVersion
        case mustSucceedForCutover
        case operatingSystem
        case order
        case parameters
        case timeoutSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionID = self.actionID {
            try encodeContainer.encode(actionID, forKey: .actionID)
        }
        if let actionName = self.actionName {
            try encodeContainer.encode(actionName, forKey: .actionName)
        }
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let documentIdentifier = self.documentIdentifier {
            try encodeContainer.encode(documentIdentifier, forKey: .documentIdentifier)
        }
        if let documentVersion = self.documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let mustSucceedForCutover = self.mustSucceedForCutover {
            try encodeContainer.encode(mustSucceedForCutover, forKey: .mustSucceedForCutover)
        }
        if let operatingSystem = self.operatingSystem {
            try encodeContainer.encode(operatingSystem, forKey: .operatingSystem)
        }
        if order != 0 {
            try encodeContainer.encode(order, forKey: .order)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, ssmDocumentParameters0) in parameters {
                var ssmDocumentParameters0Container = parametersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for ssmparameterstoreparameter1 in ssmDocumentParameters0 {
                    try ssmDocumentParameters0Container.encode(ssmparameterstoreparameter1)
                }
            }
        }
        if timeoutSeconds != 0 {
            try encodeContainer.encode(timeoutSeconds, forKey: .timeoutSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionID)
        actionID = actionIDDecoded
        let actionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionName)
        actionName = actionNameDecoded
        let documentIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentIdentifier)
        documentIdentifier = documentIdentifierDecoded
        let orderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .order) ?? 0
        order = orderDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let timeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeoutSeconds) ?? 0
        timeoutSeconds = timeoutSecondsDecoded
        let mustSucceedForCutoverDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .mustSucceedForCutover)
        mustSucceedForCutover = mustSucceedForCutoverDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: [MgnClientTypes.SsmParameterStoreParameter?]?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]()
            for (key0, ssmparameterstoreparameters0) in parametersContainer {
                var ssmparameterstoreparameters0Decoded0: [MgnClientTypes.SsmParameterStoreParameter]? = nil
                if let ssmparameterstoreparameters0 = ssmparameterstoreparameters0 {
                    ssmparameterstoreparameters0Decoded0 = [MgnClientTypes.SsmParameterStoreParameter]()
                    for structure1 in ssmparameterstoreparameters0 {
                        if let structure1 = structure1 {
                            ssmparameterstoreparameters0Decoded0?.append(structure1)
                        }
                    }
                }
                parametersDecoded0?[key0] = ssmparameterstoreparameters0Decoded0
            }
        }
        parameters = parametersDecoded0
        let operatingSystemDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
    }
}

extension MgnClientTypes {
    public struct TemplateActionDocument: Swift.Equatable {
        /// Template post migration custom action ID.
        public var actionID: Swift.String?
        /// Template post migration custom action name.
        public var actionName: Swift.String?
        /// Template post migration custom action active status.
        public var active: Swift.Bool?
        /// Template post migration custom action document identifier.
        public var documentIdentifier: Swift.String?
        /// Template post migration custom action document version.
        public var documentVersion: Swift.String?
        /// Template post migration custom action must succeed for cutover.
        public var mustSucceedForCutover: Swift.Bool?
        /// Operating system eligible for this template post migration custom action.
        public var operatingSystem: Swift.String?
        /// Template post migration custom action order.
        public var order: Swift.Int
        /// Template post migration custom action parameters.
        public var parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]?
        /// Template post migration custom action timeout in seconds.
        public var timeoutSeconds: Swift.Int

        public init (
            actionID: Swift.String? = nil,
            actionName: Swift.String? = nil,
            active: Swift.Bool? = nil,
            documentIdentifier: Swift.String? = nil,
            documentVersion: Swift.String? = nil,
            mustSucceedForCutover: Swift.Bool? = nil,
            operatingSystem: Swift.String? = nil,
            order: Swift.Int = 0,
            parameters: [Swift.String:[MgnClientTypes.SsmParameterStoreParameter]]? = nil,
            timeoutSeconds: Swift.Int = 0
        )
        {
            self.actionID = actionID
            self.actionName = actionName
            self.active = active
            self.documentIdentifier = documentIdentifier
            self.documentVersion = documentVersion
            self.mustSucceedForCutover = mustSucceedForCutover
            self.operatingSystem = operatingSystem
            self.order = order
            self.parameters = parameters
            self.timeoutSeconds = timeoutSeconds
        }
    }

}

extension MgnClientTypes.TemplateActionsRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionIDs = actionIDs {
            var actionIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actionIDs)
            for actionid0 in actionIDs {
                try actionIDsContainer.encode(actionid0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actionIDs)
        var actionIDsDecoded0:[Swift.String]? = nil
        if let actionIDsContainer = actionIDsContainer {
            actionIDsDecoded0 = [Swift.String]()
            for string0 in actionIDsContainer {
                if let string0 = string0 {
                    actionIDsDecoded0?.append(string0)
                }
            }
        }
        actionIDs = actionIDsDecoded0
    }
}

extension MgnClientTypes {
    /// Template post migration custom action filters.
    public struct TemplateActionsRequestFilters: Swift.Equatable {
        /// Action IDs to filter template post migration custom actions by.
        public var actionIDs: [Swift.String]?

        public init (
            actionIDs: [Swift.String]? = nil
        )
        {
            self.actionIDs = actionIDs
        }
    }

}

extension TerminateTargetInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TerminateTargetInstancesInput(sourceServerIDs: \(Swift.String(describing: sourceServerIDs)), tags: \"CONTENT_REDACTED\")"}
}

extension TerminateTargetInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerIDs
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for sourceserverid0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(sourceserverid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TerminateTargetInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/TerminateTargetInstances"
    }
}

public struct TerminateTargetInstancesInput: Swift.Equatable {
    /// Terminate Target instance by Source Server IDs.
    /// This member is required.
    public var sourceServerIDs: [Swift.String]?
    /// Terminate Target instance by Tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        sourceServerIDs: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.sourceServerIDs = sourceServerIDs
        self.tags = tags
    }
}

struct TerminateTargetInstancesInputBody: Swift.Equatable {
    let sourceServerIDs: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension TerminateTargetInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerIDs
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[Swift.String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [Swift.String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TerminateTargetInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TerminateTargetInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TerminateTargetInstancesOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TerminateTargetInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TerminateTargetInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct TerminateTargetInstancesOutputResponse: Swift.Equatable {
    /// Terminate Target instance Job response.
    public var job: MgnClientTypes.Job?

    public init (
        job: MgnClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct TerminateTargetInstancesOutputResponseBody: Swift.Equatable {
    let job: MgnClientTypes.Job?
}

extension TerminateTargetInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Reached throttling quota exception.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Reached throttling quota exception.
    public var quotaCode: Swift.String?
    /// Reached throttling quota exception will retry after x seconds.
    public var retryAfterSeconds: Swift.String?
    /// Reached throttling quota exception service code.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension UnarchiveApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationID = self.applicationID {
            try encodeContainer.encode(applicationID, forKey: .applicationID)
        }
    }
}

extension UnarchiveApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UnarchiveApplication"
    }
}

public struct UnarchiveApplicationInput: Swift.Equatable {
    /// Application ID.
    /// This member is required.
    public var applicationID: Swift.String?

    public init (
        applicationID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
    }
}

struct UnarchiveApplicationInputBody: Swift.Equatable {
    let applicationID: Swift.String?
}

extension UnarchiveApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
    }
}

extension UnarchiveApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnarchiveApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UnarchiveApplicationOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnarchiveApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnarchiveApplicationOutputResponse(applicationAggregatedStatus: \(Swift.String(describing: applicationAggregatedStatus)), applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension UnarchiveApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnarchiveApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationAggregatedStatus = output.applicationAggregatedStatus
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.isArchived = output.isArchived
            self.lastModifiedDateTime = output.lastModifiedDateTime
            self.name = output.name
            self.tags = output.tags
            self.waveID = output.waveID
        } else {
            self.applicationAggregatedStatus = nil
            self.applicationID = nil
            self.arn = nil
            self.creationDateTime = nil
            self.description = nil
            self.isArchived = nil
            self.lastModifiedDateTime = nil
            self.name = nil
            self.tags = nil
            self.waveID = nil
        }
    }
}

public struct UnarchiveApplicationOutputResponse: Swift.Equatable {
    /// Application aggregated status.
    public var applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
    /// Application ID.
    public var applicationID: Swift.String?
    /// Application ARN.
    public var arn: Swift.String?
    /// Application creation dateTime.
    public var creationDateTime: Swift.String?
    /// Application description.
    public var description: Swift.String?
    /// Application archival status.
    public var isArchived: Swift.Bool?
    /// Application last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Application name.
    public var name: Swift.String?
    /// Application tags.
    public var tags: [Swift.String:Swift.String]?
    /// Application wave ID.
    public var waveID: Swift.String?

    public init (
        applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus? = nil,
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.applicationAggregatedStatus = applicationAggregatedStatus
        self.applicationID = applicationID
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveID = waveID
    }
}

struct UnarchiveApplicationOutputResponseBody: Swift.Equatable {
    let applicationID: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let isArchived: Swift.Bool?
    let applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
    let creationDateTime: Swift.String?
    let lastModifiedDateTime: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let waveID: Swift.String?
}

extension UnarchiveApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationAggregatedStatus
        case applicationID
        case arn
        case creationDateTime
        case description
        case isArchived
        case lastModifiedDateTime
        case name
        case tags
        case waveID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let applicationAggregatedStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ApplicationAggregatedStatus.self, forKey: .applicationAggregatedStatus)
        applicationAggregatedStatus = applicationAggregatedStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
    }
}

extension UnarchiveWaveInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case waveID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let waveID = self.waveID {
            try encodeContainer.encode(waveID, forKey: .waveID)
        }
    }
}

extension UnarchiveWaveInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UnarchiveWave"
    }
}

public struct UnarchiveWaveInput: Swift.Equatable {
    /// Wave ID.
    /// This member is required.
    public var waveID: Swift.String?

    public init (
        waveID: Swift.String? = nil
    )
    {
        self.waveID = waveID
    }
}

struct UnarchiveWaveInputBody: Swift.Equatable {
    let waveID: Swift.String?
}

extension UnarchiveWaveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case waveID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
    }
}

extension UnarchiveWaveOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnarchiveWaveOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UnarchiveWaveOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnarchiveWaveOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnarchiveWaveOutputResponse(arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveAggregatedStatus: \(Swift.String(describing: waveAggregatedStatus)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension UnarchiveWaveOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnarchiveWaveOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.isArchived = output.isArchived
            self.lastModifiedDateTime = output.lastModifiedDateTime
            self.name = output.name
            self.tags = output.tags
            self.waveAggregatedStatus = output.waveAggregatedStatus
            self.waveID = output.waveID
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.description = nil
            self.isArchived = nil
            self.lastModifiedDateTime = nil
            self.name = nil
            self.tags = nil
            self.waveAggregatedStatus = nil
            self.waveID = nil
        }
    }
}

public struct UnarchiveWaveOutputResponse: Swift.Equatable {
    /// Wave ARN.
    public var arn: Swift.String?
    /// Wave creation dateTime.
    public var creationDateTime: Swift.String?
    /// Wave description.
    public var description: Swift.String?
    /// Wave archival status.
    public var isArchived: Swift.Bool?
    /// Wave last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Wave name.
    public var name: Swift.String?
    /// Wave tags.
    public var tags: [Swift.String:Swift.String]?
    /// Wave aggregated status.
    public var waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
    /// Wave ID.
    public var waveID: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveAggregatedStatus = waveAggregatedStatus
        self.waveID = waveID
    }
}

struct UnarchiveWaveOutputResponseBody: Swift.Equatable {
    let waveID: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let isArchived: Swift.Bool?
    let waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
    let creationDateTime: Swift.String?
    let lastModifiedDateTime: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UnarchiveWaveOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case description
        case isArchived
        case lastModifiedDateTime
        case name
        case tags
        case waveAggregatedStatus
        case waveID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let waveAggregatedStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.WaveAggregatedStatus.self, forKey: .waveAggregatedStatus)
        waveAggregatedStatus = waveAggregatedStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UninitializedAccountException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UninitializedAccountExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Uninitialized account exception.
public struct UninitializedAccountException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct UninitializedAccountExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension UninitializedAccountExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \"CONTENT_REDACTED\")"}
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// Untag resource by ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Untag resource by Keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationID = self.applicationID {
            try encodeContainer.encode(applicationID, forKey: .applicationID)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateApplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateApplication"
    }
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// Application ID.
    /// This member is required.
    public var applicationID: Swift.String?
    /// Application description.
    public var description: Swift.String?
    /// Application name.
    public var name: Swift.String?

    public init (
        applicationID: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.description = description
        self.name = name
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    let applicationID: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case description
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateApplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateApplicationOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateApplicationOutputResponse(applicationAggregatedStatus: \(Swift.String(describing: applicationAggregatedStatus)), applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension UpdateApplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationAggregatedStatus = output.applicationAggregatedStatus
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.isArchived = output.isArchived
            self.lastModifiedDateTime = output.lastModifiedDateTime
            self.name = output.name
            self.tags = output.tags
            self.waveID = output.waveID
        } else {
            self.applicationAggregatedStatus = nil
            self.applicationID = nil
            self.arn = nil
            self.creationDateTime = nil
            self.description = nil
            self.isArchived = nil
            self.lastModifiedDateTime = nil
            self.name = nil
            self.tags = nil
            self.waveID = nil
        }
    }
}

public struct UpdateApplicationOutputResponse: Swift.Equatable {
    /// Application aggregated status.
    public var applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
    /// Application ID.
    public var applicationID: Swift.String?
    /// Application ARN.
    public var arn: Swift.String?
    /// Application creation dateTime.
    public var creationDateTime: Swift.String?
    /// Application description.
    public var description: Swift.String?
    /// Application archival status.
    public var isArchived: Swift.Bool?
    /// Application last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Application name.
    public var name: Swift.String?
    /// Application tags.
    public var tags: [Swift.String:Swift.String]?
    /// Application wave ID.
    public var waveID: Swift.String?

    public init (
        applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus? = nil,
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.applicationAggregatedStatus = applicationAggregatedStatus
        self.applicationID = applicationID
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveID = waveID
    }
}

struct UpdateApplicationOutputResponseBody: Swift.Equatable {
    let applicationID: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let isArchived: Swift.Bool?
    let applicationAggregatedStatus: MgnClientTypes.ApplicationAggregatedStatus?
    let creationDateTime: Swift.String?
    let lastModifiedDateTime: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let waveID: Swift.String?
}

extension UpdateApplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationAggregatedStatus
        case applicationID
        case arn
        case creationDateTime
        case description
        case isArchived
        case lastModifiedDateTime
        case name
        case tags
        case waveID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let applicationAggregatedStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ApplicationAggregatedStatus.self, forKey: .applicationAggregatedStatus)
        applicationAggregatedStatus = applicationAggregatedStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
    }
}

extension UpdateLaunchConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bootMode
        case copyPrivateIp
        case copyTags
        case enableMapAutoTagging
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case name
        case postLaunchActions
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bootMode = self.bootMode {
            try encodeContainer.encode(bootMode.rawValue, forKey: .bootMode)
        }
        if let copyPrivateIp = self.copyPrivateIp {
            try encodeContainer.encode(copyPrivateIp, forKey: .copyPrivateIp)
        }
        if let copyTags = self.copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let enableMapAutoTagging = self.enableMapAutoTagging {
            try encodeContainer.encode(enableMapAutoTagging, forKey: .enableMapAutoTagging)
        }
        if let launchDisposition = self.launchDisposition {
            try encodeContainer.encode(launchDisposition.rawValue, forKey: .launchDisposition)
        }
        if let licensing = self.licensing {
            try encodeContainer.encode(licensing, forKey: .licensing)
        }
        if let mapAutoTaggingMpeID = self.mapAutoTaggingMpeID {
            try encodeContainer.encode(mapAutoTaggingMpeID, forKey: .mapAutoTaggingMpeID)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let postLaunchActions = self.postLaunchActions {
            try encodeContainer.encode(postLaunchActions, forKey: .postLaunchActions)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let targetInstanceTypeRightSizingMethod = self.targetInstanceTypeRightSizingMethod {
            try encodeContainer.encode(targetInstanceTypeRightSizingMethod.rawValue, forKey: .targetInstanceTypeRightSizingMethod)
        }
    }
}

extension UpdateLaunchConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateLaunchConfiguration"
    }
}

public struct UpdateLaunchConfigurationInput: Swift.Equatable {
    /// Update Launch configuration boot mode request.
    public var bootMode: MgnClientTypes.BootMode?
    /// Update Launch configuration copy Private IP request.
    public var copyPrivateIp: Swift.Bool?
    /// Update Launch configuration copy Tags request.
    public var copyTags: Swift.Bool?
    /// Enable map auto tagging.
    public var enableMapAutoTagging: Swift.Bool?
    /// Update Launch configuration launch disposition request.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Update Launch configuration licensing request.
    public var licensing: MgnClientTypes.Licensing?
    /// Launch configuration map auto tagging MPE ID.
    public var mapAutoTaggingMpeID: Swift.String?
    /// Update Launch configuration name request.
    public var name: Swift.String?
    /// Post Launch Actions to executed on the Test or Cutover instance.
    public var postLaunchActions: MgnClientTypes.PostLaunchActions?
    /// Update Launch configuration by Source Server ID request.
    /// This member is required.
    public var sourceServerID: Swift.String?
    /// Update Launch configuration Target instance right sizing request.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init (
        bootMode: MgnClientTypes.BootMode? = nil,
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        enableMapAutoTagging: Swift.Bool? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        mapAutoTaggingMpeID: Swift.String? = nil,
        name: Swift.String? = nil,
        postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
        sourceServerID: Swift.String? = nil,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.bootMode = bootMode
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.enableMapAutoTagging = enableMapAutoTagging
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
        self.name = name
        self.postLaunchActions = postLaunchActions
        self.sourceServerID = sourceServerID
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct UpdateLaunchConfigurationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let launchDisposition: MgnClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: MgnClientTypes.Licensing?
    let bootMode: MgnClientTypes.BootMode?
    let postLaunchActions: MgnClientTypes.PostLaunchActions?
    let enableMapAutoTagging: Swift.Bool?
    let mapAutoTaggingMpeID: Swift.String?
}

extension UpdateLaunchConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bootMode
        case copyPrivateIp
        case copyTags
        case enableMapAutoTagging
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case name
        case postLaunchActions
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(MgnClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let bootModeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.BootMode.self, forKey: .bootMode)
        bootMode = bootModeDecoded
        let postLaunchActionsDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActions.self, forKey: .postLaunchActions)
        postLaunchActions = postLaunchActionsDecoded
        let enableMapAutoTaggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMapAutoTagging)
        enableMapAutoTagging = enableMapAutoTaggingDecoded
        let mapAutoTaggingMpeIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapAutoTaggingMpeID)
        mapAutoTaggingMpeID = mapAutoTaggingMpeIDDecoded
    }
}

extension UpdateLaunchConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLaunchConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateLaunchConfigurationOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLaunchConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateLaunchConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bootMode = output.bootMode
            self.copyPrivateIp = output.copyPrivateIp
            self.copyTags = output.copyTags
            self.ec2LaunchTemplateID = output.ec2LaunchTemplateID
            self.enableMapAutoTagging = output.enableMapAutoTagging
            self.launchDisposition = output.launchDisposition
            self.licensing = output.licensing
            self.mapAutoTaggingMpeID = output.mapAutoTaggingMpeID
            self.name = output.name
            self.postLaunchActions = output.postLaunchActions
            self.sourceServerID = output.sourceServerID
            self.targetInstanceTypeRightSizingMethod = output.targetInstanceTypeRightSizingMethod
        } else {
            self.bootMode = nil
            self.copyPrivateIp = nil
            self.copyTags = nil
            self.ec2LaunchTemplateID = nil
            self.enableMapAutoTagging = nil
            self.launchDisposition = nil
            self.licensing = nil
            self.mapAutoTaggingMpeID = nil
            self.name = nil
            self.postLaunchActions = nil
            self.sourceServerID = nil
            self.targetInstanceTypeRightSizingMethod = nil
        }
    }
}

public struct UpdateLaunchConfigurationOutputResponse: Swift.Equatable {
    /// Launch configuration boot mode.
    public var bootMode: MgnClientTypes.BootMode?
    /// Copy Private IP during Launch Configuration.
    public var copyPrivateIp: Swift.Bool?
    /// Copy Tags during Launch Configuration.
    public var copyTags: Swift.Bool?
    /// Launch configuration EC2 Launch template ID.
    public var ec2LaunchTemplateID: Swift.String?
    /// Enable map auto tagging.
    public var enableMapAutoTagging: Swift.Bool?
    /// Launch disposition for launch configuration.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Launch configuration OS licensing.
    public var licensing: MgnClientTypes.Licensing?
    /// Map auto tagging MPE ID.
    public var mapAutoTaggingMpeID: Swift.String?
    /// Launch configuration name.
    public var name: Swift.String?
    /// Post Launch Actions to executed on the Test or Cutover instance.
    public var postLaunchActions: MgnClientTypes.PostLaunchActions?
    /// Launch configuration Source Server ID.
    public var sourceServerID: Swift.String?
    /// Launch configuration Target instance type right sizing method.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init (
        bootMode: MgnClientTypes.BootMode? = nil,
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        ec2LaunchTemplateID: Swift.String? = nil,
        enableMapAutoTagging: Swift.Bool? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        mapAutoTaggingMpeID: Swift.String? = nil,
        name: Swift.String? = nil,
        postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
        sourceServerID: Swift.String? = nil,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.bootMode = bootMode
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.ec2LaunchTemplateID = ec2LaunchTemplateID
        self.enableMapAutoTagging = enableMapAutoTagging
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
        self.name = name
        self.postLaunchActions = postLaunchActions
        self.sourceServerID = sourceServerID
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct UpdateLaunchConfigurationOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let ec2LaunchTemplateID: Swift.String?
    let launchDisposition: MgnClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: MgnClientTypes.Licensing?
    let bootMode: MgnClientTypes.BootMode?
    let postLaunchActions: MgnClientTypes.PostLaunchActions?
    let enableMapAutoTagging: Swift.Bool?
    let mapAutoTaggingMpeID: Swift.String?
}

extension UpdateLaunchConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bootMode
        case copyPrivateIp
        case copyTags
        case ec2LaunchTemplateID
        case enableMapAutoTagging
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case name
        case postLaunchActions
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ec2LaunchTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2LaunchTemplateID)
        ec2LaunchTemplateID = ec2LaunchTemplateIDDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(MgnClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let bootModeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.BootMode.self, forKey: .bootMode)
        bootMode = bootModeDecoded
        let postLaunchActionsDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActions.self, forKey: .postLaunchActions)
        postLaunchActions = postLaunchActionsDecoded
        let enableMapAutoTaggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMapAutoTagging)
        enableMapAutoTagging = enableMapAutoTaggingDecoded
        let mapAutoTaggingMpeIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapAutoTaggingMpeID)
        mapAutoTaggingMpeID = mapAutoTaggingMpeIDDecoded
    }
}

extension UpdateLaunchConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatePublicIpAddress
        case bootMode
        case copyPrivateIp
        case copyTags
        case enableMapAutoTagging
        case largeVolumeConf
        case launchConfigurationTemplateID
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case postLaunchActions
        case smallVolumeConf
        case smallVolumeMaxSize
        case targetInstanceTypeRightSizingMethod
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatePublicIpAddress = self.associatePublicIpAddress {
            try encodeContainer.encode(associatePublicIpAddress, forKey: .associatePublicIpAddress)
        }
        if let bootMode = self.bootMode {
            try encodeContainer.encode(bootMode.rawValue, forKey: .bootMode)
        }
        if let copyPrivateIp = self.copyPrivateIp {
            try encodeContainer.encode(copyPrivateIp, forKey: .copyPrivateIp)
        }
        if let copyTags = self.copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let enableMapAutoTagging = self.enableMapAutoTagging {
            try encodeContainer.encode(enableMapAutoTagging, forKey: .enableMapAutoTagging)
        }
        if let largeVolumeConf = self.largeVolumeConf {
            try encodeContainer.encode(largeVolumeConf, forKey: .largeVolumeConf)
        }
        if let launchConfigurationTemplateID = self.launchConfigurationTemplateID {
            try encodeContainer.encode(launchConfigurationTemplateID, forKey: .launchConfigurationTemplateID)
        }
        if let launchDisposition = self.launchDisposition {
            try encodeContainer.encode(launchDisposition.rawValue, forKey: .launchDisposition)
        }
        if let licensing = self.licensing {
            try encodeContainer.encode(licensing, forKey: .licensing)
        }
        if let mapAutoTaggingMpeID = self.mapAutoTaggingMpeID {
            try encodeContainer.encode(mapAutoTaggingMpeID, forKey: .mapAutoTaggingMpeID)
        }
        if let postLaunchActions = self.postLaunchActions {
            try encodeContainer.encode(postLaunchActions, forKey: .postLaunchActions)
        }
        if let smallVolumeConf = self.smallVolumeConf {
            try encodeContainer.encode(smallVolumeConf, forKey: .smallVolumeConf)
        }
        if smallVolumeMaxSize != 0 {
            try encodeContainer.encode(smallVolumeMaxSize, forKey: .smallVolumeMaxSize)
        }
        if let targetInstanceTypeRightSizingMethod = self.targetInstanceTypeRightSizingMethod {
            try encodeContainer.encode(targetInstanceTypeRightSizingMethod.rawValue, forKey: .targetInstanceTypeRightSizingMethod)
        }
    }
}

extension UpdateLaunchConfigurationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateLaunchConfigurationTemplate"
    }
}

public struct UpdateLaunchConfigurationTemplateInput: Swift.Equatable {
    /// Associate public Ip address.
    public var associatePublicIpAddress: Swift.Bool?
    /// Launch configuration template boot mode.
    public var bootMode: MgnClientTypes.BootMode?
    /// Copy private Ip.
    public var copyPrivateIp: Swift.Bool?
    /// Copy tags.
    public var copyTags: Swift.Bool?
    /// Enable map auto tagging.
    public var enableMapAutoTagging: Swift.Bool?
    /// Large volume config.
    public var largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// Launch Configuration Template ID.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?
    /// Launch disposition.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Configure Licensing.
    public var licensing: MgnClientTypes.Licensing?
    /// Launch configuration template map auto tagging MPE ID.
    public var mapAutoTaggingMpeID: Swift.String?
    /// Post Launch Action to execute on the Test or Cutover instance.
    public var postLaunchActions: MgnClientTypes.PostLaunchActions?
    /// Small volume config.
    public var smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// Small volume maximum size.
    public var smallVolumeMaxSize: Swift.Int
    /// Target instance type right-sizing method.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init (
        associatePublicIpAddress: Swift.Bool? = nil,
        bootMode: MgnClientTypes.BootMode? = nil,
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        enableMapAutoTagging: Swift.Bool? = nil,
        largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        launchConfigurationTemplateID: Swift.String? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        mapAutoTaggingMpeID: Swift.String? = nil,
        postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
        smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        smallVolumeMaxSize: Swift.Int = 0,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.associatePublicIpAddress = associatePublicIpAddress
        self.bootMode = bootMode
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.enableMapAutoTagging = enableMapAutoTagging
        self.largeVolumeConf = largeVolumeConf
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
        self.postLaunchActions = postLaunchActions
        self.smallVolumeConf = smallVolumeConf
        self.smallVolumeMaxSize = smallVolumeMaxSize
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct UpdateLaunchConfigurationTemplateInputBody: Swift.Equatable {
    let launchConfigurationTemplateID: Swift.String?
    let postLaunchActions: MgnClientTypes.PostLaunchActions?
    let enableMapAutoTagging: Swift.Bool?
    let mapAutoTaggingMpeID: Swift.String?
    let launchDisposition: MgnClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let associatePublicIpAddress: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: MgnClientTypes.Licensing?
    let bootMode: MgnClientTypes.BootMode?
    let smallVolumeMaxSize: Swift.Int
    let smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    let largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
}

extension UpdateLaunchConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatePublicIpAddress
        case bootMode
        case copyPrivateIp
        case copyTags
        case enableMapAutoTagging
        case largeVolumeConf
        case launchConfigurationTemplateID
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case postLaunchActions
        case smallVolumeConf
        case smallVolumeMaxSize
        case targetInstanceTypeRightSizingMethod
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationTemplateID)
        launchConfigurationTemplateID = launchConfigurationTemplateIDDecoded
        let postLaunchActionsDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActions.self, forKey: .postLaunchActions)
        postLaunchActions = postLaunchActionsDecoded
        let enableMapAutoTaggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMapAutoTagging)
        enableMapAutoTagging = enableMapAutoTaggingDecoded
        let mapAutoTaggingMpeIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapAutoTaggingMpeID)
        mapAutoTaggingMpeID = mapAutoTaggingMpeIDDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(MgnClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let associatePublicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associatePublicIpAddress)
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let bootModeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.BootMode.self, forKey: .bootMode)
        bootMode = bootModeDecoded
        let smallVolumeMaxSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .smallVolumeMaxSize) ?? 0
        smallVolumeMaxSize = smallVolumeMaxSizeDecoded
        let smallVolumeConfDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchTemplateDiskConf.self, forKey: .smallVolumeConf)
        smallVolumeConf = smallVolumeConfDecoded
        let largeVolumeConfDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchTemplateDiskConf.self, forKey: .largeVolumeConf)
        largeVolumeConf = largeVolumeConfDecoded
    }
}

extension UpdateLaunchConfigurationTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLaunchConfigurationTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateLaunchConfigurationTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLaunchConfigurationTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateLaunchConfigurationTemplateOutputResponse(arn: \(Swift.String(describing: arn)), associatePublicIpAddress: \(Swift.String(describing: associatePublicIpAddress)), bootMode: \(Swift.String(describing: bootMode)), copyPrivateIp: \(Swift.String(describing: copyPrivateIp)), copyTags: \(Swift.String(describing: copyTags)), ec2LaunchTemplateID: \(Swift.String(describing: ec2LaunchTemplateID)), enableMapAutoTagging: \(Swift.String(describing: enableMapAutoTagging)), largeVolumeConf: \(Swift.String(describing: largeVolumeConf)), launchConfigurationTemplateID: \(Swift.String(describing: launchConfigurationTemplateID)), launchDisposition: \(Swift.String(describing: launchDisposition)), licensing: \(Swift.String(describing: licensing)), mapAutoTaggingMpeID: \(Swift.String(describing: mapAutoTaggingMpeID)), postLaunchActions: \(Swift.String(describing: postLaunchActions)), smallVolumeConf: \(Swift.String(describing: smallVolumeConf)), smallVolumeMaxSize: \(Swift.String(describing: smallVolumeMaxSize)), targetInstanceTypeRightSizingMethod: \(Swift.String(describing: targetInstanceTypeRightSizingMethod)), tags: \"CONTENT_REDACTED\")"}
}

extension UpdateLaunchConfigurationTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateLaunchConfigurationTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associatePublicIpAddress = output.associatePublicIpAddress
            self.bootMode = output.bootMode
            self.copyPrivateIp = output.copyPrivateIp
            self.copyTags = output.copyTags
            self.ec2LaunchTemplateID = output.ec2LaunchTemplateID
            self.enableMapAutoTagging = output.enableMapAutoTagging
            self.largeVolumeConf = output.largeVolumeConf
            self.launchConfigurationTemplateID = output.launchConfigurationTemplateID
            self.launchDisposition = output.launchDisposition
            self.licensing = output.licensing
            self.mapAutoTaggingMpeID = output.mapAutoTaggingMpeID
            self.postLaunchActions = output.postLaunchActions
            self.smallVolumeConf = output.smallVolumeConf
            self.smallVolumeMaxSize = output.smallVolumeMaxSize
            self.tags = output.tags
            self.targetInstanceTypeRightSizingMethod = output.targetInstanceTypeRightSizingMethod
        } else {
            self.arn = nil
            self.associatePublicIpAddress = nil
            self.bootMode = nil
            self.copyPrivateIp = nil
            self.copyTags = nil
            self.ec2LaunchTemplateID = nil
            self.enableMapAutoTagging = nil
            self.largeVolumeConf = nil
            self.launchConfigurationTemplateID = nil
            self.launchDisposition = nil
            self.licensing = nil
            self.mapAutoTaggingMpeID = nil
            self.postLaunchActions = nil
            self.smallVolumeConf = nil
            self.smallVolumeMaxSize = 0
            self.tags = nil
            self.targetInstanceTypeRightSizingMethod = nil
        }
    }
}

public struct UpdateLaunchConfigurationTemplateOutputResponse: Swift.Equatable {
    /// ARN of the Launch Configuration Template.
    public var arn: Swift.String?
    /// Associate public Ip address.
    public var associatePublicIpAddress: Swift.Bool?
    /// Launch configuration template boot mode.
    public var bootMode: MgnClientTypes.BootMode?
    /// Copy private Ip.
    public var copyPrivateIp: Swift.Bool?
    /// Copy tags.
    public var copyTags: Swift.Bool?
    /// EC2 launch template ID.
    public var ec2LaunchTemplateID: Swift.String?
    /// Enable map auto tagging.
    public var enableMapAutoTagging: Swift.Bool?
    /// Large volume config.
    public var largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// ID of the Launch Configuration Template.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?
    /// Launch disposition.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Configure Licensing.
    public var licensing: MgnClientTypes.Licensing?
    /// Launch configuration template map auto tagging MPE ID.
    public var mapAutoTaggingMpeID: Swift.String?
    /// Post Launch Actions of the Launch Configuration Template.
    public var postLaunchActions: MgnClientTypes.PostLaunchActions?
    /// Small volume config.
    public var smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    /// Small volume maximum size.
    public var smallVolumeMaxSize: Swift.Int
    /// Tags of the Launch Configuration Template.
    public var tags: [Swift.String:Swift.String]?
    /// Target instance type right-sizing method.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init (
        arn: Swift.String? = nil,
        associatePublicIpAddress: Swift.Bool? = nil,
        bootMode: MgnClientTypes.BootMode? = nil,
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        ec2LaunchTemplateID: Swift.String? = nil,
        enableMapAutoTagging: Swift.Bool? = nil,
        largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        launchConfigurationTemplateID: Swift.String? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        mapAutoTaggingMpeID: Swift.String? = nil,
        postLaunchActions: MgnClientTypes.PostLaunchActions? = nil,
        smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf? = nil,
        smallVolumeMaxSize: Swift.Int = 0,
        tags: [Swift.String:Swift.String]? = nil,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.arn = arn
        self.associatePublicIpAddress = associatePublicIpAddress
        self.bootMode = bootMode
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.ec2LaunchTemplateID = ec2LaunchTemplateID
        self.enableMapAutoTagging = enableMapAutoTagging
        self.largeVolumeConf = largeVolumeConf
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.mapAutoTaggingMpeID = mapAutoTaggingMpeID
        self.postLaunchActions = postLaunchActions
        self.smallVolumeConf = smallVolumeConf
        self.smallVolumeMaxSize = smallVolumeMaxSize
        self.tags = tags
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct UpdateLaunchConfigurationTemplateOutputResponseBody: Swift.Equatable {
    let launchConfigurationTemplateID: Swift.String?
    let arn: Swift.String?
    let postLaunchActions: MgnClientTypes.PostLaunchActions?
    let enableMapAutoTagging: Swift.Bool?
    let mapAutoTaggingMpeID: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let ec2LaunchTemplateID: Swift.String?
    let launchDisposition: MgnClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let associatePublicIpAddress: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: MgnClientTypes.Licensing?
    let bootMode: MgnClientTypes.BootMode?
    let smallVolumeMaxSize: Swift.Int
    let smallVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
    let largeVolumeConf: MgnClientTypes.LaunchTemplateDiskConf?
}

extension UpdateLaunchConfigurationTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associatePublicIpAddress
        case bootMode
        case copyPrivateIp
        case copyTags
        case ec2LaunchTemplateID
        case enableMapAutoTagging
        case largeVolumeConf
        case launchConfigurationTemplateID
        case launchDisposition
        case licensing
        case mapAutoTaggingMpeID
        case postLaunchActions
        case smallVolumeConf
        case smallVolumeMaxSize
        case tags
        case targetInstanceTypeRightSizingMethod
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationTemplateID)
        launchConfigurationTemplateID = launchConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let postLaunchActionsDecoded = try containerValues.decodeIfPresent(MgnClientTypes.PostLaunchActions.self, forKey: .postLaunchActions)
        postLaunchActions = postLaunchActionsDecoded
        let enableMapAutoTaggingDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enableMapAutoTagging)
        enableMapAutoTagging = enableMapAutoTaggingDecoded
        let mapAutoTaggingMpeIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mapAutoTaggingMpeID)
        mapAutoTaggingMpeID = mapAutoTaggingMpeIDDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let ec2LaunchTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2LaunchTemplateID)
        ec2LaunchTemplateID = ec2LaunchTemplateIDDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(MgnClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let associatePublicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associatePublicIpAddress)
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let bootModeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.BootMode.self, forKey: .bootMode)
        bootMode = bootModeDecoded
        let smallVolumeMaxSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .smallVolumeMaxSize) ?? 0
        smallVolumeMaxSize = smallVolumeMaxSizeDecoded
        let smallVolumeConfDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchTemplateDiskConf.self, forKey: .smallVolumeConf)
        smallVolumeConf = smallVolumeConfDecoded
        let largeVolumeConfDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchTemplateDiskConf.self, forKey: .largeVolumeConf)
        largeVolumeConf = largeVolumeConfDecoded
    }
}

extension UpdateReplicationConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReplicationConfigurationInput(associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), name: \(Swift.String(describing: name)), replicatedDisks: \(Swift.String(describing: replicatedDisks)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), sourceServerID: \(Swift.String(describing: sourceServerID)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), stagingAreaTags: \"CONTENT_REDACTED\")"}
}

extension UpdateReplicationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associateDefaultSecurityGroup = self.associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = self.createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = self.dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = self.defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = self.ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = self.ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let replicatedDisks = replicatedDisks {
            var replicatedDisksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicatedDisks)
            for replicationconfigurationreplicateddisk0 in replicatedDisks {
                try replicatedDisksContainer.encode(replicationconfigurationreplicateddisk0)
            }
        }
        if let replicationServerInstanceType = self.replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for securitygroupid0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(securitygroupid0)
            }
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let stagingAreaSubnetId = self.stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsMap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = self.useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
    }
}

extension UpdateReplicationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateReplicationConfiguration"
    }
}

public struct UpdateReplicationConfigurationInput: Swift.Equatable {
    /// Update replication configuration associate default Application Migration Service Security group request.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Update replication configuration bandwidth throttling request.
    public var bandwidthThrottling: Swift.Int
    /// Update replication configuration create Public IP request.
    public var createPublicIP: Swift.Bool?
    /// Update replication configuration data plane routing request.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Update replication configuration use default large Staging Disk type request.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Update replication configuration EBS encryption request.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Update replication configuration EBS encryption key ARN request.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Update replication configuration name request.
    public var name: Swift.String?
    /// Update replication configuration replicated disks request.
    public var replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]?
    /// Update replication configuration Replication Server instance type request.
    public var replicationServerInstanceType: Swift.String?
    /// Update replication configuration Replication Server Security Groups IDs request.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Update replication configuration Source Server ID request.
    /// This member is required.
    public var sourceServerID: Swift.String?
    /// Update replication configuration Staging Area subnet request.
    public var stagingAreaSubnetId: Swift.String?
    /// Update replication configuration Staging Area Tags request.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Update replication configuration use dedicated Replication Server request.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init (
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        sourceServerID: Swift.String? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.name = name
        self.replicatedDisks = replicatedDisks
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.sourceServerID = sourceServerID
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct UpdateReplicationConfigurationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]?
    let ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
}

extension UpdateReplicationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([MgnClientTypes.ReplicationConfigurationReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[MgnClientTypes.ReplicationConfigurationReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [MgnClientTypes.ReplicationConfigurationReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
    }
}

extension UpdateReplicationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateReplicationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateReplicationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateReplicationConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReplicationConfigurationOutputResponse(associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), name: \(Swift.String(describing: name)), replicatedDisks: \(Swift.String(describing: replicatedDisks)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), sourceServerID: \(Swift.String(describing: sourceServerID)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), stagingAreaTags: \"CONTENT_REDACTED\")"}
}

extension UpdateReplicationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateReplicationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.name = output.name
            self.replicatedDisks = output.replicatedDisks
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.sourceServerID = output.sourceServerID
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
        } else {
            self.associateDefaultSecurityGroup = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.name = nil
            self.replicatedDisks = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.sourceServerID = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.useDedicatedReplicationServer = nil
        }
    }
}

public struct UpdateReplicationConfigurationOutputResponse: Swift.Equatable {
    /// Replication Configuration associate default Application Migration Service Security Group.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Replication Configuration set bandwidth throttling.
    public var bandwidthThrottling: Swift.Int
    /// Replication Configuration create Public IP.
    public var createPublicIP: Swift.Bool?
    /// Replication Configuration data plane routing.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Replication Configuration use default large Staging Disks.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Replication Configuration EBS encryption.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Replication Configuration EBS encryption key ARN.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Replication Configuration name.
    public var name: Swift.String?
    /// Replication Configuration replicated disks.
    public var replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]?
    /// Replication Configuration Replication Server instance type.
    public var replicationServerInstanceType: Swift.String?
    /// Replication Configuration Replication Server Security Group IDs.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Replication Configuration Source Server ID.
    public var sourceServerID: Swift.String?
    /// Replication Configuration Staging Area subnet ID.
    public var stagingAreaSubnetId: Swift.String?
    /// Replication Configuration Staging Area tags.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Replication Configuration use Dedicated Replication Server.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init (
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        sourceServerID: Swift.String? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.name = name
        self.replicatedDisks = replicatedDisks
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.sourceServerID = sourceServerID
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct UpdateReplicationConfigurationOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]?
    let ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
}

extension UpdateReplicationConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([MgnClientTypes.ReplicationConfigurationReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[MgnClientTypes.ReplicationConfigurationReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [MgnClientTypes.ReplicationConfigurationReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
    }
}

extension UpdateReplicationConfigurationTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReplicationConfigurationTemplateInput(arn: \(Swift.String(describing: arn)), associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), replicationConfigurationTemplateID: \(Swift.String(describing: replicationConfigurationTemplateID)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), stagingAreaTags: \"CONTENT_REDACTED\")"}
}

extension UpdateReplicationConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let associateDefaultSecurityGroup = self.associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = self.createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = self.dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = self.defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = self.ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = self.ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let replicationConfigurationTemplateID = self.replicationConfigurationTemplateID {
            try encodeContainer.encode(replicationConfigurationTemplateID, forKey: .replicationConfigurationTemplateID)
        }
        if let replicationServerInstanceType = self.replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for securitygroupid0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(securitygroupid0)
            }
        }
        if let stagingAreaSubnetId = self.stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsMap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = self.useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
    }
}

extension UpdateReplicationConfigurationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateReplicationConfigurationTemplate"
    }
}

public struct UpdateReplicationConfigurationTemplateInput: Swift.Equatable {
    /// Update replication configuration template ARN request.
    public var arn: Swift.String?
    /// Update replication configuration template associate default Application Migration Service Security group request.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Update replication configuration template bandwidth throttling request.
    public var bandwidthThrottling: Swift.Int
    /// Update replication configuration template create Public IP request.
    public var createPublicIP: Swift.Bool?
    /// Update replication configuration template data plane routing request.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Update replication configuration template use default large Staging Disk type request.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Update replication configuration template EBS encryption request.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Update replication configuration template EBS encryption key ARN request.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Update replication configuration template template ID request.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?
    /// Update replication configuration template Replication Server instance type request.
    public var replicationServerInstanceType: Swift.String?
    /// Update replication configuration template Replication Server Security groups IDs request.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Update replication configuration template Staging Area subnet ID request.
    public var stagingAreaSubnetId: Swift.String?
    /// Update replication configuration template Staging Area Tags request.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Update replication configuration template use dedicated Replication Server request.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init (
        arn: Swift.String? = nil,
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        replicationConfigurationTemplateID: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct UpdateReplicationConfigurationTemplateInputBody: Swift.Equatable {
    let replicationConfigurationTemplateID: Swift.String?
    let arn: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
}

extension UpdateReplicationConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
    }
}

extension UpdateReplicationConfigurationTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateReplicationConfigurationTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateReplicationConfigurationTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateReplicationConfigurationTemplateOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReplicationConfigurationTemplateOutputResponse(arn: \(Swift.String(describing: arn)), associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), replicationConfigurationTemplateID: \(Swift.String(describing: replicationConfigurationTemplateID)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), stagingAreaTags: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension UpdateReplicationConfigurationTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateReplicationConfigurationTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.replicationConfigurationTemplateID = output.replicationConfigurationTemplateID
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.tags = output.tags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
        } else {
            self.arn = nil
            self.associateDefaultSecurityGroup = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.replicationConfigurationTemplateID = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.tags = nil
            self.useDedicatedReplicationServer = nil
        }
    }
}

public struct UpdateReplicationConfigurationTemplateOutputResponse: Swift.Equatable {
    /// Replication Configuration template ARN.
    public var arn: Swift.String?
    /// Replication Configuration template associate default Application Migration Service Security group.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Replication Configuration template bandwidth throttling.
    public var bandwidthThrottling: Swift.Int
    /// Replication Configuration template create Public IP.
    public var createPublicIP: Swift.Bool?
    /// Replication Configuration template data plane routing.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Replication Configuration template use default large Staging Disk type.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Replication Configuration template EBS encryption.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Replication Configuration template EBS encryption key ARN.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Replication Configuration template ID.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?
    /// Replication Configuration template server instance type.
    public var replicationServerInstanceType: Swift.String?
    /// Replication Configuration template server Security Groups IDs.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Replication Configuration template Staging Area subnet ID.
    public var stagingAreaSubnetId: Swift.String?
    /// Replication Configuration template Staging Area Tags.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Replication Configuration template Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Replication Configuration template use Dedicated Replication Server.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init (
        arn: Swift.String? = nil,
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        replicationConfigurationTemplateID: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct UpdateReplicationConfigurationTemplateOutputResponseBody: Swift.Equatable {
    let replicationConfigurationTemplateID: Swift.String?
    let arn: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateReplicationConfigurationTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateSourceServerReplicationTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationType
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationType = self.replicationType {
            try encodeContainer.encode(replicationType.rawValue, forKey: .replicationType)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension UpdateSourceServerReplicationTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateSourceServerReplicationType"
    }
}

public struct UpdateSourceServerReplicationTypeInput: Swift.Equatable {
    /// Replication type to which to update source server.
    /// This member is required.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// ID of source server on which to update replication type.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.replicationType = replicationType
        self.sourceServerID = sourceServerID
    }
}

struct UpdateSourceServerReplicationTypeInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let replicationType: MgnClientTypes.ReplicationType?
}

extension UpdateSourceServerReplicationTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationType
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
    }
}

extension UpdateSourceServerReplicationTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSourceServerReplicationTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSourceServerReplicationTypeOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSourceServerReplicationTypeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateSourceServerReplicationTypeOutputResponse(applicationID: \(Swift.String(describing: applicationID)), arn: \(Swift.String(describing: arn)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), isArchived: \(Swift.String(describing: isArchived)), launchedInstance: \(Swift.String(describing: launchedInstance)), lifeCycle: \(Swift.String(describing: lifeCycle)), replicationType: \(Swift.String(describing: replicationType)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), tags: \"CONTENT_REDACTED\")"}
}

extension UpdateSourceServerReplicationTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSourceServerReplicationTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationID = output.applicationID
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.applicationID = nil
            self.arn = nil
            self.dataReplicationInfo = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.vcenterClientID = nil
        }
    }
}

public struct UpdateSourceServerReplicationTypeOutputResponse: Swift.Equatable {
    /// Source server application ID.
    public var applicationID: Swift.String?
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init (
        applicationID: Swift.String? = nil,
        arn: Swift.String? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.applicationID = applicationID
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.vcenterClientID = vcenterClientID
    }
}

struct UpdateSourceServerReplicationTypeOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
    let applicationID: Swift.String?
}

extension UpdateSourceServerReplicationTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationID
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case vcenterClientID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let applicationIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationID)
        applicationID = applicationIDDecoded
    }
}

extension UpdateWaveInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case waveID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let waveID = self.waveID {
            try encodeContainer.encode(waveID, forKey: .waveID)
        }
    }
}

extension UpdateWaveInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateWave"
    }
}

public struct UpdateWaveInput: Swift.Equatable {
    /// Wave description.
    public var description: Swift.String?
    /// Wave name.
    public var name: Swift.String?
    /// Wave ID.
    /// This member is required.
    public var waveID: Swift.String?

    public init (
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.description = description
        self.name = name
        self.waveID = waveID
    }
}

struct UpdateWaveInputBody: Swift.Equatable {
    let waveID: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateWaveInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case waveID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateWaveOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWaveOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateWaveOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWaveOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateWaveOutputResponse(arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveAggregatedStatus: \(Swift.String(describing: waveAggregatedStatus)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension UpdateWaveOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateWaveOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.description = output.description
            self.isArchived = output.isArchived
            self.lastModifiedDateTime = output.lastModifiedDateTime
            self.name = output.name
            self.tags = output.tags
            self.waveAggregatedStatus = output.waveAggregatedStatus
            self.waveID = output.waveID
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.description = nil
            self.isArchived = nil
            self.lastModifiedDateTime = nil
            self.name = nil
            self.tags = nil
            self.waveAggregatedStatus = nil
            self.waveID = nil
        }
    }
}

public struct UpdateWaveOutputResponse: Swift.Equatable {
    /// Wave ARN.
    public var arn: Swift.String?
    /// Wave creation dateTime.
    public var creationDateTime: Swift.String?
    /// Wave description.
    public var description: Swift.String?
    /// Wave archival status.
    public var isArchived: Swift.Bool?
    /// Wave last modified dateTime.
    public var lastModifiedDateTime: Swift.String?
    /// Wave name.
    public var name: Swift.String?
    /// Wave tags.
    public var tags: [Swift.String:Swift.String]?
    /// Wave aggregated status.
    public var waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
    /// Wave ID.
    public var waveID: Swift.String?

    public init (
        arn: Swift.String? = nil,
        creationDateTime: Swift.String? = nil,
        description: Swift.String? = nil,
        isArchived: Swift.Bool? = nil,
        lastModifiedDateTime: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus? = nil,
        waveID: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.description = description
        self.isArchived = isArchived
        self.lastModifiedDateTime = lastModifiedDateTime
        self.name = name
        self.tags = tags
        self.waveAggregatedStatus = waveAggregatedStatus
        self.waveID = waveID
    }
}

struct UpdateWaveOutputResponseBody: Swift.Equatable {
    let waveID: Swift.String?
    let arn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let isArchived: Swift.Bool?
    let waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
    let creationDateTime: Swift.String?
    let lastModifiedDateTime: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateWaveOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case description
        case isArchived
        case lastModifiedDateTime
        case name
        case tags
        case waveAggregatedStatus
        case waveID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let waveAggregatedStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.WaveAggregatedStatus.self, forKey: .waveAggregatedStatus)
        waveAggregatedStatus = waveAggregatedStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.code = nil
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Validate exception.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    /// Validate exception field list.
    public var fieldList: [MgnClientTypes.ValidationExceptionField]?
    public var message: Swift.String?
    /// Validate exception reason.
    public var reason: MgnClientTypes.ValidationExceptionReason?

    public init (
        code: Swift.String? = nil,
        fieldList: [MgnClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: MgnClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.code = code
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
    let reason: MgnClientTypes.ValidationExceptionReason?
    let fieldList: [MgnClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case fieldList
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([MgnClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[MgnClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [MgnClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension MgnClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MgnClientTypes {
    /// Validate exception field.
    public struct ValidationExceptionField: Swift.Equatable {
        /// Validate exception field message.
        public var message: Swift.String?
        /// Validate exception field name.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension MgnClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.VcenterClient: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case datacenterName
        case hostname
        case lastSeenDatetime
        case sourceServerTags
        case tags
        case vcenterClientID
        case vcenterUUID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let datacenterName = self.datacenterName {
            try encodeContainer.encode(datacenterName, forKey: .datacenterName)
        }
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let lastSeenDatetime = self.lastSeenDatetime {
            try encodeContainer.encode(lastSeenDatetime, forKey: .lastSeenDatetime)
        }
        if let sourceServerTags = sourceServerTags {
            var sourceServerTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sourceServerTags)
            for (dictKey0, tagsMap0) in sourceServerTags {
                try sourceServerTagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vcenterClientID = self.vcenterClientID {
            try encodeContainer.encode(vcenterClientID, forKey: .vcenterClientID)
        }
        if let vcenterUUID = self.vcenterUUID {
            try encodeContainer.encode(vcenterUUID, forKey: .vcenterUUID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let vcenterUUIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterUUID)
        vcenterUUID = vcenterUUIDDecoded
        let datacenterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datacenterName)
        datacenterName = datacenterNameDecoded
        let lastSeenDatetimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSeenDatetime)
        lastSeenDatetime = lastSeenDatetimeDecoded
        let sourceServerTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sourceServerTags)
        var sourceServerTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let sourceServerTagsContainer = sourceServerTagsContainer {
            sourceServerTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in sourceServerTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    sourceServerTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        sourceServerTags = sourceServerTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MgnClientTypes.VcenterClient: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VcenterClient(arn: \(Swift.String(describing: arn)), datacenterName: \(Swift.String(describing: datacenterName)), hostname: \(Swift.String(describing: hostname)), lastSeenDatetime: \(Swift.String(describing: lastSeenDatetime)), vcenterClientID: \(Swift.String(describing: vcenterClientID)), vcenterUUID: \(Swift.String(describing: vcenterUUID)), sourceServerTags: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension MgnClientTypes {
    /// vCenter client.
    public struct VcenterClient: Swift.Equatable {
        /// Arn of vCenter client.
        public var arn: Swift.String?
        /// Datacenter name of vCenter client.
        public var datacenterName: Swift.String?
        /// Hostname of vCenter client .
        public var hostname: Swift.String?
        /// Last seen time of vCenter client.
        public var lastSeenDatetime: Swift.String?
        /// Tags for Source Server of vCenter client.
        public var sourceServerTags: [Swift.String:Swift.String]?
        /// Tags for vCenter client.
        public var tags: [Swift.String:Swift.String]?
        /// ID of vCenter client.
        public var vcenterClientID: Swift.String?
        /// Vcenter UUID of vCenter client.
        public var vcenterUUID: Swift.String?

        public init (
            arn: Swift.String? = nil,
            datacenterName: Swift.String? = nil,
            hostname: Swift.String? = nil,
            lastSeenDatetime: Swift.String? = nil,
            sourceServerTags: [Swift.String:Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            vcenterClientID: Swift.String? = nil,
            vcenterUUID: Swift.String? = nil
        )
        {
            self.arn = arn
            self.datacenterName = datacenterName
            self.hostname = hostname
            self.lastSeenDatetime = lastSeenDatetime
            self.sourceServerTags = sourceServerTags
            self.tags = tags
            self.vcenterClientID = vcenterClientID
            self.vcenterUUID = vcenterUUID
        }
    }

}

extension MgnClientTypes {
    public enum VolumeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gp2
        case gp3
        case io1
        case io2
        case sc1
        case st1
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [VolumeType] {
            return [
                .gp2,
                .gp3,
                .io1,
                .io2,
                .sc1,
                .st1,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gp2: return "gp2"
            case .gp3: return "gp3"
            case .io1: return "io1"
            case .io2: return "io2"
            case .sc1: return "sc1"
            case .st1: return "st1"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VolumeType(rawValue: rawValue) ?? VolumeType.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.Wave: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case description
        case isArchived
        case lastModifiedDateTime
        case name
        case tags
        case waveAggregatedStatus
        case waveID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encode(creationDateTime, forKey: .creationDateTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let isArchived = self.isArchived {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let lastModifiedDateTime = self.lastModifiedDateTime {
            try encodeContainer.encode(lastModifiedDateTime, forKey: .lastModifiedDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let waveAggregatedStatus = self.waveAggregatedStatus {
            try encodeContainer.encode(waveAggregatedStatus, forKey: .waveAggregatedStatus)
        }
        if let waveID = self.waveID {
            try encodeContainer.encode(waveID, forKey: .waveID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waveIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .waveID)
        waveID = waveIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let waveAggregatedStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.WaveAggregatedStatus.self, forKey: .waveAggregatedStatus)
        waveAggregatedStatus = waveAggregatedStatusDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let lastModifiedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastModifiedDateTime)
        lastModifiedDateTime = lastModifiedDateTimeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MgnClientTypes.Wave: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Wave(arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), description: \(Swift.String(describing: description)), isArchived: \(Swift.String(describing: isArchived)), lastModifiedDateTime: \(Swift.String(describing: lastModifiedDateTime)), name: \(Swift.String(describing: name)), waveAggregatedStatus: \(Swift.String(describing: waveAggregatedStatus)), waveID: \(Swift.String(describing: waveID)), tags: \"CONTENT_REDACTED\")"}
}

extension MgnClientTypes {
    public struct Wave: Swift.Equatable {
        /// Wave ARN.
        public var arn: Swift.String?
        /// Wave creation dateTime.
        public var creationDateTime: Swift.String?
        /// Wave description.
        public var description: Swift.String?
        /// Wave archival status.
        public var isArchived: Swift.Bool?
        /// Wave last modified dateTime.
        public var lastModifiedDateTime: Swift.String?
        /// Wave name.
        public var name: Swift.String?
        /// Wave tags.
        public var tags: [Swift.String:Swift.String]?
        /// Wave aggregated status.
        public var waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus?
        /// Wave ID.
        public var waveID: Swift.String?

        public init (
            arn: Swift.String? = nil,
            creationDateTime: Swift.String? = nil,
            description: Swift.String? = nil,
            isArchived: Swift.Bool? = nil,
            lastModifiedDateTime: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            waveAggregatedStatus: MgnClientTypes.WaveAggregatedStatus? = nil,
            waveID: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.description = description
            self.isArchived = isArchived
            self.lastModifiedDateTime = lastModifiedDateTime
            self.name = name
            self.tags = tags
            self.waveAggregatedStatus = waveAggregatedStatus
            self.waveID = waveID
        }
    }

}

extension MgnClientTypes.WaveAggregatedStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthStatus
        case lastUpdateDateTime
        case progressStatus
        case replicationStartedDateTime
        case totalApplications
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let healthStatus = self.healthStatus {
            try encodeContainer.encode(healthStatus.rawValue, forKey: .healthStatus)
        }
        if let lastUpdateDateTime = self.lastUpdateDateTime {
            try encodeContainer.encode(lastUpdateDateTime, forKey: .lastUpdateDateTime)
        }
        if let progressStatus = self.progressStatus {
            try encodeContainer.encode(progressStatus.rawValue, forKey: .progressStatus)
        }
        if let replicationStartedDateTime = self.replicationStartedDateTime {
            try encodeContainer.encode(replicationStartedDateTime, forKey: .replicationStartedDateTime)
        }
        if totalApplications != 0 {
            try encodeContainer.encode(totalApplications, forKey: .totalApplications)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastUpdateDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdateDateTime)
        lastUpdateDateTime = lastUpdateDateTimeDecoded
        let replicationStartedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationStartedDateTime)
        replicationStartedDateTime = replicationStartedDateTimeDecoded
        let healthStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.WaveHealthStatus.self, forKey: .healthStatus)
        healthStatus = healthStatusDecoded
        let progressStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.WaveProgressStatus.self, forKey: .progressStatus)
        progressStatus = progressStatusDecoded
        let totalApplicationsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalApplications) ?? 0
        totalApplications = totalApplicationsDecoded
    }
}

extension MgnClientTypes {
    /// Wave aggregated status.
    public struct WaveAggregatedStatus: Swift.Equatable {
        /// Wave aggregated status health status.
        public var healthStatus: MgnClientTypes.WaveHealthStatus?
        /// Wave aggregated status last update dateTime.
        public var lastUpdateDateTime: Swift.String?
        /// Wave aggregated status progress status.
        public var progressStatus: MgnClientTypes.WaveProgressStatus?
        /// DateTime marking when the first source server in the wave started replication.
        public var replicationStartedDateTime: Swift.String?
        /// Wave aggregated status total applications amount.
        public var totalApplications: Swift.Int

        public init (
            healthStatus: MgnClientTypes.WaveHealthStatus? = nil,
            lastUpdateDateTime: Swift.String? = nil,
            progressStatus: MgnClientTypes.WaveProgressStatus? = nil,
            replicationStartedDateTime: Swift.String? = nil,
            totalApplications: Swift.Int = 0
        )
        {
            self.healthStatus = healthStatus
            self.lastUpdateDateTime = lastUpdateDateTime
            self.progressStatus = progressStatus
            self.replicationStartedDateTime = replicationStartedDateTime
            self.totalApplications = totalApplications
        }
    }

}

extension MgnClientTypes {
    public enum WaveHealthStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case healthy
        case lagging
        case sdkUnknown(Swift.String)

        public static var allCases: [WaveHealthStatus] {
            return [
                .error,
                .healthy,
                .lagging,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .healthy: return "HEALTHY"
            case .lagging: return "LAGGING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WaveHealthStatus(rawValue: rawValue) ?? WaveHealthStatus.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum WaveProgressStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case inProgress
        case notStarted
        case sdkUnknown(Swift.String)

        public static var allCases: [WaveProgressStatus] {
            return [
                .completed,
                .inProgress,
                .notStarted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WaveProgressStatus(rawValue: rawValue) ?? WaveProgressStatus.sdkUnknown(rawValue)
        }
    }
}
