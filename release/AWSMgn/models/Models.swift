// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Operating denied due to a file permission or access check error.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension MgnClientTypes.CPU: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cores
        case modelName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cores != 0 {
            try encodeContainer.encode(cores, forKey: .cores)
        }
        if let modelName = modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coresDecoded = try containerValues.decode(Swift.Int.self, forKey: .cores)
        cores = coresDecoded
        let modelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelName)
        modelName = modelNameDecoded
    }
}

extension MgnClientTypes {
    /// Source server CPU information.
    public struct CPU: Swift.Equatable {
        /// The number of CPU cores on the source server.
        public var cores: Swift.Int
        /// The source server's CPU model name.
        public var modelName: Swift.String?

        public init (
            cores: Swift.Int = 0,
            modelName: Swift.String? = nil
        )
        {
            self.cores = cores
            self.modelName = modelName
        }
    }

}

extension ChangeServerLifeCycleStateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifeCycle
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifeCycle = lifeCycle {
            try encodeContainer.encode(lifeCycle, forKey: .lifeCycle)
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension ChangeServerLifeCycleStateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ChangeServerLifeCycleState"
    }
}

public struct ChangeServerLifeCycleStateInput: Swift.Equatable {
    /// The request to change the source server migration lifecycle state.
    /// This member is required.
    public var lifeCycle: MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycle?
    /// The request to change the source server migration lifecycle state by source server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        lifeCycle: MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycle? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.lifeCycle = lifeCycle
        self.sourceServerID = sourceServerID
    }
}

struct ChangeServerLifeCycleStateInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let lifeCycle: MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycle?
}

extension ChangeServerLifeCycleStateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifeCycle
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
    }
}

extension ChangeServerLifeCycleStateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ChangeServerLifeCycleStateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ChangeServerLifeCycleStateOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ChangeServerLifeCycleStateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ChangeServerLifeCycleStateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.arn = nil
            self.dataReplicationInfo = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.vcenterClientID = nil
        }
    }
}

public struct ChangeServerLifeCycleStateOutputResponse: Swift.Equatable {
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init (
        arn: Swift.String? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.vcenterClientID = vcenterClientID
    }
}

struct ChangeServerLifeCycleStateOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
}

extension ChangeServerLifeCycleStateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case vcenterClientID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
    }
}

extension MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycleState.self, forKey: .state)
        state = stateDecoded
    }
}

extension MgnClientTypes {
    /// The request to change the source server migration lifecycle state.
    public struct ChangeServerLifeCycleStateSourceServerLifecycle: Swift.Equatable {
        /// The request to change the source server migration lifecycle state.
        /// This member is required.
        public var state: MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycleState?

        public init (
            state: MgnClientTypes.ChangeServerLifeCycleStateSourceServerLifecycleState? = nil
        )
        {
            self.state = state
        }
    }

}

extension MgnClientTypes {
    public enum ChangeServerLifeCycleStateSourceServerLifecycleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cutover
        case readyForCutover
        case readyForTest
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeServerLifeCycleStateSourceServerLifecycleState] {
            return [
                .cutover,
                .readyForCutover,
                .readyForTest,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cutover: return "CUTOVER"
            case .readyForCutover: return "READY_FOR_CUTOVER"
            case .readyForTest: return "READY_FOR_TEST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeServerLifeCycleStateSourceServerLifecycleState(rawValue: rawValue) ?? ChangeServerLifeCycleStateSourceServerLifecycleState.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.code = nil
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be completed due to a conflict with the current state of the target resource.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?
    /// A conflict occured when prompting for the Resource ID.
    public var resourceId: Swift.String?
    /// A conflict occured when prompting for resource type.
    public var resourceType: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateReplicationConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associateDefaultSecurityGroup = associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let replicationServerInstanceType = replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for replicationserverssecuritygroupsids0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(replicationserverssecuritygroupsids0)
            }
        }
        if let stagingAreaSubnetId = stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsmap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
    }
}

extension CreateReplicationConfigurationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateReplicationConfigurationTemplate"
    }
}

public struct CreateReplicationConfigurationTemplateInput: Swift.Equatable {
    /// Request to associate the default Application Migration Service Security group with the Replication Settings template.
    /// This member is required.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Request to configure bandwidth throttling during Replication Settings template creation.
    /// This member is required.
    public var bandwidthThrottling: Swift.Int
    /// Request to create Public IP during Replication Settings template creation.
    /// This member is required.
    public var createPublicIP: Swift.Bool?
    /// Request to configure data plane routing during Replication Settings template creation.
    /// This member is required.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Request to configure the Staging Disk EBS volume type to "gp2" during Replication Settings template creation.
    /// This member is required.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Request to configure EBS enryption during Replication Settings template creation.
    /// This member is required.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Request to configure an EBS enryption key during Replication Settings template creation.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Request to configure the Replication Server instance type during Replication Settings template creation.
    /// This member is required.
    public var replicationServerInstanceType: Swift.String?
    /// Request to configure the Replication Server Secuirity group ID during Replication Settings template creation.
    /// This member is required.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Request to configure the Staging Area subnet ID during Replication Settings template creation.
    /// This member is required.
    public var stagingAreaSubnetId: Swift.String?
    /// Request to configure Staiging Area tags during Replication Settings template creation.
    /// This member is required.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Request to configure tags during Replication Settings template creation.
    public var tags: [Swift.String:Swift.String]?
    /// Request to use Dedicated Replication Servers during Replication Settings template creation.
    /// This member is required.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init (
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct CreateReplicationConfigurationTemplateInputBody: Swift.Equatable {
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateReplicationConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Swift.Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateReplicationConfigurationTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReplicationConfigurationTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateReplicationConfigurationTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReplicationConfigurationTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateReplicationConfigurationTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.replicationConfigurationTemplateID = output.replicationConfigurationTemplateID
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.tags = output.tags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
        } else {
            self.arn = nil
            self.associateDefaultSecurityGroup = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.replicationConfigurationTemplateID = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.tags = nil
            self.useDedicatedReplicationServer = nil
        }
    }
}

public struct CreateReplicationConfigurationTemplateOutputResponse: Swift.Equatable {
    /// Replication Configuration template ARN.
    public var arn: Swift.String?
    /// Replication Configuration template associate default Application Migration Service Security group.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Replication Configuration template bandwidth throtting.
    public var bandwidthThrottling: Swift.Int
    /// Replication Configuration template create Public IP.
    public var createPublicIP: Swift.Bool?
    /// Replication Configuration template data plane routing.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Replication Configuration template use dedault large Staging Disk type.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Replication Configuration template EBS encryption.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Replication Configuration template EBS encryption key ARN.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Replication Configuration template template ID.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?
    /// Replication Configuration template server instance type.
    public var replicationServerInstanceType: Swift.String?
    /// Replication Configuration template server Security Groups IDs.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Replication Configuration template Staging Area subnet ID.
    public var stagingAreaSubnetId: Swift.String?
    /// Replication Configuration template Staging Area Tags.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Replication Configuration template Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Replication Configuration template use Dedicated Replication Server.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init (
        arn: Swift.String? = nil,
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        replicationConfigurationTemplateID: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct CreateReplicationConfigurationTemplateOutputResponseBody: Swift.Equatable {
    let replicationConfigurationTemplateID: Swift.String?
    let arn: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateReplicationConfigurationTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Swift.Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MgnClientTypes.DataReplicationError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case rawError
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error.rawValue, forKey: .error)
        }
        if let rawError = rawError {
            try encodeContainer.encode(rawError, forKey: .rawError)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationErrorString.self, forKey: .error)
        error = errorDecoded
        let rawErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rawError)
        rawError = rawErrorDecoded
    }
}

extension MgnClientTypes {
    /// Error in data replication.
    public struct DataReplicationError: Swift.Equatable {
        /// Error in data replication.
        public var error: MgnClientTypes.DataReplicationErrorString?
        /// Error in data replication.
        public var rawError: Swift.String?

        public init (
            error: MgnClientTypes.DataReplicationErrorString? = nil,
            rawError: Swift.String? = nil
        )
        {
            self.error = error
            self.rawError = rawError
        }
    }

}

extension MgnClientTypes {
    public enum DataReplicationErrorString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agentNotSeen
        case failedToAttachStagingDisks
        case failedToAuthenticateWithService
        case failedToBootReplicationServer
        case failedToConnectAgentToReplicationServer
        case failedToCreateSecurityGroup
        case failedToCreateStagingDisks
        case failedToDownloadReplicationSoftware
        case failedToLaunchReplicationServer
        case failedToPairReplicationServerWithAgent
        case failedToStartDataTransfer
        case lastSnapshotJobFailed
        case notConverging
        case snapshotsFailure
        case unstableNetwork
        case unsupportedVmConfiguration
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationErrorString] {
            return [
                .agentNotSeen,
                .failedToAttachStagingDisks,
                .failedToAuthenticateWithService,
                .failedToBootReplicationServer,
                .failedToConnectAgentToReplicationServer,
                .failedToCreateSecurityGroup,
                .failedToCreateStagingDisks,
                .failedToDownloadReplicationSoftware,
                .failedToLaunchReplicationServer,
                .failedToPairReplicationServerWithAgent,
                .failedToStartDataTransfer,
                .lastSnapshotJobFailed,
                .notConverging,
                .snapshotsFailure,
                .unstableNetwork,
                .unsupportedVmConfiguration,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agentNotSeen: return "AGENT_NOT_SEEN"
            case .failedToAttachStagingDisks: return "FAILED_TO_ATTACH_STAGING_DISKS"
            case .failedToAuthenticateWithService: return "FAILED_TO_AUTHENTICATE_WITH_SERVICE"
            case .failedToBootReplicationServer: return "FAILED_TO_BOOT_REPLICATION_SERVER"
            case .failedToConnectAgentToReplicationServer: return "FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"
            case .failedToCreateSecurityGroup: return "FAILED_TO_CREATE_SECURITY_GROUP"
            case .failedToCreateStagingDisks: return "FAILED_TO_CREATE_STAGING_DISKS"
            case .failedToDownloadReplicationSoftware: return "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"
            case .failedToLaunchReplicationServer: return "FAILED_TO_LAUNCH_REPLICATION_SERVER"
            case .failedToPairReplicationServerWithAgent: return "FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"
            case .failedToStartDataTransfer: return "FAILED_TO_START_DATA_TRANSFER"
            case .lastSnapshotJobFailed: return "LAST_SNAPSHOT_JOB_FAILED"
            case .notConverging: return "NOT_CONVERGING"
            case .snapshotsFailure: return "SNAPSHOTS_FAILURE"
            case .unstableNetwork: return "UNSTABLE_NETWORK"
            case .unsupportedVmConfiguration: return "UNSUPPORTED_VM_CONFIGURATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplicationErrorString(rawValue: rawValue) ?? DataReplicationErrorString.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.DataReplicationInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataReplicationError
        case dataReplicationInitiation
        case dataReplicationState
        case etaDateTime
        case lagDuration
        case lastSnapshotDateTime
        case replicatedDisks
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataReplicationError = dataReplicationError {
            try encodeContainer.encode(dataReplicationError, forKey: .dataReplicationError)
        }
        if let dataReplicationInitiation = dataReplicationInitiation {
            try encodeContainer.encode(dataReplicationInitiation, forKey: .dataReplicationInitiation)
        }
        if let dataReplicationState = dataReplicationState {
            try encodeContainer.encode(dataReplicationState.rawValue, forKey: .dataReplicationState)
        }
        if let etaDateTime = etaDateTime {
            try encodeContainer.encode(etaDateTime, forKey: .etaDateTime)
        }
        if let lagDuration = lagDuration {
            try encodeContainer.encode(lagDuration, forKey: .lagDuration)
        }
        if let lastSnapshotDateTime = lastSnapshotDateTime {
            try encodeContainer.encode(lastSnapshotDateTime, forKey: .lastSnapshotDateTime)
        }
        if let replicatedDisks = replicatedDisks {
            var replicatedDisksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicatedDisks)
            for datareplicationinforeplicateddisks0 in replicatedDisks {
                try replicatedDisksContainer.encode(datareplicationinforeplicateddisks0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lagDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagDuration)
        lagDuration = lagDurationDecoded
        let etaDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .etaDateTime)
        etaDateTime = etaDateTimeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([MgnClientTypes.DataReplicationInfoReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[MgnClientTypes.DataReplicationInfoReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [MgnClientTypes.DataReplicationInfoReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let dataReplicationStateDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationState.self, forKey: .dataReplicationState)
        dataReplicationState = dataReplicationStateDecoded
        let dataReplicationInitiationDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInitiation.self, forKey: .dataReplicationInitiation)
        dataReplicationInitiation = dataReplicationInitiationDecoded
        let dataReplicationErrorDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationError.self, forKey: .dataReplicationError)
        dataReplicationError = dataReplicationErrorDecoded
        let lastSnapshotDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSnapshotDateTime)
        lastSnapshotDateTime = lastSnapshotDateTimeDecoded
    }
}

extension MgnClientTypes {
    /// Request data replication info.
    public struct DataReplicationInfo: Swift.Equatable {
        /// Error in obtaining data replication info.
        public var dataReplicationError: MgnClientTypes.DataReplicationError?
        /// Request to query whether data replication has been initiated.
        public var dataReplicationInitiation: MgnClientTypes.DataReplicationInitiation?
        /// Request to query the data replication state.
        public var dataReplicationState: MgnClientTypes.DataReplicationState?
        /// Request to query the time when data replication will be complete.
        public var etaDateTime: Swift.String?
        /// Request to query data replication lag durating.
        public var lagDuration: Swift.String?
        /// Request to query data replication last snapshot time.
        public var lastSnapshotDateTime: Swift.String?
        /// Request to query disks replicated.
        public var replicatedDisks: [MgnClientTypes.DataReplicationInfoReplicatedDisk]?

        public init (
            dataReplicationError: MgnClientTypes.DataReplicationError? = nil,
            dataReplicationInitiation: MgnClientTypes.DataReplicationInitiation? = nil,
            dataReplicationState: MgnClientTypes.DataReplicationState? = nil,
            etaDateTime: Swift.String? = nil,
            lagDuration: Swift.String? = nil,
            lastSnapshotDateTime: Swift.String? = nil,
            replicatedDisks: [MgnClientTypes.DataReplicationInfoReplicatedDisk]? = nil
        )
        {
            self.dataReplicationError = dataReplicationError
            self.dataReplicationInitiation = dataReplicationInitiation
            self.dataReplicationState = dataReplicationState
            self.etaDateTime = etaDateTime
            self.lagDuration = lagDuration
            self.lastSnapshotDateTime = lastSnapshotDateTime
            self.replicatedDisks = replicatedDisks
        }
    }

}

extension MgnClientTypes.DataReplicationInfoReplicatedDisk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backloggedStorageBytes
        case deviceName
        case replicatedStorageBytes
        case rescannedStorageBytes
        case totalStorageBytes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if backloggedStorageBytes != 0 {
            try encodeContainer.encode(backloggedStorageBytes, forKey: .backloggedStorageBytes)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if replicatedStorageBytes != 0 {
            try encodeContainer.encode(replicatedStorageBytes, forKey: .replicatedStorageBytes)
        }
        if rescannedStorageBytes != 0 {
            try encodeContainer.encode(rescannedStorageBytes, forKey: .rescannedStorageBytes)
        }
        if totalStorageBytes != 0 {
            try encodeContainer.encode(totalStorageBytes, forKey: .totalStorageBytes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let totalStorageBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalStorageBytes)
        totalStorageBytes = totalStorageBytesDecoded
        let replicatedStorageBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .replicatedStorageBytes)
        replicatedStorageBytes = replicatedStorageBytesDecoded
        let rescannedStorageBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .rescannedStorageBytes)
        rescannedStorageBytes = rescannedStorageBytesDecoded
        let backloggedStorageBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .backloggedStorageBytes)
        backloggedStorageBytes = backloggedStorageBytesDecoded
    }
}

extension MgnClientTypes {
    /// Request to query disks replicated.
    public struct DataReplicationInfoReplicatedDisk: Swift.Equatable {
        /// Request to query data replication backlog size in bytes.
        public var backloggedStorageBytes: Swift.Int
        /// Request to query device name.
        public var deviceName: Swift.String?
        /// Request to query amount of data replicated in bytes.
        public var replicatedStorageBytes: Swift.Int
        /// Request to query amount of data rescanned in bytes.
        public var rescannedStorageBytes: Swift.Int
        /// Request to query total amount of data replicated in bytes.
        public var totalStorageBytes: Swift.Int

        public init (
            backloggedStorageBytes: Swift.Int = 0,
            deviceName: Swift.String? = nil,
            replicatedStorageBytes: Swift.Int = 0,
            rescannedStorageBytes: Swift.Int = 0,
            totalStorageBytes: Swift.Int = 0
        )
        {
            self.backloggedStorageBytes = backloggedStorageBytes
            self.deviceName = deviceName
            self.replicatedStorageBytes = replicatedStorageBytes
            self.rescannedStorageBytes = rescannedStorageBytes
            self.totalStorageBytes = totalStorageBytes
        }
    }

}

extension MgnClientTypes.DataReplicationInitiation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextAttemptDateTime
        case startDateTime
        case steps
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextAttemptDateTime = nextAttemptDateTime {
            try encodeContainer.encode(nextAttemptDateTime, forKey: .nextAttemptDateTime)
        }
        if let startDateTime = startDateTime {
            try encodeContainer.encode(startDateTime, forKey: .startDateTime)
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for datareplicationinitiationsteps0 in steps {
                try stepsContainer.encode(datareplicationinitiationsteps0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let nextAttemptDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextAttemptDateTime)
        nextAttemptDateTime = nextAttemptDateTimeDecoded
        let stepsContainer = try containerValues.decodeIfPresent([MgnClientTypes.DataReplicationInitiationStep?].self, forKey: .steps)
        var stepsDecoded0:[MgnClientTypes.DataReplicationInitiationStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [MgnClientTypes.DataReplicationInitiationStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
    }
}

extension MgnClientTypes {
    /// Data replication initiation.
    public struct DataReplicationInitiation: Swift.Equatable {
        /// Request to query next data initiation date and time.
        public var nextAttemptDateTime: Swift.String?
        /// Request to query data initiation start date and time.
        public var startDateTime: Swift.String?
        /// Request to query data initiation steps.
        public var steps: [MgnClientTypes.DataReplicationInitiationStep]?

        public init (
            nextAttemptDateTime: Swift.String? = nil,
            startDateTime: Swift.String? = nil,
            steps: [MgnClientTypes.DataReplicationInitiationStep]? = nil
        )
        {
            self.nextAttemptDateTime = nextAttemptDateTime
            self.startDateTime = startDateTime
            self.steps = steps
        }
    }

}

extension MgnClientTypes.DataReplicationInitiationStep: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInitiationStepName.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInitiationStepStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension MgnClientTypes {
    /// Data replication intiation step.
    public struct DataReplicationInitiationStep: Swift.Equatable {
        /// Request to query data initiation step name.
        public var name: MgnClientTypes.DataReplicationInitiationStepName?
        /// Request to query data initiation status.
        public var status: MgnClientTypes.DataReplicationInitiationStepStatus?

        public init (
            name: MgnClientTypes.DataReplicationInitiationStepName? = nil,
            status: MgnClientTypes.DataReplicationInitiationStepStatus? = nil
        )
        {
            self.name = name
            self.status = status
        }
    }

}

extension MgnClientTypes {
    public enum DataReplicationInitiationStepName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attachStagingDisks
        case authenticateWithService
        case bootReplicationServer
        case connectAgentToReplicationServer
        case createSecurityGroup
        case createStagingDisks
        case downloadReplicationSoftware
        case launchReplicationServer
        case pairReplicationServerWithAgent
        case startDataTransfer
        case wait
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationInitiationStepName] {
            return [
                .attachStagingDisks,
                .authenticateWithService,
                .bootReplicationServer,
                .connectAgentToReplicationServer,
                .createSecurityGroup,
                .createStagingDisks,
                .downloadReplicationSoftware,
                .launchReplicationServer,
                .pairReplicationServerWithAgent,
                .startDataTransfer,
                .wait,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attachStagingDisks: return "ATTACH_STAGING_DISKS"
            case .authenticateWithService: return "AUTHENTICATE_WITH_SERVICE"
            case .bootReplicationServer: return "BOOT_REPLICATION_SERVER"
            case .connectAgentToReplicationServer: return "CONNECT_AGENT_TO_REPLICATION_SERVER"
            case .createSecurityGroup: return "CREATE_SECURITY_GROUP"
            case .createStagingDisks: return "CREATE_STAGING_DISKS"
            case .downloadReplicationSoftware: return "DOWNLOAD_REPLICATION_SOFTWARE"
            case .launchReplicationServer: return "LAUNCH_REPLICATION_SERVER"
            case .pairReplicationServerWithAgent: return "PAIR_REPLICATION_SERVER_WITH_AGENT"
            case .startDataTransfer: return "START_DATA_TRANSFER"
            case .wait: return "WAIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplicationInitiationStepName(rawValue: rawValue) ?? DataReplicationInitiationStepName.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum DataReplicationInitiationStepStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case notStarted
        case skipped
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationInitiationStepStatus] {
            return [
                .failed,
                .inProgress,
                .notStarted,
                .skipped,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case .skipped: return "SKIPPED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplicationInitiationStepStatus(rawValue: rawValue) ?? DataReplicationInitiationStepStatus.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum DataReplicationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backlog
        case continuous
        case creatingSnapshot
        case disconnected
        case initialSync
        case initiating
        case paused
        case pendingSnapshotShipping
        case rescan
        case shippingSnapshot
        case stalled
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationState] {
            return [
                .backlog,
                .continuous,
                .creatingSnapshot,
                .disconnected,
                .initialSync,
                .initiating,
                .paused,
                .pendingSnapshotShipping,
                .rescan,
                .shippingSnapshot,
                .stalled,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backlog: return "BACKLOG"
            case .continuous: return "CONTINUOUS"
            case .creatingSnapshot: return "CREATING_SNAPSHOT"
            case .disconnected: return "DISCONNECTED"
            case .initialSync: return "INITIAL_SYNC"
            case .initiating: return "INITIATING"
            case .paused: return "PAUSED"
            case .pendingSnapshotShipping: return "PENDING_SNAPSHOT_SHIPPING"
            case .rescan: return "RESCAN"
            case .shippingSnapshot: return "SHIPPING_SNAPSHOT"
            case .stalled: return "STALLED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplicationState(rawValue: rawValue) ?? DataReplicationState.sdkUnknown(rawValue)
        }
    }
}

extension DeleteJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobID = jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
    }
}

extension DeleteJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteJob"
    }
}

public struct DeleteJobInput: Swift.Equatable {
    /// Request to delete Job from service by Job ID.
    /// This member is required.
    public var jobID: Swift.String?

    public init (
        jobID: Swift.String? = nil
    )
    {
        self.jobID = jobID
    }
}

struct DeleteJobInputBody: Swift.Equatable {
    let jobID: Swift.String?
}

extension DeleteJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
    }
}

extension DeleteJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteJobOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteJobOutputResponse: Swift.Equatable {

}

extension DeleteReplicationConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfigurationTemplateID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationConfigurationTemplateID = replicationConfigurationTemplateID {
            try encodeContainer.encode(replicationConfigurationTemplateID, forKey: .replicationConfigurationTemplateID)
        }
    }
}

extension DeleteReplicationConfigurationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteReplicationConfigurationTemplate"
    }
}

public struct DeleteReplicationConfigurationTemplateInput: Swift.Equatable {
    /// Request to delete Replication Configuration Template from service by Replication Configuration Template ID.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?

    public init (
        replicationConfigurationTemplateID: Swift.String? = nil
    )
    {
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
    }
}

struct DeleteReplicationConfigurationTemplateInputBody: Swift.Equatable {
    let replicationConfigurationTemplateID: Swift.String?
}

extension DeleteReplicationConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfigurationTemplateID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
    }
}

extension DeleteReplicationConfigurationTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReplicationConfigurationTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReplicationConfigurationTemplateOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReplicationConfigurationTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteReplicationConfigurationTemplateOutputResponse: Swift.Equatable {

}

extension DeleteSourceServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension DeleteSourceServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteSourceServer"
    }
}

public struct DeleteSourceServerInput: Swift.Equatable {
    /// Request to delete Source Server from service by Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct DeleteSourceServerInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension DeleteSourceServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension DeleteSourceServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSourceServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSourceServerOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSourceServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSourceServerOutputResponse: Swift.Equatable {

}

extension DeleteVcenterClientInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vcenterClientID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vcenterClientID = vcenterClientID {
            try encodeContainer.encode(vcenterClientID, forKey: .vcenterClientID)
        }
    }
}

extension DeleteVcenterClientInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteVcenterClient"
    }
}

public struct DeleteVcenterClientInput: Swift.Equatable {
    /// ID of resource to be deleted.
    /// This member is required.
    public var vcenterClientID: Swift.String?

    public init (
        vcenterClientID: Swift.String? = nil
    )
    {
        self.vcenterClientID = vcenterClientID
    }
}

struct DeleteVcenterClientInputBody: Swift.Equatable {
    let vcenterClientID: Swift.String?
}

extension DeleteVcenterClientInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vcenterClientID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
    }
}

extension DeleteVcenterClientOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVcenterClientOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVcenterClientOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVcenterClientOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteVcenterClientOutputResponse: Swift.Equatable {

}

extension DescribeJobLogItemsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobID
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobID = jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeJobLogItemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeJobLogItems"
    }
}

public struct DescribeJobLogItemsInput: Swift.Equatable {
    /// Request to describe Job log job ID.
    /// This member is required.
    public var jobID: Swift.String?
    /// Request to describe Job log item maximum results.
    public var maxResults: Swift.Int
    /// Request to describe Job log next token.
    public var nextToken: Swift.String?

    public init (
        jobID: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.jobID = jobID
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeJobLogItemsInputBody: Swift.Equatable {
    let jobID: Swift.String?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeJobLogItemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobID
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeJobLogItemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobLogItemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJobLogItemsOutputError: Swift.Error, Swift.Equatable {
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobLogItemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeJobLogItemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeJobLogItemsOutputResponse: Swift.Equatable {
    /// Request to describe Job log response items.
    public var items: [MgnClientTypes.JobLog]?
    /// Request to describe Job log response next token.
    public var nextToken: Swift.String?

    public init (
        items: [MgnClientTypes.JobLog]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeJobLogItemsOutputResponseBody: Swift.Equatable {
    let items: [MgnClientTypes.JobLog]?
    let nextToken: Swift.String?
}

extension DescribeJobLogItemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.JobLog?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.JobLog]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.JobLog]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeJobs"
    }
}

public struct DescribeJobsInput: Swift.Equatable {
    /// Request to describe Job log filters.
    /// This member is required.
    public var filters: MgnClientTypes.DescribeJobsRequestFilters?
    /// Request to describe Job log by max results.
    public var maxResults: Swift.Int
    /// Request to describe Job logby next token.
    public var nextToken: Swift.String?

    public init (
        filters: MgnClientTypes.DescribeJobsRequestFilters? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeJobsInputBody: Swift.Equatable {
    let filters: MgnClientTypes.DescribeJobsRequestFilters?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DescribeJobsRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJobsOutputError: Swift.Error, Swift.Equatable {
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeJobsOutputResponse: Swift.Equatable {
    /// Request to describe Job log items.
    public var items: [MgnClientTypes.Job]?
    /// Request to describe Job response by next token.
    public var nextToken: Swift.String?

    public init (
        items: [MgnClientTypes.Job]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeJobsOutputResponseBody: Swift.Equatable {
    let items: [MgnClientTypes.Job]?
    let nextToken: Swift.String?
}

extension DescribeJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.Job?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.Job]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.Job]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MgnClientTypes.DescribeJobsRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromDate
        case jobIDs
        case toDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromDate = fromDate {
            try encodeContainer.encode(fromDate, forKey: .fromDate)
        }
        if let jobIDs = jobIDs {
            var jobIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobIDs)
            for describejobsrequestfiltersjobids0 in jobIDs {
                try jobIDsContainer.encode(describejobsrequestfiltersjobids0)
            }
        }
        if let toDate = toDate {
            try encodeContainer.encode(toDate, forKey: .toDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .jobIDs)
        var jobIDsDecoded0:[Swift.String]? = nil
        if let jobIDsContainer = jobIDsContainer {
            jobIDsDecoded0 = [Swift.String]()
            for string0 in jobIDsContainer {
                if let string0 = string0 {
                    jobIDsDecoded0?.append(string0)
                }
            }
        }
        jobIDs = jobIDsDecoded0
        let fromDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromDate)
        fromDate = fromDateDecoded
        let toDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .toDate)
        toDate = toDateDecoded
    }
}

extension MgnClientTypes {
    /// Request to describe Job log filters.
    public struct DescribeJobsRequestFilters: Swift.Equatable {
        /// Request to describe Job log filters by date.
        public var fromDate: Swift.String?
        /// Request to describe Job log filters by job ID.
        public var jobIDs: [Swift.String]?
        /// Request to describe Job log by last date.
        public var toDate: Swift.String?

        public init (
            fromDate: Swift.String? = nil,
            jobIDs: [Swift.String]? = nil,
            toDate: Swift.String? = nil
        )
        {
            self.fromDate = fromDate
            self.jobIDs = jobIDs
            self.toDate = toDate
        }
    }

}

extension DescribeReplicationConfigurationTemplatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case replicationConfigurationTemplateIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDs {
            var replicationConfigurationTemplateIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationConfigurationTemplateIDs)
            for replicationconfigurationtemplateids0 in replicationConfigurationTemplateIDs {
                try replicationConfigurationTemplateIDsContainer.encode(replicationconfigurationtemplateids0)
            }
        }
    }
}

extension DescribeReplicationConfigurationTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeReplicationConfigurationTemplates"
    }
}

public struct DescribeReplicationConfigurationTemplatesInput: Swift.Equatable {
    /// Request to describe Replication Configuration template by max results.
    public var maxResults: Swift.Int
    /// Request to describe Replication Configuration template by next token.
    public var nextToken: Swift.String?
    /// Request to describe Replication Configuration template by template IDs.
    /// This member is required.
    public var replicationConfigurationTemplateIDs: [Swift.String]?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        replicationConfigurationTemplateIDs: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDs
    }
}

struct DescribeReplicationConfigurationTemplatesInputBody: Swift.Equatable {
    let replicationConfigurationTemplateIDs: [Swift.String]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeReplicationConfigurationTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case replicationConfigurationTemplateIDs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationConfigurationTemplateIDs)
        var replicationConfigurationTemplateIDsDecoded0:[Swift.String]? = nil
        if let replicationConfigurationTemplateIDsContainer = replicationConfigurationTemplateIDsContainer {
            replicationConfigurationTemplateIDsDecoded0 = [Swift.String]()
            for string0 in replicationConfigurationTemplateIDsContainer {
                if let string0 = string0 {
                    replicationConfigurationTemplateIDsDecoded0?.append(string0)
                }
            }
        }
        replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDsDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeReplicationConfigurationTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationConfigurationTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReplicationConfigurationTemplatesOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationConfigurationTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReplicationConfigurationTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeReplicationConfigurationTemplatesOutputResponse: Swift.Equatable {
    /// Request to describe Replication Configuration template by items.
    public var items: [MgnClientTypes.ReplicationConfigurationTemplate]?
    /// Request to describe Replication Configuration template by next token.
    public var nextToken: Swift.String?

    public init (
        items: [MgnClientTypes.ReplicationConfigurationTemplate]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeReplicationConfigurationTemplatesOutputResponseBody: Swift.Equatable {
    let items: [MgnClientTypes.ReplicationConfigurationTemplate]?
    let nextToken: Swift.String?
}

extension DescribeReplicationConfigurationTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.ReplicationConfigurationTemplate?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.ReplicationConfigurationTemplate]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.ReplicationConfigurationTemplate]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSourceServersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeSourceServersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeSourceServers"
    }
}

public struct DescribeSourceServersInput: Swift.Equatable {
    /// Request to filter Source Servers list.
    /// This member is required.
    public var filters: MgnClientTypes.DescribeSourceServersRequestFilters?
    /// Request to filter Source Servers list by maximum results.
    public var maxResults: Swift.Int
    /// Request to filter Source Servers list by next token.
    public var nextToken: Swift.String?

    public init (
        filters: MgnClientTypes.DescribeSourceServersRequestFilters? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeSourceServersInputBody: Swift.Equatable {
    let filters: MgnClientTypes.DescribeSourceServersRequestFilters?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeSourceServersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DescribeSourceServersRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSourceServersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSourceServersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSourceServersOutputError: Swift.Error, Swift.Equatable {
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSourceServersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSourceServersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeSourceServersOutputResponse: Swift.Equatable {
    /// Request to filter Source Servers list by item.
    public var items: [MgnClientTypes.SourceServer]?
    /// Request to filter Source Servers next token.
    public var nextToken: Swift.String?

    public init (
        items: [MgnClientTypes.SourceServer]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeSourceServersOutputResponseBody: Swift.Equatable {
    let items: [MgnClientTypes.SourceServer]?
    let nextToken: Swift.String?
}

extension DescribeSourceServersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.SourceServer?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.SourceServer]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.SourceServer]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension MgnClientTypes.DescribeSourceServersRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isArchived
        case lifeCycleStates
        case replicationTypes
        case sourceServerIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isArchived = isArchived {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let lifeCycleStates = lifeCycleStates {
            var lifeCycleStatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lifeCycleStates)
            for lifecyclestates0 in lifeCycleStates {
                try lifeCycleStatesContainer.encode(lifecyclestates0.rawValue)
            }
        }
        if let replicationTypes = replicationTypes {
            var replicationTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationTypes)
            for replicationtypes0 in replicationTypes {
                try replicationTypesContainer.encode(replicationtypes0.rawValue)
            }
        }
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for describesourceserversrequestfiltersids0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(describesourceserversrequestfiltersids0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[Swift.String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [Swift.String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let replicationTypesContainer = try containerValues.decodeIfPresent([MgnClientTypes.ReplicationType?].self, forKey: .replicationTypes)
        var replicationTypesDecoded0:[MgnClientTypes.ReplicationType]? = nil
        if let replicationTypesContainer = replicationTypesContainer {
            replicationTypesDecoded0 = [MgnClientTypes.ReplicationType]()
            for string0 in replicationTypesContainer {
                if let string0 = string0 {
                    replicationTypesDecoded0?.append(string0)
                }
            }
        }
        replicationTypes = replicationTypesDecoded0
        let lifeCycleStatesContainer = try containerValues.decodeIfPresent([MgnClientTypes.LifeCycleState?].self, forKey: .lifeCycleStates)
        var lifeCycleStatesDecoded0:[MgnClientTypes.LifeCycleState]? = nil
        if let lifeCycleStatesContainer = lifeCycleStatesContainer {
            lifeCycleStatesDecoded0 = [MgnClientTypes.LifeCycleState]()
            for string0 in lifeCycleStatesContainer {
                if let string0 = string0 {
                    lifeCycleStatesDecoded0?.append(string0)
                }
            }
        }
        lifeCycleStates = lifeCycleStatesDecoded0
    }
}

extension MgnClientTypes {
    /// Request to filter Source Servers list.
    public struct DescribeSourceServersRequestFilters: Swift.Equatable {
        /// Request to filter Source Servers list by archived.
        public var isArchived: Swift.Bool?
        /// Request to filter Source Servers list by life cycle states.
        public var lifeCycleStates: [MgnClientTypes.LifeCycleState]?
        /// Request to filter Source Servers list by replication type.
        public var replicationTypes: [MgnClientTypes.ReplicationType]?
        /// Request to filter Source Servers list by Source Server ID.
        public var sourceServerIDs: [Swift.String]?

        public init (
            isArchived: Swift.Bool? = nil,
            lifeCycleStates: [MgnClientTypes.LifeCycleState]? = nil,
            replicationTypes: [MgnClientTypes.ReplicationType]? = nil,
            sourceServerIDs: [Swift.String]? = nil
        )
        {
            self.isArchived = isArchived
            self.lifeCycleStates = lifeCycleStates
            self.replicationTypes = replicationTypes
            self.sourceServerIDs = sourceServerIDs
        }
    }

}

extension DescribeVcenterClientsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if maxResults != 0 {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension DescribeVcenterClientsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeVcenterClients"
    }
}

public struct DescribeVcenterClientsInput: Swift.Equatable {
    /// Maximum results to be returned in DescribeVcenterClients.
    public var maxResults: Swift.Int
    /// Next pagination token to be provided for DescribeVcenterClients.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeVcenterClientsInputBody: Swift.Equatable {
}

extension DescribeVcenterClientsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeVcenterClientsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVcenterClientsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeVcenterClientsOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVcenterClientsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeVcenterClientsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeVcenterClientsOutputResponse: Swift.Equatable {
    /// List of items returned by DescribeVcenterClients.
    public var items: [MgnClientTypes.VcenterClient]?
    /// Next pagination token returned from DescribeVcenterClients.
    public var nextToken: Swift.String?

    public init (
        items: [MgnClientTypes.VcenterClient]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeVcenterClientsOutputResponseBody: Swift.Equatable {
    let items: [MgnClientTypes.VcenterClient]?
    let nextToken: Swift.String?
}

extension DescribeVcenterClientsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([MgnClientTypes.VcenterClient?].self, forKey: .items)
        var itemsDecoded0:[MgnClientTypes.VcenterClient]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [MgnClientTypes.VcenterClient]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DisconnectFromServiceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension DisconnectFromServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DisconnectFromService"
    }
}

public struct DisconnectFromServiceInput: Swift.Equatable {
    /// Request to disconnect Source Server from service by Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct DisconnectFromServiceInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension DisconnectFromServiceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension DisconnectFromServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisconnectFromServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisconnectFromServiceOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisconnectFromServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisconnectFromServiceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.arn = nil
            self.dataReplicationInfo = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.vcenterClientID = nil
        }
    }
}

public struct DisconnectFromServiceOutputResponse: Swift.Equatable {
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init (
        arn: Swift.String? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.vcenterClientID = vcenterClientID
    }
}

struct DisconnectFromServiceOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
}

extension DisconnectFromServiceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case vcenterClientID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
    }
}

extension MgnClientTypes.Disk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytes
        case deviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bytes != 0 {
            try encodeContainer.encode(bytes, forKey: .bytes)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let bytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .bytes)
        bytes = bytesDecoded
    }
}

extension MgnClientTypes {
    /// The disk identifier.
    public struct Disk: Swift.Equatable {
        /// The amount of storage on the disk in bytes.
        public var bytes: Swift.Int
        /// The disk or device name.
        public var deviceName: Swift.String?

        public init (
            bytes: Swift.Int = 0,
            deviceName: Swift.String? = nil
        )
        {
            self.bytes = bytes
            self.deviceName = deviceName
        }
    }

}

extension FinalizeCutoverInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension FinalizeCutoverInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/FinalizeCutover"
    }
}

public struct FinalizeCutoverInput: Swift.Equatable {
    /// Request to finalize Cutover by Soure Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct FinalizeCutoverInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension FinalizeCutoverInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension FinalizeCutoverOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension FinalizeCutoverOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum FinalizeCutoverOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension FinalizeCutoverOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: FinalizeCutoverOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.arn = nil
            self.dataReplicationInfo = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.vcenterClientID = nil
        }
    }
}

public struct FinalizeCutoverOutputResponse: Swift.Equatable {
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init (
        arn: Swift.String? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.vcenterClientID = vcenterClientID
    }
}

struct FinalizeCutoverOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
}

extension FinalizeCutoverOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case vcenterClientID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
    }
}

extension MgnClientTypes {
    public enum FirstBoot: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case stopped
        case succeeded
        case unknown
        case waiting
        case sdkUnknown(Swift.String)

        public static var allCases: [FirstBoot] {
            return [
                .stopped,
                .succeeded,
                .unknown,
                .waiting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .stopped: return "STOPPED"
            case .succeeded: return "SUCCEEDED"
            case .unknown: return "UNKNOWN"
            case .waiting: return "WAITING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FirstBoot(rawValue: rawValue) ?? FirstBoot.sdkUnknown(rawValue)
        }
    }
}

extension GetLaunchConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension GetLaunchConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetLaunchConfiguration"
    }
}

public struct GetLaunchConfigurationInput: Swift.Equatable {
    /// Request to get Launch Configuration information by Source Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct GetLaunchConfigurationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension GetLaunchConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension GetLaunchConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLaunchConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLaunchConfigurationOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLaunchConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLaunchConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.copyPrivateIp = output.copyPrivateIp
            self.copyTags = output.copyTags
            self.ec2LaunchTemplateID = output.ec2LaunchTemplateID
            self.launchDisposition = output.launchDisposition
            self.licensing = output.licensing
            self.name = output.name
            self.sourceServerID = output.sourceServerID
            self.targetInstanceTypeRightSizingMethod = output.targetInstanceTypeRightSizingMethod
        } else {
            self.copyPrivateIp = nil
            self.copyTags = nil
            self.ec2LaunchTemplateID = nil
            self.launchDisposition = nil
            self.licensing = nil
            self.name = nil
            self.sourceServerID = nil
            self.targetInstanceTypeRightSizingMethod = nil
        }
    }
}

public struct GetLaunchConfigurationOutputResponse: Swift.Equatable {
    /// Copy Private IP during Launch Configuration.
    public var copyPrivateIp: Swift.Bool?
    /// Copy Tags during Launch Configuration.
    public var copyTags: Swift.Bool?
    /// Configure EC2 lauch configuration template ID.
    public var ec2LaunchTemplateID: Swift.String?
    /// Configure launch dispostion for launch configuration.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Configure launch configuration OS licensing.
    public var licensing: MgnClientTypes.Licensing?
    /// Configure launch configuration name.
    public var name: Swift.String?
    /// Configure launch configuration Source Server ID.
    public var sourceServerID: Swift.String?
    /// Configure launch configuration Target instance type right sizing method.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init (
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        ec2LaunchTemplateID: Swift.String? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        name: Swift.String? = nil,
        sourceServerID: Swift.String? = nil,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.ec2LaunchTemplateID = ec2LaunchTemplateID
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.name = name
        self.sourceServerID = sourceServerID
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct GetLaunchConfigurationOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let ec2LaunchTemplateID: Swift.String?
    let launchDisposition: MgnClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: MgnClientTypes.Licensing?
}

extension GetLaunchConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyPrivateIp
        case copyTags
        case ec2LaunchTemplateID
        case launchDisposition
        case licensing
        case name
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ec2LaunchTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2LaunchTemplateID)
        ec2LaunchTemplateID = ec2LaunchTemplateIDDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(MgnClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
    }
}

extension GetReplicationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension GetReplicationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetReplicationConfiguration"
    }
}

public struct GetReplicationConfigurationInput: Swift.Equatable {
    /// Request to get Replication Configuaration by Source Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct GetReplicationConfigurationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension GetReplicationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension GetReplicationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReplicationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetReplicationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReplicationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetReplicationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.name = output.name
            self.replicatedDisks = output.replicatedDisks
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.sourceServerID = output.sourceServerID
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
        } else {
            self.associateDefaultSecurityGroup = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.name = nil
            self.replicatedDisks = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.sourceServerID = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.useDedicatedReplicationServer = nil
        }
    }
}

public struct GetReplicationConfigurationOutputResponse: Swift.Equatable {
    /// Replication Configuration associate default Application Migration Service Security Group.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Replication Configuration set bandwidth throttling.
    public var bandwidthThrottling: Swift.Int
    /// Replication Configuration create Public IP.
    public var createPublicIP: Swift.Bool?
    /// Replication Configuration data plane routing.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Replication Configuration use default large Staging Disks.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Replication Configuration EBS encryption.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Replication Configuration EBS encryption key ARN.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Replication Configuration name.
    public var name: Swift.String?
    /// Replication Configuration replicated disks.
    public var replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]?
    /// Replication Configuration Replication Server instance type.
    public var replicationServerInstanceType: Swift.String?
    /// Replication Configuration Replication Server Security Group IDs.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Replication Configuration Source Server ID.
    public var sourceServerID: Swift.String?
    /// Replication Configuration Staging Area subnet ID.
    public var stagingAreaSubnetId: Swift.String?
    /// Replication Configuration Staging Area tags.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Replication Configuration use Dedicated Replication Server.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init (
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        sourceServerID: Swift.String? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.name = name
        self.replicatedDisks = replicatedDisks
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.sourceServerID = sourceServerID
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct GetReplicationConfigurationOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]?
    let ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
}

extension GetReplicationConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([MgnClientTypes.ReplicationConfigurationReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[MgnClientTypes.ReplicationConfigurationReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [MgnClientTypes.ReplicationConfigurationReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Swift.Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
    }
}

extension MgnClientTypes.IdentificationHints: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsInstanceID
        case fqdn
        case hostname
        case vmPath
        case vmWareUuid
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsInstanceID = awsInstanceID {
            try encodeContainer.encode(awsInstanceID, forKey: .awsInstanceID)
        }
        if let fqdn = fqdn {
            try encodeContainer.encode(fqdn, forKey: .fqdn)
        }
        if let hostname = hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let vmPath = vmPath {
            try encodeContainer.encode(vmPath, forKey: .vmPath)
        }
        if let vmWareUuid = vmWareUuid {
            try encodeContainer.encode(vmWareUuid, forKey: .vmWareUuid)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fqdnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fqdn)
        fqdn = fqdnDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let vmWareUuidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmWareUuid)
        vmWareUuid = vmWareUuidDecoded
        let awsInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsInstanceID)
        awsInstanceID = awsInstanceIDDecoded
        let vmPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmPath)
        vmPath = vmPathDecoded
    }
}

extension MgnClientTypes {
    /// Identification hints.
    public struct IdentificationHints: Swift.Equatable {
        /// AWS Instance ID identification hint.
        public var awsInstanceID: Swift.String?
        /// FQDN address identification hint.
        public var fqdn: Swift.String?
        /// Hostname identification hint.
        public var hostname: Swift.String?
        /// vCenter VM path identification hint.
        public var vmPath: Swift.String?
        /// vmWare UUID identification hint.
        public var vmWareUuid: Swift.String?

        public init (
            awsInstanceID: Swift.String? = nil,
            fqdn: Swift.String? = nil,
            hostname: Swift.String? = nil,
            vmPath: Swift.String? = nil,
            vmWareUuid: Swift.String? = nil
        )
        {
            self.awsInstanceID = awsInstanceID
            self.fqdn = fqdn
            self.hostname = hostname
            self.vmPath = vmPath
            self.vmWareUuid = vmWareUuid
        }
    }

}

extension InitializeServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/InitializeService"
    }
}

public struct InitializeServiceInput: Swift.Equatable {

}

struct InitializeServiceInputBody: Swift.Equatable {
}

extension InitializeServiceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension InitializeServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitializeServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InitializeServiceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitializeServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct InitializeServiceOutputResponse: Swift.Equatable {

}

extension MgnClientTypes {
    public enum InitiatedBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case diagnostic
        case startCutover
        case startTest
        case terminate
        case sdkUnknown(Swift.String)

        public static var allCases: [InitiatedBy] {
            return [
                .diagnostic,
                .startCutover,
                .startTest,
                .terminate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .diagnostic: return "DIAGNOSTIC"
            case .startCutover: return "START_CUTOVER"
            case .startTest: return "START_TEST"
            case .terminate: return "TERMINATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InitiatedBy(rawValue: rawValue) ?? InitiatedBy.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The server encountered an unexpected condition that prevented it from fulfilling the request.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// The server encountered an unexpected condition that prevented it from fulfilling the request. The request will be retried again after x seconds.
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MgnClientTypes.Job: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case endDateTime
        case initiatedBy
        case jobID
        case participatingServers
        case status
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime, forKey: .creationDateTime)
        }
        if let endDateTime = endDateTime {
            try encodeContainer.encode(endDateTime, forKey: .endDateTime)
        }
        if let initiatedBy = initiatedBy {
            try encodeContainer.encode(initiatedBy.rawValue, forKey: .initiatedBy)
        }
        if let jobID = jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
        if let participatingServers = participatingServers {
            var participatingServersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .participatingServers)
            for participatingservers0 in participatingServers {
                try participatingServersContainer.encode(participatingservers0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.JobType.self, forKey: .type)
        type = typeDecoded
        let initiatedByDecoded = try containerValues.decodeIfPresent(MgnClientTypes.InitiatedBy.self, forKey: .initiatedBy)
        initiatedBy = initiatedByDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let participatingServersContainer = try containerValues.decodeIfPresent([MgnClientTypes.ParticipatingServer?].self, forKey: .participatingServers)
        var participatingServersDecoded0:[MgnClientTypes.ParticipatingServer]? = nil
        if let participatingServersContainer = participatingServersContainer {
            participatingServersDecoded0 = [MgnClientTypes.ParticipatingServer]()
            for structure0 in participatingServersContainer {
                if let structure0 = structure0 {
                    participatingServersDecoded0?.append(structure0)
                }
            }
        }
        participatingServers = participatingServersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MgnClientTypes {
    /// Job.
    public struct Job: Swift.Equatable {
        /// the ARN of the specific Job.
        public var arn: Swift.String?
        /// Job creation time.
        public var creationDateTime: Swift.String?
        /// Job end time.
        public var endDateTime: Swift.String?
        /// Job initiated by field.
        public var initiatedBy: MgnClientTypes.InitiatedBy?
        /// Job ID.
        /// This member is required.
        public var jobID: Swift.String?
        /// Servers participating in a specific Job.
        public var participatingServers: [MgnClientTypes.ParticipatingServer]?
        /// Job status.
        public var status: MgnClientTypes.JobStatus?
        /// Tags associated with spcific Job.
        public var tags: [Swift.String:Swift.String]?
        /// Job type.
        public var type: MgnClientTypes.JobType?

        public init (
            arn: Swift.String? = nil,
            creationDateTime: Swift.String? = nil,
            endDateTime: Swift.String? = nil,
            initiatedBy: MgnClientTypes.InitiatedBy? = nil,
            jobID: Swift.String? = nil,
            participatingServers: [MgnClientTypes.ParticipatingServer]? = nil,
            status: MgnClientTypes.JobStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: MgnClientTypes.JobType? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.endDateTime = endDateTime
            self.initiatedBy = initiatedBy
            self.jobID = jobID
            self.participatingServers = participatingServers
            self.status = status
            self.tags = tags
            self.type = type
        }
    }

}

extension MgnClientTypes.JobLog: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case eventData
        case logDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let eventData = eventData {
            try encodeContainer.encode(eventData, forKey: .eventData)
        }
        if let logDateTime = logDateTime {
            try encodeContainer.encode(logDateTime, forKey: .logDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logDateTime)
        logDateTime = logDateTimeDecoded
        let eventDecoded = try containerValues.decodeIfPresent(MgnClientTypes.JobLogEvent.self, forKey: .event)
        event = eventDecoded
        let eventDataDecoded = try containerValues.decodeIfPresent(MgnClientTypes.JobLogEventData.self, forKey: .eventData)
        eventData = eventDataDecoded
    }
}

extension MgnClientTypes {
    /// Job log.
    public struct JobLog: Swift.Equatable {
        /// Job log event.
        public var event: MgnClientTypes.JobLogEvent?
        /// Job event data
        public var eventData: MgnClientTypes.JobLogEventData?
        /// Job log event date and time.
        public var logDateTime: Swift.String?

        public init (
            event: MgnClientTypes.JobLogEvent? = nil,
            eventData: MgnClientTypes.JobLogEventData? = nil,
            logDateTime: Swift.String? = nil
        )
        {
            self.event = event
            self.eventData = eventData
            self.logDateTime = logDateTime
        }
    }

}

extension MgnClientTypes {
    public enum JobLogEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cleanupEnd
        case cleanupFail
        case cleanupStart
        case conversionEnd
        case conversionFail
        case conversionStart
        case jobCancel
        case jobEnd
        case jobStart
        case launchFailed
        case launchStart
        case serverSkipped
        case snapshotEnd
        case snapshotFail
        case snapshotStart
        case usingPreviousSnapshot
        case sdkUnknown(Swift.String)

        public static var allCases: [JobLogEvent] {
            return [
                .cleanupEnd,
                .cleanupFail,
                .cleanupStart,
                .conversionEnd,
                .conversionFail,
                .conversionStart,
                .jobCancel,
                .jobEnd,
                .jobStart,
                .launchFailed,
                .launchStart,
                .serverSkipped,
                .snapshotEnd,
                .snapshotFail,
                .snapshotStart,
                .usingPreviousSnapshot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cleanupEnd: return "CLEANUP_END"
            case .cleanupFail: return "CLEANUP_FAIL"
            case .cleanupStart: return "CLEANUP_START"
            case .conversionEnd: return "CONVERSION_END"
            case .conversionFail: return "CONVERSION_FAIL"
            case .conversionStart: return "CONVERSION_START"
            case .jobCancel: return "JOB_CANCEL"
            case .jobEnd: return "JOB_END"
            case .jobStart: return "JOB_START"
            case .launchFailed: return "LAUNCH_FAILED"
            case .launchStart: return "LAUNCH_START"
            case .serverSkipped: return "SERVER_SKIPPED"
            case .snapshotEnd: return "SNAPSHOT_END"
            case .snapshotFail: return "SNAPSHOT_FAIL"
            case .snapshotStart: return "SNAPSHOT_START"
            case .usingPreviousSnapshot: return "USING_PREVIOUS_SNAPSHOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobLogEvent(rawValue: rawValue) ?? JobLogEvent.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.JobLogEventData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conversionServerID
        case rawError
        case sourceServerID
        case targetInstanceID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conversionServerID = conversionServerID {
            try encodeContainer.encode(conversionServerID, forKey: .conversionServerID)
        }
        if let rawError = rawError {
            try encodeContainer.encode(rawError, forKey: .rawError)
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let targetInstanceID = targetInstanceID {
            try encodeContainer.encode(targetInstanceID, forKey: .targetInstanceID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let conversionServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conversionServerID)
        conversionServerID = conversionServerIDDecoded
        let targetInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetInstanceID)
        targetInstanceID = targetInstanceIDDecoded
        let rawErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rawError)
        rawError = rawErrorDecoded
    }
}

extension MgnClientTypes {
    /// Job log data
    public struct JobLogEventData: Swift.Equatable {
        /// Job Event conversion Server ID.
        public var conversionServerID: Swift.String?
        /// Job error.
        public var rawError: Swift.String?
        /// Job Event Source Server ID.
        public var sourceServerID: Swift.String?
        /// Job Event Target instance ID.
        public var targetInstanceID: Swift.String?

        public init (
            conversionServerID: Swift.String? = nil,
            rawError: Swift.String? = nil,
            sourceServerID: Swift.String? = nil,
            targetInstanceID: Swift.String? = nil
        )
        {
            self.conversionServerID = conversionServerID
            self.rawError = rawError
            self.sourceServerID = sourceServerID
            self.targetInstanceID = targetInstanceID
        }
    }

}

extension MgnClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case pending
        case started
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .completed,
                .pending,
                .started,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .pending: return "PENDING"
            case .started: return "STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum JobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case launch
        case terminate
        case sdkUnknown(Swift.String)

        public static var allCases: [JobType] {
            return [
                .launch,
                .terminate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .launch: return "LAUNCH"
            case .terminate: return "TERMINATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobType(rawValue: rawValue) ?? JobType.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum LaunchDisposition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case started
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchDisposition] {
            return [
                .started,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchDisposition(rawValue: rawValue) ?? LaunchDisposition.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum LaunchStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case launched
        case pending
        case terminated
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchStatus] {
            return [
                .failed,
                .inProgress,
                .launched,
                .pending,
                .terminated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .launched: return "LAUNCHED"
            case .pending: return "PENDING"
            case .terminated: return "TERMINATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchStatus(rawValue: rawValue) ?? LaunchStatus.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.LaunchedInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ec2InstanceID
        case firstBoot
        case jobID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ec2InstanceID = ec2InstanceID {
            try encodeContainer.encode(ec2InstanceID, forKey: .ec2InstanceID)
        }
        if let firstBoot = firstBoot {
            try encodeContainer.encode(firstBoot.rawValue, forKey: .firstBoot)
        }
        if let jobID = jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2InstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceID)
        ec2InstanceID = ec2InstanceIDDecoded
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let firstBootDecoded = try containerValues.decodeIfPresent(MgnClientTypes.FirstBoot.self, forKey: .firstBoot)
        firstBoot = firstBootDecoded
    }
}

extension MgnClientTypes {
    /// Configure launced instance.
    public struct LaunchedInstance: Swift.Equatable {
        /// Configure launced instance EC2 ID.
        public var ec2InstanceID: Swift.String?
        /// Configure launced instance first boot.
        public var firstBoot: MgnClientTypes.FirstBoot?
        /// Configure launced instance Job ID.
        public var jobID: Swift.String?

        public init (
            ec2InstanceID: Swift.String? = nil,
            firstBoot: MgnClientTypes.FirstBoot? = nil,
            jobID: Swift.String? = nil
        )
        {
            self.ec2InstanceID = ec2InstanceID
            self.firstBoot = firstBoot
            self.jobID = jobID
        }
    }

}

extension MgnClientTypes.Licensing: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case osByol
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let osByol = osByol {
            try encodeContainer.encode(osByol, forKey: .osByol)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let osByolDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .osByol)
        osByol = osByolDecoded
    }
}

extension MgnClientTypes {
    /// Configure Licensing.
    public struct Licensing: Swift.Equatable {
        /// Configure BYOL OS licensing.
        public var osByol: Swift.Bool?

        public init (
            osByol: Swift.Bool? = nil
        )
        {
            self.osByol = osByol
        }
    }

}

extension MgnClientTypes.LifeCycle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addedToServiceDateTime
        case elapsedReplicationDuration
        case firstByteDateTime
        case lastCutover
        case lastSeenByServiceDateTime
        case lastTest
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addedToServiceDateTime = addedToServiceDateTime {
            try encodeContainer.encode(addedToServiceDateTime, forKey: .addedToServiceDateTime)
        }
        if let elapsedReplicationDuration = elapsedReplicationDuration {
            try encodeContainer.encode(elapsedReplicationDuration, forKey: .elapsedReplicationDuration)
        }
        if let firstByteDateTime = firstByteDateTime {
            try encodeContainer.encode(firstByteDateTime, forKey: .firstByteDateTime)
        }
        if let lastCutover = lastCutover {
            try encodeContainer.encode(lastCutover, forKey: .lastCutover)
        }
        if let lastSeenByServiceDateTime = lastSeenByServiceDateTime {
            try encodeContainer.encode(lastSeenByServiceDateTime, forKey: .lastSeenByServiceDateTime)
        }
        if let lastTest = lastTest {
            try encodeContainer.encode(lastTest, forKey: .lastTest)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addedToServiceDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addedToServiceDateTime)
        addedToServiceDateTime = addedToServiceDateTimeDecoded
        let firstByteDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstByteDateTime)
        firstByteDateTime = firstByteDateTimeDecoded
        let elapsedReplicationDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elapsedReplicationDuration)
        elapsedReplicationDuration = elapsedReplicationDurationDecoded
        let lastSeenByServiceDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSeenByServiceDateTime)
        lastSeenByServiceDateTime = lastSeenByServiceDateTimeDecoded
        let lastTestDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastTest.self, forKey: .lastTest)
        lastTest = lastTestDecoded
        let lastCutoverDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastCutover.self, forKey: .lastCutover)
        lastCutover = lastCutoverDecoded
        let stateDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleState.self, forKey: .state)
        state = stateDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle.
    public struct LifeCycle: Swift.Equatable {
        /// Lifecycle added to service data and time.
        public var addedToServiceDateTime: Swift.String?
        /// Lifecycle elapsed time and duration.
        public var elapsedReplicationDuration: Swift.String?
        /// Lifecycle replication initiation date and time.
        public var firstByteDateTime: Swift.String?
        /// Lifecycle last Cutover.
        public var lastCutover: MgnClientTypes.LifeCycleLastCutover?
        /// Lifecycle last seen date and time.
        public var lastSeenByServiceDateTime: Swift.String?
        /// Lifecycle last Test.
        public var lastTest: MgnClientTypes.LifeCycleLastTest?
        /// Lifecycle state.
        public var state: MgnClientTypes.LifeCycleState?

        public init (
            addedToServiceDateTime: Swift.String? = nil,
            elapsedReplicationDuration: Swift.String? = nil,
            firstByteDateTime: Swift.String? = nil,
            lastCutover: MgnClientTypes.LifeCycleLastCutover? = nil,
            lastSeenByServiceDateTime: Swift.String? = nil,
            lastTest: MgnClientTypes.LifeCycleLastTest? = nil,
            state: MgnClientTypes.LifeCycleState? = nil
        )
        {
            self.addedToServiceDateTime = addedToServiceDateTime
            self.elapsedReplicationDuration = elapsedReplicationDuration
            self.firstByteDateTime = firstByteDateTime
            self.lastCutover = lastCutover
            self.lastSeenByServiceDateTime = lastSeenByServiceDateTime
            self.lastTest = lastTest
            self.state = state
        }
    }

}

extension MgnClientTypes.LifeCycleLastCutover: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case finalized
        case initiated
        case reverted
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let finalized = finalized {
            try encodeContainer.encode(finalized, forKey: .finalized)
        }
        if let initiated = initiated {
            try encodeContainer.encode(initiated, forKey: .initiated)
        }
        if let reverted = reverted {
            try encodeContainer.encode(reverted, forKey: .reverted)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initiatedDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastCutoverInitiated.self, forKey: .initiated)
        initiated = initiatedDecoded
        let revertedDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastCutoverReverted.self, forKey: .reverted)
        reverted = revertedDecoded
        let finalizedDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastCutoverFinalized.self, forKey: .finalized)
        finalized = finalizedDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle last Cutover .
    public struct LifeCycleLastCutover: Swift.Equatable {
        /// Lifecycle Cutover finalized date and time.
        public var finalized: MgnClientTypes.LifeCycleLastCutoverFinalized?
        /// Lifecycle last Cutover initiated.
        public var initiated: MgnClientTypes.LifeCycleLastCutoverInitiated?
        /// Lifecycle last Cutover reverted.
        public var reverted: MgnClientTypes.LifeCycleLastCutoverReverted?

        public init (
            finalized: MgnClientTypes.LifeCycleLastCutoverFinalized? = nil,
            initiated: MgnClientTypes.LifeCycleLastCutoverInitiated? = nil,
            reverted: MgnClientTypes.LifeCycleLastCutoverReverted? = nil
        )
        {
            self.finalized = finalized
            self.initiated = initiated
            self.reverted = reverted
        }
    }

}

extension MgnClientTypes.LifeCycleLastCutoverFinalized: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCallDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle Cutover finalized
    public struct LifeCycleLastCutoverFinalized: Swift.Equatable {
        /// Lifecycle Cutover finalized date and time.
        public var apiCallDateTime: Swift.String?

        public init (
            apiCallDateTime: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
        }
    }

}

extension MgnClientTypes.LifeCycleLastCutoverInitiated: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCallDateTime
        case jobID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
        if let jobID = jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle last Cutover initiated.
    public struct LifeCycleLastCutoverInitiated: Swift.Equatable {
        ///
        public var apiCallDateTime: Swift.String?
        /// Lifecycle last Cutover initiated by Job ID.
        public var jobID: Swift.String?

        public init (
            apiCallDateTime: Swift.String? = nil,
            jobID: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
            self.jobID = jobID
        }
    }

}

extension MgnClientTypes.LifeCycleLastCutoverReverted: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCallDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle last Cutover reverted.
    public struct LifeCycleLastCutoverReverted: Swift.Equatable {
        /// Lifecycle last Cutover reverted API call date time.
        public var apiCallDateTime: Swift.String?

        public init (
            apiCallDateTime: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
        }
    }

}

extension MgnClientTypes.LifeCycleLastTest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case finalized
        case initiated
        case reverted
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let finalized = finalized {
            try encodeContainer.encode(finalized, forKey: .finalized)
        }
        if let initiated = initiated {
            try encodeContainer.encode(initiated, forKey: .initiated)
        }
        if let reverted = reverted {
            try encodeContainer.encode(reverted, forKey: .reverted)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initiatedDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastTestInitiated.self, forKey: .initiated)
        initiated = initiatedDecoded
        let revertedDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastTestReverted.self, forKey: .reverted)
        reverted = revertedDecoded
        let finalizedDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycleLastTestFinalized.self, forKey: .finalized)
        finalized = finalizedDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle last Test.
    public struct LifeCycleLastTest: Swift.Equatable {
        /// Lifecycle last Test finlized.
        public var finalized: MgnClientTypes.LifeCycleLastTestFinalized?
        /// Lifecycle last Test initiated.
        public var initiated: MgnClientTypes.LifeCycleLastTestInitiated?
        /// Lifecycle last Test reverted.
        public var reverted: MgnClientTypes.LifeCycleLastTestReverted?

        public init (
            finalized: MgnClientTypes.LifeCycleLastTestFinalized? = nil,
            initiated: MgnClientTypes.LifeCycleLastTestInitiated? = nil,
            reverted: MgnClientTypes.LifeCycleLastTestReverted? = nil
        )
        {
            self.finalized = finalized
            self.initiated = initiated
            self.reverted = reverted
        }
    }

}

extension MgnClientTypes.LifeCycleLastTestFinalized: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCallDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle last Test finlized.
    public struct LifeCycleLastTestFinalized: Swift.Equatable {
        /// Lifecycle Test failed API call date and time.
        public var apiCallDateTime: Swift.String?

        public init (
            apiCallDateTime: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
        }
    }

}

extension MgnClientTypes.LifeCycleLastTestInitiated: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCallDateTime
        case jobID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
        if let jobID = jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle last Test initiated.
    public struct LifeCycleLastTestInitiated: Swift.Equatable {
        /// Lifecycle last Test initiated API call date and time.
        public var apiCallDateTime: Swift.String?
        /// Lifecycle last Test initiated Job ID.
        public var jobID: Swift.String?

        public init (
            apiCallDateTime: Swift.String? = nil,
            jobID: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
            self.jobID = jobID
        }
    }

}

extension MgnClientTypes.LifeCycleLastTestReverted: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCallDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
    }
}

extension MgnClientTypes {
    /// Lifecycle last Test reverted.
    public struct LifeCycleLastTestReverted: Swift.Equatable {
        /// Lifecycle last Test reverted API call date and time.
        public var apiCallDateTime: Swift.String?

        public init (
            apiCallDateTime: Swift.String? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
        }
    }

}

extension MgnClientTypes {
    public enum LifeCycleState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cutover
        case cuttingOver
        case disconnected
        case discovered
        case notReady
        case readyForCutover
        case readyForTest
        case stopped
        case testing
        case sdkUnknown(Swift.String)

        public static var allCases: [LifeCycleState] {
            return [
                .cutover,
                .cuttingOver,
                .disconnected,
                .discovered,
                .notReady,
                .readyForCutover,
                .readyForTest,
                .stopped,
                .testing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cutover: return "CUTOVER"
            case .cuttingOver: return "CUTTING_OVER"
            case .disconnected: return "DISCONNECTED"
            case .discovered: return "DISCOVERED"
            case .notReady: return "NOT_READY"
            case .readyForCutover: return "READY_FOR_CUTOVER"
            case .readyForTest: return "READY_FOR_TEST"
            case .stopped: return "STOPPED"
            case .testing: return "TESTING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LifeCycleState(rawValue: rawValue) ?? LifeCycleState.sdkUnknown(rawValue)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// List tags for resource request by ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// List tags for resource response.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MarkAsArchivedInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension MarkAsArchivedInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/MarkAsArchived"
    }
}

public struct MarkAsArchivedInput: Swift.Equatable {
    /// Mark as archived by Source Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct MarkAsArchivedInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension MarkAsArchivedInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension MarkAsArchivedOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension MarkAsArchivedOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum MarkAsArchivedOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension MarkAsArchivedOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: MarkAsArchivedOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.arn = nil
            self.dataReplicationInfo = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.vcenterClientID = nil
        }
    }
}

public struct MarkAsArchivedOutputResponse: Swift.Equatable {
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init (
        arn: Swift.String? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.vcenterClientID = vcenterClientID
    }
}

struct MarkAsArchivedOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
}

extension MarkAsArchivedOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case vcenterClientID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
    }
}

extension MgnClientTypes.NetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ips
        case isPrimary
        case macAddress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ips = ips {
            var ipsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ips)
            for ipslist0 in ips {
                try ipsContainer.encode(ipslist0)
            }
        }
        if let isPrimary = isPrimary {
            try encodeContainer.encode(isPrimary, forKey: .isPrimary)
        }
        if let macAddress = macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let macAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let ipsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ips)
        var ipsDecoded0:[Swift.String]? = nil
        if let ipsContainer = ipsContainer {
            ipsDecoded0 = [Swift.String]()
            for string0 in ipsContainer {
                if let string0 = string0 {
                    ipsDecoded0?.append(string0)
                }
            }
        }
        ips = ipsDecoded0
        let isPrimaryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPrimary)
        isPrimary = isPrimaryDecoded
    }
}

extension MgnClientTypes {
    /// Network interface.
    public struct NetworkInterface: Swift.Equatable {
        /// Network interface IPs.
        public var ips: [Swift.String]?
        /// Network interface primary IP.
        public var isPrimary: Swift.Bool?
        /// Network interface Mac address.
        public var macAddress: Swift.String?

        public init (
            ips: [Swift.String]? = nil,
            isPrimary: Swift.Bool? = nil,
            macAddress: Swift.String? = nil
        )
        {
            self.ips = ips
            self.isPrimary = isPrimary
            self.macAddress = macAddress
        }
    }

}

extension MgnClientTypes.OS: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fullString
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fullString = fullString {
            try encodeContainer.encode(fullString, forKey: .fullString)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fullString)
        fullString = fullStringDecoded
    }
}

extension MgnClientTypes {
    /// Operating System.
    public struct OS: Swift.Equatable {
        /// OS full string.
        public var fullString: Swift.String?

        public init (
            fullString: Swift.String? = nil
        )
        {
            self.fullString = fullString
        }
    }

}

extension MgnClientTypes.ParticipatingServer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchStatus
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchStatus = launchStatus {
            try encodeContainer.encode(launchStatus.rawValue, forKey: .launchStatus)
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let launchStatusDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchStatus.self, forKey: .launchStatus)
        launchStatus = launchStatusDecoded
    }
}

extension MgnClientTypes {
    /// Server participating in Job.
    public struct ParticipatingServer: Swift.Equatable {
        /// Participating server launch status.
        public var launchStatus: MgnClientTypes.LaunchStatus?
        /// Participating server Source Server ID.
        public var sourceServerID: Swift.String?

        public init (
            launchStatus: MgnClientTypes.LaunchStatus? = nil,
            sourceServerID: Swift.String? = nil
        )
        {
            self.launchStatus = launchStatus
            self.sourceServerID = sourceServerID
        }
    }

}

extension MgnClientTypes {
    public enum ReplicationConfigurationDataPlaneRouting: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case privateIp
        case publicIp
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationDataPlaneRouting] {
            return [
                .privateIp,
                .publicIp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .privateIp: return "PRIVATE_IP"
            case .publicIp: return "PUBLIC_IP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationConfigurationDataPlaneRouting(rawValue: rawValue) ?? ReplicationConfigurationDataPlaneRouting.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum ReplicationConfigurationDefaultLargeStagingDiskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gp2
        case st1
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationDefaultLargeStagingDiskType] {
            return [
                .gp2,
                .st1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gp2: return "GP2"
            case .st1: return "ST1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationConfigurationDefaultLargeStagingDiskType(rawValue: rawValue) ?? ReplicationConfigurationDefaultLargeStagingDiskType.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes {
    public enum ReplicationConfigurationEbsEncryption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationEbsEncryption] {
            return [
                .custom,
                .default,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .default: return "DEFAULT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationConfigurationEbsEncryption(rawValue: rawValue) ?? ReplicationConfigurationEbsEncryption.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.ReplicationConfigurationReplicatedDisk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceName
        case iops
        case isBootDisk
        case stagingDiskType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if iops != 0 {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let isBootDisk = isBootDisk {
            try encodeContainer.encode(isBootDisk, forKey: .isBootDisk)
        }
        if let stagingDiskType = stagingDiskType {
            try encodeContainer.encode(stagingDiskType.rawValue, forKey: .stagingDiskType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let isBootDiskDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isBootDisk)
        isBootDisk = isBootDiskDecoded
        let stagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationReplicatedDiskStagingDiskType.self, forKey: .stagingDiskType)
        stagingDiskType = stagingDiskTypeDecoded
        let iopsDecoded = try containerValues.decode(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
    }
}

extension MgnClientTypes {
    /// Replication Configuration replicated disk.
    public struct ReplicationConfigurationReplicatedDisk: Swift.Equatable {
        /// Replication Configuration replicated disk device name.
        public var deviceName: Swift.String?
        /// Replication Configuration replicated disk IOPs.
        public var iops: Swift.Int
        /// Replication Configuration replicated disk boot disk.
        public var isBootDisk: Swift.Bool?
        /// Replication Configuration replicated disk staging disk type.
        public var stagingDiskType: MgnClientTypes.ReplicationConfigurationReplicatedDiskStagingDiskType?

        public init (
            deviceName: Swift.String? = nil,
            iops: Swift.Int = 0,
            isBootDisk: Swift.Bool? = nil,
            stagingDiskType: MgnClientTypes.ReplicationConfigurationReplicatedDiskStagingDiskType? = nil
        )
        {
            self.deviceName = deviceName
            self.iops = iops
            self.isBootDisk = isBootDisk
            self.stagingDiskType = stagingDiskType
        }
    }

}

extension MgnClientTypes {
    public enum ReplicationConfigurationReplicatedDiskStagingDiskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case gp2
        case io1
        case sc1
        case st1
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationReplicatedDiskStagingDiskType] {
            return [
                .auto,
                .gp2,
                .io1,
                .sc1,
                .st1,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .gp2: return "GP2"
            case .io1: return "IO1"
            case .sc1: return "SC1"
            case .st1: return "ST1"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationConfigurationReplicatedDiskStagingDiskType(rawValue: rawValue) ?? ReplicationConfigurationReplicatedDiskStagingDiskType.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.ReplicationConfigurationTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let associateDefaultSecurityGroup = associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let replicationConfigurationTemplateID = replicationConfigurationTemplateID {
            try encodeContainer.encode(replicationConfigurationTemplateID, forKey: .replicationConfigurationTemplateID)
        }
        if let replicationServerInstanceType = replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for replicationserverssecuritygroupsids0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(replicationserverssecuritygroupsids0)
            }
        }
        if let stagingAreaSubnetId = stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsmap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Swift.Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MgnClientTypes {
    public struct ReplicationConfigurationTemplate: Swift.Equatable {
        /// Replication Configuration template ARN.
        public var arn: Swift.String?
        /// Replication Configuration template associate default Application Migration Service Security group.
        public var associateDefaultSecurityGroup: Swift.Bool?
        /// Replication Configuration template bandwidth throtting.
        public var bandwidthThrottling: Swift.Int
        /// Replication Configuration template create Public IP.
        public var createPublicIP: Swift.Bool?
        /// Replication Configuration template data plane routing.
        public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
        /// Replication Configuration template use dedault large Staging Disk type.
        public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
        /// Replication Configuration template EBS encryption.
        public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
        /// Replication Configuration template EBS encryption key ARN.
        public var ebsEncryptionKeyArn: Swift.String?
        /// Replication Configuration template template ID.
        /// This member is required.
        public var replicationConfigurationTemplateID: Swift.String?
        /// Replication Configuration template server instance type.
        public var replicationServerInstanceType: Swift.String?
        /// Replication Configuration template server Security Groups IDs.
        public var replicationServersSecurityGroupsIDs: [Swift.String]?
        /// Replication Configuration template Staging Area subnet ID.
        public var stagingAreaSubnetId: Swift.String?
        /// Replication Configuration template Staging Area Tags.
        public var stagingAreaTags: [Swift.String:Swift.String]?
        /// Replication Configuration template Tags.
        public var tags: [Swift.String:Swift.String]?
        /// Replication Configuration template use Dedicated Replication Server.
        public var useDedicatedReplicationServer: Swift.Bool?

        public init (
            arn: Swift.String? = nil,
            associateDefaultSecurityGroup: Swift.Bool? = nil,
            bandwidthThrottling: Swift.Int = 0,
            createPublicIP: Swift.Bool? = nil,
            dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
            defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
            ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
            ebsEncryptionKeyArn: Swift.String? = nil,
            replicationConfigurationTemplateID: Swift.String? = nil,
            replicationServerInstanceType: Swift.String? = nil,
            replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
            stagingAreaSubnetId: Swift.String? = nil,
            stagingAreaTags: [Swift.String:Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            useDedicatedReplicationServer: Swift.Bool? = nil
        )
        {
            self.arn = arn
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.tags = tags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
        }
    }

}

extension MgnClientTypes {
    public enum ReplicationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agentBased
        case snapshotShipping
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationType] {
            return [
                .agentBased,
                .snapshotShipping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agentBased: return "AGENT_BASED"
            case .snapshotShipping: return "SNAPSHOT_SHIPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationType(rawValue: rawValue) ?? ReplicationType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.code = nil
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Resource not found exception.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?
    /// Resource ID not found error.
    public var resourceId: Swift.String?
    /// Resource type not found error.
    public var resourceType: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension RetryDataReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension RetryDataReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/RetryDataReplication"
    }
}

public struct RetryDataReplicationInput: Swift.Equatable {
    /// Retry data replication for Source Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct RetryDataReplicationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension RetryDataReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension RetryDataReplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RetryDataReplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RetryDataReplicationOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RetryDataReplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RetryDataReplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.arn = nil
            self.dataReplicationInfo = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.vcenterClientID = nil
        }
    }
}

public struct RetryDataReplicationOutputResponse: Swift.Equatable {
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init (
        arn: Swift.String? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.vcenterClientID = vcenterClientID
    }
}

struct RetryDataReplicationOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
}

extension RetryDataReplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case vcenterClientID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.code = nil
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be completed because its exceeded the service quota.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?
    /// Exceeded the service quota code.
    public var quotaCode: Swift.String?
    /// Exceeded the service quota resource Id.
    public var resourceId: Swift.String?
    /// Exceeded the service quota resource type.
    public var resourceType: Swift.String?
    /// Exceeded the service quota service code.
    public var serviceCode: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension MgnClientTypes.SourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpus
        case disks
        case identificationHints
        case lastUpdatedDateTime
        case networkInterfaces
        case os
        case ramBytes
        case recommendedInstanceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpus = cpus {
            var cpusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cpus)
            for cpus0 in cpus {
                try cpusContainer.encode(cpus0)
            }
        }
        if let disks = disks {
            var disksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .disks)
            for disks0 in disks {
                try disksContainer.encode(disks0)
            }
        }
        if let identificationHints = identificationHints {
            try encodeContainer.encode(identificationHints, forKey: .identificationHints)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime, forKey: .lastUpdatedDateTime)
        }
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterfaces0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterfaces0)
            }
        }
        if let os = os {
            try encodeContainer.encode(os, forKey: .os)
        }
        if ramBytes != 0 {
            try encodeContainer.encode(ramBytes, forKey: .ramBytes)
        }
        if let recommendedInstanceType = recommendedInstanceType {
            try encodeContainer.encode(recommendedInstanceType, forKey: .recommendedInstanceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let recommendedInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedInstanceType)
        recommendedInstanceType = recommendedInstanceTypeDecoded
        let identificationHintsDecoded = try containerValues.decodeIfPresent(MgnClientTypes.IdentificationHints.self, forKey: .identificationHints)
        identificationHints = identificationHintsDecoded
        let networkInterfacesContainer = try containerValues.decodeIfPresent([MgnClientTypes.NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[MgnClientTypes.NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [MgnClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
        let disksContainer = try containerValues.decodeIfPresent([MgnClientTypes.Disk?].self, forKey: .disks)
        var disksDecoded0:[MgnClientTypes.Disk]? = nil
        if let disksContainer = disksContainer {
            disksDecoded0 = [MgnClientTypes.Disk]()
            for structure0 in disksContainer {
                if let structure0 = structure0 {
                    disksDecoded0?.append(structure0)
                }
            }
        }
        disks = disksDecoded0
        let cpusContainer = try containerValues.decodeIfPresent([MgnClientTypes.CPU?].self, forKey: .cpus)
        var cpusDecoded0:[MgnClientTypes.CPU]? = nil
        if let cpusContainer = cpusContainer {
            cpusDecoded0 = [MgnClientTypes.CPU]()
            for structure0 in cpusContainer {
                if let structure0 = structure0 {
                    cpusDecoded0?.append(structure0)
                }
            }
        }
        cpus = cpusDecoded0
        let ramBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .ramBytes)
        ramBytes = ramBytesDecoded
        let osDecoded = try containerValues.decodeIfPresent(MgnClientTypes.OS.self, forKey: .os)
        os = osDecoded
    }
}

extension MgnClientTypes {
    /// Source server properties.
    public struct SourceProperties: Swift.Equatable {
        /// Source Server CPUs.
        public var cpus: [MgnClientTypes.CPU]?
        /// Source Server disks.
        public var disks: [MgnClientTypes.Disk]?
        /// Source server identification hints.
        public var identificationHints: MgnClientTypes.IdentificationHints?
        /// Source server last update date and time.
        public var lastUpdatedDateTime: Swift.String?
        /// Source server network interfaces.
        public var networkInterfaces: [MgnClientTypes.NetworkInterface]?
        /// Source server OS.
        public var os: MgnClientTypes.OS?
        /// Source server RAM in bytes.
        public var ramBytes: Swift.Int
        /// Source server recommended instance type.
        public var recommendedInstanceType: Swift.String?

        public init (
            cpus: [MgnClientTypes.CPU]? = nil,
            disks: [MgnClientTypes.Disk]? = nil,
            identificationHints: MgnClientTypes.IdentificationHints? = nil,
            lastUpdatedDateTime: Swift.String? = nil,
            networkInterfaces: [MgnClientTypes.NetworkInterface]? = nil,
            os: MgnClientTypes.OS? = nil,
            ramBytes: Swift.Int = 0,
            recommendedInstanceType: Swift.String? = nil
        )
        {
            self.cpus = cpus
            self.disks = disks
            self.identificationHints = identificationHints
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.networkInterfaces = networkInterfaces
            self.os = os
            self.ramBytes = ramBytes
            self.recommendedInstanceType = recommendedInstanceType
        }
    }

}

extension MgnClientTypes.SourceServer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case vcenterClientID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dataReplicationInfo = dataReplicationInfo {
            try encodeContainer.encode(dataReplicationInfo, forKey: .dataReplicationInfo)
        }
        if let isArchived = isArchived {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let launchedInstance = launchedInstance {
            try encodeContainer.encode(launchedInstance, forKey: .launchedInstance)
        }
        if let lifeCycle = lifeCycle {
            try encodeContainer.encode(lifeCycle, forKey: .lifeCycle)
        }
        if let replicationType = replicationType {
            try encodeContainer.encode(replicationType.rawValue, forKey: .replicationType)
        }
        if let sourceProperties = sourceProperties {
            try encodeContainer.encode(sourceProperties, forKey: .sourceProperties)
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vcenterClientID = vcenterClientID {
            try encodeContainer.encode(vcenterClientID, forKey: .vcenterClientID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
    }
}

extension MgnClientTypes {
    public struct SourceServer: Swift.Equatable {
        /// Source server ARN.
        public var arn: Swift.String?
        /// Source server data replication info.
        public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
        /// Source server archived status.
        public var isArchived: Swift.Bool?
        /// Source server launched instance.
        public var launchedInstance: MgnClientTypes.LaunchedInstance?
        /// Source server lifecycle state.
        public var lifeCycle: MgnClientTypes.LifeCycle?
        /// Source server replication type.
        public var replicationType: MgnClientTypes.ReplicationType?
        /// Source server properties.
        public var sourceProperties: MgnClientTypes.SourceProperties?
        /// Source server ID.
        public var sourceServerID: Swift.String?
        /// Source server Tags.
        public var tags: [Swift.String:Swift.String]?
        /// Source server vCenter client id.
        public var vcenterClientID: Swift.String?

        public init (
            arn: Swift.String? = nil,
            dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
            isArchived: Swift.Bool? = nil,
            launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
            lifeCycle: MgnClientTypes.LifeCycle? = nil,
            replicationType: MgnClientTypes.ReplicationType? = nil,
            sourceProperties: MgnClientTypes.SourceProperties? = nil,
            sourceServerID: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            vcenterClientID: Swift.String? = nil
        )
        {
            self.arn = arn
            self.dataReplicationInfo = dataReplicationInfo
            self.isArchived = isArchived
            self.launchedInstance = launchedInstance
            self.lifeCycle = lifeCycle
            self.replicationType = replicationType
            self.sourceProperties = sourceProperties
            self.sourceServerID = sourceServerID
            self.tags = tags
            self.vcenterClientID = vcenterClientID
        }
    }

}

extension StartCutoverInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerIDs
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for startcutoverrequestsourceserverids0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(startcutoverrequestsourceserverids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartCutoverInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StartCutover"
    }
}

public struct StartCutoverInput: Swift.Equatable {
    /// Start Cutover by Source Server IDs.
    /// This member is required.
    public var sourceServerIDs: [Swift.String]?
    /// Start Cutover by Tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        sourceServerIDs: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.sourceServerIDs = sourceServerIDs
        self.tags = tags
    }
}

struct StartCutoverInputBody: Swift.Equatable {
    let sourceServerIDs: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension StartCutoverInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerIDs
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[Swift.String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [Swift.String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartCutoverOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartCutoverOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartCutoverOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartCutoverOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartCutoverOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StartCutoverOutputResponse: Swift.Equatable {
    /// Start Cutover Job response.
    public var job: MgnClientTypes.Job?

    public init (
        job: MgnClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct StartCutoverOutputResponseBody: Swift.Equatable {
    let job: MgnClientTypes.Job?
}

extension StartCutoverOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

extension StartReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension StartReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StartReplication"
    }
}

public struct StartReplicationInput: Swift.Equatable {
    /// ID of source server on which to start replication.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct StartReplicationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension StartReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension StartReplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartReplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartReplicationOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartReplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartReplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.arn = nil
            self.dataReplicationInfo = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.vcenterClientID = nil
        }
    }
}

public struct StartReplicationOutputResponse: Swift.Equatable {
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init (
        arn: Swift.String? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.vcenterClientID = vcenterClientID
    }
}

struct StartReplicationOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
}

extension StartReplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case vcenterClientID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
    }
}

extension StartTestInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerIDs
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for starttestrequestsourceserverids0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(starttestrequestsourceserverids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartTestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StartTest"
    }
}

public struct StartTestInput: Swift.Equatable {
    /// Start Test for Source Server IDs.
    /// This member is required.
    public var sourceServerIDs: [Swift.String]?
    /// Start Test by Tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        sourceServerIDs: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.sourceServerIDs = sourceServerIDs
        self.tags = tags
    }
}

struct StartTestInputBody: Swift.Equatable {
    let sourceServerIDs: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension StartTestInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerIDs
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[Swift.String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [Swift.String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartTestOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartTestOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartTestOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartTestOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartTestOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StartTestOutputResponse: Swift.Equatable {
    /// Start Test Job response.
    public var job: MgnClientTypes.Job?

    public init (
        job: MgnClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct StartTestOutputResponseBody: Swift.Equatable {
    let job: MgnClientTypes.Job?
}

extension StartTestOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// Tag resource by ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Tag resource by Tags.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension MgnClientTypes {
    public enum TargetInstanceTypeRightSizingMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basic
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetInstanceTypeRightSizingMethod] {
            return [
                .basic,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basic: return "BASIC"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetInstanceTypeRightSizingMethod(rawValue: rawValue) ?? TargetInstanceTypeRightSizingMethod.sdkUnknown(rawValue)
        }
    }
}

extension TerminateTargetInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerIDs
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for terminatetargetinstancesrequestsourceserverids0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(terminatetargetinstancesrequestsourceserverids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TerminateTargetInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/TerminateTargetInstances"
    }
}

public struct TerminateTargetInstancesInput: Swift.Equatable {
    /// Terminate Target instance by Source Server IDs.
    /// This member is required.
    public var sourceServerIDs: [Swift.String]?
    /// Terminate Target instance by Tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        sourceServerIDs: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.sourceServerIDs = sourceServerIDs
        self.tags = tags
    }
}

struct TerminateTargetInstancesInputBody: Swift.Equatable {
    let sourceServerIDs: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension TerminateTargetInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerIDs
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[Swift.String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [Swift.String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TerminateTargetInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TerminateTargetInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TerminateTargetInstancesOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TerminateTargetInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TerminateTargetInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct TerminateTargetInstancesOutputResponse: Swift.Equatable {
    /// Terminate Target instance Job response.
    public var job: MgnClientTypes.Job?

    public init (
        job: MgnClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct TerminateTargetInstancesOutputResponseBody: Swift.Equatable {
    let job: MgnClientTypes.Job?
}

extension TerminateTargetInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Reached throttling quota exception.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Reached throttling quota exception.
    public var quotaCode: Swift.String?
    /// Reached throttling quota exception will retry after x seconds.
    public var retryAfterSeconds: Swift.String?
    /// Reached throttling quota exception service code.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension UninitializedAccountException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UninitializedAccountExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Unitialized account exception.
public struct UninitializedAccountException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct UninitializedAccountExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension UninitializedAccountExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// Untag resource by ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Untag resource by Keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateLaunchConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyPrivateIp
        case copyTags
        case launchDisposition
        case licensing
        case name
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let copyPrivateIp = copyPrivateIp {
            try encodeContainer.encode(copyPrivateIp, forKey: .copyPrivateIp)
        }
        if let copyTags = copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let launchDisposition = launchDisposition {
            try encodeContainer.encode(launchDisposition.rawValue, forKey: .launchDisposition)
        }
        if let licensing = licensing {
            try encodeContainer.encode(licensing, forKey: .licensing)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod {
            try encodeContainer.encode(targetInstanceTypeRightSizingMethod.rawValue, forKey: .targetInstanceTypeRightSizingMethod)
        }
    }
}

extension UpdateLaunchConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateLaunchConfiguration"
    }
}

public struct UpdateLaunchConfigurationInput: Swift.Equatable {
    /// Update Launch configuration copy Private IP request.
    public var copyPrivateIp: Swift.Bool?
    /// Update Launch configuration copy Tags request.
    public var copyTags: Swift.Bool?
    /// Update Launch configuration launch disposition request.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Update Launch configuration licensing request.
    public var licensing: MgnClientTypes.Licensing?
    /// Update Launch configuration name request.
    public var name: Swift.String?
    /// Update Launch configuration by Source Server ID request.
    /// This member is required.
    public var sourceServerID: Swift.String?
    /// Update Launch configuration Target instance right sizing request.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init (
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        name: Swift.String? = nil,
        sourceServerID: Swift.String? = nil,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.name = name
        self.sourceServerID = sourceServerID
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct UpdateLaunchConfigurationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let launchDisposition: MgnClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: MgnClientTypes.Licensing?
}

extension UpdateLaunchConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyPrivateIp
        case copyTags
        case launchDisposition
        case licensing
        case name
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(MgnClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
    }
}

extension UpdateLaunchConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLaunchConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLaunchConfigurationOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLaunchConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateLaunchConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.copyPrivateIp = output.copyPrivateIp
            self.copyTags = output.copyTags
            self.ec2LaunchTemplateID = output.ec2LaunchTemplateID
            self.launchDisposition = output.launchDisposition
            self.licensing = output.licensing
            self.name = output.name
            self.sourceServerID = output.sourceServerID
            self.targetInstanceTypeRightSizingMethod = output.targetInstanceTypeRightSizingMethod
        } else {
            self.copyPrivateIp = nil
            self.copyTags = nil
            self.ec2LaunchTemplateID = nil
            self.launchDisposition = nil
            self.licensing = nil
            self.name = nil
            self.sourceServerID = nil
            self.targetInstanceTypeRightSizingMethod = nil
        }
    }
}

public struct UpdateLaunchConfigurationOutputResponse: Swift.Equatable {
    /// Copy Private IP during Launch Configuration.
    public var copyPrivateIp: Swift.Bool?
    /// Copy Tags during Launch Configuration.
    public var copyTags: Swift.Bool?
    /// Configure EC2 lauch configuration template ID.
    public var ec2LaunchTemplateID: Swift.String?
    /// Configure launch dispostion for launch configuration.
    public var launchDisposition: MgnClientTypes.LaunchDisposition?
    /// Configure launch configuration OS licensing.
    public var licensing: MgnClientTypes.Licensing?
    /// Configure launch configuration name.
    public var name: Swift.String?
    /// Configure launch configuration Source Server ID.
    public var sourceServerID: Swift.String?
    /// Configure launch configuration Target instance type right sizing method.
    public var targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?

    public init (
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        ec2LaunchTemplateID: Swift.String? = nil,
        launchDisposition: MgnClientTypes.LaunchDisposition? = nil,
        licensing: MgnClientTypes.Licensing? = nil,
        name: Swift.String? = nil,
        sourceServerID: Swift.String? = nil,
        targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.ec2LaunchTemplateID = ec2LaunchTemplateID
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.name = name
        self.sourceServerID = sourceServerID
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct UpdateLaunchConfigurationOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let ec2LaunchTemplateID: Swift.String?
    let launchDisposition: MgnClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: MgnClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: MgnClientTypes.Licensing?
}

extension UpdateLaunchConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyPrivateIp
        case copyTags
        case ec2LaunchTemplateID
        case launchDisposition
        case licensing
        case name
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ec2LaunchTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2LaunchTemplateID)
        ec2LaunchTemplateID = ec2LaunchTemplateIDDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(MgnClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
    }
}

extension UpdateReplicationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associateDefaultSecurityGroup = associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let replicatedDisks = replicatedDisks {
            var replicatedDisksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicatedDisks)
            for replicationconfigurationreplicateddisks0 in replicatedDisks {
                try replicatedDisksContainer.encode(replicationconfigurationreplicateddisks0)
            }
        }
        if let replicationServerInstanceType = replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for replicationserverssecuritygroupsids0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(replicationserverssecuritygroupsids0)
            }
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let stagingAreaSubnetId = stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsmap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
    }
}

extension UpdateReplicationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateReplicationConfiguration"
    }
}

public struct UpdateReplicationConfigurationInput: Swift.Equatable {
    /// Update replication configuration associate default Application Migration Service Security group request.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Update replication configuration bandwidth throttling request.
    public var bandwidthThrottling: Swift.Int
    /// Update replication configuration create Public IP request.
    public var createPublicIP: Swift.Bool?
    /// Update replication configuration data plane routing request.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Update replication configuration use default large Staging Disk type request.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Update replication configuration EBS encryption request.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Update replication configuration EBS encryption key ARN request.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Update replication configuration name request.
    public var name: Swift.String?
    /// Update replication configuration replicated disks request.
    public var replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]?
    /// Update replication configuration Replication Server instance type request.
    public var replicationServerInstanceType: Swift.String?
    /// Update replication configuration Replication Server Security Groups IDs request.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Update replication configuration Source Server ID request.
    /// This member is required.
    public var sourceServerID: Swift.String?
    /// Update replication configuration Staging Area subnet request.
    public var stagingAreaSubnetId: Swift.String?
    /// Update replication configuration Staging Area Tags request.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Update replication configuration use dedicated Replication Server request.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init (
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        sourceServerID: Swift.String? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.name = name
        self.replicatedDisks = replicatedDisks
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.sourceServerID = sourceServerID
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct UpdateReplicationConfigurationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]?
    let ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
}

extension UpdateReplicationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([MgnClientTypes.ReplicationConfigurationReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[MgnClientTypes.ReplicationConfigurationReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [MgnClientTypes.ReplicationConfigurationReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Swift.Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
    }
}

extension UpdateReplicationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateReplicationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateReplicationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateReplicationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateReplicationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.name = output.name
            self.replicatedDisks = output.replicatedDisks
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.sourceServerID = output.sourceServerID
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
        } else {
            self.associateDefaultSecurityGroup = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.name = nil
            self.replicatedDisks = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.sourceServerID = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.useDedicatedReplicationServer = nil
        }
    }
}

public struct UpdateReplicationConfigurationOutputResponse: Swift.Equatable {
    /// Replication Configuration associate default Application Migration Service Security Group.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Replication Configuration set bandwidth throttling.
    public var bandwidthThrottling: Swift.Int
    /// Replication Configuration create Public IP.
    public var createPublicIP: Swift.Bool?
    /// Replication Configuration data plane routing.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Replication Configuration use default large Staging Disks.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Replication Configuration EBS encryption.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Replication Configuration EBS encryption key ARN.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Replication Configuration name.
    public var name: Swift.String?
    /// Replication Configuration replicated disks.
    public var replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]?
    /// Replication Configuration Replication Server instance type.
    public var replicationServerInstanceType: Swift.String?
    /// Replication Configuration Replication Server Security Group IDs.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Replication Configuration Source Server ID.
    public var sourceServerID: Swift.String?
    /// Replication Configuration Staging Area subnet ID.
    public var stagingAreaSubnetId: Swift.String?
    /// Replication Configuration Staging Area tags.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Replication Configuration use Dedicated Replication Server.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init (
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        sourceServerID: Swift.String? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.name = name
        self.replicatedDisks = replicatedDisks
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.sourceServerID = sourceServerID
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct UpdateReplicationConfigurationOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let replicatedDisks: [MgnClientTypes.ReplicationConfigurationReplicatedDisk]?
    let ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
}

extension UpdateReplicationConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([MgnClientTypes.ReplicationConfigurationReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[MgnClientTypes.ReplicationConfigurationReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [MgnClientTypes.ReplicationConfigurationReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Swift.Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
    }
}

extension UpdateReplicationConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let associateDefaultSecurityGroup = associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let replicationConfigurationTemplateID = replicationConfigurationTemplateID {
            try encodeContainer.encode(replicationConfigurationTemplateID, forKey: .replicationConfigurationTemplateID)
        }
        if let replicationServerInstanceType = replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for replicationserverssecuritygroupsids0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(replicationserverssecuritygroupsids0)
            }
        }
        if let stagingAreaSubnetId = stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsmap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
    }
}

extension UpdateReplicationConfigurationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateReplicationConfigurationTemplate"
    }
}

public struct UpdateReplicationConfigurationTemplateInput: Swift.Equatable {
    /// Update replication configuration template ARN request.
    public var arn: Swift.String?
    /// Update replication configuration template associate default Application Migration Service Security group request.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Update replication configuration template bandwidth throttling request.
    public var bandwidthThrottling: Swift.Int
    /// Update replication configuration template create Public IP request.
    public var createPublicIP: Swift.Bool?
    /// Update replication configuration template data plane routing request.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Update replication configuration template use default large Staging Disk type request.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Update replication configuration template EBS encryption request.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Update replication configuration template EBS encryption key ARN request.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Update replication configuration template template ID request.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?
    /// Update replication configuration template Replication Server instance type request.
    public var replicationServerInstanceType: Swift.String?
    /// Update replication configuration template Replication Server Security groups IDs request.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Update replication configuration template Staging Area subnet ID request.
    public var stagingAreaSubnetId: Swift.String?
    /// Update replication configuration template Staging Area Tags request.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Update replication configuration template use dedicated Replication Server request.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init (
        arn: Swift.String? = nil,
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        replicationConfigurationTemplateID: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct UpdateReplicationConfigurationTemplateInputBody: Swift.Equatable {
    let replicationConfigurationTemplateID: Swift.String?
    let arn: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
}

extension UpdateReplicationConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Swift.Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
    }
}

extension UpdateReplicationConfigurationTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateReplicationConfigurationTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateReplicationConfigurationTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateReplicationConfigurationTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateReplicationConfigurationTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.replicationConfigurationTemplateID = output.replicationConfigurationTemplateID
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.tags = output.tags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
        } else {
            self.arn = nil
            self.associateDefaultSecurityGroup = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.replicationConfigurationTemplateID = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.tags = nil
            self.useDedicatedReplicationServer = nil
        }
    }
}

public struct UpdateReplicationConfigurationTemplateOutputResponse: Swift.Equatable {
    /// Replication Configuration template ARN.
    public var arn: Swift.String?
    /// Replication Configuration template associate default Application Migration Service Security group.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Replication Configuration template bandwidth throtting.
    public var bandwidthThrottling: Swift.Int
    /// Replication Configuration template create Public IP.
    public var createPublicIP: Swift.Bool?
    /// Replication Configuration template data plane routing.
    public var dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// Replication Configuration template use dedault large Staging Disk type.
    public var defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// Replication Configuration template EBS encryption.
    public var ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    /// Replication Configuration template EBS encryption key ARN.
    public var ebsEncryptionKeyArn: Swift.String?
    /// Replication Configuration template template ID.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?
    /// Replication Configuration template server instance type.
    public var replicationServerInstanceType: Swift.String?
    /// Replication Configuration template server Security Groups IDs.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// Replication Configuration template Staging Area subnet ID.
    public var stagingAreaSubnetId: Swift.String?
    /// Replication Configuration template Staging Area Tags.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Replication Configuration template Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Replication Configuration template use Dedicated Replication Server.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init (
        arn: Swift.String? = nil,
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        replicationConfigurationTemplateID: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct UpdateReplicationConfigurationTemplateOutputResponseBody: Swift.Equatable {
    let replicationConfigurationTemplateID: Swift.String?
    let arn: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let ebsEncryption: MgnClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: MgnClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension UpdateReplicationConfigurationTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Swift.Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateSourceServerReplicationTypeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationType
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationType = replicationType {
            try encodeContainer.encode(replicationType.rawValue, forKey: .replicationType)
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension UpdateSourceServerReplicationTypeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateSourceServerReplicationType"
    }
}

public struct UpdateSourceServerReplicationTypeInput: Swift.Equatable {
    /// Replication type to which to update source server.
    /// This member is required.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// ID of source server on which to update replication type.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.replicationType = replicationType
        self.sourceServerID = sourceServerID
    }
}

struct UpdateSourceServerReplicationTypeInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let replicationType: MgnClientTypes.ReplicationType?
}

extension UpdateSourceServerReplicationTypeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationType
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
    }
}

extension UpdateSourceServerReplicationTypeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSourceServerReplicationTypeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSourceServerReplicationTypeOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSourceServerReplicationTypeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateSourceServerReplicationTypeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.isArchived = output.isArchived
            self.launchedInstance = output.launchedInstance
            self.lifeCycle = output.lifeCycle
            self.replicationType = output.replicationType
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
            self.vcenterClientID = output.vcenterClientID
        } else {
            self.arn = nil
            self.dataReplicationInfo = nil
            self.isArchived = nil
            self.launchedInstance = nil
            self.lifeCycle = nil
            self.replicationType = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
            self.vcenterClientID = nil
        }
    }
}

public struct UpdateSourceServerReplicationTypeOutputResponse: Swift.Equatable {
    /// Source server ARN.
    public var arn: Swift.String?
    /// Source server data replication info.
    public var dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    /// Source server archived status.
    public var isArchived: Swift.Bool?
    /// Source server launched instance.
    public var launchedInstance: MgnClientTypes.LaunchedInstance?
    /// Source server lifecycle state.
    public var lifeCycle: MgnClientTypes.LifeCycle?
    /// Source server replication type.
    public var replicationType: MgnClientTypes.ReplicationType?
    /// Source server properties.
    public var sourceProperties: MgnClientTypes.SourceProperties?
    /// Source server ID.
    public var sourceServerID: Swift.String?
    /// Source server Tags.
    public var tags: [Swift.String:Swift.String]?
    /// Source server vCenter client id.
    public var vcenterClientID: Swift.String?

    public init (
        arn: Swift.String? = nil,
        dataReplicationInfo: MgnClientTypes.DataReplicationInfo? = nil,
        isArchived: Swift.Bool? = nil,
        launchedInstance: MgnClientTypes.LaunchedInstance? = nil,
        lifeCycle: MgnClientTypes.LifeCycle? = nil,
        replicationType: MgnClientTypes.ReplicationType? = nil,
        sourceProperties: MgnClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vcenterClientID: Swift.String? = nil
    )
    {
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.isArchived = isArchived
        self.launchedInstance = launchedInstance
        self.lifeCycle = lifeCycle
        self.replicationType = replicationType
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
        self.vcenterClientID = vcenterClientID
    }
}

struct UpdateSourceServerReplicationTypeOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let isArchived: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let launchedInstance: MgnClientTypes.LaunchedInstance?
    let dataReplicationInfo: MgnClientTypes.DataReplicationInfo?
    let lifeCycle: MgnClientTypes.LifeCycle?
    let sourceProperties: MgnClientTypes.SourceProperties?
    let replicationType: MgnClientTypes.ReplicationType?
    let vcenterClientID: Swift.String?
}

extension UpdateSourceServerReplicationTypeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dataReplicationInfo
        case isArchived
        case launchedInstance
        case lifeCycle
        case replicationType
        case sourceProperties
        case sourceServerID
        case tags
        case vcenterClientID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let isArchivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchedInstanceDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LaunchedInstance.self, forKey: .launchedInstance)
        launchedInstance = launchedInstanceDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(MgnClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(MgnClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(MgnClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let replicationTypeDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ReplicationType.self, forKey: .replicationType)
        replicationType = replicationTypeDecoded
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.code = nil
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Validate exception.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    /// Validate exception field list.
    public var fieldList: [MgnClientTypes.ValidationExceptionField]?
    public var message: Swift.String?
    /// Validate exception reason.
    public var reason: MgnClientTypes.ValidationExceptionReason?

    public init (
        code: Swift.String? = nil,
        fieldList: [MgnClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: MgnClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.code = code
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
    let reason: MgnClientTypes.ValidationExceptionReason?
    let fieldList: [MgnClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case fieldList
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(MgnClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([MgnClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[MgnClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [MgnClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension MgnClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MgnClientTypes {
    /// Validate exception field.
    public struct ValidationExceptionField: Swift.Equatable {
        /// Validate exception field message.
        public var message: Swift.String?
        /// Validate exception field name.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension MgnClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension MgnClientTypes.VcenterClient: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case datacenterName
        case hostname
        case lastSeenDatetime
        case sourceServerTags
        case tags
        case vcenterClientID
        case vcenterUUID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let datacenterName = datacenterName {
            try encodeContainer.encode(datacenterName, forKey: .datacenterName)
        }
        if let hostname = hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let lastSeenDatetime = lastSeenDatetime {
            try encodeContainer.encode(lastSeenDatetime, forKey: .lastSeenDatetime)
        }
        if let sourceServerTags = sourceServerTags {
            var sourceServerTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sourceServerTags)
            for (dictKey0, tagsmap0) in sourceServerTags {
                try sourceServerTagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vcenterClientID = vcenterClientID {
            try encodeContainer.encode(vcenterClientID, forKey: .vcenterClientID)
        }
        if let vcenterUUID = vcenterUUID {
            try encodeContainer.encode(vcenterUUID, forKey: .vcenterUUID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vcenterClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterClientID)
        vcenterClientID = vcenterClientIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let vcenterUUIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterUUID)
        vcenterUUID = vcenterUUIDDecoded
        let datacenterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datacenterName)
        datacenterName = datacenterNameDecoded
        let lastSeenDatetimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSeenDatetime)
        lastSeenDatetime = lastSeenDatetimeDecoded
        let sourceServerTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sourceServerTags)
        var sourceServerTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let sourceServerTagsContainer = sourceServerTagsContainer {
            sourceServerTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in sourceServerTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    sourceServerTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        sourceServerTags = sourceServerTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension MgnClientTypes {
    /// vCenter client.
    public struct VcenterClient: Swift.Equatable {
        /// Arn of vCenter client.
        public var arn: Swift.String?
        /// Datacenter name of vCenter client.
        public var datacenterName: Swift.String?
        /// Hostname of vCenter client .
        public var hostname: Swift.String?
        /// Last seen time of vCenter client.
        public var lastSeenDatetime: Swift.String?
        /// Tags for Source Server of vCenter client.
        public var sourceServerTags: [Swift.String:Swift.String]?
        /// Tags for vCenter client.
        public var tags: [Swift.String:Swift.String]?
        /// ID of vCenter client.
        public var vcenterClientID: Swift.String?
        /// Vcenter UUID of vCenter client.
        public var vcenterUUID: Swift.String?

        public init (
            arn: Swift.String? = nil,
            datacenterName: Swift.String? = nil,
            hostname: Swift.String? = nil,
            lastSeenDatetime: Swift.String? = nil,
            sourceServerTags: [Swift.String:Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            vcenterClientID: Swift.String? = nil,
            vcenterUUID: Swift.String? = nil
        )
        {
            self.arn = arn
            self.datacenterName = datacenterName
            self.hostname = hostname
            self.lastSeenDatetime = lastSeenDatetime
            self.sourceServerTags = sourceServerTags
            self.tags = tags
            self.vcenterClientID = vcenterClientID
            self.vcenterUUID = vcenterUUID
        }
    }

}
