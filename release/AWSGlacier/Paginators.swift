// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime


/// Paginate over `[ListJobsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListJobsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListJobsOutputResponse`
extension GlacierClient {
    public func listJobsPaginated(input: ListJobsInput) -> ClientRuntime.PaginatorSequence<ListJobsInput, ListJobsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListJobsInput, ListJobsOutputResponse>(input: input, inputKey: \ListJobsInput.marker, outputKey: \ListJobsOutputResponse.marker, paginationFunction: self.listJobs(input:))
    }
}

extension ListJobsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListJobsInput {
        return ListJobsInput(
            accountId: self.accountId,
            completed: self.completed,
            limit: self.limit,
            marker: token,
            statuscode: self.statuscode,
            vaultName: self.vaultName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listJobsPaginated`
/// to access the nested member `[GlacierClientTypes.GlacierJobDescription]`
/// - Returns: `[GlacierClientTypes.GlacierJobDescription]`
extension PaginatorSequence where Input == ListJobsInput, Output == ListJobsOutputResponse {
    func jobList() async throws -> [GlacierClientTypes.GlacierJobDescription] {
        return try await self.asyncCompactMap { item in item.jobList }
    }
}

/// Paginate over `[ListMultipartUploadsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListMultipartUploadsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListMultipartUploadsOutputResponse`
extension GlacierClient {
    public func listMultipartUploadsPaginated(input: ListMultipartUploadsInput) -> ClientRuntime.PaginatorSequence<ListMultipartUploadsInput, ListMultipartUploadsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListMultipartUploadsInput, ListMultipartUploadsOutputResponse>(input: input, inputKey: \ListMultipartUploadsInput.marker, outputKey: \ListMultipartUploadsOutputResponse.marker, paginationFunction: self.listMultipartUploads(input:))
    }
}

extension ListMultipartUploadsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListMultipartUploadsInput {
        return ListMultipartUploadsInput(
            accountId: self.accountId,
            limit: self.limit,
            marker: token,
            vaultName: self.vaultName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listMultipartUploadsPaginated`
/// to access the nested member `[GlacierClientTypes.UploadListElement]`
/// - Returns: `[GlacierClientTypes.UploadListElement]`
extension PaginatorSequence where Input == ListMultipartUploadsInput, Output == ListMultipartUploadsOutputResponse {
    func uploadsList() async throws -> [GlacierClientTypes.UploadListElement] {
        return try await self.asyncCompactMap { item in item.uploadsList }
    }
}

/// Paginate over `[ListPartsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListPartsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListPartsOutputResponse`
extension GlacierClient {
    public func listPartsPaginated(input: ListPartsInput) -> ClientRuntime.PaginatorSequence<ListPartsInput, ListPartsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListPartsInput, ListPartsOutputResponse>(input: input, inputKey: \ListPartsInput.marker, outputKey: \ListPartsOutputResponse.marker, paginationFunction: self.listParts(input:))
    }
}

extension ListPartsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPartsInput {
        return ListPartsInput(
            accountId: self.accountId,
            limit: self.limit,
            marker: token,
            uploadId: self.uploadId,
            vaultName: self.vaultName
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listPartsPaginated`
/// to access the nested member `[GlacierClientTypes.PartListElement]`
/// - Returns: `[GlacierClientTypes.PartListElement]`
extension PaginatorSequence where Input == ListPartsInput, Output == ListPartsOutputResponse {
    func parts() async throws -> [GlacierClientTypes.PartListElement] {
        return try await self.asyncCompactMap { item in item.parts }
    }
}

/// Paginate over `[ListVaultsOutputResponse]` results.
///
/// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
/// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
/// until then. If there are errors in your request, you will see the failures only after you start iterating.
/// - Parameters:
///     - input: A `[ListVaultsInput]` to start pagination
/// - Returns: An `AsyncSequence` that can iterate over `ListVaultsOutputResponse`
extension GlacierClient {
    public func listVaultsPaginated(input: ListVaultsInput) -> ClientRuntime.PaginatorSequence<ListVaultsInput, ListVaultsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListVaultsInput, ListVaultsOutputResponse>(input: input, inputKey: \ListVaultsInput.marker, outputKey: \ListVaultsOutputResponse.marker, paginationFunction: self.listVaults(input:))
    }
}

extension ListVaultsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListVaultsInput {
        return ListVaultsInput(
            accountId: self.accountId,
            limit: self.limit,
            marker: token
        )}
}

/// This paginator transforms the `AsyncSequence` returned by `listVaultsPaginated`
/// to access the nested member `[GlacierClientTypes.DescribeVaultOutput]`
/// - Returns: `[GlacierClientTypes.DescribeVaultOutput]`
extension PaginatorSequence where Input == ListVaultsInput, Output == ListVaultsOutputResponse {
    func vaultList() async throws -> [GlacierClientTypes.DescribeVaultOutput] {
        return try await self.asyncCompactMap { item in item.vaultList }
    }
}
