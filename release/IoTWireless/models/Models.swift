// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AbpV1_0_x: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case devAddr = "DevAddr"
        case sessionKeys = "SessionKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devAddr = devAddr {
            try encodeContainer.encode(devAddr, forKey: .devAddr)
        }
        if let sessionKeys = sessionKeys {
            try encodeContainer.encode(sessionKeys, forKey: .sessionKeys)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devAddrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .devAddr)
        devAddr = devAddrDecoded
        let sessionKeysDecoded = try containerValues.decodeIfPresent(SessionKeysAbpV1_0_x.self, forKey: .sessionKeys)
        sessionKeys = sessionKeysDecoded
    }
}

extension AbpV1_0_x: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AbpV1_0_x(devAddr: \(String(describing: devAddr)), sessionKeys: \(String(describing: sessionKeys)))"}
}

/// <p>ABP device object for LoRaWAN specification v1.0.x</p>
public struct AbpV1_0_x: Equatable {
    /// <p>The DevAddr value.</p>
    public let devAddr: String?
    /// <p>Session keys for ABP v1.0.x</p>
    public let sessionKeys: SessionKeysAbpV1_0_x?

    public init (
        devAddr: String? = nil,
        sessionKeys: SessionKeysAbpV1_0_x? = nil
    )
    {
        self.devAddr = devAddr
        self.sessionKeys = sessionKeys
    }
}

extension AbpV1_1: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case devAddr = "DevAddr"
        case sessionKeys = "SessionKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devAddr = devAddr {
            try encodeContainer.encode(devAddr, forKey: .devAddr)
        }
        if let sessionKeys = sessionKeys {
            try encodeContainer.encode(sessionKeys, forKey: .sessionKeys)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devAddrDecoded = try containerValues.decodeIfPresent(String.self, forKey: .devAddr)
        devAddr = devAddrDecoded
        let sessionKeysDecoded = try containerValues.decodeIfPresent(SessionKeysAbpV1_1.self, forKey: .sessionKeys)
        sessionKeys = sessionKeysDecoded
    }
}

extension AbpV1_1: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AbpV1_1(devAddr: \(String(describing: devAddr)), sessionKeys: \(String(describing: sessionKeys)))"}
}

/// <p>ABP device object for LoRaWAN specification v1.1</p>
public struct AbpV1_1: Equatable {
    /// <p>The DevAddr value.</p>
    public let devAddr: String?
    /// <p>Session keys for ABP v1.1</p>
    public let sessionKeys: SessionKeysAbpV1_1?

    public init (
        devAddr: String? = nil,
        sessionKeys: SessionKeysAbpV1_1? = nil
    )
    {
        self.devAddr = devAddr
        self.sessionKeys = sessionKeys
    }
}

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>User does not have permission to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AssociateAwsAccountWithPartnerAccountInputBodyMiddleware: Middleware {
    public let id: String = "AssociateAwsAccountWithPartnerAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateAwsAccountWithPartnerAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateAwsAccountWithPartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateAwsAccountWithPartnerAccountInput>
    public typealias MOutput = OperationOutput<AssociateAwsAccountWithPartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateAwsAccountWithPartnerAccountOutputError>
}

extension AssociateAwsAccountWithPartnerAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateAwsAccountWithPartnerAccountInput(clientRequestToken: \(String(describing: clientRequestToken)), sidewalk: \(String(describing: sidewalk)), tags: \(String(describing: tags)))"}
}

extension AssociateAwsAccountWithPartnerAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sidewalk = "Sidewalk"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let sidewalk = sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct AssociateAwsAccountWithPartnerAccountInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateAwsAccountWithPartnerAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateAwsAccountWithPartnerAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateAwsAccountWithPartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateAwsAccountWithPartnerAccountInput>
    public typealias MOutput = OperationOutput<AssociateAwsAccountWithPartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateAwsAccountWithPartnerAccountOutputError>
}

public struct AssociateAwsAccountWithPartnerAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateAwsAccountWithPartnerAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateAwsAccountWithPartnerAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateAwsAccountWithPartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateAwsAccountWithPartnerAccountInput>
    public typealias MOutput = OperationOutput<AssociateAwsAccountWithPartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateAwsAccountWithPartnerAccountOutputError>
}

public struct AssociateAwsAccountWithPartnerAccountInput: Equatable {
    /// <p>Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. </p>
    public var clientRequestToken: String?
    /// <p>The Sidewalk account credentials.</p>
    public let sidewalk: SidewalkAccountInfo?
    /// <p>The tags to attach to the specified resource. Tags are metadata that you can use to manage a resource.</p>
    public let tags: [Tag]?

    public init (
        clientRequestToken: String? = nil,
        sidewalk: SidewalkAccountInfo? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.sidewalk = sidewalk
        self.tags = tags
    }
}

struct AssociateAwsAccountWithPartnerAccountInputBody: Equatable {
    public let sidewalk: SidewalkAccountInfo?
    public let clientRequestToken: String?
    public let tags: [Tag]?
}

extension AssociateAwsAccountWithPartnerAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case sidewalk = "Sidewalk"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(SidewalkAccountInfo.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension AssociateAwsAccountWithPartnerAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateAwsAccountWithPartnerAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateAwsAccountWithPartnerAccountOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateAwsAccountWithPartnerAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateAwsAccountWithPartnerAccountOutputResponse(arn: \(String(describing: arn)), sidewalk: \(String(describing: sidewalk)))"}
}

extension AssociateAwsAccountWithPartnerAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateAwsAccountWithPartnerAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.sidewalk = output.sidewalk
        } else {
            self.arn = nil
            self.sidewalk = nil
        }
    }
}

public struct AssociateAwsAccountWithPartnerAccountOutputResponse: Equatable {
    /// <p>The Amazon Resource Name of the resource.</p>
    public let arn: String?
    /// <p>The Sidewalk account credentials.</p>
    public let sidewalk: SidewalkAccountInfo?

    public init (
        arn: String? = nil,
        sidewalk: SidewalkAccountInfo? = nil
    )
    {
        self.arn = arn
        self.sidewalk = sidewalk
    }
}

struct AssociateAwsAccountWithPartnerAccountOutputResponseBody: Equatable {
    public let sidewalk: SidewalkAccountInfo?
    public let arn: String?
}

extension AssociateAwsAccountWithPartnerAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case sidewalk = "Sidewalk"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(SidewalkAccountInfo.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct AssociateWirelessDeviceWithThingInputBodyMiddleware: Middleware {
    public let id: String = "AssociateWirelessDeviceWithThingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateWirelessDeviceWithThingInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateWirelessDeviceWithThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateWirelessDeviceWithThingInput>
    public typealias MOutput = OperationOutput<AssociateWirelessDeviceWithThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateWirelessDeviceWithThingOutputError>
}

extension AssociateWirelessDeviceWithThingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateWirelessDeviceWithThingInput(id: \(String(describing: id)), thingArn: \(String(describing: thingArn)))"}
}

extension AssociateWirelessDeviceWithThingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case thingArn = "ThingArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingArn = thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }
}

public struct AssociateWirelessDeviceWithThingInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateWirelessDeviceWithThingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateWirelessDeviceWithThingInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateWirelessDeviceWithThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateWirelessDeviceWithThingInput>
    public typealias MOutput = OperationOutput<AssociateWirelessDeviceWithThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateWirelessDeviceWithThingOutputError>
}

public struct AssociateWirelessDeviceWithThingInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateWirelessDeviceWithThingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateWirelessDeviceWithThingInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateWirelessDeviceWithThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateWirelessDeviceWithThingInput>
    public typealias MOutput = OperationOutput<AssociateWirelessDeviceWithThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateWirelessDeviceWithThingOutputError>
}

public struct AssociateWirelessDeviceWithThingInput: Equatable {
    /// <p>The ID of the resource to update.</p>
    public let id: String?
    /// <p>The ARN of the thing to associate with the wireless device.</p>
    public let thingArn: String?

    public init (
        id: String? = nil,
        thingArn: String? = nil
    )
    {
        self.id = id
        self.thingArn = thingArn
    }
}

struct AssociateWirelessDeviceWithThingInputBody: Equatable {
    public let thingArn: String?
}

extension AssociateWirelessDeviceWithThingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case thingArn = "ThingArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension AssociateWirelessDeviceWithThingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWirelessDeviceWithThingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateWirelessDeviceWithThingOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWirelessDeviceWithThingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateWirelessDeviceWithThingOutputResponse()"}
}

extension AssociateWirelessDeviceWithThingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateWirelessDeviceWithThingOutputResponse: Equatable {

    public init() {}
}

struct AssociateWirelessDeviceWithThingOutputResponseBody: Equatable {
}

extension AssociateWirelessDeviceWithThingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct AssociateWirelessGatewayWithCertificateInputBodyMiddleware: Middleware {
    public let id: String = "AssociateWirelessGatewayWithCertificateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateWirelessGatewayWithCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateWirelessGatewayWithCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateWirelessGatewayWithCertificateInput>
    public typealias MOutput = OperationOutput<AssociateWirelessGatewayWithCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateWirelessGatewayWithCertificateOutputError>
}

extension AssociateWirelessGatewayWithCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateWirelessGatewayWithCertificateInput(id: \(String(describing: id)), iotCertificateId: \(String(describing: iotCertificateId)))"}
}

extension AssociateWirelessGatewayWithCertificateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iotCertificateId = "IotCertificateId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iotCertificateId = iotCertificateId {
            try encodeContainer.encode(iotCertificateId, forKey: .iotCertificateId)
        }
    }
}

public struct AssociateWirelessGatewayWithCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateWirelessGatewayWithCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateWirelessGatewayWithCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateWirelessGatewayWithCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateWirelessGatewayWithCertificateInput>
    public typealias MOutput = OperationOutput<AssociateWirelessGatewayWithCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateWirelessGatewayWithCertificateOutputError>
}

public struct AssociateWirelessGatewayWithCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateWirelessGatewayWithCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateWirelessGatewayWithCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateWirelessGatewayWithCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateWirelessGatewayWithCertificateInput>
    public typealias MOutput = OperationOutput<AssociateWirelessGatewayWithCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateWirelessGatewayWithCertificateOutputError>
}

public struct AssociateWirelessGatewayWithCertificateInput: Equatable {
    /// <p>The ID of the resource to update.</p>
    public let id: String?
    /// <p>The ID of the certificate to associate with the wireless gateway.</p>
    public let iotCertificateId: String?

    public init (
        id: String? = nil,
        iotCertificateId: String? = nil
    )
    {
        self.id = id
        self.iotCertificateId = iotCertificateId
    }
}

struct AssociateWirelessGatewayWithCertificateInputBody: Equatable {
    public let iotCertificateId: String?
}

extension AssociateWirelessGatewayWithCertificateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case iotCertificateId = "IotCertificateId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iotCertificateId)
        iotCertificateId = iotCertificateIdDecoded
    }
}

extension AssociateWirelessGatewayWithCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWirelessGatewayWithCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateWirelessGatewayWithCertificateOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWirelessGatewayWithCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateWirelessGatewayWithCertificateOutputResponse(iotCertificateId: \(String(describing: iotCertificateId)))"}
}

extension AssociateWirelessGatewayWithCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateWirelessGatewayWithCertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.iotCertificateId = output.iotCertificateId
        } else {
            self.iotCertificateId = nil
        }
    }
}

public struct AssociateWirelessGatewayWithCertificateOutputResponse: Equatable {
    /// <p>The ID of the certificate associated with the wireless gateway.</p>
    public let iotCertificateId: String?

    public init (
        iotCertificateId: String? = nil
    )
    {
        self.iotCertificateId = iotCertificateId
    }
}

struct AssociateWirelessGatewayWithCertificateOutputResponseBody: Equatable {
    public let iotCertificateId: String?
}

extension AssociateWirelessGatewayWithCertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case iotCertificateId = "IotCertificateId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iotCertificateId)
        iotCertificateId = iotCertificateIdDecoded
    }
}

public struct AssociateWirelessGatewayWithThingInputBodyMiddleware: Middleware {
    public let id: String = "AssociateWirelessGatewayWithThingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateWirelessGatewayWithThingInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateWirelessGatewayWithThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateWirelessGatewayWithThingInput>
    public typealias MOutput = OperationOutput<AssociateWirelessGatewayWithThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateWirelessGatewayWithThingOutputError>
}

extension AssociateWirelessGatewayWithThingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateWirelessGatewayWithThingInput(id: \(String(describing: id)), thingArn: \(String(describing: thingArn)))"}
}

extension AssociateWirelessGatewayWithThingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case thingArn = "ThingArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let thingArn = thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }
}

public struct AssociateWirelessGatewayWithThingInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateWirelessGatewayWithThingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateWirelessGatewayWithThingInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateWirelessGatewayWithThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateWirelessGatewayWithThingInput>
    public typealias MOutput = OperationOutput<AssociateWirelessGatewayWithThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateWirelessGatewayWithThingOutputError>
}

public struct AssociateWirelessGatewayWithThingInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateWirelessGatewayWithThingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateWirelessGatewayWithThingInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateWirelessGatewayWithThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateWirelessGatewayWithThingInput>
    public typealias MOutput = OperationOutput<AssociateWirelessGatewayWithThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateWirelessGatewayWithThingOutputError>
}

public struct AssociateWirelessGatewayWithThingInput: Equatable {
    /// <p>The ID of the resource to update.</p>
    public let id: String?
    /// <p>The ARN of the thing to associate with the wireless gateway.</p>
    public let thingArn: String?

    public init (
        id: String? = nil,
        thingArn: String? = nil
    )
    {
        self.id = id
        self.thingArn = thingArn
    }
}

struct AssociateWirelessGatewayWithThingInputBody: Equatable {
    public let thingArn: String?
}

extension AssociateWirelessGatewayWithThingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case thingArn = "ThingArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension AssociateWirelessGatewayWithThingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateWirelessGatewayWithThingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateWirelessGatewayWithThingOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateWirelessGatewayWithThingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateWirelessGatewayWithThingOutputResponse()"}
}

extension AssociateWirelessGatewayWithThingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct AssociateWirelessGatewayWithThingOutputResponse: Equatable {

    public init() {}
}

struct AssociateWirelessGatewayWithThingOutputResponseBody: Equatable {
}

extension AssociateWirelessGatewayWithThingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

/// <p>Sidewalk device battery level.</p>
public enum BatteryLevel {
    case critical
    case low
    case normal
    case sdkUnknown(String)
}

extension BatteryLevel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BatteryLevel] {
        return [
            .critical,
            .low,
            .normal,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .critical: return "critical"
        case .low: return "low"
        case .normal: return "normal"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BatteryLevel(rawValue: rawValue) ?? BatteryLevel.sdkUnknown(rawValue)
    }
}

extension CertificateList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case signingAlg = "SigningAlg"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signingAlg = signingAlg {
            try encodeContainer.encode(signingAlg.rawValue, forKey: .signingAlg)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingAlgDecoded = try containerValues.decodeIfPresent(SigningAlg.self, forKey: .signingAlg)
        signingAlg = signingAlgDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CertificateList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CertificateList(signingAlg: \(String(describing: signingAlg)), value: \(String(describing: value)))"}
}

/// <p>List of sidewalk certificates.</p>
public struct CertificateList: Equatable {
    /// <p>The certificate chain algorithm provided by sidewalk.</p>
    public let signingAlg: SigningAlg?
    /// <p>The value of the chosen sidewalk certificate.</p>
    public let value: String?

    public init (
        signingAlg: SigningAlg? = nil,
        value: String? = nil
    )
    {
        self.signingAlg = signingAlg
        self.value = value
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Adding, updating, or deleting the resource can cause an inconsistent state.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>Id of the resource in the conflicting operation.</p>
    public var resourceId: String?
    /// <p>Type of the resource in the conflicting operation.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public enum ConnectionStatus {
    case connected
    case disconnected
    case sdkUnknown(String)
}

extension ConnectionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionStatus] {
        return [
            .connected,
            .disconnected,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .connected: return "Connected"
        case .disconnected: return "Disconnected"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
    }
}

public struct CreateDestinationInputBodyMiddleware: Middleware {
    public let id: String = "CreateDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDestinationInput>
    public typealias MOutput = OperationOutput<CreateDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDestinationOutputError>
}

extension CreateDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDestinationInput(clientRequestToken: \(String(describing: clientRequestToken)), description: \(String(describing: description)), expression: \(String(describing: expression)), expressionType: \(String(describing: expressionType)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)), tags: \(String(describing: tags)))"}
}

extension CreateDestinationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case name = "Name"
        case roleArn = "RoleArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let expressionType = expressionType {
            try encodeContainer.encode(expressionType.rawValue, forKey: .expressionType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDestinationInput>
    public typealias MOutput = OperationOutput<CreateDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDestinationOutputError>
}

public struct CreateDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDestinationInput>
    public typealias MOutput = OperationOutput<CreateDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDestinationOutputError>
}

public struct CreateDestinationInput: Equatable {
    /// <p>Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. </p>
    public var clientRequestToken: String?
    /// <p>The description of the new resource.</p>
    public let description: String?
    /// <p>The rule name or topic rule to send messages to.</p>
    public let expression: String?
    /// <p>The type of value in <code>Expression</code>.</p>
    public let expressionType: ExpressionType?
    /// <p>The name of the new resource.</p>
    public let name: String?
    /// <p>The ARN of the IAM Role that authorizes the destination.</p>
    public let roleArn: String?
    /// <p>The tags to attach to the new destination. Tags are metadata that you can use to manage a resource.</p>
    public let tags: [Tag]?

    public init (
        clientRequestToken: String? = nil,
        description: String? = nil,
        expression: String? = nil,
        expressionType: ExpressionType? = nil,
        name: String? = nil,
        roleArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.expression = expression
        self.expressionType = expressionType
        self.name = name
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateDestinationInputBody: Equatable {
    public let name: String?
    public let expressionType: ExpressionType?
    public let expression: String?
    public let description: String?
    public let roleArn: String?
    public let tags: [Tag]?
    public let clientRequestToken: String?
}

extension CreateDestinationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case name = "Name"
        case roleArn = "RoleArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDestinationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDestinationOutputResponse(arn: \(String(describing: arn)), name: \(String(describing: name)))"}
}

extension CreateDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDestinationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.name = output.name
        } else {
            self.arn = nil
            self.name = nil
        }
    }
}

public struct CreateDestinationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name of the new resource.</p>
    public let arn: String?
    /// <p>The name of the new resource.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.name = name
    }
}

struct CreateDestinationOutputResponseBody: Equatable {
    public let arn: String?
    public let name: String?
}

extension CreateDestinationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
    }
}

public struct CreateDeviceProfileInputBodyMiddleware: Middleware {
    public let id: String = "CreateDeviceProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeviceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeviceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeviceProfileInput>
    public typealias MOutput = OperationOutput<CreateDeviceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeviceProfileOutputError>
}

extension CreateDeviceProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeviceProfileInput(clientRequestToken: \(String(describing: clientRequestToken)), loRaWAN: \(String(describing: loRaWAN)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateDeviceProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateDeviceProfileInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDeviceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeviceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeviceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeviceProfileInput>
    public typealias MOutput = OperationOutput<CreateDeviceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeviceProfileOutputError>
}

public struct CreateDeviceProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDeviceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeviceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeviceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeviceProfileInput>
    public typealias MOutput = OperationOutput<CreateDeviceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeviceProfileOutputError>
}

public struct CreateDeviceProfileInput: Equatable {
    /// <p>Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. </p>
    public var clientRequestToken: String?
    /// <p>The device profile information to use to create the device profile.</p>
    public let loRaWAN: LoRaWANDeviceProfile?
    /// <p>The name of the new resource.</p>
    public let name: String?
    /// <p>The tags to attach to the new device profile. Tags are metadata that you can use to manage a resource.</p>
    public let tags: [Tag]?

    public init (
        clientRequestToken: String? = nil,
        loRaWAN: LoRaWANDeviceProfile? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

struct CreateDeviceProfileInputBody: Equatable {
    public let name: String?
    public let loRaWAN: LoRaWANDeviceProfile?
    public let tags: [Tag]?
    public let clientRequestToken: String?
}

extension CreateDeviceProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(LoRaWANDeviceProfile.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateDeviceProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeviceProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeviceProfileOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeviceProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeviceProfileOutputResponse(arn: \(String(describing: arn)), id: \(String(describing: id)))"}
}

extension CreateDeviceProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDeviceProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateDeviceProfileOutputResponse: Equatable {
    /// <p>The Amazon Resource Name of the new resource.</p>
    public let arn: String?
    /// <p>The ID of the new device profile.</p>
    public let id: String?

    public init (
        arn: String? = nil,
        id: String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateDeviceProfileOutputResponseBody: Equatable {
    public let arn: String?
    public let id: String?
}

extension CreateDeviceProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

public struct CreateServiceProfileInputBodyMiddleware: Middleware {
    public let id: String = "CreateServiceProfileInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServiceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServiceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServiceProfileInput>
    public typealias MOutput = OperationOutput<CreateServiceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServiceProfileOutputError>
}

extension CreateServiceProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateServiceProfileInput(clientRequestToken: \(String(describing: clientRequestToken)), loRaWAN: \(String(describing: loRaWAN)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateServiceProfileInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateServiceProfileInputHeadersMiddleware: Middleware {
    public let id: String = "CreateServiceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServiceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServiceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServiceProfileInput>
    public typealias MOutput = OperationOutput<CreateServiceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServiceProfileOutputError>
}

public struct CreateServiceProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateServiceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServiceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServiceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServiceProfileInput>
    public typealias MOutput = OperationOutput<CreateServiceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServiceProfileOutputError>
}

public struct CreateServiceProfileInput: Equatable {
    /// <p>Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. </p>
    public var clientRequestToken: String?
    /// <p>The service profile information to use to create the service profile.</p>
    public let loRaWAN: LoRaWANServiceProfile?
    /// <p>The name of the new resource.</p>
    public let name: String?
    /// <p>The tags to attach to the new service profile. Tags are metadata that you can use to manage a resource.</p>
    public let tags: [Tag]?

    public init (
        clientRequestToken: String? = nil,
        loRaWAN: LoRaWANServiceProfile? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

struct CreateServiceProfileInputBody: Equatable {
    public let name: String?
    public let loRaWAN: LoRaWANServiceProfile?
    public let tags: [Tag]?
    public let clientRequestToken: String?
}

extension CreateServiceProfileInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(LoRaWANServiceProfile.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateServiceProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServiceProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServiceProfileOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServiceProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateServiceProfileOutputResponse(arn: \(String(describing: arn)), id: \(String(describing: id)))"}
}

extension CreateServiceProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateServiceProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateServiceProfileOutputResponse: Equatable {
    /// <p>The Amazon Resource Name of the new resource.</p>
    public let arn: String?
    /// <p>The ID of the new service profile.</p>
    public let id: String?

    public init (
        arn: String? = nil,
        id: String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateServiceProfileOutputResponseBody: Equatable {
    public let arn: String?
    public let id: String?
}

extension CreateServiceProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

public struct CreateWirelessDeviceInputBodyMiddleware: Middleware {
    public let id: String = "CreateWirelessDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWirelessDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWirelessDeviceInput>
    public typealias MOutput = OperationOutput<CreateWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWirelessDeviceOutputError>
}

extension CreateWirelessDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWirelessDeviceInput(clientRequestToken: \(String(describing: clientRequestToken)), description: \(String(describing: description)), destinationName: \(String(describing: destinationName)), loRaWAN: \(String(describing: loRaWAN)), name: \(String(describing: name)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

extension CreateWirelessDeviceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case destinationName = "DestinationName"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationName = destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

public struct CreateWirelessDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateWirelessDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWirelessDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWirelessDeviceInput>
    public typealias MOutput = OperationOutput<CreateWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWirelessDeviceOutputError>
}

public struct CreateWirelessDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateWirelessDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWirelessDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWirelessDeviceInput>
    public typealias MOutput = OperationOutput<CreateWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWirelessDeviceOutputError>
}

public struct CreateWirelessDeviceInput: Equatable {
    /// <p>Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. </p>
    public var clientRequestToken: String?
    /// <p>The description of the new resource.</p>
    public let description: String?
    /// <p>The name of the destination to assign to the new wireless device.</p>
    public let destinationName: String?
    /// <p>The device configuration information to use to create the wireless device.</p>
    public let loRaWAN: LoRaWANDevice?
    /// <p>The name of the new resource.</p>
    public let name: String?
    /// <p>The tags to attach to the new wireless device. Tags are metadata that you can use to manage a resource.</p>
    public let tags: [Tag]?
    /// <p>The wireless device type.</p>
    public let type: WirelessDeviceType?

    public init (
        clientRequestToken: String? = nil,
        description: String? = nil,
        destinationName: String? = nil,
        loRaWAN: LoRaWANDevice? = nil,
        name: String? = nil,
        tags: [Tag]? = nil,
        type: WirelessDeviceType? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.destinationName = destinationName
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
        self.type = type
    }
}

struct CreateWirelessDeviceInputBody: Equatable {
    public let type: WirelessDeviceType?
    public let name: String?
    public let description: String?
    public let destinationName: String?
    public let clientRequestToken: String?
    public let loRaWAN: LoRaWANDevice?
    public let tags: [Tag]?
}

extension CreateWirelessDeviceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case destinationName = "DestinationName"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(WirelessDeviceType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(LoRaWANDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWirelessDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWirelessDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWirelessDeviceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWirelessDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWirelessDeviceOutputResponse(arn: \(String(describing: arn)), id: \(String(describing: id)))"}
}

extension CreateWirelessDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateWirelessDeviceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateWirelessDeviceOutputResponse: Equatable {
    /// <p>The Amazon Resource Name of the new resource.</p>
    public let arn: String?
    /// <p>The ID of the new wireless device.</p>
    public let id: String?

    public init (
        arn: String? = nil,
        id: String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateWirelessDeviceOutputResponseBody: Equatable {
    public let arn: String?
    public let id: String?
}

extension CreateWirelessDeviceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

public struct CreateWirelessGatewayInputBodyMiddleware: Middleware {
    public let id: String = "CreateWirelessGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWirelessGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWirelessGatewayInput>
    public typealias MOutput = OperationOutput<CreateWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWirelessGatewayOutputError>
}

extension CreateWirelessGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWirelessGatewayInput(clientRequestToken: \(String(describing: clientRequestToken)), description: \(String(describing: description)), loRaWAN: \(String(describing: loRaWAN)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateWirelessGatewayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateWirelessGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "CreateWirelessGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWirelessGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWirelessGatewayInput>
    public typealias MOutput = OperationOutput<CreateWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWirelessGatewayOutputError>
}

public struct CreateWirelessGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateWirelessGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWirelessGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWirelessGatewayInput>
    public typealias MOutput = OperationOutput<CreateWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWirelessGatewayOutputError>
}

public struct CreateWirelessGatewayInput: Equatable {
    /// <p>Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. </p>
    public var clientRequestToken: String?
    /// <p>The description of the new resource.</p>
    public let description: String?
    /// <p>The gateway configuration information to use to create the wireless gateway.</p>
    public let loRaWAN: LoRaWANGateway?
    /// <p>The name of the new resource.</p>
    public let name: String?
    /// <p>The tags to attach to the new wireless gateway. Tags are metadata that you can use to manage a resource.</p>
    public let tags: [Tag]?

    public init (
        clientRequestToken: String? = nil,
        description: String? = nil,
        loRaWAN: LoRaWANGateway? = nil,
        name: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.loRaWAN = loRaWAN
        self.name = name
        self.tags = tags
    }
}

struct CreateWirelessGatewayInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let loRaWAN: LoRaWANGateway?
    public let tags: [Tag]?
    public let clientRequestToken: String?
}

extension CreateWirelessGatewayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(LoRaWANGateway.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension CreateWirelessGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWirelessGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWirelessGatewayOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWirelessGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWirelessGatewayOutputResponse(arn: \(String(describing: arn)), id: \(String(describing: id)))"}
}

extension CreateWirelessGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateWirelessGatewayOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateWirelessGatewayOutputResponse: Equatable {
    /// <p>The Amazon Resource Name of the new resource.</p>
    public let arn: String?
    /// <p>The ID of the new wireless gateway.</p>
    public let id: String?

    public init (
        arn: String? = nil,
        id: String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateWirelessGatewayOutputResponseBody: Equatable {
    public let arn: String?
    public let id: String?
}

extension CreateWirelessGatewayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

public struct CreateWirelessGatewayTaskDefinitionInputBodyMiddleware: Middleware {
    public let id: String = "CreateWirelessGatewayTaskDefinitionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWirelessGatewayTaskDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWirelessGatewayTaskDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWirelessGatewayTaskDefinitionInput>
    public typealias MOutput = OperationOutput<CreateWirelessGatewayTaskDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWirelessGatewayTaskDefinitionOutputError>
}

extension CreateWirelessGatewayTaskDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWirelessGatewayTaskDefinitionInput(autoCreateTasks: \(String(describing: autoCreateTasks)), clientRequestToken: \(String(describing: clientRequestToken)), name: \(String(describing: name)), tags: \(String(describing: tags)), update: \(String(describing: update)))"}
}

extension CreateWirelessGatewayTaskDefinitionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case autoCreateTasks = "AutoCreateTasks"
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case tags = "Tags"
        case update = "Update"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoCreateTasks != false {
            try encodeContainer.encode(autoCreateTasks, forKey: .autoCreateTasks)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let update = update {
            try encodeContainer.encode(update, forKey: .update)
        }
    }
}

public struct CreateWirelessGatewayTaskDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateWirelessGatewayTaskDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWirelessGatewayTaskDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWirelessGatewayTaskDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWirelessGatewayTaskDefinitionInput>
    public typealias MOutput = OperationOutput<CreateWirelessGatewayTaskDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWirelessGatewayTaskDefinitionOutputError>
}

public struct CreateWirelessGatewayTaskDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateWirelessGatewayTaskDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWirelessGatewayTaskDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWirelessGatewayTaskDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWirelessGatewayTaskDefinitionInput>
    public typealias MOutput = OperationOutput<CreateWirelessGatewayTaskDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWirelessGatewayTaskDefinitionOutputError>
}

public struct CreateWirelessGatewayTaskDefinitionInput: Equatable {
    /// <p>Whether to automatically create tasks using this task definition for all gateways with the specified current version. If <code>false</code>, the task must me created by calling <code>CreateWirelessGatewayTask</code>.</p>
    public let autoCreateTasks: Bool
    /// <p>Each resource must have a unique client request token. If you try to create a new resource with the same token as a resource that already exists, an exception occurs. If you omit this value, AWS SDKs will automatically generate a unique client request. </p>
    public var clientRequestToken: String?
    /// <p>The name of the new resource.</p>
    public let name: String?
    /// <p>The tags to attach to the specified resource. Tags are metadata that you can use to manage a resource.</p>
    public let tags: [Tag]?
    /// <p>Information about the gateways to update.</p>
    public let update: UpdateWirelessGatewayTaskCreate?

    public init (
        autoCreateTasks: Bool = false,
        clientRequestToken: String? = nil,
        name: String? = nil,
        tags: [Tag]? = nil,
        update: UpdateWirelessGatewayTaskCreate? = nil
    )
    {
        self.autoCreateTasks = autoCreateTasks
        self.clientRequestToken = clientRequestToken
        self.name = name
        self.tags = tags
        self.update = update
    }
}

struct CreateWirelessGatewayTaskDefinitionInputBody: Equatable {
    public let autoCreateTasks: Bool
    public let name: String?
    public let update: UpdateWirelessGatewayTaskCreate?
    public let clientRequestToken: String?
    public let tags: [Tag]?
}

extension CreateWirelessGatewayTaskDefinitionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case autoCreateTasks = "AutoCreateTasks"
        case clientRequestToken = "ClientRequestToken"
        case name = "Name"
        case tags = "Tags"
        case update = "Update"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoCreateTasksDecoded = try containerValues.decode(Bool.self, forKey: .autoCreateTasks)
        autoCreateTasks = autoCreateTasksDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let updateDecoded = try containerValues.decodeIfPresent(UpdateWirelessGatewayTaskCreate.self, forKey: .update)
        update = updateDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateWirelessGatewayTaskDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWirelessGatewayTaskDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWirelessGatewayTaskDefinitionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWirelessGatewayTaskDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWirelessGatewayTaskDefinitionOutputResponse(arn: \(String(describing: arn)), id: \(String(describing: id)))"}
}

extension CreateWirelessGatewayTaskDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateWirelessGatewayTaskDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.id = output.id
        } else {
            self.arn = nil
            self.id = nil
        }
    }
}

public struct CreateWirelessGatewayTaskDefinitionOutputResponse: Equatable {
    /// <p>The Amazon Resource Name of the resource.</p>
    public let arn: String?
    /// <p>The ID of the new wireless gateway task definition.</p>
    public let id: String?

    public init (
        arn: String? = nil,
        id: String? = nil
    )
    {
        self.arn = arn
        self.id = id
    }
}

struct CreateWirelessGatewayTaskDefinitionOutputResponseBody: Equatable {
    public let id: String?
    public let arn: String?
}

extension CreateWirelessGatewayTaskDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct CreateWirelessGatewayTaskInputBodyMiddleware: Middleware {
    public let id: String = "CreateWirelessGatewayTaskInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWirelessGatewayTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWirelessGatewayTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWirelessGatewayTaskInput>
    public typealias MOutput = OperationOutput<CreateWirelessGatewayTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWirelessGatewayTaskOutputError>
}

extension CreateWirelessGatewayTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWirelessGatewayTaskInput(id: \(String(describing: id)), wirelessGatewayTaskDefinitionId: \(String(describing: wirelessGatewayTaskDefinitionId)))"}
}

extension CreateWirelessGatewayTaskInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId {
            try encodeContainer.encode(wirelessGatewayTaskDefinitionId, forKey: .wirelessGatewayTaskDefinitionId)
        }
    }
}

public struct CreateWirelessGatewayTaskInputHeadersMiddleware: Middleware {
    public let id: String = "CreateWirelessGatewayTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWirelessGatewayTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWirelessGatewayTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWirelessGatewayTaskInput>
    public typealias MOutput = OperationOutput<CreateWirelessGatewayTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWirelessGatewayTaskOutputError>
}

public struct CreateWirelessGatewayTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateWirelessGatewayTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateWirelessGatewayTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateWirelessGatewayTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateWirelessGatewayTaskInput>
    public typealias MOutput = OperationOutput<CreateWirelessGatewayTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateWirelessGatewayTaskOutputError>
}

public struct CreateWirelessGatewayTaskInput: Equatable {
    /// <p>The ID of the resource to update.</p>
    public let id: String?
    /// <p>The ID of the WirelessGatewayTaskDefinition.</p>
    public let wirelessGatewayTaskDefinitionId: String?

    public init (
        id: String? = nil,
        wirelessGatewayTaskDefinitionId: String? = nil
    )
    {
        self.id = id
        self.wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId
    }
}

struct CreateWirelessGatewayTaskInputBody: Equatable {
    public let wirelessGatewayTaskDefinitionId: String?
}

extension CreateWirelessGatewayTaskInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayTaskDefinitionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .wirelessGatewayTaskDefinitionId)
        wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionIdDecoded
    }
}

extension CreateWirelessGatewayTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateWirelessGatewayTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateWirelessGatewayTaskOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateWirelessGatewayTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateWirelessGatewayTaskOutputResponse(status: \(String(describing: status)), wirelessGatewayTaskDefinitionId: \(String(describing: wirelessGatewayTaskDefinitionId)))"}
}

extension CreateWirelessGatewayTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateWirelessGatewayTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
            self.wirelessGatewayTaskDefinitionId = output.wirelessGatewayTaskDefinitionId
        } else {
            self.status = nil
            self.wirelessGatewayTaskDefinitionId = nil
        }
    }
}

public struct CreateWirelessGatewayTaskOutputResponse: Equatable {
    /// <p>The status of the request.</p>
    public let status: WirelessGatewayTaskStatus?
    /// <p>The ID of the WirelessGatewayTaskDefinition.</p>
    public let wirelessGatewayTaskDefinitionId: String?

    public init (
        status: WirelessGatewayTaskStatus? = nil,
        wirelessGatewayTaskDefinitionId: String? = nil
    )
    {
        self.status = status
        self.wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId
    }
}

struct CreateWirelessGatewayTaskOutputResponseBody: Equatable {
    public let wirelessGatewayTaskDefinitionId: String?
    public let status: WirelessGatewayTaskStatus?
}

extension CreateWirelessGatewayTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
        case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayTaskDefinitionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .wirelessGatewayTaskDefinitionId)
        wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WirelessGatewayTaskStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DeleteDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDestinationInput(name: \(String(describing: name)))"}
}

extension DeleteDestinationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDestinationInput>
    public typealias MOutput = OperationOutput<DeleteDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDestinationOutputError>
}

public struct DeleteDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDestinationInput>
    public typealias MOutput = OperationOutput<DeleteDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDestinationOutputError>
}

public struct DeleteDestinationInput: Equatable {
    /// <p>The name of the resource to delete.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteDestinationInputBody: Equatable {
}

extension DeleteDestinationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDestinationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDestinationOutputResponse()"}
}

extension DeleteDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDestinationOutputResponse: Equatable {

    public init() {}
}

struct DeleteDestinationOutputResponseBody: Equatable {
}

extension DeleteDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDeviceProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDeviceProfileInput(id: \(String(describing: id)))"}
}

extension DeleteDeviceProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDeviceProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDeviceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDeviceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDeviceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDeviceProfileInput>
    public typealias MOutput = OperationOutput<DeleteDeviceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDeviceProfileOutputError>
}

public struct DeleteDeviceProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDeviceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDeviceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDeviceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDeviceProfileInput>
    public typealias MOutput = OperationOutput<DeleteDeviceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDeviceProfileOutputError>
}

public struct DeleteDeviceProfileInput: Equatable {
    /// <p>The ID of the resource to delete.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteDeviceProfileInputBody: Equatable {
}

extension DeleteDeviceProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDeviceProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeviceProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDeviceProfileOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeviceProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDeviceProfileOutputResponse()"}
}

extension DeleteDeviceProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDeviceProfileOutputResponse: Equatable {

    public init() {}
}

struct DeleteDeviceProfileOutputResponseBody: Equatable {
}

extension DeleteDeviceProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteServiceProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServiceProfileInput(id: \(String(describing: id)))"}
}

extension DeleteServiceProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteServiceProfileInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteServiceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServiceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServiceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServiceProfileInput>
    public typealias MOutput = OperationOutput<DeleteServiceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServiceProfileOutputError>
}

public struct DeleteServiceProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteServiceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServiceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServiceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServiceProfileInput>
    public typealias MOutput = OperationOutput<DeleteServiceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServiceProfileOutputError>
}

public struct DeleteServiceProfileInput: Equatable {
    /// <p>The ID of the resource to delete.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteServiceProfileInputBody: Equatable {
}

extension DeleteServiceProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteServiceProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServiceProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServiceProfileOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServiceProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServiceProfileOutputResponse()"}
}

extension DeleteServiceProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServiceProfileOutputResponse: Equatable {

    public init() {}
}

struct DeleteServiceProfileOutputResponseBody: Equatable {
}

extension DeleteServiceProfileOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteWirelessDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWirelessDeviceInput(id: \(String(describing: id)))"}
}

extension DeleteWirelessDeviceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteWirelessDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteWirelessDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWirelessDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWirelessDeviceInput>
    public typealias MOutput = OperationOutput<DeleteWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWirelessDeviceOutputError>
}

public struct DeleteWirelessDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteWirelessDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWirelessDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWirelessDeviceInput>
    public typealias MOutput = OperationOutput<DeleteWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWirelessDeviceOutputError>
}

public struct DeleteWirelessDeviceInput: Equatable {
    /// <p>The ID of the resource to delete.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWirelessDeviceInputBody: Equatable {
}

extension DeleteWirelessDeviceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteWirelessDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWirelessDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWirelessDeviceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWirelessDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWirelessDeviceOutputResponse()"}
}

extension DeleteWirelessDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWirelessDeviceOutputResponse: Equatable {

    public init() {}
}

struct DeleteWirelessDeviceOutputResponseBody: Equatable {
}

extension DeleteWirelessDeviceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteWirelessGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWirelessGatewayInput(id: \(String(describing: id)))"}
}

extension DeleteWirelessGatewayInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteWirelessGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteWirelessGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWirelessGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWirelessGatewayInput>
    public typealias MOutput = OperationOutput<DeleteWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWirelessGatewayOutputError>
}

public struct DeleteWirelessGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteWirelessGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWirelessGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWirelessGatewayInput>
    public typealias MOutput = OperationOutput<DeleteWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWirelessGatewayOutputError>
}

public struct DeleteWirelessGatewayInput: Equatable {
    /// <p>The ID of the resource to delete.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWirelessGatewayInputBody: Equatable {
}

extension DeleteWirelessGatewayInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteWirelessGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWirelessGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWirelessGatewayOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWirelessGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWirelessGatewayOutputResponse()"}
}

extension DeleteWirelessGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWirelessGatewayOutputResponse: Equatable {

    public init() {}
}

struct DeleteWirelessGatewayOutputResponseBody: Equatable {
}

extension DeleteWirelessGatewayOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteWirelessGatewayTaskDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWirelessGatewayTaskDefinitionInput(id: \(String(describing: id)))"}
}

extension DeleteWirelessGatewayTaskDefinitionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteWirelessGatewayTaskDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteWirelessGatewayTaskDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWirelessGatewayTaskDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWirelessGatewayTaskDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWirelessGatewayTaskDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteWirelessGatewayTaskDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWirelessGatewayTaskDefinitionOutputError>
}

public struct DeleteWirelessGatewayTaskDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteWirelessGatewayTaskDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWirelessGatewayTaskDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWirelessGatewayTaskDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWirelessGatewayTaskDefinitionInput>
    public typealias MOutput = OperationOutput<DeleteWirelessGatewayTaskDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWirelessGatewayTaskDefinitionOutputError>
}

public struct DeleteWirelessGatewayTaskDefinitionInput: Equatable {
    /// <p>The ID of the resource to delete.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWirelessGatewayTaskDefinitionInputBody: Equatable {
}

extension DeleteWirelessGatewayTaskDefinitionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteWirelessGatewayTaskDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWirelessGatewayTaskDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWirelessGatewayTaskDefinitionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWirelessGatewayTaskDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWirelessGatewayTaskDefinitionOutputResponse()"}
}

extension DeleteWirelessGatewayTaskDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWirelessGatewayTaskDefinitionOutputResponse: Equatable {

    public init() {}
}

struct DeleteWirelessGatewayTaskDefinitionOutputResponseBody: Equatable {
}

extension DeleteWirelessGatewayTaskDefinitionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteWirelessGatewayTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWirelessGatewayTaskInput(id: \(String(describing: id)))"}
}

extension DeleteWirelessGatewayTaskInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteWirelessGatewayTaskInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteWirelessGatewayTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWirelessGatewayTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWirelessGatewayTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWirelessGatewayTaskInput>
    public typealias MOutput = OperationOutput<DeleteWirelessGatewayTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWirelessGatewayTaskOutputError>
}

public struct DeleteWirelessGatewayTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteWirelessGatewayTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteWirelessGatewayTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteWirelessGatewayTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteWirelessGatewayTaskInput>
    public typealias MOutput = OperationOutput<DeleteWirelessGatewayTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteWirelessGatewayTaskOutputError>
}

public struct DeleteWirelessGatewayTaskInput: Equatable {
    /// <p>The ID of the resource to delete.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DeleteWirelessGatewayTaskInputBody: Equatable {
}

extension DeleteWirelessGatewayTaskInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteWirelessGatewayTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteWirelessGatewayTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteWirelessGatewayTaskOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteWirelessGatewayTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteWirelessGatewayTaskOutputResponse()"}
}

extension DeleteWirelessGatewayTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteWirelessGatewayTaskOutputResponse: Equatable {

    public init() {}
}

struct DeleteWirelessGatewayTaskOutputResponseBody: Equatable {
}

extension DeleteWirelessGatewayTaskOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Destinations: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case name = "Name"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let expressionType = expressionType {
            try encodeContainer.encode(expressionType.rawValue, forKey: .expressionType)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension Destinations: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Destinations(arn: \(String(describing: arn)), description: \(String(describing: description)), expression: \(String(describing: expression)), expressionType: \(String(describing: expressionType)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Describes a destination.</p>
public struct Destinations: Equatable {
    /// <p>The Amazon Resource Name of the resource.</p>
    public let arn: String?
    /// <p>The description of the resource.</p>
    public let description: String?
    /// <p>The rule name or topic rule to send messages to.</p>
    public let expression: String?
    /// <p>The type of value in <code>Expression</code>.</p>
    public let expressionType: ExpressionType?
    /// <p>The name of the resource.</p>
    public let name: String?
    /// <p>The ARN of the IAM Role that authorizes the destination.</p>
    public let roleArn: String?

    public init (
        arn: String? = nil,
        description: String? = nil,
        expression: String? = nil,
        expressionType: ExpressionType? = nil,
        name: String? = nil,
        roleArn: String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.expression = expression
        self.expressionType = expressionType
        self.name = name
        self.roleArn = roleArn
    }
}

extension DeviceProfile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension DeviceProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeviceProfile(arn: \(String(describing: arn)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>Describes a device profile.</p>
public struct DeviceProfile: Equatable {
    /// <p>The Amazon Resource Name of the resource.</p>
    public let arn: String?
    /// <p>The ID of the device profile.</p>
    public let id: String?
    /// <p>The name of the resource.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
    }
}

/// <p>Device state defines the device status of sidewalk device.</p>
public enum DeviceState {
    case provisioned
    case registerednotseen
    case registeredreachable
    case registeredunreachable
    case sdkUnknown(String)
}

extension DeviceState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeviceState] {
        return [
            .provisioned,
            .registerednotseen,
            .registeredreachable,
            .registeredunreachable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .provisioned: return "Provisioned"
        case .registerednotseen: return "RegisteredNotSeen"
        case .registeredreachable: return "RegisteredReachable"
        case .registeredunreachable: return "RegisteredUnreachable"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeviceState(rawValue: rawValue) ?? DeviceState.sdkUnknown(rawValue)
    }
}

extension DisassociateAwsAccountFromPartnerAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateAwsAccountFromPartnerAccountInput(partnerAccountId: \(String(describing: partnerAccountId)), partnerType: \(String(describing: partnerType)))"}
}

extension DisassociateAwsAccountFromPartnerAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateAwsAccountFromPartnerAccountInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateAwsAccountFromPartnerAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateAwsAccountFromPartnerAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateAwsAccountFromPartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateAwsAccountFromPartnerAccountInput>
    public typealias MOutput = OperationOutput<DisassociateAwsAccountFromPartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateAwsAccountFromPartnerAccountOutputError>
}

public struct DisassociateAwsAccountFromPartnerAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateAwsAccountFromPartnerAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateAwsAccountFromPartnerAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateAwsAccountFromPartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let partnerType = input.operationInput.partnerType {
            let partnerTypeQueryItem = URLQueryItem(name: "partnerType".urlPercentEncoding(), value: String(partnerType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(partnerTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateAwsAccountFromPartnerAccountInput>
    public typealias MOutput = OperationOutput<DisassociateAwsAccountFromPartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateAwsAccountFromPartnerAccountOutputError>
}

public struct DisassociateAwsAccountFromPartnerAccountInput: Equatable {
    /// <p>The partner account ID to disassociate from the AWS account.</p>
    public let partnerAccountId: String?
    /// <p>The partner type.</p>
    public let partnerType: PartnerType?

    public init (
        partnerAccountId: String? = nil,
        partnerType: PartnerType? = nil
    )
    {
        self.partnerAccountId = partnerAccountId
        self.partnerType = partnerType
    }
}

struct DisassociateAwsAccountFromPartnerAccountInputBody: Equatable {
}

extension DisassociateAwsAccountFromPartnerAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateAwsAccountFromPartnerAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateAwsAccountFromPartnerAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateAwsAccountFromPartnerAccountOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateAwsAccountFromPartnerAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateAwsAccountFromPartnerAccountOutputResponse()"}
}

extension DisassociateAwsAccountFromPartnerAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateAwsAccountFromPartnerAccountOutputResponse: Equatable {

    public init() {}
}

struct DisassociateAwsAccountFromPartnerAccountOutputResponseBody: Equatable {
}

extension DisassociateAwsAccountFromPartnerAccountOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateWirelessDeviceFromThingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateWirelessDeviceFromThingInput(id: \(String(describing: id)))"}
}

extension DisassociateWirelessDeviceFromThingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateWirelessDeviceFromThingInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateWirelessDeviceFromThingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateWirelessDeviceFromThingInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateWirelessDeviceFromThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateWirelessDeviceFromThingInput>
    public typealias MOutput = OperationOutput<DisassociateWirelessDeviceFromThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateWirelessDeviceFromThingOutputError>
}

public struct DisassociateWirelessDeviceFromThingInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateWirelessDeviceFromThingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateWirelessDeviceFromThingInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateWirelessDeviceFromThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateWirelessDeviceFromThingInput>
    public typealias MOutput = OperationOutput<DisassociateWirelessDeviceFromThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateWirelessDeviceFromThingOutputError>
}

public struct DisassociateWirelessDeviceFromThingInput: Equatable {
    /// <p>The ID of the resource to update.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DisassociateWirelessDeviceFromThingInputBody: Equatable {
}

extension DisassociateWirelessDeviceFromThingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateWirelessDeviceFromThingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWirelessDeviceFromThingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateWirelessDeviceFromThingOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWirelessDeviceFromThingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateWirelessDeviceFromThingOutputResponse()"}
}

extension DisassociateWirelessDeviceFromThingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWirelessDeviceFromThingOutputResponse: Equatable {

    public init() {}
}

struct DisassociateWirelessDeviceFromThingOutputResponseBody: Equatable {
}

extension DisassociateWirelessDeviceFromThingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateWirelessGatewayFromCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateWirelessGatewayFromCertificateInput(id: \(String(describing: id)))"}
}

extension DisassociateWirelessGatewayFromCertificateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateWirelessGatewayFromCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateWirelessGatewayFromCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateWirelessGatewayFromCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateWirelessGatewayFromCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateWirelessGatewayFromCertificateInput>
    public typealias MOutput = OperationOutput<DisassociateWirelessGatewayFromCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateWirelessGatewayFromCertificateOutputError>
}

public struct DisassociateWirelessGatewayFromCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateWirelessGatewayFromCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateWirelessGatewayFromCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateWirelessGatewayFromCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateWirelessGatewayFromCertificateInput>
    public typealias MOutput = OperationOutput<DisassociateWirelessGatewayFromCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateWirelessGatewayFromCertificateOutputError>
}

public struct DisassociateWirelessGatewayFromCertificateInput: Equatable {
    /// <p>The ID of the resource to update.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DisassociateWirelessGatewayFromCertificateInputBody: Equatable {
}

extension DisassociateWirelessGatewayFromCertificateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateWirelessGatewayFromCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWirelessGatewayFromCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateWirelessGatewayFromCertificateOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWirelessGatewayFromCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateWirelessGatewayFromCertificateOutputResponse()"}
}

extension DisassociateWirelessGatewayFromCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWirelessGatewayFromCertificateOutputResponse: Equatable {

    public init() {}
}

struct DisassociateWirelessGatewayFromCertificateOutputResponseBody: Equatable {
}

extension DisassociateWirelessGatewayFromCertificateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateWirelessGatewayFromThingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateWirelessGatewayFromThingInput(id: \(String(describing: id)))"}
}

extension DisassociateWirelessGatewayFromThingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateWirelessGatewayFromThingInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateWirelessGatewayFromThingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateWirelessGatewayFromThingInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateWirelessGatewayFromThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateWirelessGatewayFromThingInput>
    public typealias MOutput = OperationOutput<DisassociateWirelessGatewayFromThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateWirelessGatewayFromThingOutputError>
}

public struct DisassociateWirelessGatewayFromThingInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateWirelessGatewayFromThingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateWirelessGatewayFromThingInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateWirelessGatewayFromThingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateWirelessGatewayFromThingInput>
    public typealias MOutput = OperationOutput<DisassociateWirelessGatewayFromThingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateWirelessGatewayFromThingOutputError>
}

public struct DisassociateWirelessGatewayFromThingInput: Equatable {
    /// <p>The ID of the resource to update.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct DisassociateWirelessGatewayFromThingInputBody: Equatable {
}

extension DisassociateWirelessGatewayFromThingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateWirelessGatewayFromThingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateWirelessGatewayFromThingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateWirelessGatewayFromThingOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateWirelessGatewayFromThingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateWirelessGatewayFromThingOutputResponse()"}
}

extension DisassociateWirelessGatewayFromThingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateWirelessGatewayFromThingOutputResponse: Equatable {

    public init() {}
}

struct DisassociateWirelessGatewayFromThingOutputResponseBody: Equatable {
}

extension DisassociateWirelessGatewayFromThingOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

/// <p>Sidewalk device status notification.</p>
public enum Event {
    case ack
    case discovered
    case lost
    case nack
    case passthrough
    case sdkUnknown(String)
}

extension Event : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Event] {
        return [
            .ack,
            .discovered,
            .lost,
            .nack,
            .passthrough,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ack: return "ack"
        case .discovered: return "discovered"
        case .lost: return "lost"
        case .nack: return "nack"
        case .passthrough: return "passthrough"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Event(rawValue: rawValue) ?? Event.sdkUnknown(rawValue)
    }
}

public enum ExpressionType {
    case mqtttopic
    case rulename
    case sdkUnknown(String)
}

extension ExpressionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ExpressionType] {
        return [
            .mqtttopic,
            .rulename,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .mqtttopic: return "MqttTopic"
        case .rulename: return "RuleName"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ExpressionType(rawValue: rawValue) ?? ExpressionType.sdkUnknown(rawValue)
    }
}

extension GetDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDestinationInput(name: \(String(describing: name)))"}
}

extension GetDestinationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "GetDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDestinationInput>
    public typealias MOutput = OperationOutput<GetDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDestinationOutputError>
}

public struct GetDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDestinationInput>
    public typealias MOutput = OperationOutput<GetDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDestinationOutputError>
}

public struct GetDestinationInput: Equatable {
    /// <p>The name of the resource to get.</p>
    public let name: String?

    public init (
        name: String? = nil
    )
    {
        self.name = name
    }
}

struct GetDestinationInputBody: Equatable {
}

extension GetDestinationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDestinationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDestinationOutputResponse(arn: \(String(describing: arn)), description: \(String(describing: description)), expression: \(String(describing: expression)), expressionType: \(String(describing: expressionType)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)))"}
}

extension GetDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDestinationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.description = output.description
            self.expression = output.expression
            self.expressionType = output.expressionType
            self.name = output.name
            self.roleArn = output.roleArn
        } else {
            self.arn = nil
            self.description = nil
            self.expression = nil
            self.expressionType = nil
            self.name = nil
            self.roleArn = nil
        }
    }
}

public struct GetDestinationOutputResponse: Equatable {
    /// <p>The Amazon Resource Name of the resource.</p>
    public let arn: String?
    /// <p>The description of the resource.</p>
    public let description: String?
    /// <p>The rule name or topic rule to send messages to.</p>
    public let expression: String?
    /// <p>The type of value in <code>Expression</code>.</p>
    public let expressionType: ExpressionType?
    /// <p>The name of the resource.</p>
    public let name: String?
    /// <p>The ARN of the IAM Role that authorizes the destination.</p>
    public let roleArn: String?

    public init (
        arn: String? = nil,
        description: String? = nil,
        expression: String? = nil,
        expressionType: ExpressionType? = nil,
        name: String? = nil,
        roleArn: String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.expression = expression
        self.expressionType = expressionType
        self.name = name
        self.roleArn = roleArn
    }
}

struct GetDestinationOutputResponseBody: Equatable {
    public let arn: String?
    public let name: String?
    public let expression: String?
    public let expressionType: ExpressionType?
    public let description: String?
    public let roleArn: String?
}

extension GetDestinationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case name = "Name"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
        let expressionTypeDecoded = try containerValues.decodeIfPresent(ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension GetDeviceProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeviceProfileInput(id: \(String(describing: id)))"}
}

extension GetDeviceProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDeviceProfileInputHeadersMiddleware: Middleware {
    public let id: String = "GetDeviceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceProfileInput>
    public typealias MOutput = OperationOutput<GetDeviceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceProfileOutputError>
}

public struct GetDeviceProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDeviceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDeviceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDeviceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDeviceProfileInput>
    public typealias MOutput = OperationOutput<GetDeviceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDeviceProfileOutputError>
}

public struct GetDeviceProfileInput: Equatable {
    /// <p>The ID of the resource to get.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetDeviceProfileInputBody: Equatable {
}

extension GetDeviceProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDeviceProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeviceProfileOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDeviceProfileOutputResponse(arn: \(String(describing: arn)), id: \(String(describing: id)), loRaWAN: \(String(describing: loRaWAN)), name: \(String(describing: name)))"}
}

extension GetDeviceProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDeviceProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
        } else {
            self.arn = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
        }
    }
}

public struct GetDeviceProfileOutputResponse: Equatable {
    /// <p>The Amazon Resource Name of the resource.</p>
    public let arn: String?
    /// <p>The ID of the device profile.</p>
    public let id: String?
    /// <p>Information about the device profile.</p>
    public let loRaWAN: LoRaWANDeviceProfile?
    /// <p>The name of the resource.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        id: String? = nil,
        loRaWAN: LoRaWANDeviceProfile? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
    }
}

struct GetDeviceProfileOutputResponseBody: Equatable {
    public let arn: String?
    public let name: String?
    public let id: String?
    public let loRaWAN: LoRaWANDeviceProfile?
}

extension GetDeviceProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(LoRaWANDeviceProfile.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension GetLogLevelsByResourceTypesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLogLevelsByResourceTypesInput()"}
}

extension GetLogLevelsByResourceTypesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetLogLevelsByResourceTypesInputHeadersMiddleware: Middleware {
    public let id: String = "GetLogLevelsByResourceTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLogLevelsByResourceTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLogLevelsByResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLogLevelsByResourceTypesInput>
    public typealias MOutput = OperationOutput<GetLogLevelsByResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLogLevelsByResourceTypesOutputError>
}

public struct GetLogLevelsByResourceTypesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLogLevelsByResourceTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLogLevelsByResourceTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLogLevelsByResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLogLevelsByResourceTypesInput>
    public typealias MOutput = OperationOutput<GetLogLevelsByResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLogLevelsByResourceTypesOutputError>
}

public struct GetLogLevelsByResourceTypesInput: Equatable {

    public init() {}
}

struct GetLogLevelsByResourceTypesInputBody: Equatable {
}

extension GetLogLevelsByResourceTypesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetLogLevelsByResourceTypesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLogLevelsByResourceTypesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLogLevelsByResourceTypesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLogLevelsByResourceTypesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLogLevelsByResourceTypesOutputResponse(defaultLogLevel: \(String(describing: defaultLogLevel)), wirelessDeviceLogOptions: \(String(describing: wirelessDeviceLogOptions)), wirelessGatewayLogOptions: \(String(describing: wirelessGatewayLogOptions)))"}
}

extension GetLogLevelsByResourceTypesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLogLevelsByResourceTypesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.defaultLogLevel = output.defaultLogLevel
            self.wirelessDeviceLogOptions = output.wirelessDeviceLogOptions
            self.wirelessGatewayLogOptions = output.wirelessGatewayLogOptions
        } else {
            self.defaultLogLevel = nil
            self.wirelessDeviceLogOptions = nil
            self.wirelessGatewayLogOptions = nil
        }
    }
}

public struct GetLogLevelsByResourceTypesOutputResponse: Equatable {
    /// <p>The log level for a log message.</p>
    public let defaultLogLevel: LogLevel?
    /// <p>The list of wireless device log options.</p>
    public let wirelessDeviceLogOptions: [WirelessDeviceLogOption]?
    /// <p>The list of wireless gateway log options.</p>
    public let wirelessGatewayLogOptions: [WirelessGatewayLogOption]?

    public init (
        defaultLogLevel: LogLevel? = nil,
        wirelessDeviceLogOptions: [WirelessDeviceLogOption]? = nil,
        wirelessGatewayLogOptions: [WirelessGatewayLogOption]? = nil
    )
    {
        self.defaultLogLevel = defaultLogLevel
        self.wirelessDeviceLogOptions = wirelessDeviceLogOptions
        self.wirelessGatewayLogOptions = wirelessGatewayLogOptions
    }
}

struct GetLogLevelsByResourceTypesOutputResponseBody: Equatable {
    public let defaultLogLevel: LogLevel?
    public let wirelessGatewayLogOptions: [WirelessGatewayLogOption]?
    public let wirelessDeviceLogOptions: [WirelessDeviceLogOption]?
}

extension GetLogLevelsByResourceTypesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultLogLevel = "DefaultLogLevel"
        case wirelessDeviceLogOptions = "WirelessDeviceLogOptions"
        case wirelessGatewayLogOptions = "WirelessGatewayLogOptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultLogLevelDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .defaultLogLevel)
        defaultLogLevel = defaultLogLevelDecoded
        let wirelessGatewayLogOptionsContainer = try containerValues.decodeIfPresent([WirelessGatewayLogOption?].self, forKey: .wirelessGatewayLogOptions)
        var wirelessGatewayLogOptionsDecoded0:[WirelessGatewayLogOption]? = nil
        if let wirelessGatewayLogOptionsContainer = wirelessGatewayLogOptionsContainer {
            wirelessGatewayLogOptionsDecoded0 = [WirelessGatewayLogOption]()
            for structure0 in wirelessGatewayLogOptionsContainer {
                if let structure0 = structure0 {
                    wirelessGatewayLogOptionsDecoded0?.append(structure0)
                }
            }
        }
        wirelessGatewayLogOptions = wirelessGatewayLogOptionsDecoded0
        let wirelessDeviceLogOptionsContainer = try containerValues.decodeIfPresent([WirelessDeviceLogOption?].self, forKey: .wirelessDeviceLogOptions)
        var wirelessDeviceLogOptionsDecoded0:[WirelessDeviceLogOption]? = nil
        if let wirelessDeviceLogOptionsContainer = wirelessDeviceLogOptionsContainer {
            wirelessDeviceLogOptionsDecoded0 = [WirelessDeviceLogOption]()
            for structure0 in wirelessDeviceLogOptionsContainer {
                if let structure0 = structure0 {
                    wirelessDeviceLogOptionsDecoded0?.append(structure0)
                }
            }
        }
        wirelessDeviceLogOptions = wirelessDeviceLogOptionsDecoded0
    }
}

extension GetPartnerAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPartnerAccountInput(partnerAccountId: \(String(describing: partnerAccountId)), partnerType: \(String(describing: partnerType)))"}
}

extension GetPartnerAccountInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetPartnerAccountInputHeadersMiddleware: Middleware {
    public let id: String = "GetPartnerAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPartnerAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPartnerAccountInput>
    public typealias MOutput = OperationOutput<GetPartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPartnerAccountOutputError>
}

public struct GetPartnerAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPartnerAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPartnerAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let partnerType = input.operationInput.partnerType {
            let partnerTypeQueryItem = URLQueryItem(name: "partnerType".urlPercentEncoding(), value: String(partnerType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(partnerTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPartnerAccountInput>
    public typealias MOutput = OperationOutput<GetPartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPartnerAccountOutputError>
}

public struct GetPartnerAccountInput: Equatable {
    /// <p>The partner account ID to disassociate from the AWS account.</p>
    public let partnerAccountId: String?
    /// <p>The partner type.</p>
    public let partnerType: PartnerType?

    public init (
        partnerAccountId: String? = nil,
        partnerType: PartnerType? = nil
    )
    {
        self.partnerAccountId = partnerAccountId
        self.partnerType = partnerType
    }
}

struct GetPartnerAccountInputBody: Equatable {
}

extension GetPartnerAccountInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetPartnerAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPartnerAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPartnerAccountOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPartnerAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPartnerAccountOutputResponse(accountLinked: \(String(describing: accountLinked)), sidewalk: \(String(describing: sidewalk)))"}
}

extension GetPartnerAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPartnerAccountOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountLinked = output.accountLinked
            self.sidewalk = output.sidewalk
        } else {
            self.accountLinked = false
            self.sidewalk = nil
        }
    }
}

public struct GetPartnerAccountOutputResponse: Equatable {
    /// <p>Whether the partner account is linked to the AWS account.</p>
    public let accountLinked: Bool
    /// <p>The Sidewalk account credentials.</p>
    public let sidewalk: SidewalkAccountInfoWithFingerprint?

    public init (
        accountLinked: Bool = false,
        sidewalk: SidewalkAccountInfoWithFingerprint? = nil
    )
    {
        self.accountLinked = accountLinked
        self.sidewalk = sidewalk
    }
}

struct GetPartnerAccountOutputResponseBody: Equatable {
    public let sidewalk: SidewalkAccountInfoWithFingerprint?
    public let accountLinked: Bool
}

extension GetPartnerAccountOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountLinked = "AccountLinked"
        case sidewalk = "Sidewalk"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(SidewalkAccountInfoWithFingerprint.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
        let accountLinkedDecoded = try containerValues.decode(Bool.self, forKey: .accountLinked)
        accountLinked = accountLinkedDecoded
    }
}

extension GetResourceLogLevelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceLogLevelInput(resourceIdentifier: \(String(describing: resourceIdentifier)), resourceType: \(String(describing: resourceType)))"}
}

extension GetResourceLogLevelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetResourceLogLevelInputHeadersMiddleware: Middleware {
    public let id: String = "GetResourceLogLevelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceLogLevelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceLogLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceLogLevelInput>
    public typealias MOutput = OperationOutput<GetResourceLogLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceLogLevelOutputError>
}

public struct GetResourceLogLevelInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResourceLogLevelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourceLogLevelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourceLogLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceType = input.operationInput.resourceType {
            let resourceTypeQueryItem = URLQueryItem(name: "resourceType".urlPercentEncoding(), value: String(resourceType).urlPercentEncoding())
            input.builder.withQueryItem(resourceTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourceLogLevelInput>
    public typealias MOutput = OperationOutput<GetResourceLogLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourceLogLevelOutputError>
}

public struct GetResourceLogLevelInput: Equatable {
    /// <p>The identifier of the resource. For a Wireless Device, it is the wireless device id. For a wireless gateway, it is the wireless gateway id.</p>
    public let resourceIdentifier: String?
    /// <p>The type of the resource, currently support WirelessDevice and WirelessGateway.</p>
    public let resourceType: String?

    public init (
        resourceIdentifier: String? = nil,
        resourceType: String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct GetResourceLogLevelInputBody: Equatable {
}

extension GetResourceLogLevelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetResourceLogLevelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourceLogLevelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourceLogLevelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourceLogLevelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourceLogLevelOutputResponse(logLevel: \(String(describing: logLevel)))"}
}

extension GetResourceLogLevelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResourceLogLevelOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.logLevel = output.logLevel
        } else {
            self.logLevel = nil
        }
    }
}

public struct GetResourceLogLevelOutputResponse: Equatable {
    /// <p>The log level for a log message.</p>
    public let logLevel: LogLevel?

    public init (
        logLevel: LogLevel? = nil
    )
    {
        self.logLevel = logLevel
    }
}

struct GetResourceLogLevelOutputResponseBody: Equatable {
    public let logLevel: LogLevel?
}

extension GetResourceLogLevelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case logLevel = "LogLevel"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logLevelDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension GetServiceEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceEndpointInput(serviceType: \(String(describing: serviceType)))"}
}

extension GetServiceEndpointInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetServiceEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "GetServiceEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceEndpointInput>
    public typealias MOutput = OperationOutput<GetServiceEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceEndpointOutputError>
}

public struct GetServiceEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "GetServiceEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let serviceType = input.operationInput.serviceType {
            let serviceTypeQueryItem = URLQueryItem(name: "serviceType".urlPercentEncoding(), value: String(serviceType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(serviceTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceEndpointInput>
    public typealias MOutput = OperationOutput<GetServiceEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceEndpointOutputError>
}

public struct GetServiceEndpointInput: Equatable {
    /// <p>The service type for which to get endpoint information about. Can be <code>CUPS</code> for the Configuration and Update Server endpoint, or <code>LNS</code> for the LoRaWAN Network Server endpoint.</p>
    public let serviceType: WirelessGatewayServiceType?

    public init (
        serviceType: WirelessGatewayServiceType? = nil
    )
    {
        self.serviceType = serviceType
    }
}

struct GetServiceEndpointInputBody: Equatable {
}

extension GetServiceEndpointInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetServiceEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceEndpointOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceEndpointOutputResponse(serverTrust: \(String(describing: serverTrust)), serviceEndpoint: \(String(describing: serviceEndpoint)), serviceType: \(String(describing: serviceType)))"}
}

extension GetServiceEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetServiceEndpointOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.serverTrust = output.serverTrust
            self.serviceEndpoint = output.serviceEndpoint
            self.serviceType = output.serviceType
        } else {
            self.serverTrust = nil
            self.serviceEndpoint = nil
            self.serviceType = nil
        }
    }
}

public struct GetServiceEndpointOutputResponse: Equatable {
    /// <p>The Root CA of the server trust certificate.</p>
    public let serverTrust: String?
    /// <p>The service endpoint value.</p>
    public let serviceEndpoint: String?
    /// <p>The endpoint's service type.</p>
    public let serviceType: WirelessGatewayServiceType?

    public init (
        serverTrust: String? = nil,
        serviceEndpoint: String? = nil,
        serviceType: WirelessGatewayServiceType? = nil
    )
    {
        self.serverTrust = serverTrust
        self.serviceEndpoint = serviceEndpoint
        self.serviceType = serviceType
    }
}

struct GetServiceEndpointOutputResponseBody: Equatable {
    public let serviceType: WirelessGatewayServiceType?
    public let serviceEndpoint: String?
    public let serverTrust: String?
}

extension GetServiceEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverTrust = "ServerTrust"
        case serviceEndpoint = "ServiceEndpoint"
        case serviceType = "ServiceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceTypeDecoded = try containerValues.decodeIfPresent(WirelessGatewayServiceType.self, forKey: .serviceType)
        serviceType = serviceTypeDecoded
        let serviceEndpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceEndpoint)
        serviceEndpoint = serviceEndpointDecoded
        let serverTrustDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverTrust)
        serverTrust = serverTrustDecoded
    }
}

extension GetServiceProfileInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceProfileInput(id: \(String(describing: id)))"}
}

extension GetServiceProfileInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetServiceProfileInputHeadersMiddleware: Middleware {
    public let id: String = "GetServiceProfileInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceProfileInput>
    public typealias MOutput = OperationOutput<GetServiceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceProfileOutputError>
}

public struct GetServiceProfileInputQueryItemMiddleware: Middleware {
    public let id: String = "GetServiceProfileInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetServiceProfileInput>,
                  next: H) -> Swift.Result<OperationOutput<GetServiceProfileOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetServiceProfileInput>
    public typealias MOutput = OperationOutput<GetServiceProfileOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetServiceProfileOutputError>
}

public struct GetServiceProfileInput: Equatable {
    /// <p>The ID of the resource to get.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetServiceProfileInputBody: Equatable {
}

extension GetServiceProfileInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetServiceProfileOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetServiceProfileOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetServiceProfileOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetServiceProfileOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetServiceProfileOutputResponse(arn: \(String(describing: arn)), id: \(String(describing: id)), loRaWAN: \(String(describing: loRaWAN)), name: \(String(describing: name)))"}
}

extension GetServiceProfileOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetServiceProfileOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
        } else {
            self.arn = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
        }
    }
}

public struct GetServiceProfileOutputResponse: Equatable {
    /// <p>The Amazon Resource Name of the resource.</p>
    public let arn: String?
    /// <p>The ID of the service profile.</p>
    public let id: String?
    /// <p>Information about the service profile.</p>
    public let loRaWAN: LoRaWANGetServiceProfileInfo?
    /// <p>The name of the resource.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        id: String? = nil,
        loRaWAN: LoRaWANGetServiceProfileInfo? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
    }
}

struct GetServiceProfileOutputResponseBody: Equatable {
    public let arn: String?
    public let name: String?
    public let id: String?
    public let loRaWAN: LoRaWANGetServiceProfileInfo?
}

extension GetServiceProfileOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(LoRaWANGetServiceProfileInfo.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension GetWirelessDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWirelessDeviceInput(identifier: \(String(describing: identifier)), identifierType: \(String(describing: identifierType)))"}
}

extension GetWirelessDeviceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetWirelessDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "GetWirelessDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWirelessDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWirelessDeviceInput>
    public typealias MOutput = OperationOutput<GetWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWirelessDeviceOutputError>
}

public struct GetWirelessDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "GetWirelessDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWirelessDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let identifierType = input.operationInput.identifierType {
            let identifierTypeQueryItem = URLQueryItem(name: "identifierType".urlPercentEncoding(), value: String(identifierType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(identifierTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWirelessDeviceInput>
    public typealias MOutput = OperationOutput<GetWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWirelessDeviceOutputError>
}

public struct GetWirelessDeviceInput: Equatable {
    /// <p>The identifier of the wireless device to get.</p>
    public let identifier: String?
    /// <p>The type of identifier used in <code>identifier</code>.</p>
    public let identifierType: WirelessDeviceIdType?

    public init (
        identifier: String? = nil,
        identifierType: WirelessDeviceIdType? = nil
    )
    {
        self.identifier = identifier
        self.identifierType = identifierType
    }
}

struct GetWirelessDeviceInputBody: Equatable {
}

extension GetWirelessDeviceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetWirelessDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessDeviceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWirelessDeviceOutputResponse(arn: \(String(describing: arn)), description: \(String(describing: description)), destinationName: \(String(describing: destinationName)), id: \(String(describing: id)), loRaWAN: \(String(describing: loRaWAN)), name: \(String(describing: name)), sidewalk: \(String(describing: sidewalk)), thingArn: \(String(describing: thingArn)), thingName: \(String(describing: thingName)), type: \(String(describing: type)))"}
}

extension GetWirelessDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetWirelessDeviceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.description = output.description
            self.destinationName = output.destinationName
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
            self.sidewalk = output.sidewalk
            self.thingArn = output.thingArn
            self.thingName = output.thingName
            self.type = output.type
        } else {
            self.arn = nil
            self.description = nil
            self.destinationName = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
            self.sidewalk = nil
            self.thingArn = nil
            self.thingName = nil
            self.type = nil
        }
    }
}

public struct GetWirelessDeviceOutputResponse: Equatable {
    /// <p>The Amazon Resource Name of the resource.</p>
    public let arn: String?
    /// <p>The description of the resource.</p>
    public let description: String?
    /// <p>The name of the destination to which the device is assigned.</p>
    public let destinationName: String?
    /// <p>The ID of the wireless device.</p>
    public let id: String?
    /// <p>Information about the wireless device.</p>
    public let loRaWAN: LoRaWANDevice?
    /// <p>The name of the resource.</p>
    public let name: String?
    /// <p>Sidewalk device object.</p>
    public let sidewalk: SidewalkDevice?
    /// <p>The ARN of the thing associated with the wireless device.</p>
    public let thingArn: String?
    /// <p>The name of the thing associated with the wireless device. The value is empty if a thing isn't associated with the device.</p>
    public let thingName: String?
    /// <p>The wireless device type.</p>
    public let type: WirelessDeviceType?

    public init (
        arn: String? = nil,
        description: String? = nil,
        destinationName: String? = nil,
        id: String? = nil,
        loRaWAN: LoRaWANDevice? = nil,
        name: String? = nil,
        sidewalk: SidewalkDevice? = nil,
        thingArn: String? = nil,
        thingName: String? = nil,
        type: WirelessDeviceType? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.destinationName = destinationName
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.sidewalk = sidewalk
        self.thingArn = thingArn
        self.thingName = thingName
        self.type = type
    }
}

struct GetWirelessDeviceOutputResponseBody: Equatable {
    public let type: WirelessDeviceType?
    public let name: String?
    public let description: String?
    public let destinationName: String?
    public let id: String?
    public let arn: String?
    public let thingName: String?
    public let thingArn: String?
    public let loRaWAN: LoRaWANDevice?
    public let sidewalk: SidewalkDevice?
}

extension GetWirelessDeviceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case description = "Description"
        case destinationName = "DestinationName"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case sidewalk = "Sidewalk"
        case thingArn = "ThingArn"
        case thingName = "ThingName"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(WirelessDeviceType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(LoRaWANDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(SidewalkDevice.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension GetWirelessDeviceStatisticsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWirelessDeviceStatisticsInput(wirelessDeviceId: \(String(describing: wirelessDeviceId)))"}
}

extension GetWirelessDeviceStatisticsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetWirelessDeviceStatisticsInputHeadersMiddleware: Middleware {
    public let id: String = "GetWirelessDeviceStatisticsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWirelessDeviceStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWirelessDeviceStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWirelessDeviceStatisticsInput>
    public typealias MOutput = OperationOutput<GetWirelessDeviceStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWirelessDeviceStatisticsOutputError>
}

public struct GetWirelessDeviceStatisticsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetWirelessDeviceStatisticsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWirelessDeviceStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWirelessDeviceStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWirelessDeviceStatisticsInput>
    public typealias MOutput = OperationOutput<GetWirelessDeviceStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWirelessDeviceStatisticsOutputError>
}

public struct GetWirelessDeviceStatisticsInput: Equatable {
    /// <p>The ID of the wireless device for which to get the data.</p>
    public let wirelessDeviceId: String?

    public init (
        wirelessDeviceId: String? = nil
    )
    {
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct GetWirelessDeviceStatisticsInputBody: Equatable {
}

extension GetWirelessDeviceStatisticsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetWirelessDeviceStatisticsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessDeviceStatisticsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessDeviceStatisticsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessDeviceStatisticsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWirelessDeviceStatisticsOutputResponse(lastUplinkReceivedAt: \(String(describing: lastUplinkReceivedAt)), loRaWAN: \(String(describing: loRaWAN)), sidewalk: \(String(describing: sidewalk)), wirelessDeviceId: \(String(describing: wirelessDeviceId)))"}
}

extension GetWirelessDeviceStatisticsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetWirelessDeviceStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lastUplinkReceivedAt = output.lastUplinkReceivedAt
            self.loRaWAN = output.loRaWAN
            self.sidewalk = output.sidewalk
            self.wirelessDeviceId = output.wirelessDeviceId
        } else {
            self.lastUplinkReceivedAt = nil
            self.loRaWAN = nil
            self.sidewalk = nil
            self.wirelessDeviceId = nil
        }
    }
}

public struct GetWirelessDeviceStatisticsOutputResponse: Equatable {
    /// <p>The date and time when the most recent uplink was received.</p>
    public let lastUplinkReceivedAt: String?
    /// <p>Information about the wireless device's operations.</p>
    public let loRaWAN: LoRaWANDeviceMetadata?
    /// <p>MetaData for Sidewalk device.</p>
    public let sidewalk: SidewalkDeviceMetadata?
    /// <p>The ID of the wireless device.</p>
    public let wirelessDeviceId: String?

    public init (
        lastUplinkReceivedAt: String? = nil,
        loRaWAN: LoRaWANDeviceMetadata? = nil,
        sidewalk: SidewalkDeviceMetadata? = nil,
        wirelessDeviceId: String? = nil
    )
    {
        self.lastUplinkReceivedAt = lastUplinkReceivedAt
        self.loRaWAN = loRaWAN
        self.sidewalk = sidewalk
        self.wirelessDeviceId = wirelessDeviceId
    }
}

struct GetWirelessDeviceStatisticsOutputResponseBody: Equatable {
    public let wirelessDeviceId: String?
    public let lastUplinkReceivedAt: String?
    public let loRaWAN: LoRaWANDeviceMetadata?
    public let sidewalk: SidewalkDeviceMetadata?
}

extension GetWirelessDeviceStatisticsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case loRaWAN = "LoRaWAN"
        case sidewalk = "Sidewalk"
        case wirelessDeviceId = "WirelessDeviceId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessDeviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .wirelessDeviceId)
        wirelessDeviceId = wirelessDeviceIdDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(LoRaWANDeviceMetadata.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(SidewalkDeviceMetadata.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension GetWirelessGatewayCertificateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWirelessGatewayCertificateInput(id: \(String(describing: id)))"}
}

extension GetWirelessGatewayCertificateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetWirelessGatewayCertificateInputHeadersMiddleware: Middleware {
    public let id: String = "GetWirelessGatewayCertificateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWirelessGatewayCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWirelessGatewayCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWirelessGatewayCertificateInput>
    public typealias MOutput = OperationOutput<GetWirelessGatewayCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWirelessGatewayCertificateOutputError>
}

public struct GetWirelessGatewayCertificateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetWirelessGatewayCertificateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWirelessGatewayCertificateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWirelessGatewayCertificateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWirelessGatewayCertificateInput>
    public typealias MOutput = OperationOutput<GetWirelessGatewayCertificateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWirelessGatewayCertificateOutputError>
}

public struct GetWirelessGatewayCertificateInput: Equatable {
    /// <p>The ID of the resource to get.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetWirelessGatewayCertificateInputBody: Equatable {
}

extension GetWirelessGatewayCertificateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetWirelessGatewayCertificateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayCertificateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessGatewayCertificateOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayCertificateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWirelessGatewayCertificateOutputResponse(iotCertificateId: \(String(describing: iotCertificateId)), loRaWANNetworkServerCertificateId: \(String(describing: loRaWANNetworkServerCertificateId)))"}
}

extension GetWirelessGatewayCertificateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetWirelessGatewayCertificateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.iotCertificateId = output.iotCertificateId
            self.loRaWANNetworkServerCertificateId = output.loRaWANNetworkServerCertificateId
        } else {
            self.iotCertificateId = nil
            self.loRaWANNetworkServerCertificateId = nil
        }
    }
}

public struct GetWirelessGatewayCertificateOutputResponse: Equatable {
    /// <p>The ID of the certificate associated with the wireless gateway.</p>
    public let iotCertificateId: String?
    /// <p>The ID of the certificate that is associated with the wireless gateway and used for the LoRaWANNetworkServer endpoint.</p>
    public let loRaWANNetworkServerCertificateId: String?

    public init (
        iotCertificateId: String? = nil,
        loRaWANNetworkServerCertificateId: String? = nil
    )
    {
        self.iotCertificateId = iotCertificateId
        self.loRaWANNetworkServerCertificateId = loRaWANNetworkServerCertificateId
    }
}

struct GetWirelessGatewayCertificateOutputResponseBody: Equatable {
    public let iotCertificateId: String?
    public let loRaWANNetworkServerCertificateId: String?
}

extension GetWirelessGatewayCertificateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case iotCertificateId = "IotCertificateId"
        case loRaWANNetworkServerCertificateId = "LoRaWANNetworkServerCertificateId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iotCertificateId)
        iotCertificateId = iotCertificateIdDecoded
        let loRaWANNetworkServerCertificateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .loRaWANNetworkServerCertificateId)
        loRaWANNetworkServerCertificateId = loRaWANNetworkServerCertificateIdDecoded
    }
}

extension GetWirelessGatewayFirmwareInformationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWirelessGatewayFirmwareInformationInput(id: \(String(describing: id)))"}
}

extension GetWirelessGatewayFirmwareInformationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetWirelessGatewayFirmwareInformationInputHeadersMiddleware: Middleware {
    public let id: String = "GetWirelessGatewayFirmwareInformationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWirelessGatewayFirmwareInformationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWirelessGatewayFirmwareInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWirelessGatewayFirmwareInformationInput>
    public typealias MOutput = OperationOutput<GetWirelessGatewayFirmwareInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWirelessGatewayFirmwareInformationOutputError>
}

public struct GetWirelessGatewayFirmwareInformationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetWirelessGatewayFirmwareInformationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWirelessGatewayFirmwareInformationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWirelessGatewayFirmwareInformationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWirelessGatewayFirmwareInformationInput>
    public typealias MOutput = OperationOutput<GetWirelessGatewayFirmwareInformationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWirelessGatewayFirmwareInformationOutputError>
}

public struct GetWirelessGatewayFirmwareInformationInput: Equatable {
    /// <p>The ID of the resource to get.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetWirelessGatewayFirmwareInformationInputBody: Equatable {
}

extension GetWirelessGatewayFirmwareInformationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetWirelessGatewayFirmwareInformationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayFirmwareInformationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessGatewayFirmwareInformationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayFirmwareInformationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWirelessGatewayFirmwareInformationOutputResponse(loRaWAN: \(String(describing: loRaWAN)))"}
}

extension GetWirelessGatewayFirmwareInformationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetWirelessGatewayFirmwareInformationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.loRaWAN = output.loRaWAN
        } else {
            self.loRaWAN = nil
        }
    }
}

public struct GetWirelessGatewayFirmwareInformationOutputResponse: Equatable {
    /// <p>Information about the wireless gateway's firmware.</p>
    public let loRaWAN: LoRaWANGatewayCurrentVersion?

    public init (
        loRaWAN: LoRaWANGatewayCurrentVersion? = nil
    )
    {
        self.loRaWAN = loRaWAN
    }
}

struct GetWirelessGatewayFirmwareInformationOutputResponseBody: Equatable {
    public let loRaWAN: LoRaWANGatewayCurrentVersion?
}

extension GetWirelessGatewayFirmwareInformationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case loRaWAN = "LoRaWAN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(LoRaWANGatewayCurrentVersion.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension GetWirelessGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWirelessGatewayInput(identifier: \(String(describing: identifier)), identifierType: \(String(describing: identifierType)))"}
}

extension GetWirelessGatewayInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetWirelessGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "GetWirelessGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWirelessGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWirelessGatewayInput>
    public typealias MOutput = OperationOutput<GetWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWirelessGatewayOutputError>
}

public struct GetWirelessGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "GetWirelessGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWirelessGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let identifierType = input.operationInput.identifierType {
            let identifierTypeQueryItem = URLQueryItem(name: "identifierType".urlPercentEncoding(), value: String(identifierType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(identifierTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWirelessGatewayInput>
    public typealias MOutput = OperationOutput<GetWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWirelessGatewayOutputError>
}

public struct GetWirelessGatewayInput: Equatable {
    /// <p>The identifier of the wireless gateway to get.</p>
    public let identifier: String?
    /// <p>The type of identifier used in <code>identifier</code>.</p>
    public let identifierType: WirelessGatewayIdType?

    public init (
        identifier: String? = nil,
        identifierType: WirelessGatewayIdType? = nil
    )
    {
        self.identifier = identifier
        self.identifierType = identifierType
    }
}

struct GetWirelessGatewayInputBody: Equatable {
}

extension GetWirelessGatewayInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetWirelessGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessGatewayOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWirelessGatewayOutputResponse(arn: \(String(describing: arn)), description: \(String(describing: description)), id: \(String(describing: id)), loRaWAN: \(String(describing: loRaWAN)), name: \(String(describing: name)), thingArn: \(String(describing: thingArn)), thingName: \(String(describing: thingName)))"}
}

extension GetWirelessGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetWirelessGatewayOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.description = output.description
            self.id = output.id
            self.loRaWAN = output.loRaWAN
            self.name = output.name
            self.thingArn = output.thingArn
            self.thingName = output.thingName
        } else {
            self.arn = nil
            self.description = nil
            self.id = nil
            self.loRaWAN = nil
            self.name = nil
            self.thingArn = nil
            self.thingName = nil
        }
    }
}

public struct GetWirelessGatewayOutputResponse: Equatable {
    /// <p>The Amazon Resource Name of the resource.</p>
    public let arn: String?
    /// <p>The description of the resource.</p>
    public let description: String?
    /// <p>The ID of the wireless gateway.</p>
    public let id: String?
    /// <p>Information about the wireless gateway.</p>
    public let loRaWAN: LoRaWANGateway?
    /// <p>The name of the resource.</p>
    public let name: String?
    /// <p>The ARN of the thing associated with the wireless gateway.</p>
    public let thingArn: String?
    /// <p>The name of the thing associated with the wireless gateway. The value is empty if a thing isn't associated with the gateway.</p>
    public let thingName: String?

    public init (
        arn: String? = nil,
        description: String? = nil,
        id: String? = nil,
        loRaWAN: LoRaWANGateway? = nil,
        name: String? = nil,
        thingArn: String? = nil,
        thingName: String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
        self.thingArn = thingArn
        self.thingName = thingName
    }
}

struct GetWirelessGatewayOutputResponseBody: Equatable {
    public let name: String?
    public let id: String?
    public let description: String?
    public let loRaWAN: LoRaWANGateway?
    public let arn: String?
    public let thingName: String?
    public let thingArn: String?
}

extension GetWirelessGatewayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case description = "Description"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case thingArn = "ThingArn"
        case thingName = "ThingName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(LoRaWANGateway.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let thingNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingName)
        thingName = thingNameDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension GetWirelessGatewayStatisticsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWirelessGatewayStatisticsInput(wirelessGatewayId: \(String(describing: wirelessGatewayId)))"}
}

extension GetWirelessGatewayStatisticsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetWirelessGatewayStatisticsInputHeadersMiddleware: Middleware {
    public let id: String = "GetWirelessGatewayStatisticsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWirelessGatewayStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWirelessGatewayStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWirelessGatewayStatisticsInput>
    public typealias MOutput = OperationOutput<GetWirelessGatewayStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWirelessGatewayStatisticsOutputError>
}

public struct GetWirelessGatewayStatisticsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetWirelessGatewayStatisticsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWirelessGatewayStatisticsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWirelessGatewayStatisticsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWirelessGatewayStatisticsInput>
    public typealias MOutput = OperationOutput<GetWirelessGatewayStatisticsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWirelessGatewayStatisticsOutputError>
}

public struct GetWirelessGatewayStatisticsInput: Equatable {
    /// <p>The ID of the wireless gateway for which to get the data.</p>
    public let wirelessGatewayId: String?

    public init (
        wirelessGatewayId: String? = nil
    )
    {
        self.wirelessGatewayId = wirelessGatewayId
    }
}

struct GetWirelessGatewayStatisticsInputBody: Equatable {
}

extension GetWirelessGatewayStatisticsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetWirelessGatewayStatisticsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayStatisticsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessGatewayStatisticsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayStatisticsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWirelessGatewayStatisticsOutputResponse(connectionStatus: \(String(describing: connectionStatus)), lastUplinkReceivedAt: \(String(describing: lastUplinkReceivedAt)), wirelessGatewayId: \(String(describing: wirelessGatewayId)))"}
}

extension GetWirelessGatewayStatisticsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetWirelessGatewayStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connectionStatus = output.connectionStatus
            self.lastUplinkReceivedAt = output.lastUplinkReceivedAt
            self.wirelessGatewayId = output.wirelessGatewayId
        } else {
            self.connectionStatus = nil
            self.lastUplinkReceivedAt = nil
            self.wirelessGatewayId = nil
        }
    }
}

public struct GetWirelessGatewayStatisticsOutputResponse: Equatable {
    /// <p>The connection status of the wireless gateway.</p>
    public let connectionStatus: ConnectionStatus?
    /// <p>The date and time when the most recent uplink was received.</p>
    public let lastUplinkReceivedAt: String?
    /// <p>The ID of the wireless gateway.</p>
    public let wirelessGatewayId: String?

    public init (
        connectionStatus: ConnectionStatus? = nil,
        lastUplinkReceivedAt: String? = nil,
        wirelessGatewayId: String? = nil
    )
    {
        self.connectionStatus = connectionStatus
        self.lastUplinkReceivedAt = lastUplinkReceivedAt
        self.wirelessGatewayId = wirelessGatewayId
    }
}

struct GetWirelessGatewayStatisticsOutputResponseBody: Equatable {
    public let wirelessGatewayId: String?
    public let lastUplinkReceivedAt: String?
    public let connectionStatus: ConnectionStatus?
}

extension GetWirelessGatewayStatisticsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectionStatus = "ConnectionStatus"
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case wirelessGatewayId = "WirelessGatewayId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .wirelessGatewayId)
        wirelessGatewayId = wirelessGatewayIdDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
        let connectionStatusDecoded = try containerValues.decodeIfPresent(ConnectionStatus.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
    }
}

extension GetWirelessGatewayTaskDefinitionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWirelessGatewayTaskDefinitionInput(id: \(String(describing: id)))"}
}

extension GetWirelessGatewayTaskDefinitionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetWirelessGatewayTaskDefinitionInputHeadersMiddleware: Middleware {
    public let id: String = "GetWirelessGatewayTaskDefinitionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWirelessGatewayTaskDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWirelessGatewayTaskDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWirelessGatewayTaskDefinitionInput>
    public typealias MOutput = OperationOutput<GetWirelessGatewayTaskDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWirelessGatewayTaskDefinitionOutputError>
}

public struct GetWirelessGatewayTaskDefinitionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetWirelessGatewayTaskDefinitionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWirelessGatewayTaskDefinitionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWirelessGatewayTaskDefinitionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWirelessGatewayTaskDefinitionInput>
    public typealias MOutput = OperationOutput<GetWirelessGatewayTaskDefinitionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWirelessGatewayTaskDefinitionOutputError>
}

public struct GetWirelessGatewayTaskDefinitionInput: Equatable {
    /// <p>The ID of the resource to get.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetWirelessGatewayTaskDefinitionInputBody: Equatable {
}

extension GetWirelessGatewayTaskDefinitionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetWirelessGatewayTaskDefinitionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayTaskDefinitionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessGatewayTaskDefinitionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayTaskDefinitionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWirelessGatewayTaskDefinitionOutputResponse(arn: \(String(describing: arn)), autoCreateTasks: \(String(describing: autoCreateTasks)), name: \(String(describing: name)), update: \(String(describing: update)))"}
}

extension GetWirelessGatewayTaskDefinitionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetWirelessGatewayTaskDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
            self.autoCreateTasks = output.autoCreateTasks
            self.name = output.name
            self.update = output.update
        } else {
            self.arn = nil
            self.autoCreateTasks = false
            self.name = nil
            self.update = nil
        }
    }
}

public struct GetWirelessGatewayTaskDefinitionOutputResponse: Equatable {
    /// <p>The Amazon Resource Name of the resource.</p>
    public let arn: String?
    /// <p>Whether to automatically create tasks using this task definition for all gateways with the specified current version. If <code>false</code>, the task must me created by calling <code>CreateWirelessGatewayTask</code>.</p>
    public let autoCreateTasks: Bool
    /// <p>The name of the resource.</p>
    public let name: String?
    /// <p>Information about the gateways to update.</p>
    public let update: UpdateWirelessGatewayTaskCreate?

    public init (
        arn: String? = nil,
        autoCreateTasks: Bool = false,
        name: String? = nil,
        update: UpdateWirelessGatewayTaskCreate? = nil
    )
    {
        self.arn = arn
        self.autoCreateTasks = autoCreateTasks
        self.name = name
        self.update = update
    }
}

struct GetWirelessGatewayTaskDefinitionOutputResponseBody: Equatable {
    public let autoCreateTasks: Bool
    public let name: String?
    public let update: UpdateWirelessGatewayTaskCreate?
    public let arn: String?
}

extension GetWirelessGatewayTaskDefinitionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case autoCreateTasks = "AutoCreateTasks"
        case name = "Name"
        case update = "Update"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoCreateTasksDecoded = try containerValues.decode(Bool.self, forKey: .autoCreateTasks)
        autoCreateTasks = autoCreateTasksDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let updateDecoded = try containerValues.decodeIfPresent(UpdateWirelessGatewayTaskCreate.self, forKey: .update)
        update = updateDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetWirelessGatewayTaskInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWirelessGatewayTaskInput(id: \(String(describing: id)))"}
}

extension GetWirelessGatewayTaskInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetWirelessGatewayTaskInputHeadersMiddleware: Middleware {
    public let id: String = "GetWirelessGatewayTaskInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWirelessGatewayTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWirelessGatewayTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWirelessGatewayTaskInput>
    public typealias MOutput = OperationOutput<GetWirelessGatewayTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWirelessGatewayTaskOutputError>
}

public struct GetWirelessGatewayTaskInputQueryItemMiddleware: Middleware {
    public let id: String = "GetWirelessGatewayTaskInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetWirelessGatewayTaskInput>,
                  next: H) -> Swift.Result<OperationOutput<GetWirelessGatewayTaskOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetWirelessGatewayTaskInput>
    public typealias MOutput = OperationOutput<GetWirelessGatewayTaskOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetWirelessGatewayTaskOutputError>
}

public struct GetWirelessGatewayTaskInput: Equatable {
    /// <p>The ID of the resource to get.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct GetWirelessGatewayTaskInputBody: Equatable {
}

extension GetWirelessGatewayTaskInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetWirelessGatewayTaskOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWirelessGatewayTaskOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetWirelessGatewayTaskOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWirelessGatewayTaskOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetWirelessGatewayTaskOutputResponse(lastUplinkReceivedAt: \(String(describing: lastUplinkReceivedAt)), status: \(String(describing: status)), taskCreatedAt: \(String(describing: taskCreatedAt)), wirelessGatewayId: \(String(describing: wirelessGatewayId)), wirelessGatewayTaskDefinitionId: \(String(describing: wirelessGatewayTaskDefinitionId)))"}
}

extension GetWirelessGatewayTaskOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetWirelessGatewayTaskOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.lastUplinkReceivedAt = output.lastUplinkReceivedAt
            self.status = output.status
            self.taskCreatedAt = output.taskCreatedAt
            self.wirelessGatewayId = output.wirelessGatewayId
            self.wirelessGatewayTaskDefinitionId = output.wirelessGatewayTaskDefinitionId
        } else {
            self.lastUplinkReceivedAt = nil
            self.status = nil
            self.taskCreatedAt = nil
            self.wirelessGatewayId = nil
            self.wirelessGatewayTaskDefinitionId = nil
        }
    }
}

public struct GetWirelessGatewayTaskOutputResponse: Equatable {
    /// <p>The date and time when the most recent uplink was received.</p>
    public let lastUplinkReceivedAt: String?
    /// <p>The status of the request.</p>
    public let status: WirelessGatewayTaskStatus?
    /// <p>The date and time when the task was created.</p>
    public let taskCreatedAt: String?
    /// <p>The ID of the wireless gateway.</p>
    public let wirelessGatewayId: String?
    /// <p>The ID of the WirelessGatewayTask.</p>
    public let wirelessGatewayTaskDefinitionId: String?

    public init (
        lastUplinkReceivedAt: String? = nil,
        status: WirelessGatewayTaskStatus? = nil,
        taskCreatedAt: String? = nil,
        wirelessGatewayId: String? = nil,
        wirelessGatewayTaskDefinitionId: String? = nil
    )
    {
        self.lastUplinkReceivedAt = lastUplinkReceivedAt
        self.status = status
        self.taskCreatedAt = taskCreatedAt
        self.wirelessGatewayId = wirelessGatewayId
        self.wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionId
    }
}

struct GetWirelessGatewayTaskOutputResponseBody: Equatable {
    public let wirelessGatewayId: String?
    public let wirelessGatewayTaskDefinitionId: String?
    public let lastUplinkReceivedAt: String?
    public let taskCreatedAt: String?
    public let status: WirelessGatewayTaskStatus?
}

extension GetWirelessGatewayTaskOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case status = "Status"
        case taskCreatedAt = "TaskCreatedAt"
        case wirelessGatewayId = "WirelessGatewayId"
        case wirelessGatewayTaskDefinitionId = "WirelessGatewayTaskDefinitionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let wirelessGatewayIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .wirelessGatewayId)
        wirelessGatewayId = wirelessGatewayIdDecoded
        let wirelessGatewayTaskDefinitionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .wirelessGatewayTaskDefinitionId)
        wirelessGatewayTaskDefinitionId = wirelessGatewayTaskDefinitionIdDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
        let taskCreatedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskCreatedAt)
        taskCreatedAt = taskCreatedAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WirelessGatewayTaskStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An unexpected error occurred while processing a request.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDestinationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDestinationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDestinationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDestinationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListDestinationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDestinationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDestinationsInput>
    public typealias MOutput = OperationOutput<ListDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDestinationsOutputError>
}

public struct ListDestinationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDestinationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDestinationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDestinationsInput>
    public typealias MOutput = OperationOutput<ListDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDestinationsOutputError>
}

public struct ListDestinationsInput: Equatable {
    /// <p>The maximum number of results to return in this operation.</p>
    public let maxResults: Int
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDestinationsInputBody: Equatable {
}

extension ListDestinationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDestinationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDestinationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDestinationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDestinationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDestinationsOutputResponse(destinationList: \(String(describing: destinationList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDestinationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDestinationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.destinationList = output.destinationList
            self.nextToken = output.nextToken
        } else {
            self.destinationList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDestinationsOutputResponse: Equatable {
    /// <p>The list of destinations.</p>
    public let destinationList: [Destinations]?
    /// <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
    public let nextToken: String?

    public init (
        destinationList: [Destinations]? = nil,
        nextToken: String? = nil
    )
    {
        self.destinationList = destinationList
        self.nextToken = nextToken
    }
}

struct ListDestinationsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let destinationList: [Destinations]?
}

extension ListDestinationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationList = "DestinationList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let destinationListContainer = try containerValues.decodeIfPresent([Destinations?].self, forKey: .destinationList)
        var destinationListDecoded0:[Destinations]? = nil
        if let destinationListContainer = destinationListContainer {
            destinationListDecoded0 = [Destinations]()
            for structure0 in destinationListContainer {
                if let structure0 = structure0 {
                    destinationListDecoded0?.append(structure0)
                }
            }
        }
        destinationList = destinationListDecoded0
    }
}

extension ListDeviceProfilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeviceProfilesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDeviceProfilesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListDeviceProfilesInputHeadersMiddleware: Middleware {
    public let id: String = "ListDeviceProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeviceProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeviceProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeviceProfilesInput>
    public typealias MOutput = OperationOutput<ListDeviceProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeviceProfilesOutputError>
}

public struct ListDeviceProfilesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListDeviceProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListDeviceProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListDeviceProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListDeviceProfilesInput>
    public typealias MOutput = OperationOutput<ListDeviceProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListDeviceProfilesOutputError>
}

public struct ListDeviceProfilesInput: Equatable {
    /// <p>The maximum number of results to return in this operation.</p>
    public let maxResults: Int
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeviceProfilesInputBody: Equatable {
}

extension ListDeviceProfilesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListDeviceProfilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeviceProfilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeviceProfilesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeviceProfilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListDeviceProfilesOutputResponse(deviceProfileList: \(String(describing: deviceProfileList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListDeviceProfilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListDeviceProfilesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.deviceProfileList = output.deviceProfileList
            self.nextToken = output.nextToken
        } else {
            self.deviceProfileList = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeviceProfilesOutputResponse: Equatable {
    /// <p>The list of device profiles.</p>
    public let deviceProfileList: [DeviceProfile]?
    /// <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
    public let nextToken: String?

    public init (
        deviceProfileList: [DeviceProfile]? = nil,
        nextToken: String? = nil
    )
    {
        self.deviceProfileList = deviceProfileList
        self.nextToken = nextToken
    }
}

struct ListDeviceProfilesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let deviceProfileList: [DeviceProfile]?
}

extension ListDeviceProfilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceProfileList = "DeviceProfileList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let deviceProfileListContainer = try containerValues.decodeIfPresent([DeviceProfile?].self, forKey: .deviceProfileList)
        var deviceProfileListDecoded0:[DeviceProfile]? = nil
        if let deviceProfileListContainer = deviceProfileListContainer {
            deviceProfileListDecoded0 = [DeviceProfile]()
            for structure0 in deviceProfileListContainer {
                if let structure0 = structure0 {
                    deviceProfileListDecoded0?.append(structure0)
                }
            }
        }
        deviceProfileList = deviceProfileListDecoded0
    }
}

extension ListPartnerAccountsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPartnerAccountsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListPartnerAccountsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListPartnerAccountsInputHeadersMiddleware: Middleware {
    public let id: String = "ListPartnerAccountsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPartnerAccountsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPartnerAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPartnerAccountsInput>
    public typealias MOutput = OperationOutput<ListPartnerAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPartnerAccountsOutputError>
}

public struct ListPartnerAccountsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListPartnerAccountsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListPartnerAccountsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListPartnerAccountsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListPartnerAccountsInput>
    public typealias MOutput = OperationOutput<ListPartnerAccountsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListPartnerAccountsOutputError>
}

public struct ListPartnerAccountsInput: Equatable {
    /// <p>The maximum number of results to return in this operation.</p>
    public let maxResults: Int
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPartnerAccountsInputBody: Equatable {
}

extension ListPartnerAccountsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListPartnerAccountsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPartnerAccountsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPartnerAccountsOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPartnerAccountsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListPartnerAccountsOutputResponse(nextToken: \(String(describing: nextToken)), sidewalk: \(String(describing: sidewalk)))"}
}

extension ListPartnerAccountsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListPartnerAccountsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.sidewalk = output.sidewalk
        } else {
            self.nextToken = nil
            self.sidewalk = nil
        }
    }
}

public struct ListPartnerAccountsOutputResponse: Equatable {
    /// <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
    public let nextToken: String?
    /// <p>The Sidewalk account credentials.</p>
    public let sidewalk: [SidewalkAccountInfoWithFingerprint]?

    public init (
        nextToken: String? = nil,
        sidewalk: [SidewalkAccountInfoWithFingerprint]? = nil
    )
    {
        self.nextToken = nextToken
        self.sidewalk = sidewalk
    }
}

struct ListPartnerAccountsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let sidewalk: [SidewalkAccountInfoWithFingerprint]?
}

extension ListPartnerAccountsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case sidewalk = "Sidewalk"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let sidewalkContainer = try containerValues.decodeIfPresent([SidewalkAccountInfoWithFingerprint?].self, forKey: .sidewalk)
        var sidewalkDecoded0:[SidewalkAccountInfoWithFingerprint]? = nil
        if let sidewalkContainer = sidewalkContainer {
            sidewalkDecoded0 = [SidewalkAccountInfoWithFingerprint]()
            for structure0 in sidewalkContainer {
                if let structure0 = structure0 {
                    sidewalkDecoded0?.append(structure0)
                }
            }
        }
        sidewalk = sidewalkDecoded0
    }
}

extension ListServiceProfilesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServiceProfilesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListServiceProfilesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListServiceProfilesInputHeadersMiddleware: Middleware {
    public let id: String = "ListServiceProfilesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServiceProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServiceProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServiceProfilesInput>
    public typealias MOutput = OperationOutput<ListServiceProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServiceProfilesOutputError>
}

public struct ListServiceProfilesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListServiceProfilesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListServiceProfilesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListServiceProfilesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListServiceProfilesInput>
    public typealias MOutput = OperationOutput<ListServiceProfilesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListServiceProfilesOutputError>
}

public struct ListServiceProfilesInput: Equatable {
    /// <p>The maximum number of results to return in this operation.</p>
    public let maxResults: Int
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListServiceProfilesInputBody: Equatable {
}

extension ListServiceProfilesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListServiceProfilesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListServiceProfilesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListServiceProfilesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListServiceProfilesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListServiceProfilesOutputResponse(nextToken: \(String(describing: nextToken)), serviceProfileList: \(String(describing: serviceProfileList)))"}
}

extension ListServiceProfilesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListServiceProfilesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.serviceProfileList = output.serviceProfileList
        } else {
            self.nextToken = nil
            self.serviceProfileList = nil
        }
    }
}

public struct ListServiceProfilesOutputResponse: Equatable {
    /// <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
    public let nextToken: String?
    /// <p>The list of service profiles.</p>
    public let serviceProfileList: [ServiceProfile]?

    public init (
        nextToken: String? = nil,
        serviceProfileList: [ServiceProfile]? = nil
    )
    {
        self.nextToken = nextToken
        self.serviceProfileList = serviceProfileList
    }
}

struct ListServiceProfilesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let serviceProfileList: [ServiceProfile]?
}

extension ListServiceProfilesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case serviceProfileList = "ServiceProfileList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serviceProfileListContainer = try containerValues.decodeIfPresent([ServiceProfile?].self, forKey: .serviceProfileList)
        var serviceProfileListDecoded0:[ServiceProfile]? = nil
        if let serviceProfileListContainer = serviceProfileListContainer {
            serviceProfileListDecoded0 = [ServiceProfile]()
            for structure0 in serviceProfileListContainer {
                if let structure0 = structure0 {
                    serviceProfileListDecoded0?.append(structure0)
                }
            }
        }
        serviceProfileList = serviceProfileListDecoded0
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The ARN of the resource for which you want to list tags.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The tags to attach to the specified resource. Tags are metadata that you can use to manage a resource.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListWirelessDevicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWirelessDevicesInput(destinationName: \(String(describing: destinationName)), deviceProfileId: \(String(describing: deviceProfileId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), serviceProfileId: \(String(describing: serviceProfileId)), wirelessDeviceType: \(String(describing: wirelessDeviceType)))"}
}

extension ListWirelessDevicesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListWirelessDevicesInputHeadersMiddleware: Middleware {
    public let id: String = "ListWirelessDevicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWirelessDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWirelessDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWirelessDevicesInput>
    public typealias MOutput = OperationOutput<ListWirelessDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWirelessDevicesOutputError>
}

public struct ListWirelessDevicesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListWirelessDevicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWirelessDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWirelessDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let deviceProfileId = input.operationInput.deviceProfileId {
            let deviceProfileIdQueryItem = URLQueryItem(name: "deviceProfileId".urlPercentEncoding(), value: String(deviceProfileId).urlPercentEncoding())
            input.builder.withQueryItem(deviceProfileIdQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let destinationName = input.operationInput.destinationName {
            let destinationNameQueryItem = URLQueryItem(name: "destinationName".urlPercentEncoding(), value: String(destinationName).urlPercentEncoding())
            input.builder.withQueryItem(destinationNameQueryItem)
        }
        if let wirelessDeviceType = input.operationInput.wirelessDeviceType {
            let wirelessDeviceTypeQueryItem = URLQueryItem(name: "wirelessDeviceType".urlPercentEncoding(), value: String(wirelessDeviceType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(wirelessDeviceTypeQueryItem)
        }
        if let serviceProfileId = input.operationInput.serviceProfileId {
            let serviceProfileIdQueryItem = URLQueryItem(name: "serviceProfileId".urlPercentEncoding(), value: String(serviceProfileId).urlPercentEncoding())
            input.builder.withQueryItem(serviceProfileIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWirelessDevicesInput>
    public typealias MOutput = OperationOutput<ListWirelessDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWirelessDevicesOutputError>
}

public struct ListWirelessDevicesInput: Equatable {
    /// <p>A filter to list only the wireless devices that use this destination.</p>
    public let destinationName: String?
    /// <p>A filter to list only the wireless devices that use this device profile.</p>
    public let deviceProfileId: String?
    /// <p>The maximum number of results to return in this operation.</p>
    public let maxResults: Int
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    public let nextToken: String?
    /// <p>A filter to list only the wireless devices that use this service profile.</p>
    public let serviceProfileId: String?
    /// <p>A filter to list only the wireless devices that use this wireless device type.</p>
    public let wirelessDeviceType: WirelessDeviceType?

    public init (
        destinationName: String? = nil,
        deviceProfileId: String? = nil,
        maxResults: Int = 0,
        nextToken: String? = nil,
        serviceProfileId: String? = nil,
        wirelessDeviceType: WirelessDeviceType? = nil
    )
    {
        self.destinationName = destinationName
        self.deviceProfileId = deviceProfileId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serviceProfileId = serviceProfileId
        self.wirelessDeviceType = wirelessDeviceType
    }
}

struct ListWirelessDevicesInputBody: Equatable {
}

extension ListWirelessDevicesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListWirelessDevicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWirelessDevicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWirelessDevicesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWirelessDevicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWirelessDevicesOutputResponse(nextToken: \(String(describing: nextToken)), wirelessDeviceList: \(String(describing: wirelessDeviceList)))"}
}

extension ListWirelessDevicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListWirelessDevicesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.wirelessDeviceList = output.wirelessDeviceList
        } else {
            self.nextToken = nil
            self.wirelessDeviceList = nil
        }
    }
}

public struct ListWirelessDevicesOutputResponse: Equatable {
    /// <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
    public let nextToken: String?
    /// <p>The ID of the wireless device.</p>
    public let wirelessDeviceList: [WirelessDeviceStatistics]?

    public init (
        nextToken: String? = nil,
        wirelessDeviceList: [WirelessDeviceStatistics]? = nil
    )
    {
        self.nextToken = nextToken
        self.wirelessDeviceList = wirelessDeviceList
    }
}

struct ListWirelessDevicesOutputResponseBody: Equatable {
    public let nextToken: String?
    public let wirelessDeviceList: [WirelessDeviceStatistics]?
}

extension ListWirelessDevicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case wirelessDeviceList = "WirelessDeviceList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let wirelessDeviceListContainer = try containerValues.decodeIfPresent([WirelessDeviceStatistics?].self, forKey: .wirelessDeviceList)
        var wirelessDeviceListDecoded0:[WirelessDeviceStatistics]? = nil
        if let wirelessDeviceListContainer = wirelessDeviceListContainer {
            wirelessDeviceListDecoded0 = [WirelessDeviceStatistics]()
            for structure0 in wirelessDeviceListContainer {
                if let structure0 = structure0 {
                    wirelessDeviceListDecoded0?.append(structure0)
                }
            }
        }
        wirelessDeviceList = wirelessDeviceListDecoded0
    }
}

extension ListWirelessGatewayTaskDefinitionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWirelessGatewayTaskDefinitionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), taskDefinitionType: \(String(describing: taskDefinitionType)))"}
}

extension ListWirelessGatewayTaskDefinitionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListWirelessGatewayTaskDefinitionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListWirelessGatewayTaskDefinitionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWirelessGatewayTaskDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWirelessGatewayTaskDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWirelessGatewayTaskDefinitionsInput>
    public typealias MOutput = OperationOutput<ListWirelessGatewayTaskDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWirelessGatewayTaskDefinitionsOutputError>
}

public struct ListWirelessGatewayTaskDefinitionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListWirelessGatewayTaskDefinitionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWirelessGatewayTaskDefinitionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWirelessGatewayTaskDefinitionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        if let taskDefinitionType = input.operationInput.taskDefinitionType {
            let taskDefinitionTypeQueryItem = URLQueryItem(name: "taskDefinitionType".urlPercentEncoding(), value: String(taskDefinitionType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(taskDefinitionTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWirelessGatewayTaskDefinitionsInput>
    public typealias MOutput = OperationOutput<ListWirelessGatewayTaskDefinitionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWirelessGatewayTaskDefinitionsOutputError>
}

public struct ListWirelessGatewayTaskDefinitionsInput: Equatable {
    /// <p>The maximum number of results to return in this operation.</p>
    public let maxResults: Int
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    public let nextToken: String?
    /// <p>A filter to list only the wireless gateway task definitions that use this task definition type.</p>
    public let taskDefinitionType: WirelessGatewayTaskDefinitionType?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil,
        taskDefinitionType: WirelessGatewayTaskDefinitionType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.taskDefinitionType = taskDefinitionType
    }
}

struct ListWirelessGatewayTaskDefinitionsInputBody: Equatable {
}

extension ListWirelessGatewayTaskDefinitionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListWirelessGatewayTaskDefinitionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWirelessGatewayTaskDefinitionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWirelessGatewayTaskDefinitionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWirelessGatewayTaskDefinitionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWirelessGatewayTaskDefinitionsOutputResponse(nextToken: \(String(describing: nextToken)), taskDefinitions: \(String(describing: taskDefinitions)))"}
}

extension ListWirelessGatewayTaskDefinitionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListWirelessGatewayTaskDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.taskDefinitions = output.taskDefinitions
        } else {
            self.nextToken = nil
            self.taskDefinitions = nil
        }
    }
}

public struct ListWirelessGatewayTaskDefinitionsOutputResponse: Equatable {
    /// <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
    public let nextToken: String?
    /// <p>The list of task definitions.</p>
    public let taskDefinitions: [UpdateWirelessGatewayTaskEntry]?

    public init (
        nextToken: String? = nil,
        taskDefinitions: [UpdateWirelessGatewayTaskEntry]? = nil
    )
    {
        self.nextToken = nextToken
        self.taskDefinitions = taskDefinitions
    }
}

struct ListWirelessGatewayTaskDefinitionsOutputResponseBody: Equatable {
    public let nextToken: String?
    public let taskDefinitions: [UpdateWirelessGatewayTaskEntry]?
}

extension ListWirelessGatewayTaskDefinitionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case taskDefinitions = "TaskDefinitions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let taskDefinitionsContainer = try containerValues.decodeIfPresent([UpdateWirelessGatewayTaskEntry?].self, forKey: .taskDefinitions)
        var taskDefinitionsDecoded0:[UpdateWirelessGatewayTaskEntry]? = nil
        if let taskDefinitionsContainer = taskDefinitionsContainer {
            taskDefinitionsDecoded0 = [UpdateWirelessGatewayTaskEntry]()
            for structure0 in taskDefinitionsContainer {
                if let structure0 = structure0 {
                    taskDefinitionsDecoded0?.append(structure0)
                }
            }
        }
        taskDefinitions = taskDefinitionsDecoded0
    }
}

extension ListWirelessGatewaysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWirelessGatewaysInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListWirelessGatewaysInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListWirelessGatewaysInputHeadersMiddleware: Middleware {
    public let id: String = "ListWirelessGatewaysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWirelessGatewaysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWirelessGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWirelessGatewaysInput>
    public typealias MOutput = OperationOutput<ListWirelessGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWirelessGatewaysOutputError>
}

public struct ListWirelessGatewaysInputQueryItemMiddleware: Middleware {
    public let id: String = "ListWirelessGatewaysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListWirelessGatewaysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListWirelessGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(input.operationInput.maxResults).urlPercentEncoding())
        input.builder.withQueryItem(maxResultsQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListWirelessGatewaysInput>
    public typealias MOutput = OperationOutput<ListWirelessGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListWirelessGatewaysOutputError>
}

public struct ListWirelessGatewaysInput: Equatable {
    /// <p>The maximum number of results to return in this operation.</p>
    public let maxResults: Int
    /// <p>To retrieve the next set of results, the <code>nextToken</code> value from a previous response; otherwise <b>null</b> to receive the first set of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int = 0,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListWirelessGatewaysInputBody: Equatable {
}

extension ListWirelessGatewaysInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListWirelessGatewaysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListWirelessGatewaysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListWirelessGatewaysOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListWirelessGatewaysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListWirelessGatewaysOutputResponse(nextToken: \(String(describing: nextToken)), wirelessGatewayList: \(String(describing: wirelessGatewayList)))"}
}

extension ListWirelessGatewaysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListWirelessGatewaysOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.wirelessGatewayList = output.wirelessGatewayList
        } else {
            self.nextToken = nil
            self.wirelessGatewayList = nil
        }
    }
}

public struct ListWirelessGatewaysOutputResponse: Equatable {
    /// <p>The token to use to get the next set of results, or <b>null</b> if there are no additional results.</p>
    public let nextToken: String?
    /// <p>The ID of the wireless gateway.</p>
    public let wirelessGatewayList: [WirelessGatewayStatistics]?

    public init (
        nextToken: String? = nil,
        wirelessGatewayList: [WirelessGatewayStatistics]? = nil
    )
    {
        self.nextToken = nextToken
        self.wirelessGatewayList = wirelessGatewayList
    }
}

struct ListWirelessGatewaysOutputResponseBody: Equatable {
    public let nextToken: String?
    public let wirelessGatewayList: [WirelessGatewayStatistics]?
}

extension ListWirelessGatewaysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case wirelessGatewayList = "WirelessGatewayList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let wirelessGatewayListContainer = try containerValues.decodeIfPresent([WirelessGatewayStatistics?].self, forKey: .wirelessGatewayList)
        var wirelessGatewayListDecoded0:[WirelessGatewayStatistics]? = nil
        if let wirelessGatewayListContainer = wirelessGatewayListContainer {
            wirelessGatewayListDecoded0 = [WirelessGatewayStatistics]()
            for structure0 in wirelessGatewayListContainer {
                if let structure0 = structure0 {
                    wirelessGatewayListDecoded0?.append(structure0)
                }
            }
        }
        wirelessGatewayList = wirelessGatewayListDecoded0
    }
}

extension LoRaWANDevice: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case abpV1_0_x = "AbpV1_0_x"
        case abpV1_1 = "AbpV1_1"
        case devEui = "DevEui"
        case deviceProfileId = "DeviceProfileId"
        case otaaV1_0_x = "OtaaV1_0_x"
        case otaaV1_1 = "OtaaV1_1"
        case serviceProfileId = "ServiceProfileId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abpV1_0_x = abpV1_0_x {
            try encodeContainer.encode(abpV1_0_x, forKey: .abpV1_0_x)
        }
        if let abpV1_1 = abpV1_1 {
            try encodeContainer.encode(abpV1_1, forKey: .abpV1_1)
        }
        if let devEui = devEui {
            try encodeContainer.encode(devEui, forKey: .devEui)
        }
        if let deviceProfileId = deviceProfileId {
            try encodeContainer.encode(deviceProfileId, forKey: .deviceProfileId)
        }
        if let otaaV1_0_x = otaaV1_0_x {
            try encodeContainer.encode(otaaV1_0_x, forKey: .otaaV1_0_x)
        }
        if let otaaV1_1 = otaaV1_1 {
            try encodeContainer.encode(otaaV1_1, forKey: .otaaV1_1)
        }
        if let serviceProfileId = serviceProfileId {
            try encodeContainer.encode(serviceProfileId, forKey: .serviceProfileId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEuiDecoded = try containerValues.decodeIfPresent(String.self, forKey: .devEui)
        devEui = devEuiDecoded
        let deviceProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceProfileId)
        deviceProfileId = deviceProfileIdDecoded
        let serviceProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceProfileId)
        serviceProfileId = serviceProfileIdDecoded
        let otaaV1_1Decoded = try containerValues.decodeIfPresent(OtaaV1_1.self, forKey: .otaaV1_1)
        otaaV1_1 = otaaV1_1Decoded
        let otaaV1_0_xDecoded = try containerValues.decodeIfPresent(OtaaV1_0_x.self, forKey: .otaaV1_0_x)
        otaaV1_0_x = otaaV1_0_xDecoded
        let abpV1_1Decoded = try containerValues.decodeIfPresent(AbpV1_1.self, forKey: .abpV1_1)
        abpV1_1 = abpV1_1Decoded
        let abpV1_0_xDecoded = try containerValues.decodeIfPresent(AbpV1_0_x.self, forKey: .abpV1_0_x)
        abpV1_0_x = abpV1_0_xDecoded
    }
}

extension LoRaWANDevice: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoRaWANDevice(abpV1_0_x: \(String(describing: abpV1_0_x)), abpV1_1: \(String(describing: abpV1_1)), devEui: \(String(describing: devEui)), deviceProfileId: \(String(describing: deviceProfileId)), otaaV1_0_x: \(String(describing: otaaV1_0_x)), otaaV1_1: \(String(describing: otaaV1_1)), serviceProfileId: \(String(describing: serviceProfileId)))"}
}

/// <p>LoRaWAN object for create functions.</p>
public struct LoRaWANDevice: Equatable {
    /// <p>LoRaWAN object for create APIs</p>
    public let abpV1_0_x: AbpV1_0_x?
    /// <p>ABP device object for create APIs for v1.1</p>
    public let abpV1_1: AbpV1_1?
    /// <p>The DevEUI value.</p>
    public let devEui: String?
    /// <p>The ID of the device profile for the new wireless device.</p>
    public let deviceProfileId: String?
    /// <p>OTAA device object for create APIs for v1.0.x</p>
    public let otaaV1_0_x: OtaaV1_0_x?
    /// <p>OTAA device object for v1.1 for create APIs</p>
    public let otaaV1_1: OtaaV1_1?
    /// <p>The ID of the service profile.</p>
    public let serviceProfileId: String?

    public init (
        abpV1_0_x: AbpV1_0_x? = nil,
        abpV1_1: AbpV1_1? = nil,
        devEui: String? = nil,
        deviceProfileId: String? = nil,
        otaaV1_0_x: OtaaV1_0_x? = nil,
        otaaV1_1: OtaaV1_1? = nil,
        serviceProfileId: String? = nil
    )
    {
        self.abpV1_0_x = abpV1_0_x
        self.abpV1_1 = abpV1_1
        self.devEui = devEui
        self.deviceProfileId = deviceProfileId
        self.otaaV1_0_x = otaaV1_0_x
        self.otaaV1_1 = otaaV1_1
        self.serviceProfileId = serviceProfileId
    }
}

extension LoRaWANDeviceMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataRate = "DataRate"
        case devEui = "DevEui"
        case fPort = "FPort"
        case frequency = "Frequency"
        case gateways = "Gateways"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataRate = dataRate {
            try encodeContainer.encode(dataRate, forKey: .dataRate)
        }
        if let devEui = devEui {
            try encodeContainer.encode(devEui, forKey: .devEui)
        }
        if let fPort = fPort {
            try encodeContainer.encode(fPort, forKey: .fPort)
        }
        if let frequency = frequency {
            try encodeContainer.encode(frequency, forKey: .frequency)
        }
        if let gateways = gateways {
            var gatewaysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .gateways)
            for lorawangatewaymetadatalist0 in gateways {
                try gatewaysContainer.encode(lorawangatewaymetadatalist0)
            }
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEuiDecoded = try containerValues.decodeIfPresent(String.self, forKey: .devEui)
        devEui = devEuiDecoded
        let fPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .fPort)
        fPort = fPortDecoded
        let dataRateDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dataRate)
        dataRate = dataRateDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .frequency)
        frequency = frequencyDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let gatewaysContainer = try containerValues.decodeIfPresent([LoRaWANGatewayMetadata?].self, forKey: .gateways)
        var gatewaysDecoded0:[LoRaWANGatewayMetadata]? = nil
        if let gatewaysContainer = gatewaysContainer {
            gatewaysDecoded0 = [LoRaWANGatewayMetadata]()
            for structure0 in gatewaysContainer {
                if let structure0 = structure0 {
                    gatewaysDecoded0?.append(structure0)
                }
            }
        }
        gateways = gatewaysDecoded0
    }
}

extension LoRaWANDeviceMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoRaWANDeviceMetadata(dataRate: \(String(describing: dataRate)), devEui: \(String(describing: devEui)), fPort: \(String(describing: fPort)), frequency: \(String(describing: frequency)), gateways: \(String(describing: gateways)), timestamp: \(String(describing: timestamp)))"}
}

/// <p>LoRaWAN device metatdata.</p>
public struct LoRaWANDeviceMetadata: Equatable {
    /// <p>The DataRate value.</p>
    public let dataRate: Int?
    /// <p>The DevEUI value.</p>
    public let devEui: String?
    /// <p>The FPort value.</p>
    public let fPort: Int?
    /// <p>The device's channel frequency in Hz.</p>
    public let frequency: Int?
    /// <p>Information about the gateways accessed by the device.</p>
    public let gateways: [LoRaWANGatewayMetadata]?
    /// <p>The date and time of the metadata.</p>
    public let timestamp: String?

    public init (
        dataRate: Int? = nil,
        devEui: String? = nil,
        fPort: Int? = nil,
        frequency: Int? = nil,
        gateways: [LoRaWANGatewayMetadata]? = nil,
        timestamp: String? = nil
    )
    {
        self.dataRate = dataRate
        self.devEui = devEui
        self.fPort = fPort
        self.frequency = frequency
        self.gateways = gateways
        self.timestamp = timestamp
    }
}

extension LoRaWANDeviceProfile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case classBTimeout = "ClassBTimeout"
        case classCTimeout = "ClassCTimeout"
        case factoryPresetFreqsList = "FactoryPresetFreqsList"
        case macVersion = "MacVersion"
        case maxDutyCycle = "MaxDutyCycle"
        case maxEirp = "MaxEirp"
        case pingSlotDr = "PingSlotDr"
        case pingSlotFreq = "PingSlotFreq"
        case pingSlotPeriod = "PingSlotPeriod"
        case regParamsRevision = "RegParamsRevision"
        case rfRegion = "RfRegion"
        case rxDataRate2 = "RxDataRate2"
        case rxDelay1 = "RxDelay1"
        case rxDrOffset1 = "RxDrOffset1"
        case rxFreq2 = "RxFreq2"
        case supports32BitFCnt = "Supports32BitFCnt"
        case supportsClassB = "SupportsClassB"
        case supportsClassC = "SupportsClassC"
        case supportsJoin = "SupportsJoin"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let classBTimeout = classBTimeout {
            try encodeContainer.encode(classBTimeout, forKey: .classBTimeout)
        }
        if let classCTimeout = classCTimeout {
            try encodeContainer.encode(classCTimeout, forKey: .classCTimeout)
        }
        if let factoryPresetFreqsList = factoryPresetFreqsList {
            var factoryPresetFreqsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .factoryPresetFreqsList)
            for factorypresetfreqslist0 in factoryPresetFreqsList {
                try factoryPresetFreqsListContainer.encode(factorypresetfreqslist0)
            }
        }
        if let macVersion = macVersion {
            try encodeContainer.encode(macVersion, forKey: .macVersion)
        }
        if let maxDutyCycle = maxDutyCycle {
            try encodeContainer.encode(maxDutyCycle, forKey: .maxDutyCycle)
        }
        if let maxEirp = maxEirp {
            try encodeContainer.encode(maxEirp, forKey: .maxEirp)
        }
        if let pingSlotDr = pingSlotDr {
            try encodeContainer.encode(pingSlotDr, forKey: .pingSlotDr)
        }
        if let pingSlotFreq = pingSlotFreq {
            try encodeContainer.encode(pingSlotFreq, forKey: .pingSlotFreq)
        }
        if let pingSlotPeriod = pingSlotPeriod {
            try encodeContainer.encode(pingSlotPeriod, forKey: .pingSlotPeriod)
        }
        if let regParamsRevision = regParamsRevision {
            try encodeContainer.encode(regParamsRevision, forKey: .regParamsRevision)
        }
        if let rfRegion = rfRegion {
            try encodeContainer.encode(rfRegion, forKey: .rfRegion)
        }
        if let rxDataRate2 = rxDataRate2 {
            try encodeContainer.encode(rxDataRate2, forKey: .rxDataRate2)
        }
        if let rxDelay1 = rxDelay1 {
            try encodeContainer.encode(rxDelay1, forKey: .rxDelay1)
        }
        if let rxDrOffset1 = rxDrOffset1 {
            try encodeContainer.encode(rxDrOffset1, forKey: .rxDrOffset1)
        }
        if let rxFreq2 = rxFreq2 {
            try encodeContainer.encode(rxFreq2, forKey: .rxFreq2)
        }
        if supports32BitFCnt != false {
            try encodeContainer.encode(supports32BitFCnt, forKey: .supports32BitFCnt)
        }
        if supportsClassB != false {
            try encodeContainer.encode(supportsClassB, forKey: .supportsClassB)
        }
        if supportsClassC != false {
            try encodeContainer.encode(supportsClassC, forKey: .supportsClassC)
        }
        if let supportsJoin = supportsJoin {
            try encodeContainer.encode(supportsJoin, forKey: .supportsJoin)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let supportsClassBDecoded = try containerValues.decode(Bool.self, forKey: .supportsClassB)
        supportsClassB = supportsClassBDecoded
        let classBTimeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .classBTimeout)
        classBTimeout = classBTimeoutDecoded
        let pingSlotPeriodDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .pingSlotPeriod)
        pingSlotPeriod = pingSlotPeriodDecoded
        let pingSlotDrDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .pingSlotDr)
        pingSlotDr = pingSlotDrDecoded
        let pingSlotFreqDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .pingSlotFreq)
        pingSlotFreq = pingSlotFreqDecoded
        let supportsClassCDecoded = try containerValues.decode(Bool.self, forKey: .supportsClassC)
        supportsClassC = supportsClassCDecoded
        let classCTimeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .classCTimeout)
        classCTimeout = classCTimeoutDecoded
        let macVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .macVersion)
        macVersion = macVersionDecoded
        let regParamsRevisionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regParamsRevision)
        regParamsRevision = regParamsRevisionDecoded
        let rxDelay1Decoded = try containerValues.decodeIfPresent(Int.self, forKey: .rxDelay1)
        rxDelay1 = rxDelay1Decoded
        let rxDrOffset1Decoded = try containerValues.decodeIfPresent(Int.self, forKey: .rxDrOffset1)
        rxDrOffset1 = rxDrOffset1Decoded
        let rxDataRate2Decoded = try containerValues.decodeIfPresent(Int.self, forKey: .rxDataRate2)
        rxDataRate2 = rxDataRate2Decoded
        let rxFreq2Decoded = try containerValues.decodeIfPresent(Int.self, forKey: .rxFreq2)
        rxFreq2 = rxFreq2Decoded
        let factoryPresetFreqsListContainer = try containerValues.decodeIfPresent([Int?].self, forKey: .factoryPresetFreqsList)
        var factoryPresetFreqsListDecoded0:[Int]? = nil
        if let factoryPresetFreqsListContainer = factoryPresetFreqsListContainer {
            factoryPresetFreqsListDecoded0 = [Int]()
            for integer0 in factoryPresetFreqsListContainer {
                if let integer0 = integer0 {
                    factoryPresetFreqsListDecoded0?.append(integer0)
                }
            }
        }
        factoryPresetFreqsList = factoryPresetFreqsListDecoded0
        let maxEirpDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxEirp)
        maxEirp = maxEirpDecoded
        let maxDutyCycleDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxDutyCycle)
        maxDutyCycle = maxDutyCycleDecoded
        let rfRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
        let supportsJoinDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .supportsJoin)
        supportsJoin = supportsJoinDecoded
        let supports32BitFCntDecoded = try containerValues.decode(Bool.self, forKey: .supports32BitFCnt)
        supports32BitFCnt = supports32BitFCntDecoded
    }
}

extension LoRaWANDeviceProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoRaWANDeviceProfile(classBTimeout: \(String(describing: classBTimeout)), classCTimeout: \(String(describing: classCTimeout)), factoryPresetFreqsList: \(String(describing: factoryPresetFreqsList)), macVersion: \(String(describing: macVersion)), maxDutyCycle: \(String(describing: maxDutyCycle)), maxEirp: \(String(describing: maxEirp)), pingSlotDr: \(String(describing: pingSlotDr)), pingSlotFreq: \(String(describing: pingSlotFreq)), pingSlotPeriod: \(String(describing: pingSlotPeriod)), regParamsRevision: \(String(describing: regParamsRevision)), rfRegion: \(String(describing: rfRegion)), rxDataRate2: \(String(describing: rxDataRate2)), rxDelay1: \(String(describing: rxDelay1)), rxDrOffset1: \(String(describing: rxDrOffset1)), rxFreq2: \(String(describing: rxFreq2)), supports32BitFCnt: \(String(describing: supports32BitFCnt)), supportsClassB: \(String(describing: supportsClassB)), supportsClassC: \(String(describing: supportsClassC)), supportsJoin: \(String(describing: supportsJoin)))"}
}

/// <p>LoRaWANDeviceProfile object.</p>
public struct LoRaWANDeviceProfile: Equatable {
    /// <p>The ClassBTimeout value.</p>
    public let classBTimeout: Int?
    /// <p>The ClassCTimeout value.</p>
    public let classCTimeout: Int?
    /// <p>The list of values that make up the FactoryPresetFreqs value.</p>
    public let factoryPresetFreqsList: [Int]?
    /// <p>The MAC version (such as OTAA 1.1 or OTAA 1.0.3) to use with this device profile.</p>
    public let macVersion: String?
    /// <p>The MaxDutyCycle value.</p>
    public let maxDutyCycle: Int?
    /// <p>The MaxEIRP value.</p>
    public let maxEirp: Int?
    /// <p>The PingSlotDR value.</p>
    public let pingSlotDr: Int?
    /// <p>The PingSlotFreq value.</p>
    public let pingSlotFreq: Int?
    /// <p>The PingSlotPeriod value.</p>
    public let pingSlotPeriod: Int?
    /// <p>The version of regional parameters.</p>
    public let regParamsRevision: String?
    /// <p>The frequency band (RFRegion) value.</p>
    public let rfRegion: String?
    /// <p>The RXDataRate2 value.</p>
    public let rxDataRate2: Int?
    /// <p>The RXDelay1 value.</p>
    public let rxDelay1: Int?
    /// <p>The RXDROffset1 value.</p>
    public let rxDrOffset1: Int?
    /// <p>The RXFreq2 value.</p>
    public let rxFreq2: Int?
    /// <p>The Supports32BitFCnt value.</p>
    public let supports32BitFCnt: Bool
    /// <p>The SupportsClassB value.</p>
    public let supportsClassB: Bool
    /// <p>The SupportsClassC value.</p>
    public let supportsClassC: Bool
    /// <p>The SupportsJoin value.</p>
    public let supportsJoin: Bool?

    public init (
        classBTimeout: Int? = nil,
        classCTimeout: Int? = nil,
        factoryPresetFreqsList: [Int]? = nil,
        macVersion: String? = nil,
        maxDutyCycle: Int? = nil,
        maxEirp: Int? = nil,
        pingSlotDr: Int? = nil,
        pingSlotFreq: Int? = nil,
        pingSlotPeriod: Int? = nil,
        regParamsRevision: String? = nil,
        rfRegion: String? = nil,
        rxDataRate2: Int? = nil,
        rxDelay1: Int? = nil,
        rxDrOffset1: Int? = nil,
        rxFreq2: Int? = nil,
        supports32BitFCnt: Bool = false,
        supportsClassB: Bool = false,
        supportsClassC: Bool = false,
        supportsJoin: Bool? = nil
    )
    {
        self.classBTimeout = classBTimeout
        self.classCTimeout = classCTimeout
        self.factoryPresetFreqsList = factoryPresetFreqsList
        self.macVersion = macVersion
        self.maxDutyCycle = maxDutyCycle
        self.maxEirp = maxEirp
        self.pingSlotDr = pingSlotDr
        self.pingSlotFreq = pingSlotFreq
        self.pingSlotPeriod = pingSlotPeriod
        self.regParamsRevision = regParamsRevision
        self.rfRegion = rfRegion
        self.rxDataRate2 = rxDataRate2
        self.rxDelay1 = rxDelay1
        self.rxDrOffset1 = rxDrOffset1
        self.rxFreq2 = rxFreq2
        self.supports32BitFCnt = supports32BitFCnt
        self.supportsClassB = supportsClassB
        self.supportsClassC = supportsClassC
        self.supportsJoin = supportsJoin
    }
}

extension LoRaWANGateway: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayEui = "GatewayEui"
        case joinEuiFilters = "JoinEuiFilters"
        case netIdFilters = "NetIdFilters"
        case rfRegion = "RfRegion"
        case subBands = "SubBands"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayEui = gatewayEui {
            try encodeContainer.encode(gatewayEui, forKey: .gatewayEui)
        }
        if let joinEuiFilters = joinEuiFilters {
            var joinEuiFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .joinEuiFilters)
            for joineuifilters0 in joinEuiFilters {
                var joineuifilters0Container = joinEuiFiltersContainer.nestedUnkeyedContainer()
                for joineuirange1 in joineuifilters0 {
                    try joineuifilters0Container.encode(joineuirange1)
                }
            }
        }
        if let netIdFilters = netIdFilters {
            var netIdFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .netIdFilters)
            for netidfilters0 in netIdFilters {
                try netIdFiltersContainer.encode(netidfilters0)
            }
        }
        if let rfRegion = rfRegion {
            try encodeContainer.encode(rfRegion, forKey: .rfRegion)
        }
        if let subBands = subBands {
            var subBandsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subBands)
            for subbands0 in subBands {
                try subBandsContainer.encode(subbands0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayEuiDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayEui)
        gatewayEui = gatewayEuiDecoded
        let rfRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rfRegion)
        rfRegion = rfRegionDecoded
        let joinEuiFiltersContainer = try containerValues.decodeIfPresent([[String?]?].self, forKey: .joinEuiFilters)
        var joinEuiFiltersDecoded0:[[String]]? = nil
        if let joinEuiFiltersContainer = joinEuiFiltersContainer {
            joinEuiFiltersDecoded0 = [[String]]()
            for list0 in joinEuiFiltersContainer {
                var list0Decoded0: [String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    joinEuiFiltersDecoded0?.append(list0Decoded0)
                }
            }
        }
        joinEuiFilters = joinEuiFiltersDecoded0
        let netIdFiltersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .netIdFilters)
        var netIdFiltersDecoded0:[String]? = nil
        if let netIdFiltersContainer = netIdFiltersContainer {
            netIdFiltersDecoded0 = [String]()
            for string0 in netIdFiltersContainer {
                if let string0 = string0 {
                    netIdFiltersDecoded0?.append(string0)
                }
            }
        }
        netIdFilters = netIdFiltersDecoded0
        let subBandsContainer = try containerValues.decodeIfPresent([Int?].self, forKey: .subBands)
        var subBandsDecoded0:[Int]? = nil
        if let subBandsContainer = subBandsContainer {
            subBandsDecoded0 = [Int]()
            for integer0 in subBandsContainer {
                if let integer0 = integer0 {
                    subBandsDecoded0?.append(integer0)
                }
            }
        }
        subBands = subBandsDecoded0
    }
}

extension LoRaWANGateway: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoRaWANGateway(gatewayEui: \(String(describing: gatewayEui)), joinEuiFilters: \(String(describing: joinEuiFilters)), netIdFilters: \(String(describing: netIdFilters)), rfRegion: \(String(describing: rfRegion)), subBands: \(String(describing: subBands)))"}
}

/// <p>LoRaWANGateway object.</p>
public struct LoRaWANGateway: Equatable {
    /// <p>The gateway's EUI value.</p>
    public let gatewayEui: String?
    /// <p>A list of JoinEuiRange used by LoRa gateways to filter LoRa frames.</p>
    public let joinEuiFilters: [[String]]?
    /// <p>A list of NetId values that are used by LoRa gateways to filter the uplink frames.</p>
    public let netIdFilters: [String]?
    /// <p>The frequency band (RFRegion) value.</p>
    public let rfRegion: String?
    /// <p>A list of integer indicating which sub bands are supported by LoRa gateway.</p>
    public let subBands: [Int]?

    public init (
        gatewayEui: String? = nil,
        joinEuiFilters: [[String]]? = nil,
        netIdFilters: [String]? = nil,
        rfRegion: String? = nil,
        subBands: [Int]? = nil
    )
    {
        self.gatewayEui = gatewayEui
        self.joinEuiFilters = joinEuiFilters
        self.netIdFilters = netIdFilters
        self.rfRegion = rfRegion
        self.subBands = subBands
    }
}

extension LoRaWANGatewayCurrentVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentVersion = "CurrentVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(LoRaWANGatewayVersion.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
    }
}

extension LoRaWANGatewayCurrentVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoRaWANGatewayCurrentVersion(currentVersion: \(String(describing: currentVersion)))"}
}

/// <p>LoRaWANGatewayCurrentVersion object.</p>
public struct LoRaWANGatewayCurrentVersion: Equatable {
    /// <p>The version of the gateways that should receive the update.</p>
    public let currentVersion: LoRaWANGatewayVersion?

    public init (
        currentVersion: LoRaWANGatewayVersion? = nil
    )
    {
        self.currentVersion = currentVersion
    }
}

extension LoRaWANGatewayMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayEui = "GatewayEui"
        case rssi = "Rssi"
        case snr = "Snr"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayEui = gatewayEui {
            try encodeContainer.encode(gatewayEui, forKey: .gatewayEui)
        }
        if let rssi = rssi {
            try encodeContainer.encode(rssi, forKey: .rssi)
        }
        if let snr = snr {
            try encodeContainer.encode(snr, forKey: .snr)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayEuiDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayEui)
        gatewayEui = gatewayEuiDecoded
        let snrDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .snr)
        snr = snrDecoded
        let rssiDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .rssi)
        rssi = rssiDecoded
    }
}

extension LoRaWANGatewayMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoRaWANGatewayMetadata(gatewayEui: \(String(describing: gatewayEui)), rssi: \(String(describing: rssi)), snr: \(String(describing: snr)))"}
}

/// <p>LoRaWAN gateway metatdata.</p>
public struct LoRaWANGatewayMetadata: Equatable {
    /// <p>The gateway's EUI value.</p>
    public let gatewayEui: String?
    /// <p>The RSSI value.</p>
    public let rssi: Double?
    /// <p>The SNR value.</p>
    public let snr: Double?

    public init (
        gatewayEui: String? = nil,
        rssi: Double? = nil,
        snr: Double? = nil
    )
    {
        self.gatewayEui = gatewayEui
        self.rssi = rssi
        self.snr = snr
    }
}

extension LoRaWANGatewayVersion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case model = "Model"
        case packageVersion = "PackageVersion"
        case station = "Station"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let model = model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let packageVersion = packageVersion {
            try encodeContainer.encode(packageVersion, forKey: .packageVersion)
        }
        if let station = station {
            try encodeContainer.encode(station, forKey: .station)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let packageVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .packageVersion)
        packageVersion = packageVersionDecoded
        let modelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .model)
        model = modelDecoded
        let stationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .station)
        station = stationDecoded
    }
}

extension LoRaWANGatewayVersion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoRaWANGatewayVersion(model: \(String(describing: model)), packageVersion: \(String(describing: packageVersion)), station: \(String(describing: station)))"}
}

/// <p>LoRaWANGatewayVersion object.</p>
public struct LoRaWANGatewayVersion: Equatable {
    /// <p>The model number of the wireless gateway.</p>
    public let model: String?
    /// <p>The version of the wireless gateway firmware.</p>
    public let packageVersion: String?
    /// <p>The basic station version of the wireless gateway.</p>
    public let station: String?

    public init (
        model: String? = nil,
        packageVersion: String? = nil,
        station: String? = nil
    )
    {
        self.model = model
        self.packageVersion = packageVersion
        self.station = station
    }
}

extension LoRaWANGetServiceProfileInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addGwMetadata = "AddGwMetadata"
        case channelMask = "ChannelMask"
        case devStatusReqFreq = "DevStatusReqFreq"
        case dlBucketSize = "DlBucketSize"
        case dlRate = "DlRate"
        case dlRatePolicy = "DlRatePolicy"
        case drMax = "DrMax"
        case drMin = "DrMin"
        case hrAllowed = "HrAllowed"
        case minGwDiversity = "MinGwDiversity"
        case nwkGeoLoc = "NwkGeoLoc"
        case prAllowed = "PrAllowed"
        case raAllowed = "RaAllowed"
        case reportDevStatusBattery = "ReportDevStatusBattery"
        case reportDevStatusMargin = "ReportDevStatusMargin"
        case targetPer = "TargetPer"
        case ulBucketSize = "UlBucketSize"
        case ulRate = "UlRate"
        case ulRatePolicy = "UlRatePolicy"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if addGwMetadata != false {
            try encodeContainer.encode(addGwMetadata, forKey: .addGwMetadata)
        }
        if let channelMask = channelMask {
            try encodeContainer.encode(channelMask, forKey: .channelMask)
        }
        if let devStatusReqFreq = devStatusReqFreq {
            try encodeContainer.encode(devStatusReqFreq, forKey: .devStatusReqFreq)
        }
        if let dlBucketSize = dlBucketSize {
            try encodeContainer.encode(dlBucketSize, forKey: .dlBucketSize)
        }
        if let dlRate = dlRate {
            try encodeContainer.encode(dlRate, forKey: .dlRate)
        }
        if let dlRatePolicy = dlRatePolicy {
            try encodeContainer.encode(dlRatePolicy, forKey: .dlRatePolicy)
        }
        if drMax != 0 {
            try encodeContainer.encode(drMax, forKey: .drMax)
        }
        if drMin != 0 {
            try encodeContainer.encode(drMin, forKey: .drMin)
        }
        if hrAllowed != false {
            try encodeContainer.encode(hrAllowed, forKey: .hrAllowed)
        }
        if let minGwDiversity = minGwDiversity {
            try encodeContainer.encode(minGwDiversity, forKey: .minGwDiversity)
        }
        if nwkGeoLoc != false {
            try encodeContainer.encode(nwkGeoLoc, forKey: .nwkGeoLoc)
        }
        if prAllowed != false {
            try encodeContainer.encode(prAllowed, forKey: .prAllowed)
        }
        if raAllowed != false {
            try encodeContainer.encode(raAllowed, forKey: .raAllowed)
        }
        if reportDevStatusBattery != false {
            try encodeContainer.encode(reportDevStatusBattery, forKey: .reportDevStatusBattery)
        }
        if reportDevStatusMargin != false {
            try encodeContainer.encode(reportDevStatusMargin, forKey: .reportDevStatusMargin)
        }
        if targetPer != 0 {
            try encodeContainer.encode(targetPer, forKey: .targetPer)
        }
        if let ulBucketSize = ulBucketSize {
            try encodeContainer.encode(ulBucketSize, forKey: .ulBucketSize)
        }
        if let ulRate = ulRate {
            try encodeContainer.encode(ulRate, forKey: .ulRate)
        }
        if let ulRatePolicy = ulRatePolicy {
            try encodeContainer.encode(ulRatePolicy, forKey: .ulRatePolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ulRateDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .ulRate)
        ulRate = ulRateDecoded
        let ulBucketSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .ulBucketSize)
        ulBucketSize = ulBucketSizeDecoded
        let ulRatePolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ulRatePolicy)
        ulRatePolicy = ulRatePolicyDecoded
        let dlRateDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dlRate)
        dlRate = dlRateDecoded
        let dlBucketSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dlBucketSize)
        dlBucketSize = dlBucketSizeDecoded
        let dlRatePolicyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dlRatePolicy)
        dlRatePolicy = dlRatePolicyDecoded
        let addGwMetadataDecoded = try containerValues.decode(Bool.self, forKey: .addGwMetadata)
        addGwMetadata = addGwMetadataDecoded
        let devStatusReqFreqDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .devStatusReqFreq)
        devStatusReqFreq = devStatusReqFreqDecoded
        let reportDevStatusBatteryDecoded = try containerValues.decode(Bool.self, forKey: .reportDevStatusBattery)
        reportDevStatusBattery = reportDevStatusBatteryDecoded
        let reportDevStatusMarginDecoded = try containerValues.decode(Bool.self, forKey: .reportDevStatusMargin)
        reportDevStatusMargin = reportDevStatusMarginDecoded
        let drMinDecoded = try containerValues.decode(Int.self, forKey: .drMin)
        drMin = drMinDecoded
        let drMaxDecoded = try containerValues.decode(Int.self, forKey: .drMax)
        drMax = drMaxDecoded
        let channelMaskDecoded = try containerValues.decodeIfPresent(String.self, forKey: .channelMask)
        channelMask = channelMaskDecoded
        let prAllowedDecoded = try containerValues.decode(Bool.self, forKey: .prAllowed)
        prAllowed = prAllowedDecoded
        let hrAllowedDecoded = try containerValues.decode(Bool.self, forKey: .hrAllowed)
        hrAllowed = hrAllowedDecoded
        let raAllowedDecoded = try containerValues.decode(Bool.self, forKey: .raAllowed)
        raAllowed = raAllowedDecoded
        let nwkGeoLocDecoded = try containerValues.decode(Bool.self, forKey: .nwkGeoLoc)
        nwkGeoLoc = nwkGeoLocDecoded
        let targetPerDecoded = try containerValues.decode(Int.self, forKey: .targetPer)
        targetPer = targetPerDecoded
        let minGwDiversityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .minGwDiversity)
        minGwDiversity = minGwDiversityDecoded
    }
}

extension LoRaWANGetServiceProfileInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoRaWANGetServiceProfileInfo(addGwMetadata: \(String(describing: addGwMetadata)), channelMask: \(String(describing: channelMask)), devStatusReqFreq: \(String(describing: devStatusReqFreq)), dlBucketSize: \(String(describing: dlBucketSize)), dlRate: \(String(describing: dlRate)), dlRatePolicy: \(String(describing: dlRatePolicy)), drMax: \(String(describing: drMax)), drMin: \(String(describing: drMin)), hrAllowed: \(String(describing: hrAllowed)), minGwDiversity: \(String(describing: minGwDiversity)), nwkGeoLoc: \(String(describing: nwkGeoLoc)), prAllowed: \(String(describing: prAllowed)), raAllowed: \(String(describing: raAllowed)), reportDevStatusBattery: \(String(describing: reportDevStatusBattery)), reportDevStatusMargin: \(String(describing: reportDevStatusMargin)), targetPer: \(String(describing: targetPer)), ulBucketSize: \(String(describing: ulBucketSize)), ulRate: \(String(describing: ulRate)), ulRatePolicy: \(String(describing: ulRatePolicy)))"}
}

/// <p>LoRaWANGetServiceProfileInfo object.</p>
public struct LoRaWANGetServiceProfileInfo: Equatable {
    /// <p>The AddGWMetaData value.</p>
    public let addGwMetadata: Bool
    /// <p>The ChannelMask value.</p>
    public let channelMask: String?
    /// <p>The DevStatusReqFreq value.</p>
    public let devStatusReqFreq: Int?
    /// <p>The DLBucketSize value.</p>
    public let dlBucketSize: Int?
    /// <p>The DLRate value.</p>
    public let dlRate: Int?
    /// <p>The DLRatePolicy value.</p>
    public let dlRatePolicy: String?
    /// <p>The DRMax value.</p>
    public let drMax: Int
    /// <p>The DRMin value.</p>
    public let drMin: Int
    /// <p>The HRAllowed value that describes whether handover roaming is allowed.</p>
    public let hrAllowed: Bool
    /// <p>The MinGwDiversity value.</p>
    public let minGwDiversity: Int?
    /// <p>The NwkGeoLoc value.</p>
    public let nwkGeoLoc: Bool
    /// <p>The PRAllowed value that describes whether passive roaming is allowed.</p>
    public let prAllowed: Bool
    /// <p>The RAAllowed value that describes whether roaming activation is allowed.</p>
    public let raAllowed: Bool
    /// <p>The ReportDevStatusBattery value.</p>
    public let reportDevStatusBattery: Bool
    /// <p>The ReportDevStatusMargin value.</p>
    public let reportDevStatusMargin: Bool
    /// <p>The TargetPER value.</p>
    public let targetPer: Int
    /// <p>The ULBucketSize value.</p>
    public let ulBucketSize: Int?
    /// <p>The ULRate value.</p>
    public let ulRate: Int?
    /// <p>The ULRatePolicy value.</p>
    public let ulRatePolicy: String?

    public init (
        addGwMetadata: Bool = false,
        channelMask: String? = nil,
        devStatusReqFreq: Int? = nil,
        dlBucketSize: Int? = nil,
        dlRate: Int? = nil,
        dlRatePolicy: String? = nil,
        drMax: Int = 0,
        drMin: Int = 0,
        hrAllowed: Bool = false,
        minGwDiversity: Int? = nil,
        nwkGeoLoc: Bool = false,
        prAllowed: Bool = false,
        raAllowed: Bool = false,
        reportDevStatusBattery: Bool = false,
        reportDevStatusMargin: Bool = false,
        targetPer: Int = 0,
        ulBucketSize: Int? = nil,
        ulRate: Int? = nil,
        ulRatePolicy: String? = nil
    )
    {
        self.addGwMetadata = addGwMetadata
        self.channelMask = channelMask
        self.devStatusReqFreq = devStatusReqFreq
        self.dlBucketSize = dlBucketSize
        self.dlRate = dlRate
        self.dlRatePolicy = dlRatePolicy
        self.drMax = drMax
        self.drMin = drMin
        self.hrAllowed = hrAllowed
        self.minGwDiversity = minGwDiversity
        self.nwkGeoLoc = nwkGeoLoc
        self.prAllowed = prAllowed
        self.raAllowed = raAllowed
        self.reportDevStatusBattery = reportDevStatusBattery
        self.reportDevStatusMargin = reportDevStatusMargin
        self.targetPer = targetPer
        self.ulBucketSize = ulBucketSize
        self.ulRate = ulRate
        self.ulRatePolicy = ulRatePolicy
    }
}

extension LoRaWANListDevice: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case devEui = "DevEui"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devEui = devEui {
            try encodeContainer.encode(devEui, forKey: .devEui)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devEuiDecoded = try containerValues.decodeIfPresent(String.self, forKey: .devEui)
        devEui = devEuiDecoded
    }
}

extension LoRaWANListDevice: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoRaWANListDevice(devEui: \(String(describing: devEui)))"}
}

/// <p>LoRaWAN object for list functions.</p>
public struct LoRaWANListDevice: Equatable {
    /// <p>The DevEUI value.</p>
    public let devEui: String?

    public init (
        devEui: String? = nil
    )
    {
        self.devEui = devEui
    }
}

extension LoRaWANSendDataToDevice: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fPort = "FPort"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fPort = fPort {
            try encodeContainer.encode(fPort, forKey: .fPort)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fPortDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .fPort)
        fPort = fPortDecoded
    }
}

extension LoRaWANSendDataToDevice: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoRaWANSendDataToDevice(fPort: \(String(describing: fPort)))"}
}

/// <p>LoRaWAN router info.</p>
public struct LoRaWANSendDataToDevice: Equatable {
    /// <p>The Fport value.</p>
    public let fPort: Int?

    public init (
        fPort: Int? = nil
    )
    {
        self.fPort = fPort
    }
}

extension LoRaWANServiceProfile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addGwMetadata = "AddGwMetadata"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if addGwMetadata != false {
            try encodeContainer.encode(addGwMetadata, forKey: .addGwMetadata)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addGwMetadataDecoded = try containerValues.decode(Bool.self, forKey: .addGwMetadata)
        addGwMetadata = addGwMetadataDecoded
    }
}

extension LoRaWANServiceProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoRaWANServiceProfile(addGwMetadata: \(String(describing: addGwMetadata)))"}
}

/// <p>LoRaWANServiceProfile object.</p>
public struct LoRaWANServiceProfile: Equatable {
    /// <p>The AddGWMetaData value.</p>
    public let addGwMetadata: Bool

    public init (
        addGwMetadata: Bool = false
    )
    {
        self.addGwMetadata = addGwMetadata
    }
}

extension LoRaWANUpdateDevice: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceProfileId = "DeviceProfileId"
        case serviceProfileId = "ServiceProfileId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceProfileId = deviceProfileId {
            try encodeContainer.encode(deviceProfileId, forKey: .deviceProfileId)
        }
        if let serviceProfileId = serviceProfileId {
            try encodeContainer.encode(serviceProfileId, forKey: .serviceProfileId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceProfileId)
        deviceProfileId = deviceProfileIdDecoded
        let serviceProfileIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceProfileId)
        serviceProfileId = serviceProfileIdDecoded
    }
}

extension LoRaWANUpdateDevice: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoRaWANUpdateDevice(deviceProfileId: \(String(describing: deviceProfileId)), serviceProfileId: \(String(describing: serviceProfileId)))"}
}

/// <p>LoRaWAN object for update functions.</p>
public struct LoRaWANUpdateDevice: Equatable {
    /// <p>The ID of the device profile for the wireless device.</p>
    public let deviceProfileId: String?
    /// <p>The ID of the service profile.</p>
    public let serviceProfileId: String?

    public init (
        deviceProfileId: String? = nil,
        serviceProfileId: String? = nil
    )
    {
        self.deviceProfileId = deviceProfileId
        self.serviceProfileId = serviceProfileId
    }
}

extension LoRaWANUpdateGatewayTaskCreate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentVersion = "CurrentVersion"
        case sigKeyCrc = "SigKeyCrc"
        case updateSignature = "UpdateSignature"
        case updateVersion = "UpdateVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let sigKeyCrc = sigKeyCrc {
            try encodeContainer.encode(sigKeyCrc, forKey: .sigKeyCrc)
        }
        if let updateSignature = updateSignature {
            try encodeContainer.encode(updateSignature, forKey: .updateSignature)
        }
        if let updateVersion = updateVersion {
            try encodeContainer.encode(updateVersion, forKey: .updateVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateSignatureDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateSignature)
        updateSignature = updateSignatureDecoded
        let sigKeyCrcDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .sigKeyCrc)
        sigKeyCrc = sigKeyCrcDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(LoRaWANGatewayVersion.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let updateVersionDecoded = try containerValues.decodeIfPresent(LoRaWANGatewayVersion.self, forKey: .updateVersion)
        updateVersion = updateVersionDecoded
    }
}

extension LoRaWANUpdateGatewayTaskCreate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoRaWANUpdateGatewayTaskCreate(currentVersion: \(String(describing: currentVersion)), sigKeyCrc: \(String(describing: sigKeyCrc)), updateSignature: \(String(describing: updateSignature)), updateVersion: \(String(describing: updateVersion)))"}
}

/// <p>LoRaWANUpdateGatewayTaskCreate object.</p>
public struct LoRaWANUpdateGatewayTaskCreate: Equatable {
    /// <p>The version of the gateways that should receive the update.</p>
    public let currentVersion: LoRaWANGatewayVersion?
    /// <p>The CRC of the signature private key to check.</p>
    public let sigKeyCrc: Int?
    /// <p>The signature used to verify the update firmware.</p>
    public let updateSignature: String?
    /// <p>The firmware version to update the gateway to.</p>
    public let updateVersion: LoRaWANGatewayVersion?

    public init (
        currentVersion: LoRaWANGatewayVersion? = nil,
        sigKeyCrc: Int? = nil,
        updateSignature: String? = nil,
        updateVersion: LoRaWANGatewayVersion? = nil
    )
    {
        self.currentVersion = currentVersion
        self.sigKeyCrc = sigKeyCrc
        self.updateSignature = updateSignature
        self.updateVersion = updateVersion
    }
}

extension LoRaWANUpdateGatewayTaskEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case currentVersion = "CurrentVersion"
        case updateVersion = "UpdateVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let updateVersion = updateVersion {
            try encodeContainer.encode(updateVersion, forKey: .updateVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let currentVersionDecoded = try containerValues.decodeIfPresent(LoRaWANGatewayVersion.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let updateVersionDecoded = try containerValues.decodeIfPresent(LoRaWANGatewayVersion.self, forKey: .updateVersion)
        updateVersion = updateVersionDecoded
    }
}

extension LoRaWANUpdateGatewayTaskEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LoRaWANUpdateGatewayTaskEntry(currentVersion: \(String(describing: currentVersion)), updateVersion: \(String(describing: updateVersion)))"}
}

/// <p>LoRaWANUpdateGatewayTaskEntry object.</p>
public struct LoRaWANUpdateGatewayTaskEntry: Equatable {
    /// <p>The version of the gateways that should receive the update.</p>
    public let currentVersion: LoRaWANGatewayVersion?
    /// <p>The firmware version to update the gateway to.</p>
    public let updateVersion: LoRaWANGatewayVersion?

    public init (
        currentVersion: LoRaWANGatewayVersion? = nil,
        updateVersion: LoRaWANGatewayVersion? = nil
    )
    {
        self.currentVersion = currentVersion
        self.updateVersion = updateVersion
    }
}

/// <p>The log level for a log message.</p>
public enum LogLevel {
    case disabled
    case error
    case info
    case sdkUnknown(String)
}

extension LogLevel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LogLevel] {
        return [
            .disabled,
            .error,
            .info,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .error: return "ERROR"
        case .info: return "INFO"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LogLevel(rawValue: rawValue) ?? LogLevel.sdkUnknown(rawValue)
    }
}

/// <p>Sidewalk device message type.</p>
public enum MessageType {
    case customCommandIdGet
    case customCommandIdNotify
    case customCommandIdResp
    case customCommandIdSet
    case sdkUnknown(String)
}

extension MessageType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MessageType] {
        return [
            .customCommandIdGet,
            .customCommandIdNotify,
            .customCommandIdResp,
            .customCommandIdSet,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .customCommandIdGet: return "CUSTOM_COMMAND_ID_GET"
        case .customCommandIdNotify: return "CUSTOM_COMMAND_ID_NOTIFY"
        case .customCommandIdResp: return "CUSTOM_COMMAND_ID_RESP"
        case .customCommandIdSet: return "CUSTOM_COMMAND_ID_SET"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MessageType(rawValue: rawValue) ?? MessageType.sdkUnknown(rawValue)
    }
}

extension OtaaV1_0_x: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appEui = "AppEui"
        case appKey = "AppKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appEui = appEui {
            try encodeContainer.encode(appEui, forKey: .appEui)
        }
        if let appKey = appKey {
            try encodeContainer.encode(appKey, forKey: .appKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appKey)
        appKey = appKeyDecoded
        let appEuiDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appEui)
        appEui = appEuiDecoded
    }
}

extension OtaaV1_0_x: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OtaaV1_0_x(appEui: \(String(describing: appEui)), appKey: \(String(describing: appKey)))"}
}

/// <p>OTAA device object for v1.0.x</p>
public struct OtaaV1_0_x: Equatable {
    /// <p>The AppEUI value.</p>
    public let appEui: String?
    /// <p>The AppKey value.</p>
    public let appKey: String?

    public init (
        appEui: String? = nil,
        appKey: String? = nil
    )
    {
        self.appEui = appEui
        self.appKey = appKey
    }
}

extension OtaaV1_1: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appKey = "AppKey"
        case joinEui = "JoinEui"
        case nwkKey = "NwkKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appKey = appKey {
            try encodeContainer.encode(appKey, forKey: .appKey)
        }
        if let joinEui = joinEui {
            try encodeContainer.encode(joinEui, forKey: .joinEui)
        }
        if let nwkKey = nwkKey {
            try encodeContainer.encode(nwkKey, forKey: .nwkKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appKey)
        appKey = appKeyDecoded
        let nwkKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nwkKey)
        nwkKey = nwkKeyDecoded
        let joinEuiDecoded = try containerValues.decodeIfPresent(String.self, forKey: .joinEui)
        joinEui = joinEuiDecoded
    }
}

extension OtaaV1_1: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OtaaV1_1(appKey: \(String(describing: appKey)), joinEui: \(String(describing: joinEui)), nwkKey: \(String(describing: nwkKey)))"}
}

/// <p>OTAA device object for v1.1</p>
public struct OtaaV1_1: Equatable {
    /// <p>The AppKey value.</p>
    public let appKey: String?
    /// <p>The JoinEUI value.</p>
    public let joinEui: String?
    /// <p>The NwkKey value.</p>
    public let nwkKey: String?

    public init (
        appKey: String? = nil,
        joinEui: String? = nil,
        nwkKey: String? = nil
    )
    {
        self.appKey = appKey
        self.joinEui = joinEui
        self.nwkKey = nwkKey
    }
}

public enum PartnerType {
    case sidewalk
    case sdkUnknown(String)
}

extension PartnerType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PartnerType] {
        return [
            .sidewalk,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .sidewalk: return "Sidewalk"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PartnerType(rawValue: rawValue) ?? PartnerType.sdkUnknown(rawValue)
    }
}

public struct PutResourceLogLevelInputBodyMiddleware: Middleware {
    public let id: String = "PutResourceLogLevelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourceLogLevelInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourceLogLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourceLogLevelInput>
    public typealias MOutput = OperationOutput<PutResourceLogLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourceLogLevelOutputError>
}

extension PutResourceLogLevelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResourceLogLevelInput(logLevel: \(String(describing: logLevel)), resourceIdentifier: \(String(describing: resourceIdentifier)), resourceType: \(String(describing: resourceType)))"}
}

extension PutResourceLogLevelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }
}

public struct PutResourceLogLevelInputHeadersMiddleware: Middleware {
    public let id: String = "PutResourceLogLevelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourceLogLevelInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourceLogLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourceLogLevelInput>
    public typealias MOutput = OperationOutput<PutResourceLogLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourceLogLevelOutputError>
}

public struct PutResourceLogLevelInputQueryItemMiddleware: Middleware {
    public let id: String = "PutResourceLogLevelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourceLogLevelInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourceLogLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceType = input.operationInput.resourceType {
            let resourceTypeQueryItem = URLQueryItem(name: "resourceType".urlPercentEncoding(), value: String(resourceType).urlPercentEncoding())
            input.builder.withQueryItem(resourceTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourceLogLevelInput>
    public typealias MOutput = OperationOutput<PutResourceLogLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourceLogLevelOutputError>
}

public struct PutResourceLogLevelInput: Equatable {
    /// <p>The log level for a log message.</p>
    public let logLevel: LogLevel?
    /// <p>The identifier of the resource. For a Wireless Device, it is the wireless device id. For a wireless gateway, it is the wireless gateway id.</p>
    public let resourceIdentifier: String?
    /// <p>The type of the resource, currently support WirelessDevice and WirelessGateway.</p>
    public let resourceType: String?

    public init (
        logLevel: LogLevel? = nil,
        resourceIdentifier: String? = nil,
        resourceType: String? = nil
    )
    {
        self.logLevel = logLevel
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct PutResourceLogLevelInputBody: Equatable {
    public let logLevel: LogLevel?
}

extension PutResourceLogLevelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case logLevel = "LogLevel"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logLevelDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension PutResourceLogLevelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourceLogLevelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutResourceLogLevelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourceLogLevelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResourceLogLevelOutputResponse()"}
}

extension PutResourceLogLevelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct PutResourceLogLevelOutputResponse: Equatable {

    public init() {}
}

struct PutResourceLogLevelOutputResponseBody: Equatable {
}

extension PutResourceLogLevelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResetAllResourceLogLevelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetAllResourceLogLevelsInput()"}
}

extension ResetAllResourceLogLevelsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ResetAllResourceLogLevelsInputHeadersMiddleware: Middleware {
    public let id: String = "ResetAllResourceLogLevelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetAllResourceLogLevelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetAllResourceLogLevelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetAllResourceLogLevelsInput>
    public typealias MOutput = OperationOutput<ResetAllResourceLogLevelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetAllResourceLogLevelsOutputError>
}

public struct ResetAllResourceLogLevelsInputQueryItemMiddleware: Middleware {
    public let id: String = "ResetAllResourceLogLevelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetAllResourceLogLevelsInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetAllResourceLogLevelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetAllResourceLogLevelsInput>
    public typealias MOutput = OperationOutput<ResetAllResourceLogLevelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetAllResourceLogLevelsOutputError>
}

public struct ResetAllResourceLogLevelsInput: Equatable {

    public init() {}
}

struct ResetAllResourceLogLevelsInputBody: Equatable {
}

extension ResetAllResourceLogLevelsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResetAllResourceLogLevelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetAllResourceLogLevelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetAllResourceLogLevelsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetAllResourceLogLevelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetAllResourceLogLevelsOutputResponse()"}
}

extension ResetAllResourceLogLevelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ResetAllResourceLogLevelsOutputResponse: Equatable {

    public init() {}
}

struct ResetAllResourceLogLevelsOutputResponseBody: Equatable {
}

extension ResetAllResourceLogLevelsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResetResourceLogLevelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetResourceLogLevelInput(resourceIdentifier: \(String(describing: resourceIdentifier)), resourceType: \(String(describing: resourceType)))"}
}

extension ResetResourceLogLevelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ResetResourceLogLevelInputHeadersMiddleware: Middleware {
    public let id: String = "ResetResourceLogLevelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetResourceLogLevelInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetResourceLogLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetResourceLogLevelInput>
    public typealias MOutput = OperationOutput<ResetResourceLogLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetResourceLogLevelOutputError>
}

public struct ResetResourceLogLevelInputQueryItemMiddleware: Middleware {
    public let id: String = "ResetResourceLogLevelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ResetResourceLogLevelInput>,
                  next: H) -> Swift.Result<OperationOutput<ResetResourceLogLevelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceType = input.operationInput.resourceType {
            let resourceTypeQueryItem = URLQueryItem(name: "resourceType".urlPercentEncoding(), value: String(resourceType).urlPercentEncoding())
            input.builder.withQueryItem(resourceTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ResetResourceLogLevelInput>
    public typealias MOutput = OperationOutput<ResetResourceLogLevelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ResetResourceLogLevelOutputError>
}

public struct ResetResourceLogLevelInput: Equatable {
    /// <p>The identifier of the resource. For a Wireless Device, it is the wireless device id. For a wireless gateway, it is the wireless gateway id.</p>
    public let resourceIdentifier: String?
    /// <p>The type of the resource, currently support WirelessDevice and WirelessGateway.</p>
    public let resourceType: String?

    public init (
        resourceIdentifier: String? = nil,
        resourceType: String? = nil
    )
    {
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct ResetResourceLogLevelInputBody: Equatable {
}

extension ResetResourceLogLevelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResetResourceLogLevelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetResourceLogLevelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResetResourceLogLevelOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetResourceLogLevelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResetResourceLogLevelOutputResponse()"}
}

extension ResetResourceLogLevelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct ResetResourceLogLevelOutputResponse: Equatable {

    public init() {}
}

struct ResetResourceLogLevelOutputResponseBody: Equatable {
}

extension ResetResourceLogLevelOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Resource does not exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>Id of the not found resource.</p>
    public var resourceId: String?
    /// <p>Type of the font found resource.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct SendDataToWirelessDeviceInputBodyMiddleware: Middleware {
    public let id: String = "SendDataToWirelessDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendDataToWirelessDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<SendDataToWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendDataToWirelessDeviceInput>
    public typealias MOutput = OperationOutput<SendDataToWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendDataToWirelessDeviceOutputError>
}

extension SendDataToWirelessDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendDataToWirelessDeviceInput(id: \(String(describing: id)), payloadData: \(String(describing: payloadData)), transmitMode: \(String(describing: transmitMode)), wirelessMetadata: \(String(describing: wirelessMetadata)))"}
}

extension SendDataToWirelessDeviceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case payloadData = "PayloadData"
        case transmitMode = "TransmitMode"
        case wirelessMetadata = "WirelessMetadata"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payloadData = payloadData {
            try encodeContainer.encode(payloadData, forKey: .payloadData)
        }
        if let transmitMode = transmitMode {
            try encodeContainer.encode(transmitMode, forKey: .transmitMode)
        }
        if let wirelessMetadata = wirelessMetadata {
            try encodeContainer.encode(wirelessMetadata, forKey: .wirelessMetadata)
        }
    }
}

public struct SendDataToWirelessDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "SendDataToWirelessDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendDataToWirelessDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<SendDataToWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendDataToWirelessDeviceInput>
    public typealias MOutput = OperationOutput<SendDataToWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendDataToWirelessDeviceOutputError>
}

public struct SendDataToWirelessDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "SendDataToWirelessDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendDataToWirelessDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<SendDataToWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendDataToWirelessDeviceInput>
    public typealias MOutput = OperationOutput<SendDataToWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendDataToWirelessDeviceOutputError>
}

public struct SendDataToWirelessDeviceInput: Equatable {
    /// <p>The ID of the wireless device to receive the data.</p>
    public let id: String?
    /// <p>The message payload to send.</p>
    public let payloadData: String?
    /// <p>The transmit mode to use to send data to the wireless device. Can be: <code>0</code> for UM (unacknowledge mode) or <code>1</code> for AM (acknowledge mode).</p>
    public let transmitMode: Int?
    /// <p>Metadata about the message request.</p>
    public let wirelessMetadata: WirelessMetadata?

    public init (
        id: String? = nil,
        payloadData: String? = nil,
        transmitMode: Int? = nil,
        wirelessMetadata: WirelessMetadata? = nil
    )
    {
        self.id = id
        self.payloadData = payloadData
        self.transmitMode = transmitMode
        self.wirelessMetadata = wirelessMetadata
    }
}

struct SendDataToWirelessDeviceInputBody: Equatable {
    public let transmitMode: Int?
    public let payloadData: String?
    public let wirelessMetadata: WirelessMetadata?
}

extension SendDataToWirelessDeviceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case payloadData = "PayloadData"
        case transmitMode = "TransmitMode"
        case wirelessMetadata = "WirelessMetadata"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transmitModeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .transmitMode)
        transmitMode = transmitModeDecoded
        let payloadDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .payloadData)
        payloadData = payloadDataDecoded
        let wirelessMetadataDecoded = try containerValues.decodeIfPresent(WirelessMetadata.self, forKey: .wirelessMetadata)
        wirelessMetadata = wirelessMetadataDecoded
    }
}

extension SendDataToWirelessDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendDataToWirelessDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendDataToWirelessDeviceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendDataToWirelessDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendDataToWirelessDeviceOutputResponse(messageId: \(String(describing: messageId)))"}
}

extension SendDataToWirelessDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendDataToWirelessDeviceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

public struct SendDataToWirelessDeviceOutputResponse: Equatable {
    /// <p>The ID of the message sent to the wireless device.</p>
    public let messageId: String?

    public init (
        messageId: String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendDataToWirelessDeviceOutputResponseBody: Equatable {
    public let messageId: String?
}

extension SendDataToWirelessDeviceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageId = "MessageId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

extension ServiceProfile: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
    }
}

extension ServiceProfile: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceProfile(arn: \(String(describing: arn)), id: \(String(describing: id)), name: \(String(describing: name)))"}
}

/// <p>Information about a service profile.</p>
public struct ServiceProfile: Equatable {
    /// <p>The Amazon Resource Name of the resource.</p>
    public let arn: String?
    /// <p>The ID of the service profile.</p>
    public let id: String?
    /// <p>The name of the resource.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        id: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
    }
}

extension SessionKeysAbpV1_0_x: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appSKey = "AppSKey"
        case nwkSKey = "NwkSKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appSKey = appSKey {
            try encodeContainer.encode(appSKey, forKey: .appSKey)
        }
        if let nwkSKey = nwkSKey {
            try encodeContainer.encode(nwkSKey, forKey: .nwkSKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nwkSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nwkSKey)
        nwkSKey = nwkSKeyDecoded
        let appSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appSKey)
        appSKey = appSKeyDecoded
    }
}

extension SessionKeysAbpV1_0_x: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SessionKeysAbpV1_0_x(appSKey: \(String(describing: appSKey)), nwkSKey: \(String(describing: nwkSKey)))"}
}

/// <p>Session keys for ABP v1.1</p>
public struct SessionKeysAbpV1_0_x: Equatable {
    /// <p>The AppSKey value.</p>
    public let appSKey: String?
    /// <p>The NwkSKey value.</p>
    public let nwkSKey: String?

    public init (
        appSKey: String? = nil,
        nwkSKey: String? = nil
    )
    {
        self.appSKey = appSKey
        self.nwkSKey = nwkSKey
    }
}

extension SessionKeysAbpV1_1: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appSKey = "AppSKey"
        case fNwkSIntKey = "FNwkSIntKey"
        case nwkSEncKey = "NwkSEncKey"
        case sNwkSIntKey = "SNwkSIntKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appSKey = appSKey {
            try encodeContainer.encode(appSKey, forKey: .appSKey)
        }
        if let fNwkSIntKey = fNwkSIntKey {
            try encodeContainer.encode(fNwkSIntKey, forKey: .fNwkSIntKey)
        }
        if let nwkSEncKey = nwkSEncKey {
            try encodeContainer.encode(nwkSEncKey, forKey: .nwkSEncKey)
        }
        if let sNwkSIntKey = sNwkSIntKey {
            try encodeContainer.encode(sNwkSIntKey, forKey: .sNwkSIntKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fNwkSIntKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fNwkSIntKey)
        fNwkSIntKey = fNwkSIntKeyDecoded
        let sNwkSIntKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sNwkSIntKey)
        sNwkSIntKey = sNwkSIntKeyDecoded
        let nwkSEncKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nwkSEncKey)
        nwkSEncKey = nwkSEncKeyDecoded
        let appSKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appSKey)
        appSKey = appSKeyDecoded
    }
}

extension SessionKeysAbpV1_1: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SessionKeysAbpV1_1(appSKey: \(String(describing: appSKey)), fNwkSIntKey: \(String(describing: fNwkSIntKey)), nwkSEncKey: \(String(describing: nwkSEncKey)), sNwkSIntKey: \(String(describing: sNwkSIntKey)))"}
}

/// <p>Session keys for ABP v1.1</p>
public struct SessionKeysAbpV1_1: Equatable {
    /// <p>The AppSKey value.</p>
    public let appSKey: String?
    /// <p>The FNwkSIntKey value.</p>
    public let fNwkSIntKey: String?
    /// <p>The NwkSEncKey value.</p>
    public let nwkSEncKey: String?
    /// <p>The SNwkSIntKey value.</p>
    public let sNwkSIntKey: String?

    public init (
        appSKey: String? = nil,
        fNwkSIntKey: String? = nil,
        nwkSEncKey: String? = nil,
        sNwkSIntKey: String? = nil
    )
    {
        self.appSKey = appSKey
        self.fNwkSIntKey = fNwkSIntKey
        self.nwkSEncKey = nwkSEncKey
        self.sNwkSIntKey = sNwkSIntKey
    }
}

extension SidewalkAccountInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amazonId = "AmazonId"
        case appServerPrivateKey = "AppServerPrivateKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let appServerPrivateKey = appServerPrivateKey {
            try encodeContainer.encode(appServerPrivateKey, forKey: .appServerPrivateKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let appServerPrivateKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appServerPrivateKey)
        appServerPrivateKey = appServerPrivateKeyDecoded
    }
}

extension SidewalkAccountInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SidewalkAccountInfo(amazonId: \(String(describing: amazonId)), appServerPrivateKey: \(String(describing: appServerPrivateKey)))"}
}

/// <p>Information about a Sidewalk account.</p>
public struct SidewalkAccountInfo: Equatable {
    /// <p>The Sidewalk Amazon ID.</p>
    public let amazonId: String?
    /// <p>The Sidewalk application server private key.</p>
    public let appServerPrivateKey: String?

    public init (
        amazonId: String? = nil,
        appServerPrivateKey: String? = nil
    )
    {
        self.amazonId = amazonId
        self.appServerPrivateKey = appServerPrivateKey
    }
}

extension SidewalkAccountInfoWithFingerprint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amazonId = "AmazonId"
        case arn = "Arn"
        case fingerprint = "Fingerprint"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let fingerprint = fingerprint {
            try encodeContainer.encode(fingerprint, forKey: .fingerprint)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let fingerprintDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fingerprint)
        fingerprint = fingerprintDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension SidewalkAccountInfoWithFingerprint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SidewalkAccountInfoWithFingerprint(amazonId: \(String(describing: amazonId)), arn: \(String(describing: arn)), fingerprint: \(String(describing: fingerprint)))"}
}

/// <p>Information about a Sidewalk account.</p>
public struct SidewalkAccountInfoWithFingerprint: Equatable {
    /// <p>The Sidewalk Amazon ID.</p>
    public let amazonId: String?
    /// <p>The Amazon Resource Name of the resource.</p>
    public let arn: String?
    /// <p>The fingerprint of the Sidewalk application server private key.</p>
    public let fingerprint: String?

    public init (
        amazonId: String? = nil,
        arn: String? = nil,
        fingerprint: String? = nil
    )
    {
        self.amazonId = amazonId
        self.arn = arn
        self.fingerprint = fingerprint
    }
}

extension SidewalkDevice: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceCertificates = "DeviceCertificates"
        case sidewalkId = "SidewalkId"
        case sidewalkManufacturingSn = "SidewalkManufacturingSn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceCertificates = deviceCertificates {
            var deviceCertificatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceCertificates)
            for devicecertificatelist0 in deviceCertificates {
                try deviceCertificatesContainer.encode(devicecertificatelist0)
            }
        }
        if let sidewalkId = sidewalkId {
            try encodeContainer.encode(sidewalkId, forKey: .sidewalkId)
        }
        if let sidewalkManufacturingSn = sidewalkManufacturingSn {
            try encodeContainer.encode(sidewalkManufacturingSn, forKey: .sidewalkManufacturingSn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sidewalkId)
        sidewalkId = sidewalkIdDecoded
        let sidewalkManufacturingSnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sidewalkManufacturingSn)
        sidewalkManufacturingSn = sidewalkManufacturingSnDecoded
        let deviceCertificatesContainer = try containerValues.decodeIfPresent([CertificateList?].self, forKey: .deviceCertificates)
        var deviceCertificatesDecoded0:[CertificateList]? = nil
        if let deviceCertificatesContainer = deviceCertificatesContainer {
            deviceCertificatesDecoded0 = [CertificateList]()
            for structure0 in deviceCertificatesContainer {
                if let structure0 = structure0 {
                    deviceCertificatesDecoded0?.append(structure0)
                }
            }
        }
        deviceCertificates = deviceCertificatesDecoded0
    }
}

extension SidewalkDevice: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SidewalkDevice(deviceCertificates: \(String(describing: deviceCertificates)), sidewalkId: \(String(describing: sidewalkId)), sidewalkManufacturingSn: \(String(describing: sidewalkManufacturingSn)))"}
}

/// <p>Sidewalk device object.</p>
public struct SidewalkDevice: Equatable {
    /// <p>The sidewalk device certificates for Ed25519 and P256r1.</p>
    public let deviceCertificates: [CertificateList]?
    /// <p>The sidewalk device identification.</p>
    public let sidewalkId: String?
    /// <p>The Sidewalk manufacturing series number.</p>
    public let sidewalkManufacturingSn: String?

    public init (
        deviceCertificates: [CertificateList]? = nil,
        sidewalkId: String? = nil,
        sidewalkManufacturingSn: String? = nil
    )
    {
        self.deviceCertificates = deviceCertificates
        self.sidewalkId = sidewalkId
        self.sidewalkManufacturingSn = sidewalkManufacturingSn
    }
}

extension SidewalkDeviceMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batteryLevel = "BatteryLevel"
        case deviceState = "DeviceState"
        case event = "Event"
        case rssi = "Rssi"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batteryLevel = batteryLevel {
            try encodeContainer.encode(batteryLevel.rawValue, forKey: .batteryLevel)
        }
        if let deviceState = deviceState {
            try encodeContainer.encode(deviceState.rawValue, forKey: .deviceState)
        }
        if let event = event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let rssi = rssi {
            try encodeContainer.encode(rssi, forKey: .rssi)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rssiDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .rssi)
        rssi = rssiDecoded
        let batteryLevelDecoded = try containerValues.decodeIfPresent(BatteryLevel.self, forKey: .batteryLevel)
        batteryLevel = batteryLevelDecoded
        let eventDecoded = try containerValues.decodeIfPresent(Event.self, forKey: .event)
        event = eventDecoded
        let deviceStateDecoded = try containerValues.decodeIfPresent(DeviceState.self, forKey: .deviceState)
        deviceState = deviceStateDecoded
    }
}

extension SidewalkDeviceMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SidewalkDeviceMetadata(batteryLevel: \(String(describing: batteryLevel)), deviceState: \(String(describing: deviceState)), event: \(String(describing: event)), rssi: \(String(describing: rssi)))"}
}

/// <p>MetaData for Sidewalk device.</p>
public struct SidewalkDeviceMetadata: Equatable {
    /// <p>Sidewalk device battery level.</p>
    public let batteryLevel: BatteryLevel?
    /// <p>Device state defines the device status of sidewalk device.</p>
    public let deviceState: DeviceState?
    /// <p>Sidewalk device status notification.</p>
    public let event: Event?
    /// <p>The RSSI value.</p>
    public let rssi: Int?

    public init (
        batteryLevel: BatteryLevel? = nil,
        deviceState: DeviceState? = nil,
        event: Event? = nil,
        rssi: Int? = nil
    )
    {
        self.batteryLevel = batteryLevel
        self.deviceState = deviceState
        self.event = event
        self.rssi = rssi
    }
}

extension SidewalkListDevice: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case amazonId = "AmazonId"
        case deviceCertificates = "DeviceCertificates"
        case sidewalkId = "SidewalkId"
        case sidewalkManufacturingSn = "SidewalkManufacturingSn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let deviceCertificates = deviceCertificates {
            var deviceCertificatesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceCertificates)
            for devicecertificatelist0 in deviceCertificates {
                try deviceCertificatesContainer.encode(devicecertificatelist0)
            }
        }
        if let sidewalkId = sidewalkId {
            try encodeContainer.encode(sidewalkId, forKey: .sidewalkId)
        }
        if let sidewalkManufacturingSn = sidewalkManufacturingSn {
            try encodeContainer.encode(sidewalkManufacturingSn, forKey: .sidewalkManufacturingSn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amazonIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let sidewalkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sidewalkId)
        sidewalkId = sidewalkIdDecoded
        let sidewalkManufacturingSnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sidewalkManufacturingSn)
        sidewalkManufacturingSn = sidewalkManufacturingSnDecoded
        let deviceCertificatesContainer = try containerValues.decodeIfPresent([CertificateList?].self, forKey: .deviceCertificates)
        var deviceCertificatesDecoded0:[CertificateList]? = nil
        if let deviceCertificatesContainer = deviceCertificatesContainer {
            deviceCertificatesDecoded0 = [CertificateList]()
            for structure0 in deviceCertificatesContainer {
                if let structure0 = structure0 {
                    deviceCertificatesDecoded0?.append(structure0)
                }
            }
        }
        deviceCertificates = deviceCertificatesDecoded0
    }
}

extension SidewalkListDevice: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SidewalkListDevice(amazonId: \(String(describing: amazonId)), deviceCertificates: \(String(describing: deviceCertificates)), sidewalkId: \(String(describing: sidewalkId)), sidewalkManufacturingSn: \(String(describing: sidewalkManufacturingSn)))"}
}

/// <p>Sidewalk object used by list functions.</p>
public struct SidewalkListDevice: Equatable {
    /// <p>The Sidewalk Amazon ID.</p>
    public let amazonId: String?
    /// <p>The sidewalk device certificates for Ed25519 and P256r1.</p>
    public let deviceCertificates: [CertificateList]?
    /// <p>The sidewalk device identification.</p>
    public let sidewalkId: String?
    /// <p>The Sidewalk manufacturing series number.</p>
    public let sidewalkManufacturingSn: String?

    public init (
        amazonId: String? = nil,
        deviceCertificates: [CertificateList]? = nil,
        sidewalkId: String? = nil,
        sidewalkManufacturingSn: String? = nil
    )
    {
        self.amazonId = amazonId
        self.deviceCertificates = deviceCertificates
        self.sidewalkId = sidewalkId
        self.sidewalkManufacturingSn = sidewalkManufacturingSn
    }
}

extension SidewalkSendDataToDevice: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case messageType = "MessageType"
        case seq = "Seq"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageType = messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let seq = seq {
            try encodeContainer.encode(seq, forKey: .seq)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let seqDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .seq)
        seq = seqDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
    }
}

extension SidewalkSendDataToDevice: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SidewalkSendDataToDevice(messageType: \(String(describing: messageType)), seq: \(String(describing: seq)))"}
}

/// <p>Information about a Sidewalk router.</p>
public struct SidewalkSendDataToDevice: Equatable {
    /// <p>Sidewalk device message type.</p>
    public let messageType: MessageType?
    /// <p>The sequence number.</p>
    public let seq: Int?

    public init (
        messageType: MessageType? = nil,
        seq: Int? = nil
    )
    {
        self.messageType = messageType
        self.seq = seq
    }
}

extension SidewalkUpdateAccount: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appServerPrivateKey = "AppServerPrivateKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appServerPrivateKey = appServerPrivateKey {
            try encodeContainer.encode(appServerPrivateKey, forKey: .appServerPrivateKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appServerPrivateKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appServerPrivateKey)
        appServerPrivateKey = appServerPrivateKeyDecoded
    }
}

extension SidewalkUpdateAccount: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SidewalkUpdateAccount(appServerPrivateKey: \(String(describing: appServerPrivateKey)))"}
}

/// <p>Sidewalk update.</p>
public struct SidewalkUpdateAccount: Equatable {
    /// <p>The new Sidewalk application server private key.</p>
    public let appServerPrivateKey: String?

    public init (
        appServerPrivateKey: String? = nil
    )
    {
        self.appServerPrivateKey = appServerPrivateKey
    }
}

/// <p>The certificate chain algorithm provided by sidewalk.</p>
public enum SigningAlg {
    case ed25519
    case p256r1
    case sdkUnknown(String)
}

extension SigningAlg : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SigningAlg] {
        return [
            .ed25519,
            .p256r1,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ed25519: return "Ed25519"
        case .p256r1: return "P256r1"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SigningAlg(rawValue: rawValue) ?? SigningAlg.sdkUnknown(rawValue)
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A simple label consisting of a customer-defined key-value pair</p>
public struct Tag: Equatable {
    /// <p>The tag's key value.</p>
    public let key: String?
    /// <p>The tag's value.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The ARN of the resource to add tags to.</p>
    public let resourceArn: String?
    /// <p>Adds to or modifies the tags of the given resource. Tags are metadata that you can use to manage a resource.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TestWirelessDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestWirelessDeviceInput(id: \(String(describing: id)))"}
}

extension TestWirelessDeviceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct TestWirelessDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "TestWirelessDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestWirelessDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<TestWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestWirelessDeviceInput>
    public typealias MOutput = OperationOutput<TestWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestWirelessDeviceOutputError>
}

public struct TestWirelessDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "TestWirelessDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TestWirelessDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<TestWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TestWirelessDeviceInput>
    public typealias MOutput = OperationOutput<TestWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TestWirelessDeviceOutputError>
}

public struct TestWirelessDeviceInput: Equatable {
    /// <p>The ID of the wireless device to test.</p>
    public let id: String?

    public init (
        id: String? = nil
    )
    {
        self.id = id
    }
}

struct TestWirelessDeviceInputBody: Equatable {
}

extension TestWirelessDeviceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TestWirelessDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TestWirelessDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TestWirelessDeviceOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TestWirelessDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TestWirelessDeviceOutputResponse(result: \(String(describing: result)))"}
}

extension TestWirelessDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TestWirelessDeviceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.result = output.result
        } else {
            self.result = nil
        }
    }
}

public struct TestWirelessDeviceOutputResponse: Equatable {
    /// <p>The result returned by the test.</p>
    public let result: String?

    public init (
        result: String? = nil
    )
    {
        self.result = result
    }
}

struct TestWirelessDeviceOutputResponseBody: Equatable {
    public let result: String?
}

extension TestWirelessDeviceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case result = "Result"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultDecoded = try containerValues.decodeIfPresent(String.self, forKey: .result)
        result = resultDecoded
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied because it exceeded the allowed API request rate.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)), resourceName: \(String(describing: resourceName)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied because the resource can't have any more tags.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>Name of the resource that exceeds maximum number of tags allowed.</p>
    public var resourceName: String?

    public init (
        message: String? = nil,
        resourceName: String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
    public let resourceName: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The ARN of the resource to remove tags from.</p>
    public let resourceArn: String?
    /// <p>A list of the keys of the tags to remove from the resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDestinationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDestinationInput>
    public typealias MOutput = OperationOutput<UpdateDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDestinationOutputError>
}

extension UpdateDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDestinationInput(description: \(String(describing: description)), expression: \(String(describing: expression)), expressionType: \(String(describing: expressionType)), name: \(String(describing: name)), roleArn: \(String(describing: roleArn)))"}
}

extension UpdateDestinationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let expressionType = expressionType {
            try encodeContainer.encode(expressionType.rawValue, forKey: .expressionType)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct UpdateDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDestinationInput>
    public typealias MOutput = OperationOutput<UpdateDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDestinationOutputError>
}

public struct UpdateDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDestinationInput>
    public typealias MOutput = OperationOutput<UpdateDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDestinationOutputError>
}

public struct UpdateDestinationInput: Equatable {
    /// <p>A new description of the resource.</p>
    public let description: String?
    /// <p>The new rule name or topic rule to send messages to.</p>
    public let expression: String?
    /// <p>The type of value in <code>Expression</code>.</p>
    public let expressionType: ExpressionType?
    /// <p>The new name of the resource.</p>
    public let name: String?
    /// <p>The ARN of the IAM Role that authorizes the destination.</p>
    public let roleArn: String?

    public init (
        description: String? = nil,
        expression: String? = nil,
        expressionType: ExpressionType? = nil,
        name: String? = nil,
        roleArn: String? = nil
    )
    {
        self.description = description
        self.expression = expression
        self.expressionType = expressionType
        self.name = name
        self.roleArn = roleArn
    }
}

struct UpdateDestinationInputBody: Equatable {
    public let expressionType: ExpressionType?
    public let expression: String?
    public let description: String?
    public let roleArn: String?
}

extension UpdateDestinationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case expression = "Expression"
        case expressionType = "ExpressionType"
        case roleArn = "RoleArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionTypeDecoded = try containerValues.decodeIfPresent(ExpressionType.self, forKey: .expressionType)
        expressionType = expressionTypeDecoded
        let expressionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expression)
        expression = expressionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDestinationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDestinationOutputResponse()"}
}

extension UpdateDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDestinationOutputResponse: Equatable {

    public init() {}
}

struct UpdateDestinationOutputResponseBody: Equatable {
}

extension UpdateDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateLogLevelsByResourceTypesInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLogLevelsByResourceTypesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLogLevelsByResourceTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLogLevelsByResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLogLevelsByResourceTypesInput>
    public typealias MOutput = OperationOutput<UpdateLogLevelsByResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLogLevelsByResourceTypesOutputError>
}

extension UpdateLogLevelsByResourceTypesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLogLevelsByResourceTypesInput(defaultLogLevel: \(String(describing: defaultLogLevel)), wirelessDeviceLogOptions: \(String(describing: wirelessDeviceLogOptions)), wirelessGatewayLogOptions: \(String(describing: wirelessGatewayLogOptions)))"}
}

extension UpdateLogLevelsByResourceTypesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultLogLevel = "DefaultLogLevel"
        case wirelessDeviceLogOptions = "WirelessDeviceLogOptions"
        case wirelessGatewayLogOptions = "WirelessGatewayLogOptions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultLogLevel = defaultLogLevel {
            try encodeContainer.encode(defaultLogLevel.rawValue, forKey: .defaultLogLevel)
        }
        if let wirelessDeviceLogOptions = wirelessDeviceLogOptions {
            var wirelessDeviceLogOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessDeviceLogOptions)
            for wirelessdevicelogoptionlist0 in wirelessDeviceLogOptions {
                try wirelessDeviceLogOptionsContainer.encode(wirelessdevicelogoptionlist0)
            }
        }
        if let wirelessGatewayLogOptions = wirelessGatewayLogOptions {
            var wirelessGatewayLogOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .wirelessGatewayLogOptions)
            for wirelessgatewaylogoptionlist0 in wirelessGatewayLogOptions {
                try wirelessGatewayLogOptionsContainer.encode(wirelessgatewaylogoptionlist0)
            }
        }
    }
}

public struct UpdateLogLevelsByResourceTypesInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLogLevelsByResourceTypesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLogLevelsByResourceTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLogLevelsByResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLogLevelsByResourceTypesInput>
    public typealias MOutput = OperationOutput<UpdateLogLevelsByResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLogLevelsByResourceTypesOutputError>
}

public struct UpdateLogLevelsByResourceTypesInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLogLevelsByResourceTypesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLogLevelsByResourceTypesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLogLevelsByResourceTypesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLogLevelsByResourceTypesInput>
    public typealias MOutput = OperationOutput<UpdateLogLevelsByResourceTypesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLogLevelsByResourceTypesOutputError>
}

public struct UpdateLogLevelsByResourceTypesInput: Equatable {
    /// <p>The log level for a log message.</p>
    public let defaultLogLevel: LogLevel?
    /// <p>The list of wireless device log options.</p>
    public let wirelessDeviceLogOptions: [WirelessDeviceLogOption]?
    /// <p>The list of wireless gateway log options.</p>
    public let wirelessGatewayLogOptions: [WirelessGatewayLogOption]?

    public init (
        defaultLogLevel: LogLevel? = nil,
        wirelessDeviceLogOptions: [WirelessDeviceLogOption]? = nil,
        wirelessGatewayLogOptions: [WirelessGatewayLogOption]? = nil
    )
    {
        self.defaultLogLevel = defaultLogLevel
        self.wirelessDeviceLogOptions = wirelessDeviceLogOptions
        self.wirelessGatewayLogOptions = wirelessGatewayLogOptions
    }
}

struct UpdateLogLevelsByResourceTypesInputBody: Equatable {
    public let defaultLogLevel: LogLevel?
    public let wirelessDeviceLogOptions: [WirelessDeviceLogOption]?
    public let wirelessGatewayLogOptions: [WirelessGatewayLogOption]?
}

extension UpdateLogLevelsByResourceTypesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case defaultLogLevel = "DefaultLogLevel"
        case wirelessDeviceLogOptions = "WirelessDeviceLogOptions"
        case wirelessGatewayLogOptions = "WirelessGatewayLogOptions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultLogLevelDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .defaultLogLevel)
        defaultLogLevel = defaultLogLevelDecoded
        let wirelessDeviceLogOptionsContainer = try containerValues.decodeIfPresent([WirelessDeviceLogOption?].self, forKey: .wirelessDeviceLogOptions)
        var wirelessDeviceLogOptionsDecoded0:[WirelessDeviceLogOption]? = nil
        if let wirelessDeviceLogOptionsContainer = wirelessDeviceLogOptionsContainer {
            wirelessDeviceLogOptionsDecoded0 = [WirelessDeviceLogOption]()
            for structure0 in wirelessDeviceLogOptionsContainer {
                if let structure0 = structure0 {
                    wirelessDeviceLogOptionsDecoded0?.append(structure0)
                }
            }
        }
        wirelessDeviceLogOptions = wirelessDeviceLogOptionsDecoded0
        let wirelessGatewayLogOptionsContainer = try containerValues.decodeIfPresent([WirelessGatewayLogOption?].self, forKey: .wirelessGatewayLogOptions)
        var wirelessGatewayLogOptionsDecoded0:[WirelessGatewayLogOption]? = nil
        if let wirelessGatewayLogOptionsContainer = wirelessGatewayLogOptionsContainer {
            wirelessGatewayLogOptionsDecoded0 = [WirelessGatewayLogOption]()
            for structure0 in wirelessGatewayLogOptionsContainer {
                if let structure0 = structure0 {
                    wirelessGatewayLogOptionsDecoded0?.append(structure0)
                }
            }
        }
        wirelessGatewayLogOptions = wirelessGatewayLogOptionsDecoded0
    }
}

extension UpdateLogLevelsByResourceTypesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLogLevelsByResourceTypesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLogLevelsByResourceTypesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLogLevelsByResourceTypesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLogLevelsByResourceTypesOutputResponse()"}
}

extension UpdateLogLevelsByResourceTypesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateLogLevelsByResourceTypesOutputResponse: Equatable {

    public init() {}
}

struct UpdateLogLevelsByResourceTypesOutputResponseBody: Equatable {
}

extension UpdateLogLevelsByResourceTypesOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdatePartnerAccountInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePartnerAccountInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePartnerAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePartnerAccountInput>
    public typealias MOutput = OperationOutput<UpdatePartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePartnerAccountOutputError>
}

extension UpdatePartnerAccountInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePartnerAccountInput(partnerAccountId: \(String(describing: partnerAccountId)), partnerType: \(String(describing: partnerType)), sidewalk: \(String(describing: sidewalk)))"}
}

extension UpdatePartnerAccountInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sidewalk = "Sidewalk"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sidewalk = sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
    }
}

public struct UpdatePartnerAccountInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePartnerAccountInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePartnerAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePartnerAccountInput>
    public typealias MOutput = OperationOutput<UpdatePartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePartnerAccountOutputError>
}

public struct UpdatePartnerAccountInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePartnerAccountInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePartnerAccountInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePartnerAccountOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let partnerType = input.operationInput.partnerType {
            let partnerTypeQueryItem = URLQueryItem(name: "partnerType".urlPercentEncoding(), value: String(partnerType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(partnerTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePartnerAccountInput>
    public typealias MOutput = OperationOutput<UpdatePartnerAccountOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePartnerAccountOutputError>
}

public struct UpdatePartnerAccountInput: Equatable {
    /// <p>The ID of the partner account to update.</p>
    public let partnerAccountId: String?
    /// <p>The partner type.</p>
    public let partnerType: PartnerType?
    /// <p>The Sidewalk account credentials.</p>
    public let sidewalk: SidewalkUpdateAccount?

    public init (
        partnerAccountId: String? = nil,
        partnerType: PartnerType? = nil,
        sidewalk: SidewalkUpdateAccount? = nil
    )
    {
        self.partnerAccountId = partnerAccountId
        self.partnerType = partnerType
        self.sidewalk = sidewalk
    }
}

struct UpdatePartnerAccountInputBody: Equatable {
    public let sidewalk: SidewalkUpdateAccount?
}

extension UpdatePartnerAccountInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sidewalk = "Sidewalk"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sidewalkDecoded = try containerValues.decodeIfPresent(SidewalkUpdateAccount.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension UpdatePartnerAccountOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePartnerAccountOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePartnerAccountOutputError: Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePartnerAccountOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePartnerAccountOutputResponse()"}
}

extension UpdatePartnerAccountOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePartnerAccountOutputResponse: Equatable {

    public init() {}
}

struct UpdatePartnerAccountOutputResponseBody: Equatable {
}

extension UpdatePartnerAccountOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateWirelessDeviceInputBodyMiddleware: Middleware {
    public let id: String = "UpdateWirelessDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWirelessDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWirelessDeviceInput>
    public typealias MOutput = OperationOutput<UpdateWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWirelessDeviceOutputError>
}

extension UpdateWirelessDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWirelessDeviceInput(description: \(String(describing: description)), destinationName: \(String(describing: destinationName)), id: \(String(describing: id)), loRaWAN: \(String(describing: loRaWAN)), name: \(String(describing: name)))"}
}

extension UpdateWirelessDeviceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case destinationName = "DestinationName"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let destinationName = destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

public struct UpdateWirelessDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateWirelessDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWirelessDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWirelessDeviceInput>
    public typealias MOutput = OperationOutput<UpdateWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWirelessDeviceOutputError>
}

public struct UpdateWirelessDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateWirelessDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWirelessDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWirelessDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWirelessDeviceInput>
    public typealias MOutput = OperationOutput<UpdateWirelessDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWirelessDeviceOutputError>
}

public struct UpdateWirelessDeviceInput: Equatable {
    /// <p>A new description of the resource.</p>
    public let description: String?
    /// <p>The name of the new destination for the device.</p>
    public let destinationName: String?
    /// <p>The ID of the resource to update.</p>
    public let id: String?
    /// <p>The updated wireless device's configuration.</p>
    public let loRaWAN: LoRaWANUpdateDevice?
    /// <p>The new name of the resource.</p>
    public let name: String?

    public init (
        description: String? = nil,
        destinationName: String? = nil,
        id: String? = nil,
        loRaWAN: LoRaWANUpdateDevice? = nil,
        name: String? = nil
    )
    {
        self.description = description
        self.destinationName = destinationName
        self.id = id
        self.loRaWAN = loRaWAN
        self.name = name
    }
}

struct UpdateWirelessDeviceInputBody: Equatable {
    public let destinationName: String?
    public let name: String?
    public let description: String?
    public let loRaWAN: LoRaWANUpdateDevice?
}

extension UpdateWirelessDeviceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case destinationName = "DestinationName"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(LoRaWANUpdateDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension UpdateWirelessDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWirelessDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWirelessDeviceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWirelessDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWirelessDeviceOutputResponse()"}
}

extension UpdateWirelessDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateWirelessDeviceOutputResponse: Equatable {

    public init() {}
}

struct UpdateWirelessDeviceOutputResponseBody: Equatable {
}

extension UpdateWirelessDeviceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateWirelessGatewayInputBodyMiddleware: Middleware {
    public let id: String = "UpdateWirelessGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWirelessGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWirelessGatewayInput>
    public typealias MOutput = OperationOutput<UpdateWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWirelessGatewayOutputError>
}

extension UpdateWirelessGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWirelessGatewayInput(description: \(String(describing: description)), id: \(String(describing: id)), joinEuiFilters: \(String(describing: joinEuiFilters)), name: \(String(describing: name)), netIdFilters: \(String(describing: netIdFilters)))"}
}

extension UpdateWirelessGatewayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case joinEuiFilters = "JoinEuiFilters"
        case name = "Name"
        case netIdFilters = "NetIdFilters"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let joinEuiFilters = joinEuiFilters {
            var joinEuiFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .joinEuiFilters)
            for joineuifilters0 in joinEuiFilters {
                var joineuifilters0Container = joinEuiFiltersContainer.nestedUnkeyedContainer()
                for joineuirange1 in joineuifilters0 {
                    try joineuifilters0Container.encode(joineuirange1)
                }
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let netIdFilters = netIdFilters {
            var netIdFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .netIdFilters)
            for netidfilters0 in netIdFilters {
                try netIdFiltersContainer.encode(netidfilters0)
            }
        }
    }
}

public struct UpdateWirelessGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateWirelessGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWirelessGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWirelessGatewayInput>
    public typealias MOutput = OperationOutput<UpdateWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWirelessGatewayOutputError>
}

public struct UpdateWirelessGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateWirelessGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateWirelessGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateWirelessGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateWirelessGatewayInput>
    public typealias MOutput = OperationOutput<UpdateWirelessGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateWirelessGatewayOutputError>
}

public struct UpdateWirelessGatewayInput: Equatable {
    /// <p>A new description of the resource.</p>
    public let description: String?
    /// <p>The ID of the resource to update.</p>
    public let id: String?
    /// <p>A list of JoinEuiRange used by LoRa gateways to filter LoRa frames.</p>
    public let joinEuiFilters: [[String]]?
    /// <p>The new name of the resource.</p>
    public let name: String?
    /// <p>A list of NetId values that are used by LoRa gateways to filter the uplink frames.</p>
    public let netIdFilters: [String]?

    public init (
        description: String? = nil,
        id: String? = nil,
        joinEuiFilters: [[String]]? = nil,
        name: String? = nil,
        netIdFilters: [String]? = nil
    )
    {
        self.description = description
        self.id = id
        self.joinEuiFilters = joinEuiFilters
        self.name = name
        self.netIdFilters = netIdFilters
    }
}

struct UpdateWirelessGatewayInputBody: Equatable {
    public let name: String?
    public let description: String?
    public let joinEuiFilters: [[String]]?
    public let netIdFilters: [String]?
}

extension UpdateWirelessGatewayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case joinEuiFilters = "JoinEuiFilters"
        case name = "Name"
        case netIdFilters = "NetIdFilters"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let joinEuiFiltersContainer = try containerValues.decodeIfPresent([[String?]?].self, forKey: .joinEuiFilters)
        var joinEuiFiltersDecoded0:[[String]]? = nil
        if let joinEuiFiltersContainer = joinEuiFiltersContainer {
            joinEuiFiltersDecoded0 = [[String]]()
            for list0 in joinEuiFiltersContainer {
                var list0Decoded0: [String]? = nil
                if let list0 = list0 {
                    list0Decoded0 = [String]()
                    for string1 in list0 {
                        if let string1 = string1 {
                            list0Decoded0?.append(string1)
                        }
                    }
                }
                if let list0Decoded0 = list0Decoded0 {
                    joinEuiFiltersDecoded0?.append(list0Decoded0)
                }
            }
        }
        joinEuiFilters = joinEuiFiltersDecoded0
        let netIdFiltersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .netIdFilters)
        var netIdFiltersDecoded0:[String]? = nil
        if let netIdFiltersContainer = netIdFiltersContainer {
            netIdFiltersDecoded0 = [String]()
            for string0 in netIdFiltersContainer {
                if let string0 = string0 {
                    netIdFiltersDecoded0?.append(string0)
                }
            }
        }
        netIdFilters = netIdFiltersDecoded0
    }
}

extension UpdateWirelessGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateWirelessGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateWirelessGatewayOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateWirelessGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWirelessGatewayOutputResponse()"}
}

extension UpdateWirelessGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateWirelessGatewayOutputResponse: Equatable {

    public init() {}
}

struct UpdateWirelessGatewayOutputResponseBody: Equatable {
}

extension UpdateWirelessGatewayOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UpdateWirelessGatewayTaskCreate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case loRaWAN = "LoRaWAN"
        case updateDataRole = "UpdateDataRole"
        case updateDataSource = "UpdateDataSource"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let updateDataRole = updateDataRole {
            try encodeContainer.encode(updateDataRole, forKey: .updateDataRole)
        }
        if let updateDataSource = updateDataSource {
            try encodeContainer.encode(updateDataSource, forKey: .updateDataSource)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateDataSourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateDataSource)
        updateDataSource = updateDataSourceDecoded
        let updateDataRoleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updateDataRole)
        updateDataRole = updateDataRoleDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(LoRaWANUpdateGatewayTaskCreate.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
    }
}

extension UpdateWirelessGatewayTaskCreate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWirelessGatewayTaskCreate(loRaWAN: \(String(describing: loRaWAN)), updateDataRole: \(String(describing: updateDataRole)), updateDataSource: \(String(describing: updateDataSource)))"}
}

/// <p>UpdateWirelessGatewayTaskCreate object.</p>
public struct UpdateWirelessGatewayTaskCreate: Equatable {
    /// <p>The properties that relate to the LoRaWAN wireless gateway.</p>
    public let loRaWAN: LoRaWANUpdateGatewayTaskCreate?
    /// <p>The IAM role used to read data from the S3 bucket.</p>
    public let updateDataRole: String?
    /// <p>The link to the S3 bucket.</p>
    public let updateDataSource: String?

    public init (
        loRaWAN: LoRaWANUpdateGatewayTaskCreate? = nil,
        updateDataRole: String? = nil,
        updateDataSource: String? = nil
    )
    {
        self.loRaWAN = loRaWAN
        self.updateDataRole = updateDataRole
        self.updateDataSource = updateDataSource
    }
}

extension UpdateWirelessGatewayTaskEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
        case loRaWAN = "LoRaWAN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(LoRaWANUpdateGatewayTaskEntry.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension UpdateWirelessGatewayTaskEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateWirelessGatewayTaskEntry(arn: \(String(describing: arn)), id: \(String(describing: id)), loRaWAN: \(String(describing: loRaWAN)))"}
}

/// <p>UpdateWirelessGatewayTaskEntry object.</p>
public struct UpdateWirelessGatewayTaskEntry: Equatable {
    /// <p>The Amazon Resource Name of the resource.</p>
    public let arn: String?
    /// <p>The ID of the new wireless gateway task entry.</p>
    public let id: String?
    /// <p>The properties that relate to the LoRaWAN wireless gateway.</p>
    public let loRaWAN: LoRaWANUpdateGatewayTaskEntry?

    public init (
        arn: String? = nil,
        id: String? = nil,
        loRaWAN: LoRaWANUpdateGatewayTaskEntry? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.loRaWAN = loRaWAN
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input did not meet the specified constraints.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

/// <p>The event for a log message, if the log message is tied to a wireless device.</p>
public enum WirelessDeviceEvent {
    case downlinkData
    case join
    case registration
    case rejoin
    case uplinkData
    case sdkUnknown(String)
}

extension WirelessDeviceEvent : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WirelessDeviceEvent] {
        return [
            .downlinkData,
            .join,
            .registration,
            .rejoin,
            .uplinkData,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .downlinkData: return "Downlink_Data"
        case .join: return "Join"
        case .registration: return "Registration"
        case .rejoin: return "Rejoin"
        case .uplinkData: return "Uplink_Data"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WirelessDeviceEvent(rawValue: rawValue) ?? WirelessDeviceEvent.sdkUnknown(rawValue)
    }
}

extension WirelessDeviceEventLogOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case event = "Event"
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(WirelessDeviceEvent.self, forKey: .event)
        event = eventDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension WirelessDeviceEventLogOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WirelessDeviceEventLogOption(event: \(String(describing: event)), logLevel: \(String(describing: logLevel)))"}
}

/// <p>The log option for a wireless device event. Can be used to set log level for a specific wireless device event. For a LoRaWAN device, the possible events for a log messsage are: Join, Rejoin, Downlink_Data, Uplink_Data. For a Sidewalk device, the possible events for a log message are: Registration, Downlink_Data, Uplink_Data.</p>
public struct WirelessDeviceEventLogOption: Equatable {
    /// <p>The event for a log message, if the log message is tied to a wireless device.</p>
    public let event: WirelessDeviceEvent?
    /// <p>The log level for a log message.</p>
    public let logLevel: LogLevel?

    public init (
        event: WirelessDeviceEvent? = nil,
        logLevel: LogLevel? = nil
    )
    {
        self.event = event
        self.logLevel = logLevel
    }
}

public enum WirelessDeviceIdType {
    case deveui
    case thingname
    case wirelessdeviceid
    case sdkUnknown(String)
}

extension WirelessDeviceIdType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WirelessDeviceIdType] {
        return [
            .deveui,
            .thingname,
            .wirelessdeviceid,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deveui: return "DevEui"
        case .thingname: return "ThingName"
        case .wirelessdeviceid: return "WirelessDeviceId"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WirelessDeviceIdType(rawValue: rawValue) ?? WirelessDeviceIdType.sdkUnknown(rawValue)
    }
}

extension WirelessDeviceLogOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case events = "Events"
        case logLevel = "LogLevel"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for wirelessdeviceeventlogoptionlist0 in events {
                try eventsContainer.encode(wirelessdeviceeventlogoptionlist0)
            }
        }
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(WirelessDeviceType.self, forKey: .type)
        type = typeDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
        let eventsContainer = try containerValues.decodeIfPresent([WirelessDeviceEventLogOption?].self, forKey: .events)
        var eventsDecoded0:[WirelessDeviceEventLogOption]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [WirelessDeviceEventLogOption]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension WirelessDeviceLogOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WirelessDeviceLogOption(events: \(String(describing: events)), logLevel: \(String(describing: logLevel)), type: \(String(describing: type)))"}
}

/// <p>The log option for wireless devices. Can be used to set log level for a specific type of wireless device.</p>
public struct WirelessDeviceLogOption: Equatable {
    /// <p>The list of wireless device event log options.</p>
    public let events: [WirelessDeviceEventLogOption]?
    /// <p>The log level for a log message.</p>
    public let logLevel: LogLevel?
    /// <p>The wireless device type.</p>
    public let type: WirelessDeviceType?

    public init (
        events: [WirelessDeviceEventLogOption]? = nil,
        logLevel: LogLevel? = nil,
        type: WirelessDeviceType? = nil
    )
    {
        self.events = events
        self.logLevel = logLevel
        self.type = type
    }
}

extension WirelessDeviceStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case destinationName = "DestinationName"
        case id = "Id"
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
        case sidewalk = "Sidewalk"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let destinationName = destinationName {
            try encodeContainer.encode(destinationName, forKey: .destinationName)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUplinkReceivedAt = lastUplinkReceivedAt {
            try encodeContainer.encode(lastUplinkReceivedAt, forKey: .lastUplinkReceivedAt)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sidewalk = sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(WirelessDeviceType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let destinationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationName)
        destinationName = destinationNameDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(LoRaWANListDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(SidewalkListDevice.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension WirelessDeviceStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WirelessDeviceStatistics(arn: \(String(describing: arn)), destinationName: \(String(describing: destinationName)), id: \(String(describing: id)), lastUplinkReceivedAt: \(String(describing: lastUplinkReceivedAt)), loRaWAN: \(String(describing: loRaWAN)), name: \(String(describing: name)), sidewalk: \(String(describing: sidewalk)), type: \(String(describing: type)))"}
}

/// <p>Information about a wireless device's operation.</p>
public struct WirelessDeviceStatistics: Equatable {
    /// <p>The Amazon Resource Name of the resource.</p>
    public let arn: String?
    /// <p>The name of the destination to which the device is assigned.</p>
    public let destinationName: String?
    /// <p>The ID of the wireless device reporting the data.</p>
    public let id: String?
    /// <p>The date and time when the most recent uplink was received.</p>
    public let lastUplinkReceivedAt: String?
    /// <p>LoRaWAN device info.</p>
    public let loRaWAN: LoRaWANListDevice?
    /// <p>The name of the resource.</p>
    public let name: String?
    /// <p>The Sidewalk account credentials.</p>
    public let sidewalk: SidewalkListDevice?
    /// <p>The wireless device type.</p>
    public let type: WirelessDeviceType?

    public init (
        arn: String? = nil,
        destinationName: String? = nil,
        id: String? = nil,
        lastUplinkReceivedAt: String? = nil,
        loRaWAN: LoRaWANListDevice? = nil,
        name: String? = nil,
        sidewalk: SidewalkListDevice? = nil,
        type: WirelessDeviceType? = nil
    )
    {
        self.arn = arn
        self.destinationName = destinationName
        self.id = id
        self.lastUplinkReceivedAt = lastUplinkReceivedAt
        self.loRaWAN = loRaWAN
        self.name = name
        self.sidewalk = sidewalk
        self.type = type
    }
}

public enum WirelessDeviceType {
    case lorawan
    case sidewalk
    case sdkUnknown(String)
}

extension WirelessDeviceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WirelessDeviceType] {
        return [
            .lorawan,
            .sidewalk,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .lorawan: return "LoRaWAN"
        case .sidewalk: return "Sidewalk"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WirelessDeviceType(rawValue: rawValue) ?? WirelessDeviceType.sdkUnknown(rawValue)
    }
}

/// <p>The event for a log message, if the log message is tied to a wireless gateway.</p>
public enum WirelessGatewayEvent {
    case cupsRequest
    case certificate
    case sdkUnknown(String)
}

extension WirelessGatewayEvent : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WirelessGatewayEvent] {
        return [
            .cupsRequest,
            .certificate,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cupsRequest: return "CUPS_Request"
        case .certificate: return "Certificate"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WirelessGatewayEvent(rawValue: rawValue) ?? WirelessGatewayEvent.sdkUnknown(rawValue)
    }
}

extension WirelessGatewayEventLogOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case event = "Event"
        case logLevel = "LogLevel"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(WirelessGatewayEvent.self, forKey: .event)
        event = eventDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
    }
}

extension WirelessGatewayEventLogOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WirelessGatewayEventLogOption(event: \(String(describing: event)), logLevel: \(String(describing: logLevel)))"}
}

/// <p>The log option for a wireless gateway event. Can be used to set log level for a specific wireless gateway event. For a LoRaWAN gateway, the possible events for a log message are: CUPS_Request, Certificate.</p>
public struct WirelessGatewayEventLogOption: Equatable {
    /// <p>The event for a log message, if the log message is tied to a wireless gateway.</p>
    public let event: WirelessGatewayEvent?
    /// <p>The log level for a log message.</p>
    public let logLevel: LogLevel?

    public init (
        event: WirelessGatewayEvent? = nil,
        logLevel: LogLevel? = nil
    )
    {
        self.event = event
        self.logLevel = logLevel
    }
}

public enum WirelessGatewayIdType {
    case gatewayeui
    case thingname
    case wirelessgatewayid
    case sdkUnknown(String)
}

extension WirelessGatewayIdType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WirelessGatewayIdType] {
        return [
            .gatewayeui,
            .thingname,
            .wirelessgatewayid,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .gatewayeui: return "GatewayEui"
        case .thingname: return "ThingName"
        case .wirelessgatewayid: return "WirelessGatewayId"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WirelessGatewayIdType(rawValue: rawValue) ?? WirelessGatewayIdType.sdkUnknown(rawValue)
    }
}

extension WirelessGatewayLogOption: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case events = "Events"
        case logLevel = "LogLevel"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let events = events {
            var eventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .events)
            for wirelessgatewayeventlogoptionlist0 in events {
                try eventsContainer.encode(wirelessgatewayeventlogoptionlist0)
            }
        }
        if let logLevel = logLevel {
            try encodeContainer.encode(logLevel.rawValue, forKey: .logLevel)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(WirelessGatewayType.self, forKey: .type)
        type = typeDecoded
        let logLevelDecoded = try containerValues.decodeIfPresent(LogLevel.self, forKey: .logLevel)
        logLevel = logLevelDecoded
        let eventsContainer = try containerValues.decodeIfPresent([WirelessGatewayEventLogOption?].self, forKey: .events)
        var eventsDecoded0:[WirelessGatewayEventLogOption]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [WirelessGatewayEventLogOption]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
    }
}

extension WirelessGatewayLogOption: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WirelessGatewayLogOption(events: \(String(describing: events)), logLevel: \(String(describing: logLevel)), type: \(String(describing: type)))"}
}

/// <p>The log option for wireless gateways. Can be used to set log level for a specific type of wireless gateway.</p>
public struct WirelessGatewayLogOption: Equatable {
    /// <p>The list of wireless gateway event log options.</p>
    public let events: [WirelessGatewayEventLogOption]?
    /// <p>The log level for a log message.</p>
    public let logLevel: LogLevel?
    /// <p>The wireless gateway type.</p>
    public let type: WirelessGatewayType?

    public init (
        events: [WirelessGatewayEventLogOption]? = nil,
        logLevel: LogLevel? = nil,
        type: WirelessGatewayType? = nil
    )
    {
        self.events = events
        self.logLevel = logLevel
        self.type = type
    }
}

public enum WirelessGatewayServiceType {
    case cups
    case lns
    case sdkUnknown(String)
}

extension WirelessGatewayServiceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WirelessGatewayServiceType] {
        return [
            .cups,
            .lns,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cups: return "CUPS"
        case .lns: return "LNS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WirelessGatewayServiceType(rawValue: rawValue) ?? WirelessGatewayServiceType.sdkUnknown(rawValue)
    }
}

extension WirelessGatewayStatistics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case description = "Description"
        case id = "Id"
        case lastUplinkReceivedAt = "LastUplinkReceivedAt"
        case loRaWAN = "LoRaWAN"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUplinkReceivedAt = lastUplinkReceivedAt {
            try encodeContainer.encode(lastUplinkReceivedAt, forKey: .lastUplinkReceivedAt)
        }
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let loRaWANDecoded = try containerValues.decodeIfPresent(LoRaWANGateway.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let lastUplinkReceivedAtDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUplinkReceivedAt)
        lastUplinkReceivedAt = lastUplinkReceivedAtDecoded
    }
}

extension WirelessGatewayStatistics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WirelessGatewayStatistics(arn: \(String(describing: arn)), description: \(String(describing: description)), id: \(String(describing: id)), lastUplinkReceivedAt: \(String(describing: lastUplinkReceivedAt)), loRaWAN: \(String(describing: loRaWAN)), name: \(String(describing: name)))"}
}

/// <p>Information about a wireless gateway's operation.</p>
public struct WirelessGatewayStatistics: Equatable {
    /// <p>The Amazon Resource Name of the resource.</p>
    public let arn: String?
    /// <p>The description of the resource.</p>
    public let description: String?
    /// <p>The ID of the wireless gateway reporting the data.</p>
    public let id: String?
    /// <p>The date and time when the most recent uplink was received.</p>
    public let lastUplinkReceivedAt: String?
    /// <p>LoRaWAN gateway info.</p>
    public let loRaWAN: LoRaWANGateway?
    /// <p>The name of the resource.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        description: String? = nil,
        id: String? = nil,
        lastUplinkReceivedAt: String? = nil,
        loRaWAN: LoRaWANGateway? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.id = id
        self.lastUplinkReceivedAt = lastUplinkReceivedAt
        self.loRaWAN = loRaWAN
        self.name = name
    }
}

public enum WirelessGatewayTaskDefinitionType {
    case update
    case sdkUnknown(String)
}

extension WirelessGatewayTaskDefinitionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WirelessGatewayTaskDefinitionType] {
        return [
            .update,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .update: return "UPDATE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WirelessGatewayTaskDefinitionType(rawValue: rawValue) ?? WirelessGatewayTaskDefinitionType.sdkUnknown(rawValue)
    }
}

public enum WirelessGatewayTaskStatus {
    case completed
    case failed
    case firstRetry
    case inProgress
    case pending
    case secondRetry
    case sdkUnknown(String)
}

extension WirelessGatewayTaskStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WirelessGatewayTaskStatus] {
        return [
            .completed,
            .failed,
            .firstRetry,
            .inProgress,
            .pending,
            .secondRetry,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .firstRetry: return "FIRST_RETRY"
        case .inProgress: return "IN_PROGRESS"
        case .pending: return "PENDING"
        case .secondRetry: return "SECOND_RETRY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WirelessGatewayTaskStatus(rawValue: rawValue) ?? WirelessGatewayTaskStatus.sdkUnknown(rawValue)
    }
}

/// <p>The wireless gateway type.</p>
public enum WirelessGatewayType {
    case lorawan
    case sdkUnknown(String)
}

extension WirelessGatewayType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [WirelessGatewayType] {
        return [
            .lorawan,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .lorawan: return "LoRaWAN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = WirelessGatewayType(rawValue: rawValue) ?? WirelessGatewayType.sdkUnknown(rawValue)
    }
}

extension WirelessMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case loRaWAN = "LoRaWAN"
        case sidewalk = "Sidewalk"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loRaWAN = loRaWAN {
            try encodeContainer.encode(loRaWAN, forKey: .loRaWAN)
        }
        if let sidewalk = sidewalk {
            try encodeContainer.encode(sidewalk, forKey: .sidewalk)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loRaWANDecoded = try containerValues.decodeIfPresent(LoRaWANSendDataToDevice.self, forKey: .loRaWAN)
        loRaWAN = loRaWANDecoded
        let sidewalkDecoded = try containerValues.decodeIfPresent(SidewalkSendDataToDevice.self, forKey: .sidewalk)
        sidewalk = sidewalkDecoded
    }
}

extension WirelessMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WirelessMetadata(loRaWAN: \(String(describing: loRaWAN)), sidewalk: \(String(describing: sidewalk)))"}
}

/// <p>WirelessMetadata object.</p>
public struct WirelessMetadata: Equatable {
    /// <p>LoRaWAN device info.</p>
    public let loRaWAN: LoRaWANSendDataToDevice?
    /// <p>The Sidewalk account credentials.</p>
    public let sidewalk: SidewalkSendDataToDevice?

    public init (
        loRaWAN: LoRaWANSendDataToDevice? = nil,
        sidewalk: SidewalkSendDataToDevice? = nil
    )
    {
        self.loRaWAN = loRaWAN
        self.sidewalk = sidewalk
    }
}
